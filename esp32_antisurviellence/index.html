<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32_AntiSurviellence</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">← Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>ESP32_AntiSurviellence</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Okay, let&#39;s build this! Combining RF, embedded systems, offensive security concepts (applied ethically!), and coding on the versatile ESP32 is a fantastic journey. As a passionate teacher, I&#39;m excited to lay out this path for you.</p>\n<p>Here is a comprehensive 8-module course outline designed to take learners from foundational concepts to building their own multi-mode ESP32 Bluetooth Reconnaissance Tool.</p>\n<hr>\n<h2>Course Title: DIY ESP32 Bluetooth Recon Tool: Building Your Multi-Mode Scanner</h2>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to design, code, and deploy a functional multi-mode Bluetooth reconnaissance tool on an ESP32 DevkitC, capable of personal tracker detection, environmental baseline analysis, and basic Bluetooth advertising exploration.</p>\n<p><strong>Target Audience:</strong> Learners with basic familiarity with electronics, programming (e.g., C/C++, Python), and computing concepts. No prior extensive RF or embedded systems experience is strictly required, but a willingness to learn hands-on is essential.</p>\n<hr>\n<h3>Module 1: Welcome to the Invisible World - Setting Up Your ESP32 Workshop</h3>\n<ul>\n<li><strong>Module Title:</strong> Getting Started: Unboxing, Setup, and Your First Blinky</li>\n<li><strong>Module Objective:</strong> Set up the necessary hardware and software environment, flash the first program onto the ESP32, and gain confidence in the development workflow.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Introduction to RF and the concept of the electromagnetic spectrum around us.</li>\n<li>Why Bluetooth? Overview of its prevalence and variations (Classic vs. BLE).</li>\n<li>Introduction to the ESP32 DevkitC: Microcontroller, Wi-Fi, and Bluetooth capabilities.</li>\n<li>Required hardware: ESP32 DevkitC, USB cable, computer.</li>\n<li>Setting up the Arduino IDE (or MicroPython environment - offer choice/comparison).</li>\n<li>Installing ESP32 board support and necessary drivers.</li>\n<li>Tour of the Arduino IDE: Sketch, Verify, Upload, Serial Monitor.</li>\n<li>Writing and uploading the classic &quot;Blink&quot; sketch.</li>\n<li>Using the Serial Monitor for basic debugging and output.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic computer literacy.</li>\n<li>ESP32 DevkitC board and USB cable.</li>\n<li>Arduino IDE installed.</li>\n<li>Links to official ESP32 documentation and getting started guides.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Successfully upload and run the &quot;Blink&quot; sketch on the ESP32. Modify the blink rate. Write a simple sketch that prints &quot;Hello, ESP32 Recon!&quot; to the Serial Monitor.</li>\n</ul>\n<h3>Module 2: Embedded Programming Essentials for the ESP32</h3>\n<ul>\n<li><strong>Module Title:</strong> Coding for the Microcontroller: Variables, Control Flow, and Libraries</li>\n<li><strong>Module Objective:</strong> Understand fundamental embedded programming concepts relevant to the ESP32 using the chosen development environment (primarily Arduino/C++ for this course).</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Review of basic C++ syntax (variables, data types, operators).</li>\n<li>Control flow: if/else, switch, for loops, while loops.</li>\n<li>Functions: Defining and calling functions.</li>\n<li>Understanding <code>setup()</code> and <code>loop()</code> in Arduino.</li>\n<li>Working with GPIO (General Purpose Input/Output) pins.</li>\n<li>Digital Read/Write (e.g., reading button state, controlling LEDs).</li>\n<li>Basic Analog Read.</li>\n<li>Introduction to Libraries: What they are and how to use them (e.g., a simple sensor library).</li>\n<li>Serial communication for debugging and data output.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 1.</li>\n<li>Basic understanding of programming concepts (variables, loops, conditions).</li>\n<li>Links to C++ tutorials and Arduino core reference documentation.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Build a simple circuit with an LED and a button. Write a sketch that turns the LED on when the button is pressed and off when released. Print button state changes to the Serial Monitor.</li>\n</ul>\n<h3>Module 3: Bluetooth Deep Dive: Protocols, Packets, and Presence</h3>\n<ul>\n<li><strong>Module Title:</strong> Understanding Bluetooth: BLE vs. Classic, Advertising, and Identification</li>\n<li><strong>Module Objective:</strong> Gain a solid theoretical understanding of Bluetooth, focusing on the concepts essential for reconnaissance and detection.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Bluetooth Classic (BR/EDR) vs. Bluetooth Low Energy (BLE): Key differences, use cases, and how they coexist.</li>\n<li>Focus on BLE: Why it&#39;s crucial for low-power devices and tracking.</li>\n<li>BLE Roles: Peripheral vs. Central, Broadcaster vs. Observer.</li>\n<li>The BLE Advertising Process: How devices announce their presence.</li>\n<li>Advertising Packets: Structure, common data types (UUIDs, names, manufacturer data).</li>\n<li>Device Identification: MAC Addresses (Public, Random Static, Random Resolvable/Non-Resolvable). Privacy implications.</li>\n<li>Signal Strength (RSSI - Received Signal Strength Indicator): What it is and how it relates to distance (with caveats).</li>\n<li>Introduction to Bluetooth Scanning: How an Observer/Central device discovers Broadcasters/Peripherals.</li>\n<li><strong>Case Study:</strong> How do devices like AirTags, Tiles, or fitness trackers use BLE advertising? Analyzing their packet structures (at a high level).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 2.</li>\n<li>Links to Bluetooth SIG specifications (overview level), BLE tutorials.</li>\n<li>Visual aids explaining packet structure and roles.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Write a short summary explaining the difference between BLE and Classic Bluetooth and the importance of advertising packets for discovery. Research and identify common BLE advertising data types you might encounter.</li>\n</ul>\n<h3>Module 4: ESP32 as a Bluetooth Scanner: Seeing the Signals</h3>\n<ul>\n<li><strong>Module Title:</strong> Scanning the Airwaves: Programming the ESP32 as a BLE Observer</li>\n<li><strong>Module Objective:</strong> Program the ESP32 to actively scan for nearby BLE devices and extract basic information from advertising packets.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Introduction to the ESP32 BLE library (e.g., <code>ESP32-BLE-Arduino</code>).</li>\n<li>Setting up the BLE scan process: Starting and stopping scans.</li>\n<li>Handling scan results: The <code>onResult</code> callback function.</li>\n<li>Extracting key information from scan results: Device address (MAC), name, RSSI.</li>\n<li>Filtering scan results (optional based on name, address, etc.).</li>\n<li>Printing scan results to the Serial Monitor in a structured format.</li>\n<li>Understanding scan parameters (scan time, active/passive scanning).</li>\n<li><strong>Real-world Example:</strong> Scanning for your own phone or Bluetooth headphones.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 3.</li>\n<li>ESP32 DevkitC.</li>\n<li>Links to the chosen ESP32 BLE library documentation and examples.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Write a sketch that performs a 10-second BLE scan and prints the MAC address, name (if available), and RSSI of every detected device to the Serial Monitor.</li>\n</ul>\n<h3>Module 5: Data Handling and Device Identification: Processing Scan Results</h3>\n<ul>\n<li><strong>Module Title:</strong> Making Sense of the Signals: Storing, Identifying, and Tracking Devices</li>\n<li><ul>\n<li><strong>Module Objective:</strong> Develop techniques to store scan data, identify unique devices, and track their presence or signal strength over time, laying the groundwork for detection modes.</li>\n</ul>\n</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Data structures for storing device information (e.g., structs, classes).</li>\n<li>Using <code>std::vector</code> or similar dynamic arrays in C++ to store multiple devices.</li>\n<li>Handling duplicate scan results (multiple advertisements from the same device).</li>\n<li>Techniques for identifying unique devices based on MAC address.</li>\n<li>Storing historical data for devices (e.g., last seen time, list of RSSI values).</li>\n<li>Estimating proximity based on RSSI (understanding the limitations).</li>\n<li>Developing a simple device list management system (add, find, update).</li>\n<li>Implementing a &quot;last seen&quot; timestamp for devices.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 4.</li>\n<li>Familiarity with C++ data structures (structs, vectors).</li>\n<li>Links to C++ standard library documentation.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Modify the scanning sketch from Module 4 to store unique devices in a list. For each scan result, check if the device is already in the list. If new, add it. If existing, update its &quot;last seen&quot; timestamp and potentially store the current RSSI. Print the list of unique devices and their last seen time after the scan.</li>\n</ul>\n<h3>Module 6: Building Detection Modes I: Personal Tracker &amp; Environmental Baseline</h3>\n<ul>\n<li><strong>Module Title:</strong> Implementing Reconnaissance Logic: Tracking and Baselining</li>\n<li><strong>Module Objective:</strong> Program the ESP32 to implement the Personal Tracker Detection and Environmental Baseline &amp; Anomaly Detection modes using the scanning and data processing skills acquired.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Structuring the main application loop for different modes (e.g., using a state machine or simple conditional logic).</li>\n<li><strong>Personal Tracker Mode:</strong><ul>\n<li>Logic for identifying &quot;persistent&quot; devices (seen multiple times over a duration).</li>\n<li>Monitoring RSSI changes for specific devices to infer movement or approach.</li>\n<li>Implementing simple alert mechanisms (e.g., printing &quot;Potential Tracker Detected!&quot; to Serial).</li>\n<li>Handling known vs. unknown persistent devices.</li>\n</ul>\n</li>\n<li><strong>Environmental Baseline Mode:</strong><ul>\n<li>Implementing a &quot;baseline scan&quot; function: Scan for a set duration and store <em>all</em> unique devices found.</li>\n<li>Implementing a &quot;comparison scan&quot; function: Scan again and compare results against the stored baseline.</li>\n<li>Logic for identifying &quot;new&quot; devices (present in comparison scan but not in baseline).</li>\n<li>Alerting on new devices found.</li>\n</ul>\n</li>\n<li>Adding basic user input via Serial Monitor to select the operational mode.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 5.</li>\n<li>Understanding of state machines or basic control flow for mode selection.</li>\n<li>Examples of implementing different operational modes in embedded systems.</li>\n<li><strong>Case Study:</strong> Using baseline analysis in security: Detecting new devices in a sensitive area after hours.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Create a sketch that allows the user to select between &quot;Personal Tracker&quot; and &quot;Baseline&quot; modes via Serial input. Implement the core logic for both modes based on the subtopics. The output should be printed to the Serial Monitor (e.g., &quot;Scanning for trackers...&quot;, &quot;Baseline scan complete, found X devices.&quot;, &quot;Comparison scan complete, NEW DEVICE detected: [MAC]&quot;).</li>\n</ul>\n<h3>Module 7: ESP32 as a Bluetooth Transmitter: Sending Signals</h3>\n<ul>\n<li><strong>Module Title:</strong> Broadcasting Your Presence: Programming the ESP32 as a BLE Advertiser</li>\n<li><strong>Module Objective:</strong> Learn how to configure the ESP32 to act as a BLE Broadcaster and send out custom advertising packets.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Introduction to the ESP32 BLE library for advertising.</li>\n<li>Setting up the BLE advertising process: Initializing, setting parameters.</li>\n<li>Configuring advertising data: Setting device name, flags, service UUIDs.</li>\n<li>Adding custom manufacturer data to advertising packets.</li>\n<li>Setting advertising interval and power.</li>\n<li>Starting and stopping advertising.</li>\n<li>Broadcasting different types of advertising packets.</li>\n<li>Using another device (like a phone app) to observe the ESP32&#39;s advertisements.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Module 6 (though this module is somewhat independent of the detection logic, it&#39;s needed for the final tool).</li>\n<li>ESP32 DevkitC.</li>\n<li>A smartphone with a BLE scanning app (e.g., nRF Connect, LightBlue).</li>\n<li>Links to the chosen ESP32 BLE library documentation for advertising.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Write a sketch where the ESP32 advertises itself with a custom name (e.g., &quot;MyESP32Advertiser&quot;) and includes some custom manufacturer data (e.g., a sequence of bytes). Use a phone app to verify that you can see the ESP32 and its custom data.</li>\n</ul>\n<h3>Module 8: Capstone Project: Integrating Modes and Exploring Advertising Flooding</h3>\n<ul>\n<li><strong>Module Title:</strong> Building the Multi-Mode Tool and Ethical Considerations</li>\n<li><strong>Module Objective:</strong> Integrate all three operational modes into a single application, implement the advertising flooding mode, and understand the ethical implications of using such tools.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Refining the mode selection mechanism (e.g., using a menu system via Serial).</li>\n<li>Integrating the Personal Tracker and Environmental Baseline code into the main structure.</li>\n<li><strong>Bluetooth Advertising Flooding Mode:</strong><ul>\n<li>Implementing rapid, continuous BLE advertising.</li>\n<li>Generating random or changing advertising data/MAC addresses (spoofing concepts).</li>\n<li>Measuring the rate of advertising packets.</li>\n<li><em>Crucially:</em> Discussion on the impact of excessive advertising (DoS concepts).</li>\n<li><em>Ethical Considerations:</em> When is it okay to scan? When is it <em>not</em> okay to flood? Laws and responsible disclosure. The difference between exploration/research and malicious activity.</li>\n</ul>\n</li>\n<li>Adding configuration options (e.g., baseline scan duration, tracker detection threshold).</li>\n<li>Code optimization and memory management tips for embedded systems.</li>\n<li>Packaging the code for the final capstone project.</li>\n<li><strong>Real-world Example:</strong> Discussing the potential uses (testing device resilience) vs. abuses (disrupting public spaces) of advertising flooding.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Completion of Modules 1-7.</li>\n<li>ESP32 DevkitC.</li>\n<li>Links to resources on embedded system best practices, DoS concepts (in a networking context), and cybersecurity ethics.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Create the final multi-mode ESP32 Bluetooth Recon Tool. The sketch should present a menu (via Serial) allowing the user to select:<ol>\n<li>Personal Tracker Detection</li>\n<li>Environmental Baseline &amp; Anomaly Detection (with options for baseline/compare)</li>\n<li>Bluetooth Advertising Flooding<br>Implement the core logic for each mode, drawing from previous modules. Ensure the flooding mode includes a clear warning or requires user confirmation due to ethical implications. Test all modes. This final project is the &quot;functional clone&quot; capstone.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>This outline provides a structured path, starting with the basics of the hardware and programming environment, moving through the core concepts of Bluetooth and data handling, then applying that knowledge to build the specific detection modes, and finally integrating everything into a comprehensive tool while addressing the ethical responsibilities that come with exploring these capabilities. Each module builds upon the last, culminating in the fully functional capstone project. Good luck, and happy hacking (ethically, of course)!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: module_3</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_3 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, team! Let&#39;s dive headfirst into the fascinating world of RF and embedded systems, specifically through the lens of our trusty ESP32. This isn&#39;t just about blinking lights; it&#39;s about understanding the invisible conversations happening all around us and learning how to listen in (ethically, of course!).</p>\n<p>I&#39;m thrilled to guide you through this. Module 1 is all about getting our hands dirty, setting up our workspace, and getting that vital first connection to our hardware. Think of it as laying the foundation for our future reconnaissance rig.</p>\n<hr>\n<h2>Module 1: Welcome to the Invisible World - Setting Up Your ESP32 Workshop</h2>\n<ul>\n<li><strong>Module Title:</strong> Getting Started: Unboxing, Setup, and Your First Blinky</li>\n<li><strong>Module Objective:</strong> By the end of this module, you will have successfully set up your hardware and software development environment for the ESP32, uploaded your first program (&quot;Blink&quot;) to verify connectivity and toolchain setup, and learned how to use the Serial Monitor for basic communication and debugging. This builds the essential confidence needed to proceed!</li>\n</ul>\n<h3>1.1 Introduction: Stepping into the Invisible Spectrum</h3>\n<p>Welcome! We live in a world saturated with radio waves. Your Wi-Fi, your phone signal, FM radio, GPS – they all operate on different parts of the electromagnetic (EM) spectrum. Most of this activity is invisible to our eyes, but it&#39;s constantly buzzing with data.</p>\n<p>Our journey begins by exploring a particularly ubiquitous part of this spectrum: <strong>Bluetooth</strong>. Why Bluetooth? Because it&#39;s <em>everywhere</em>. From headphones and speakers to smartwatches, fitness trackers, and even modern personal item trackers like AirTags and Tiles, Bluetooth is a key player in how devices connect and, importantly for us, how they <em>announce their presence</em>.</p>\n<p>We&#39;re going to use the <strong>ESP32 DevkitC</strong> as our main tool. This little board is a powerhouse! It&#39;s a microcontroller (a tiny computer designed to control things), but crucially for us, it has built-in <strong>Wi-Fi</strong> and <strong>Bluetooth</strong> capabilities. This makes it perfect for exploring the wireless world around us.</p>\n<p>In this module, we&#39;ll get this powerful board talking to your computer and running its first instructions. This might seem basic, but mastering the setup and deployment process is absolutely fundamental to everything we&#39;ll do later.</p>\n<h3>1.2 Required Hardware: Gathering Your Tools</h3>\n<p>Before we start, let&#39;s make sure you have everything you need.</p>\n<ol>\n<li><strong>ESP32 DevkitC Board:</strong> This is our main target hardware. There are many variations of ESP32 boards, but the DevkitC is standard, widely available, and well-supported. It typically has a USB port for power and programming, two rows of pins along the sides, and maybe a button or two.</li>\n<li><strong>Micro USB Cable (or USB-C, depending on your board version):</strong> This is crucial for both powering the ESP32 and uploading code. <em>Pro Tip:</em> Not all USB cables are created equal! Some are &quot;charge only&quot; and don&#39;t transfer data. Make sure you have a <em>data</em> cable. If you have issues later, trying a different cable is often the first troubleshooting step.</li>\n<li><strong>Your Computer:</strong> Windows, macOS, or Linux – the setup process is similar across platforms, though driver installation might vary slightly.</li>\n<li><strong>Internet Connection:</strong> Needed for downloading software and libraries.</li>\n</ol>\n<p>That&#39;s it for Module 1! Keep these handy.</p>\n<h3>1.3 Setting Up Your Software Environment: The Arduino IDE</h3>\n<p>While more advanced developers might use command-line tools or other IDEs, the <strong>Arduino IDE</strong> is fantastic for getting started with microcontrollers like the ESP32. It&#39;s relatively simple, has a huge community, and makes uploading code straightforward. It&#39;s written in C/C++, which is what we&#39;ll primarily use for performance and direct hardware control in this course.</p>\n<ul>\n<li><em>(Alternative: MicroPython)</em>: The ESP32 can also be programmed with MicroPython, which is great for rapid prototyping and higher-level logic. However, for direct control over hardware and the specific BLE operations we&#39;ll perform later, C++ via the Arduino framework offers more flexibility and closer access to the ESP-IDF (Espressif IoT Development Framework) features. This course will focus on the Arduino/C++ path, but feel free to explore MicroPython on your own later!</li>\n</ul>\n<p><strong>Step-by-Step Arduino IDE Setup:</strong></p>\n<ol>\n<li><strong>Download the Arduino IDE:</strong><ul>\n<li>Go to the official Arduino website: <a href=\"https://www.arduino.cc/en/software\">https://www.arduino.cc/en/software</a></li>\n<li>Download the latest version for your operating system (Windows, macOS, Linux).</li>\n<li>Choose the installer (.exe for Windows, .dmg for macOS, etc.). You can often download it for free (&quot;Just Download&quot;) or contribute.</li>\n</ul>\n</li>\n<li><strong>Install the Arduino IDE:</strong><ul>\n<li>Run the downloaded installer.</li>\n<li>Follow the on-screen instructions. Accept the license agreement.</li>\n<li>Pay attention during the Windows installation – it might ask about installing drivers. Let it install them; they are often helpful.</li>\n<li>Choose the installation location (default is usually fine).</li>\n<li>Click &quot;Install&quot;.</li>\n<li>Once finished, launch the Arduino IDE.</li>\n</ul>\n</li>\n</ol>\n<h3>1.4 Adding ESP32 Board Support to the Arduino IDE</h3>\n<p>By default, the Arduino IDE only knows about official Arduino boards. We need to tell it how to compile code for the ESP32. This is done by adding a &quot;Board Manager URL&quot; and then installing the ESP32 package.</p>\n<p><strong>Step-by-Step ESP32 Integration:</strong></p>\n<ol>\n<li><strong>Open Preferences:</strong><ul>\n<li>In the Arduino IDE, go to <code>File &gt; Preferences</code> (on Windows/Linux) or <code>Arduino IDE &gt; Settings</code> (on macOS).</li>\n</ul>\n</li>\n<li><strong>Add the ESP32 Boards Manager URL:</strong><ul>\n<li>Look for the &quot;Additional Boards Manager URLs&quot; field at the bottom of the Preferences window.</li>\n<li>If there are other URLs already there, add a comma (<code>,</code>) at the end and then paste the following URL:<pre><code>https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\n</code></pre>\n</li>\n<li><em>Important:</em> Copy the <em>entire</em> line, including <code>https://</code>.</li>\n<li>Click &quot;OK&quot; to close the Preferences window.</li>\n</ul>\n</li>\n<li><strong>Open the Boards Manager:</strong><ul>\n<li>Go to <code>Tools &gt; Board &gt; Boards Manager...</code></li>\n<li>This will open a new window and update its list of available boards (this might take a moment, requiring an internet connection).</li>\n</ul>\n</li>\n<li><strong>Search for and Install ESP32:</strong><ul>\n<li>In the search bar at the top of the Boards Manager window, type <code>esp32</code>.</li>\n<li>You should see an entry like &quot;esp32 by Espressif Systems&quot;.</li>\n<li>Click on this entry.</li>\n<li>Click the &quot;Install&quot; button. This will download and install all the necessary files for compiling code for the ESP32. This might also take a few minutes depending on your internet speed.</li>\n<li>Once installed, it will say &quot;INSTALLED&quot;.</li>\n<li>Click &quot;Close&quot; on the Boards Manager window.</li>\n</ul>\n</li>\n</ol>\n<p>Now your Arduino IDE knows how to talk to the ESP32!</p>\n<h3>1.5 Tour of the Arduino IDE</h3>\n<p>Let&#39;s quickly get familiar with the main parts of the IDE:</p>\n<p>![Conceptual Diagram of Arduino IDE layout]<br>(Imagine a simple diagram: Top Menu Bar, Sketch Area (large text editor), Output Console (bottom area), Buttons (Verify, Upload, New, Open, Save, Serial Monitor icon))</p>\n<ul>\n<li><strong>Menu Bar (Top):</strong> Standard menus (<code>File</code>, <code>Edit</code>, <code>Sketch</code>, <code>Tools</code>, <code>Help</code>). We&#39;ll use <code>Tools</code> extensively to select our board and port.</li>\n<li><strong>Buttons:</strong><ul>\n<li><strong>Verify (Checkmark):</strong> Compiles your code. This checks for syntax errors without uploading to the board. Good first step after writing/editing code.</li>\n<li><strong>Upload (Right Arrow):</strong> Compiles your code <em>and</em> uploads it to the connected board. This is what makes your program run on the ESP32.</li>\n<li><strong>New, Open, Save:</strong> Standard file operations.</li>\n<li><strong>Serial Monitor (Magnifying Glass):</strong> Opens a separate window to view output from your ESP32 and send input to it. Essential for debugging and interaction.</li>\n</ul>\n</li>\n<li><strong>Sketch Area (Large White Space):</strong> This is where you write your code, called a &quot;sketch&quot; in Arduino terms.</li>\n<li><strong>Output Console (Bottom Area):</strong> This area shows compilation progress, error messages, upload status, and other feedback from the IDE. Crucial for troubleshooting!</li>\n</ul>\n<h3>1.6 Connecting Your ESP32 and Finding the Port</h3>\n<p>Now, let&#39;s connect your ESP32 to your computer using the USB cable.</p>\n<ol>\n<li>Plug the Micro USB end into the ESP32 board.</li>\n<li>Plug the standard USB end into your computer.</li>\n<li>The ESP32 should power on, and you might see a power LED light up.</li>\n</ol>\n<p>Your computer needs to recognize the ESP32 as a serial device. This usually happens automatically with modern operating systems, but sometimes drivers are needed (especially on older Windows versions or if your board uses a specific USB-to-Serial chip like the CP2102 or CH340). If your computer doesn&#39;t seem to recognize the board, search online for &quot;CP2102 driver&quot; or &quot;CH340 driver&quot; and install the one relevant to your board (you might need to look at the small black chip near the USB port on your ESP32 to identify it).</p>\n<p>Once connected and recognized, you need to tell the Arduino IDE which communication port your ESP32 is connected to.</p>\n<ol>\n<li>In the Arduino IDE, go to <code>Tools &gt; Port</code>.</li>\n<li>You should see a list of available serial ports (e.g., <code>COM3</code>, <code>COM4</code> on Windows, <code>/dev/ttyUSB0</code>, <code>/dev/cu.SLAB_USBtoUART</code> on Linux/macOS).</li>\n<li>Select the port that corresponds to your ESP32. If you&#39;re unsure, unplug the ESP32, check the list, then plug it back in and see which new port appears. <em>This is the one you want.</em></li>\n</ol>\n<p><strong>Finally, select the correct board type:</strong></p>\n<ol>\n<li>Go to <code>Tools &gt; Board &gt; ESP32 Arduino</code>.</li>\n<li>Select <code>ESP32 Dev Module</code>. This is a generic option that works for most standard DevkitC boards.</li>\n</ol>\n<p>Okay, your environment is set up, your board is connected, and the IDE knows how to talk to it! Time for the classic test.</p>\n<h3>1.7 Your First Program: The &quot;Blink&quot; Sketch</h3>\n<p>The &quot;Blink&quot; sketch is the &quot;Hello World&quot; of microcontrollers. It simply turns an LED on and off repeatedly. This verifies that you can compile code, upload it to the board, and make the board <em>do</em> something physical.</p>\n<p>Most ESP32 DevkitC boards have a built-in LED connected to a specific GPIO (General Purpose Input/Output) pin. Often this is GPIO2, but it can vary slightly between boards. We&#39;ll use GPIO2 for this example.</p>\n<p>Here is the standard Blink sketch:</p>\n<pre><code class=\"language-cpp\">// The pin number for the built-in LED on most ESP32 DevkitC boards\nconst int ledPin = 2;\n\n// setup() runs once when the ESP32 starts\nvoid setup() {\n  // Initialize the digital pin ledPin as an output.\n  pinMode(ledPin, OUTPUT);\n}\n\n// loop() runs over and over repeatedly\nvoid loop() {\n  // Turn the LED on (HIGH is the voltage level)\n  digitalWrite(ledPin, HIGH);\n  // Wait for a second (1000 milliseconds)\n  delay(1000);\n  // Turn the LED off by making the voltage LOW\n  digitalWrite(ledPin, LOW);\n  // Wait for a second\n  delay(1000);\n}\n</code></pre>\n<p><strong>Understanding the Code:</strong></p>\n<ul>\n<li><code>const int ledPin = 2;</code>: We define a constant variable <code>ledPin</code> and set it to <code>2</code>. This makes the code easier to read; instead of using <code>2</code> directly everywhere, we use <code>ledPin</code>.</li>\n<li><code>void setup()</code>: This function runs <em>once</em> when the ESP32 is powered on or reset. It&#39;s used for initial configuration.</li>\n<li><code>pinMode(ledPin, OUTPUT);</code>: This line configures the specified pin (<code>ledPin</code>, which is 2) to act as an output pin. This means we can send signals <em>from</em> the ESP32 <em>to</em> whatever is connected to that pin (in this case, the LED).</li>\n<li><code>void loop()</code>: This function runs <em>repeatedly</em> forever after <code>setup()</code> finishes. This is where the main logic of your program goes.</li>\n<li><code>digitalWrite(ledPin, HIGH);</code>: This sets the voltage on the <code>ledPin</code> to a high level (typically 3.3V or 5V, depending on the board logic level). For an LED connected correctly, this turns it <em>on</em>.</li>\n<li><code>delay(1000);</code>: This pauses the program execution for 1000 milliseconds (1 second).</li>\n<li><code>digitalWrite(ledPin, LOW);</code>: This sets the voltage on the <code>ledPin</code> to a low level (0V). This turns the LED <em>off</em>.</li>\n<li><code>delay(1000);</code>: Another 1-second pause.</li>\n</ul>\n<p>So, the <code>loop</code> function turns the LED on, waits, turns it off, waits, and then repeats!</p>\n<p><strong>Uploading the Sketch:</strong></p>\n<ol>\n<li>Copy the code above and paste it into the main sketch area of the Arduino IDE, replacing any default code that&#39;s there.</li>\n<li>Click the <strong>Verify</strong> button (checkmark). Watch the Output Console at the bottom. It should say &quot;Compiling sketch...&quot; and eventually &quot;Done compiling.&quot; If there are errors, the console will show red text explaining them. Fix any errors before proceeding.</li>\n<li>Click the <strong>Upload</strong> button (right arrow).<ul>\n<li>The console will show &quot;Compiling sketch...&quot; again, then &quot;Uploading...&quot;.</li>\n<li>You might see dots or progress percentages.</li>\n<li>On some ESP32 boards, you might need to press and hold the <strong>BOOT</strong> button while the IDE is trying to connect and upload, and then release it once the upload starts. Watch the console for messages like &quot;Connecting...&quot; – that&#39;s the time to press BOOT if needed. <em>Most modern DevkitC boards don&#39;t require this anymore; they have auto-reset circuitry.</em></li>\n<li>If the upload is successful, you&#39;ll see messages like &quot;Hard resetting via RTS pin...&quot; and &quot;Done uploading.&quot;</li>\n</ul>\n</li>\n<li>Look at your ESP32 board! The built-in LED (usually near the Wi-Fi antenna or USB port) should now be blinking on and off with a 1-second interval.</li>\n</ol>\n<p>Congratulations! You&#39;ve successfully set up your environment and uploaded your first code. This is a huge first step!</p>\n<h3>1.8 Using the Serial Monitor</h3>\n<p>The Serial Monitor is your window into what the ESP32 is thinking. It allows the ESP32 to send text messages back to your computer, which is invaluable for debugging and seeing the output of your programs.</p>\n<p>Let&#39;s write a simple sketch that prints a message.</p>\n<pre><code class=\"language-cpp\">// setup() runs once\nvoid setup() {\n  // Initialize serial communication at 115200 bits per second:\n  Serial.begin(115200);\n  // Wait a moment for the Serial Monitor to connect (optional but good practice)\n  delay(1000);\n}\n\n// loop() runs repeatedly\nvoid loop() {\n  // Print a message to the Serial Monitor\n  Serial.println(&quot;Hello, ESP32 Recon!&quot;);\n\n  // Wait for a few seconds before printing again\n  delay(3000); // Wait 3 seconds\n}\n</code></pre>\n<p><strong>Understanding the Code:</strong></p>\n<ul>\n<li><code>Serial.begin(115200);</code>: This line is essential for using the Serial Monitor. It initializes serial communication and sets the &quot;baud rate&quot; (the speed of communication) to 115200 bits per second. <em>The baud rate in your code MUST match the baud rate selected in the Serial Monitor window.</em> 115200 is a common and good speed for the ESP32.</li>\n<li><code>Serial.println(&quot;Hello, ESP32 Recon!&quot;);</code>: This is the command to print text to the Serial Monitor. <code>println</code> adds a newline character at the end, so each message appears on a new line. You can also use <code>Serial.print()</code> to print without a newline.</li>\n</ul>\n<p><strong>Using the Serial Monitor:</strong></p>\n<ol>\n<li>Upload the sketch above to your ESP32 (remember the Verify and Upload steps).</li>\n<li>Once uploaded successfully, click the <strong>Serial Monitor</strong> icon (magnifying glass) in the top-right corner of the Arduino IDE. A new window will pop up.</li>\n<li>In the bottom-right corner of the Serial Monitor window, make sure the baud rate is set to <code>115200 baud</code>.</li>\n<li>You should start seeing &quot;Hello, ESP32 Recon!&quot; printed in the Serial Monitor window every 3 seconds.</li>\n</ol>\n<p>If you don&#39;t see anything, double-check:</p>\n<ul>\n<li>Is the correct Port selected in <code>Tools &gt; Port</code>?</li>\n<li>Is the baud rate in the Serial Monitor window set to 115200?</li>\n<li>Did the sketch upload successfully?</li>\n<li>Is the ESP32 powered?</li>\n</ul>\n<p>The Serial Monitor is your primary tool for debugging throughout this course. Get comfortable using it!</p>\n<h3>1.9 Module Project/Exercise</h3>\n<p>Time to solidify your understanding and test your setup!</p>\n<ol>\n<li><strong>Successfully upload and run the &quot;Blink&quot; sketch on your ESP32.</strong><ul>\n<li>Find the LED blinking on your board.</li>\n</ul>\n</li>\n<li><strong>Modify the blink rate:</strong> Change the <code>delay()</code> values in the <code>loop()</code> function of the Blink sketch. For example, make it blink faster (e.g., <code>delay(200);</code>). Upload the modified sketch and verify the LED blinks at the new rate.</li>\n<li><strong>Write a simple sketch that prints &quot;Hello, ESP32 Recon!&quot; to the Serial Monitor.</strong><ul>\n<li>Start a new sketch (<code>File &gt; New</code>).</li>\n<li>Implement the code from section 1.8 (the <code>Serial.begin()</code> in <code>setup()</code> and <code>Serial.println()</code> in <code>loop()</code>).</li>\n<li>Upload the sketch.</li>\n<li>Open the Serial Monitor and verify that the message is being printed correctly at the specified interval (e.g., every 3 seconds).</li>\n</ul>\n</li>\n</ol>\n<p>These exercises confirm that your hardware is working, your software is configured, you can compile and upload code, and you can receive output from the ESP32. These are the absolute bedrock skills for the rest of the course.</p>\n<h3>1.10 Suggested Resources</h3>\n<ul>\n<li><strong>Official ESP32 Arduino Core Documentation:</strong> <a href=\"https://docs.espressif.com/projects/arduino-esp32/en/latest/\">https://docs.espressif.com/projects/arduino-esp32/en/latest/</a> - The definitive source for ESP32-specific functions in the Arduino framework.</li>\n<li><strong>Arduino Core Reference:</strong> <a href=\"https://www.arduino.cc/reference/en/\">https://www.arduino.cc/reference/en/</a> - Explains standard Arduino functions like <code>pinMode()</code>, <code>digitalWrite()</code>, <code>delay()</code>, <code>Serial.begin()</code>, <code>Serial.println()</code>.</li>\n<li><strong>ESP32 Datasheet (for the brave!):</strong> <a href=\"https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf\">https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf</a> - Deep technical details about the chip itself. Not necessary for this module, but good to know it exists.</li>\n<li><strong>USB-to-Serial Driver Links:</strong> Search for &quot;CP2102 driver&quot; or &quot;CH340 driver&quot; if your computer doesn&#39;t recognize the ESP32 initially. Silicon Labs (for CP210x) and WCH (for CH340/CH341) are the common manufacturers.</li>\n</ul>\n<h3>1.11 Conclusion</h3>\n<p>You&#39;ve done it! You&#39;ve taken the crucial first step. You&#39;ve unboxed your hardware, navigated the sometimes-tricky waters of software setup, and successfully communicated with your ESP32. You&#39;ve made an LED blink and gotten the board to talk to you via the Serial Monitor.</p>\n<p>This might feel simple, but mastering this initial setup saves <em>so much</em> frustration down the line. You now have a working development environment and a basic understanding of how to load code onto your ESP32.</p>\n<p>In Module 2, we&#39;ll build on this by diving deeper into the fundamental programming concepts you&#39;ll need specifically for embedded systems like the ESP32. We&#39;ll look at variables, control flow, and interacting with other pins. Get ready to expand your coding toolkit!</p>\n<p>Keep your ESP32 and USB cable handy. You&#39;re officially on your way to building your own Bluetooth Recon Tool. Fantastic work!</p>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into Module 2! This is where we get our hands dirty with the actual code that makes the ESP32 do our bidding. Think of Module 1 as setting up the laboratory; Module 2 is learning how to use the basic tools and understand the fundamental laws of this embedded world.</p>\n<p>As your guide, I&#39;m excited to break down these core programming concepts specifically for microcontrollers like the ESP32. We&#39;ll focus on the Arduino framework using C++, as it&#39;s widely accessible and has excellent library support, which we&#39;ll definitely need for Bluetooth!</p>\n<hr>\n<h2>Module 2: Embedded Programming Essentials for the ESP32</h2>\n<p><strong>Module Title:</strong> Coding for the Microcontroller: Variables, Control Flow, and Libraries</p>\n<p><strong>Module Objective:</strong> Understand fundamental embedded programming concepts relevant to the ESP32 using the chosen development environment (primarily Arduino/C++ for this course). By the end of this module, you&#39;ll be comfortable writing basic programs that interact with the ESP32&#39;s hardware and lay the foundation for more complex projects.</p>\n<hr>\n<h3>Introduction: Why Embedded Programming is Different (and Awesome!)</h3>\n<p>Welcome back! In Module 1, we got our ESP32 blinking – a classic first step. But how did that happen? We uploaded code! Now, we&#39;re going to peel back the layers and understand the building blocks of that code and how it interacts with the microcontroller.</p>\n<p>Embedded programming isn&#39;t quite like writing a Python script on your laptop. You&#39;re working directly with limited resources (memory, processing power) and need to control specific hardware pins at a very low level. This is where the real fun begins – making silicon bend to your will!</p>\n<p>We&#39;ll be primarily using the <strong>Arduino framework</strong>, which provides a relatively friendly C++ environment for microcontrollers. It abstracts away some of the most complex low-level details while still giving you powerful access to the hardware.</p>\n<h3>Essential Subtopics:</h3>\n<p>Let&#39;s break down the core concepts we need to master.</p>\n<h4>2.1 Review of Basic C++ Syntax</h4>\n<p>You might have seen C++ before, or maybe only languages like Python or JavaScript. Don&#39;t worry, we&#39;ll cover the essentials needed for Arduino sketches. C++ is a powerful language, and the Arduino environment simplifies it significantly.</p>\n<ul>\n<li><strong>Variables:</strong> Think of variables as named containers for storing data.<ul>\n<li><strong>Declaration:</strong> You must tell the compiler what kind of data the variable will hold (its <em>data type</em>) and give it a name.<pre><code class=\"language-cpp\">int sensorValue; // Declares an integer variable named sensorValue\nfloat temperature; // Declares a floating-point variable\nbool isPressed; // Declares a boolean (true/false) variable\nchar commandChar; // Declares a single character variable\n</code></pre>\n</li>\n<li><strong>Data Types:</strong> Common types you&#39;ll use:<ul>\n<li><code>int</code>: Integers (whole numbers, positive or negative). On ESP32, typically 32-bit.</li>\n<li><code>float</code>: Floating-point numbers (numbers with decimal points).</li>\n<li><code>bool</code>: Boolean (stores <code>true</code> or <code>false</code>).</li>\n<li><code>char</code>: Single characters (like &#39;A&#39;, &#39;5&#39;, &#39;#&#39;).</li>\n<li><code>long</code>: Larger integers.</li>\n<li><code>byte</code>: An 8-bit unsigned integer (0 to 255). Useful for raw data.</li>\n<li><code>String</code>: A sequence of characters (text). <em>Caution:</em> While convenient, <code>String</code> objects can sometimes cause memory fragmentation issues on microcontrollers. For simple text, C-style character arrays (<code>char[]</code>) are often preferred in performance-critical code, but <code>String</code> is fine for our initial Serial output.</li>\n</ul>\n</li>\n<li><strong>Assignment:</strong> Giving a variable a value.<pre><code class=\"language-cpp\">sensorValue = 1023; // Assigns the value 1023 to sensorValue\ntemperature = 25.5;\nisPressed = true;\ncommandChar = &#39;S&#39;;\n</code></pre>\n</li>\n<li><strong>Initialization:</strong> Declaring and assigning a value at the same time.<pre><code class=\"language-cpp\">int ledPin = 16; // Declares an int and sets its initial value\nconst int buttonPin = 4; // const means the value cannot be changed later - good practice for pin numbers!\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Operators:</strong> Symbols that perform operations on variables and values.<ul>\n<li><strong>Arithmetic:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo - remainder).</li>\n<li><strong>Comparison:</strong> <code>==</code> (equal to), <code>!=</code> (not equal to), <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to), <code>&gt;=</code> (greater than or equal to). These are used in conditional statements.</li>\n<li><strong>Logical:</strong> <code>&amp;&amp;</code> (AND), <code>||</code> (OR), <code>!</code> (NOT). Used to combine or negate boolean expressions.</li>\n</ul>\n</li>\n<li><strong>Comments:</strong> Lines of code ignored by the compiler, used to explain your code.<ul>\n<li>Single-line: <code>// This is a single-line comment</code></li>\n<li>Multi-line:<pre><code class=\"language-cpp\">/*\nThis is a\nmulti-line\ncomment\n*/\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Code Example: Variables and Basic Output</strong></p>\n<p>Let&#39;s write a quick sketch to demonstrate variables and print them to the Serial Monitor.</p>\n<pre><code class=\"language-cpp\">// Module 2.1 - Variables and Basic Output\n\n// Use constants for things that won&#39;t change, like pin numbers (good practice!)\nconst int myNumber = 42;\nconst float piValue = 3.14159;\nconst bool isActive = true;\nconst char initial = &#39;E&#39;;\n\n// Variables that might change\nint counter = 0;\nfloat measurement = 0.0;\nString message = &quot;Hello ESP32!&quot;;\n\nvoid setup() {\n  // Initialize Serial communication at 115200 bits per second\n  // This speed needs to match the Serial Monitor setting\n  Serial.begin(115200);\n\n  // Give the Serial Monitor a moment to connect (optional but good for boot)\n  delay(1000);\n  Serial.println(&quot;--- Module 2.1 Demo ---&quot;);\n}\n\nvoid loop() {\n  // Print constant values\n  Serial.print(&quot;My constant number: &quot;);\n  Serial.println(myNumber); // println adds a newline at the end\n\n  Serial.print(&quot;Value of Pi: &quot;);\n  Serial.println(piValue);\n\n  Serial.print(&quot;Is active? &quot;);\n  Serial.println(isActive); // Prints 1 for true, 0 for false\n\n  Serial.print(&quot;Initial character: &quot;);\n  Serial.println(initial);\n\n  // Print and update changing variables\n  Serial.print(&quot;Counter: &quot;);\n  Serial.println(counter);\n  counter = counter + 1; // Increment counter (can also use counter++)\n\n  // Simulate a measurement change\n  measurement = measurement + 0.1;\n  Serial.print(&quot;Measurement: &quot;);\n  Serial.println(measurement);\n\n  // Print a String\n  Serial.println(message);\n\n  Serial.println(&quot;-----------------------&quot;);\n\n  // Wait a bit before the next loop iteration\n  delay(2000); // Wait for 2 seconds\n}\n</code></pre>\n<p>Upload this sketch, open the Serial Monitor (make sure the baud rate is set to 115200), and watch the output. You&#39;ll see your variables printed repeatedly.</p>\n<h4>2.2 Control Flow</h4>\n<p>Control flow statements determine the order in which your code executes. This is how your program makes decisions and repeats actions.</p>\n<ul>\n<li><strong><code>if</code>, <code>else if</code>, <code>else</code>:</strong> Execute blocks of code only if certain conditions are true.<pre><code class=\"language-cpp\">int temperature = 28;\nif (temperature &gt; 30) {\n  Serial.println(&quot;It&#39;s hot!&quot;);\n} else if (temperature &gt; 20) { // This block is checked only if the first condition is false\n  Serial.println(&quot;It&#39;s warm.&quot;);\n} else { // This block executes if none of the above conditions are true\n  Serial.println(&quot;It&#39;s cool.&quot;);\n}\n</code></pre>\n</li>\n<li><strong><code>switch</code>:</strong> A cleaner way to handle multiple <code>if/else if</code> statements when checking a single variable against several constant values.<pre><code class=\"language-cpp\">char command = &#39;B&#39;;\nswitch (command) {\n  case &#39;A&#39;:\n    Serial.println(&quot;Command A received.&quot;);\n    break; // Important! Exits the switch block\n  case &#39;B&#39;:\n    Serial.println(&quot;Command B received.&quot;);\n    break;\n  case &#39;C&#39;:\n    Serial.println(&quot;Command C received.&quot;);\n    break;\n  default: // Executes if none of the cases match\n    Serial.println(&quot;Unknown command.&quot;);\n    break;\n}\n</code></pre>\n</li>\n<li><strong><code>for</code> loops:</strong> Repeat a block of code a fixed number of times.<pre><code class=\"language-cpp\">// Structure: for (initialization; condition; increment/decrement)\nfor (int i = 0; i &lt; 5; i++) {\n  Serial.print(&quot;Iteration: &quot;);\n  Serial.println(i);\n}\n// Output: Iteration: 0, Iteration: 1, Iteration: 2, Iteration: 3, Iteration: 4\n</code></pre>\n</li>\n<li><strong><code>while</code> loops:</strong> Repeat a block of code as long as a condition is true. Use with caution to avoid infinite loops that freeze your microcontroller!<pre><code class=\"language-cpp\">int timer = 3;\nwhile (timer &gt; 0) {\n  Serial.print(&quot;Countdown: &quot;);\n  Serial.println(timer);\n  timer = timer - 1; // Must change the condition inside the loop!\n  delay(1000);\n}\nSerial.println(&quot;Lift off!&quot;);\n</code></pre>\n</li>\n</ul>\n<p><strong>Code Example: Control Flow</strong></p>\n<pre><code class=\"language-cpp\">// Module 2.2 - Control Flow Demo\n\nint sensorReading = 750; // Simulate reading from a sensor (e.g., 0-1023)\nint loopCounter = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  Serial.println(&quot;--- Module 2.2 Demo (Control Flow) ---&quot;);\n}\n\nvoid loop() {\n  Serial.print(&quot;Loop iteration: &quot;);\n  Serial.println(loopCounter);\n\n  // --- if/else example ---\n  if (sensorReading &gt; 800) {\n    Serial.println(&quot;Sensor reading is high.&quot;);\n  } else if (sensorReading &gt; 500) {\n    Serial.println(&quot;Sensor reading is medium.&quot;);\n  } else {\n    Serial.println(&quot;Sensor reading is low.&quot;);\n  }\n\n  // --- switch example (using loopCounter modulo 3) ---\n  int mode = loopCounter % 3; // Gives 0, 1, or 2\n  switch (mode) {\n    case 0:\n      Serial.println(&quot;Current mode: Scan.&quot;);\n      break;\n    case 1:\n      Serial.println(&quot;Current mode: Analyze.&quot;);\n      break;\n    case 2:\n      Serial.println(&quot;Current mode: Report.&quot;);\n      break;\n    default: // Should not happen with modulo, but good practice\n      Serial.println(&quot;Current mode: Unknown.&quot;);\n      break;\n  }\n\n  // --- for loop example (runs once per loop() iteration) ---\n  Serial.print(&quot;Counting up: &quot;);\n  for (int i = 0; i &lt; 3; i++) {\n    Serial.print(i);\n    Serial.print(&quot; &quot;);\n  }\n  Serial.println(); // Newline after the numbers\n\n  // --- while loop example (simulated) ---\n  // Be careful with while loops in loop()!\n  // This one is commented out to avoid blocking loop()\n  /*\n  int countdown = 2;\n  while(countdown &gt; 0){\n    Serial.print(&quot;Inner countdown: &quot;);\n    Serial.println(countdown);\n    countdown--;\n    delay(500); // Small delay\n  }\n  */\n\n  Serial.println(&quot;-----------------------&quot;);\n\n  // Simulate sensor reading changing slightly\n  sensorReading = sensorReading - 10;\n  if (sensorReading &lt; 400) {\n    sensorReading = 800; // Reset simulation\n  }\n\n  loopCounter++;\n\n  delay(1000); // Wait 1 second before next main loop() iteration\n}\n</code></pre>\n<p>Upload this and observe how the output changes based on the simulated <code>sensorReading</code> and the <code>loopCounter</code>.</p>\n<h4>2.3 Functions</h4>\n<p>Functions are blocks of code that perform a specific task. They help organize your code, make it reusable, and easier to read and debug.</p>\n<ul>\n<li><strong>Defining a function:</strong><pre><code class=\"language-cpp\">// Structure: returnType functionName(parameter1Type parameter1Name, ...) { // code block }\n\nvoid printGreeting() { // void means the function doesn&#39;t return a value\n  Serial.println(&quot;Greetings from a function!&quot;);\n}\n\nint addNumbers(int a, int b) { // Takes two integers, returns an integer\n  int sum = a + b;\n  return sum; // Send the result back\n}\n</code></pre>\n</li>\n<li><strong>Calling a function:</strong> Using the function&#39;s name followed by parentheses (and arguments if it takes parameters).<pre><code class=\"language-cpp\">printGreeting(); // Calls the printGreeting function\n\nint result = addNumbers(5, 3); // Calls addNumbers, stores the returned value in &#39;result&#39;\nSerial.print(&quot;Sum is: &quot;);\nSerial.println(result); // Output: Sum is: 8\n</code></pre>\n</li>\n</ul>\n<h4>2.4 Understanding <code>setup()</code> and <code>loop()</code> in Arduino</h4>\n<p>These are the two fundamental functions in every Arduino sketch.</p>\n<ul>\n<li><strong><code>void setup()</code>:</strong><ul>\n<li>This function runs <strong>exactly once</strong> when the ESP32 starts up (either on power-on or reset).</li>\n<li>It&#39;s used for <strong>initialization tasks</strong>:<ul>\n<li>Setting up Serial communication (<code>Serial.begin()</code>).</li>\n<li>Configuring pin modes (<code>pinMode()</code>).</li>\n<li>Initializing libraries or sensors.</li>\n<li>Setting initial variable values.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>void loop()</code>:</strong><ul>\n<li>This function runs <strong>continuously</strong> after <code>setup()</code> has finished.</li>\n<li>It&#39;s where your main program logic resides.</li>\n<li>You place the code here that you want to run repeatedly, like checking sensors, responding to input, updating outputs, or, in our case, scanning for Bluetooth devices!</li>\n</ul>\n</li>\n</ul>\n<p>Think of <code>setup()</code> as getting everything ready in your lab, and <code>loop()</code> as the actual ongoing experiment you&#39;re running.</p>\n<p><strong>Code Example: <code>setup()</code> and <code>loop()</code> (Blink Revisited)</strong></p>\n<p>Let&#39;s look at the classic Blink sketch again, highlighting <code>setup</code> and <code>loop</code>.</p>\n<pre><code class=\"language-cpp\">// Module 2.4 - setup() and loop() - Blink Revisited\n\nconst int ledPin = 2; // Onboard LED on most ESP32 Devkits (often labeled D2)\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200); // Initialize serial communication\n  delay(1000); // Wait for Serial Monitor\n\n  Serial.println(&quot;--- Module 2.4 Demo (Blink setup/loop) ---&quot;);\n  Serial.print(&quot;Configuring LED pin &quot;);\n  Serial.print(ledPin);\n  Serial.println(&quot; as OUTPUT.&quot;);\n\n  // Configure the LED pin as an OUTPUT\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n  Serial.println(&quot;LED ON&quot;);\n  // Turn the LED on (HIGH voltage)\n  digitalWrite(ledPin, HIGH);\n  delay(1000); // Wait for 1 second\n\n  Serial.println(&quot;LED OFF&quot;);\n  // Turn the LED off (LOW voltage)\n  digitalWrite(ledPin, LOW);\n  delay(1000); // Wait for 1 second\n}\n</code></pre>\n<p>In <code>setup()</code>, we tell the ESP32 that <code>ledPin</code> will be used for <em>outputting</em> a voltage. In <code>loop()</code>, we repeatedly set the voltage on that pin HIGH (on) and then LOW (off), with delays in between. This simple structure is the heart of most embedded applications.</p>\n<h4>2.5 Working with GPIO Pins (Digital)</h4>\n<p>GPIO stands for General Purpose Input/Output. These are the physical pins on the ESP32 chip (and exposed on the DevkitC board) that you can control from your code to interact with the outside world.</p>\n<ul>\n<li><strong>Digital Pins:</strong> Can be set to one of two states: HIGH (typically 3.3V on ESP32) or LOW (0V). They can also read digital signals (HIGH/LOW).</li>\n<li><strong>Pin Numbering:</strong> Refer to your specific ESP32 DevkitC pinout diagram. Common pins used for general I/O include 2, 4, 12-19, 21-23, 25-27, 32-33. Some pins have limitations or default roles (e.g., pins 6-11 are used for flash memory, pin 0 often used for boot mode, pins 34-39 are input-only). We&#39;ll stick to common, safe pins like 2, 4, 16, 17 for examples.</li>\n<li><strong>Pin Modes:</strong> Before using a digital pin, you must tell the ESP32 how you intend to use it using the <code>pinMode()</code> function in <code>setup()</code>.<ul>\n<li><code>pinMode(pin, OUTPUT);</code>: Configure the pin to send voltage out (like controlling an LED).</li>\n<li><code>pinMode(pin, INPUT);</code>: Configure the pin to read voltage in (like reading a sensor or button). The pin is high impedance.</li>\n<li><code>pinMode(pin, INPUT_PULLUP);</code>: Configure the pin as input, but also activate an internal pull-up resistor. This is <em>extremely useful</em> for connecting buttons directly between the pin and ground. When the button is open, the internal resistor pulls the pin HIGH. When the button is pressed, it connects the pin directly to LOW (ground). This avoids the need for an external resistor.</li>\n</ul>\n</li>\n<li><strong>Digital Write:</strong> Use <code>digitalWrite(pin, state);</code> to set an <code>OUTPUT</code> pin to <code>HIGH</code> or <code>LOW</code>.</li>\n<li><strong>Digital Read:</strong> Use <code>digitalRead(pin);</code> to read the state (<code>HIGH</code> or <code>LOW</code>) of an <code>INPUT</code> or <code>INPUT_PULLUP</code> pin.</li>\n</ul>\n<p><strong>Connecting Components:</strong></p>\n<ul>\n<li><strong>LED:</strong> LEDs only allow current in one direction. The <em>anode</em> (longer leg) connects to the ESP32 pin (via a resistor!), and the <em>cathode</em> (shorter leg) connects to Ground (GND). A resistor (e.g., 220 Ohm to 1k Ohm) is <em>essential</em> to limit current and prevent burning out the LED or the ESP32 pin.</li>\n<li><strong>Button:</strong> A simple momentary button has two terminals. Connect one terminal to an ESP32 digital pin configured as <code>INPUT_PULLUP</code>. Connect the other terminal to Ground (GND). When pressed, the button connects the pin to ground, causing <code>digitalRead()</code> to return <code>LOW</code>. When released, the pull-up resistor pulls the pin HIGH.</li>\n</ul>\n<p><strong>Code Example: Digital Read/Write (Button &amp; LED)</strong></p>\n<p>This is very close to our module project!</p>\n<pre><code class=\"language-cpp\">// Module 2.5 - Digital Read/Write Demo (Button &amp; LED)\n\n// Define pins using constants\nconst int ledPin = 16;   // Connect LED (with resistor) to GPIO 16\nconst int buttonPin = 4; // Connect Button between GPIO 4 and GND\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  Serial.println(&quot;--- Module 2.5 Demo (Button &amp; LED) ---&quot;);\n\n  // Configure pins\n  pinMode(ledPin, OUTPUT);       // LED pin is an output\n  pinMode(buttonPin, INPUT_PULLUP); // Button pin is an input with internal pull-up\n}\n\nvoid loop() {\n  // Read the state of the button pin\n  int buttonState = digitalRead(buttonPin);\n\n  // Note: With INPUT_PULLUP, the button is LOW when pressed\n  if (buttonState == LOW) {\n    // Button is pressed\n    Serial.println(&quot;Button PRESSED! Turning LED ON.&quot;);\n    digitalWrite(ledPin, HIGH); // Turn LED ON\n  } else {\n    // Button is not pressed\n    Serial.println(&quot;Button released. Turning LED OFF.&quot;);\n    digitalWrite(ledPin, LOW);  // Turn LED OFF\n  }\n\n  // Add a small delay to prevent flooding the Serial Monitor and for basic debouncing\n  delay(50);\n}\n</code></pre>\n<p><strong>Exercise:</strong> Wire up an LED (with resistor!) and a button as described. Upload this sketch and test it. Observe the Serial output and the LED behavior as you press and release the button.</p>\n<h4>2.6 Basic Analog Read</h4>\n<p>While not strictly needed for the final project <em>modes</em>, the outline mentions it, and it&#39;s a fundamental embedded concept. Analog pins can read a <em>range</em> of voltages, not just HIGH/LOW.</p>\n<ul>\n<li><strong>ADC (Analog-to-Digital Converter):</strong> The hardware inside the ESP32 that converts an analog voltage level into a digital number.</li>\n<li><strong><code>analogRead(pin);</code>:</strong> Reads the voltage on a specific analog-capable pin and returns a digital value.</li>\n<li><strong>Resolution:</strong> The ESP32&#39;s ADC is typically 12-bit, meaning it can represent 4096 different values (0 to 4095).</li>\n<li><strong>Analog Pins:</strong> On the ESP32 DevkitC, pins 32-39 are typically ADC-capable.</li>\n<li><strong>Voltage Range:</strong> The default input voltage range for the ADC pins is 0V to 3.3V. The <code>analogRead()</code> value will map proportionally within the 0-4095 range.</li>\n</ul>\n<p><strong>Code Example: Basic Analog Read</strong></p>\n<pre><code class=\"language-cpp\">// Module 2.6 - Basic Analog Read Demo\n\n// ESP32 ADC pins are typically 32-39\nconst int analogPin = 34; // Use an ADC-capable pin, e.g., GPIO 34\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  Serial.println(&quot;--- Module 2.6 Demo (Analog Read) ---&quot;);\n  Serial.print(&quot;Reading analog value from pin: &quot;);\n  Serial.println(analogPin);\n\n  // No pinMode needed for analogRead()!\n}\n\nvoid loop() {\n  // Read the analog value from the pin\n  int analogValue = analogRead(analogPin);\n\n  // Print the raw analog value\n  Serial.print(&quot;Raw Analog Value: &quot;);\n  Serial.println(analogValue);\n\n  // Optional: Convert the value to voltage (if a voltage is applied)\n  // Assuming 0-4095 maps to 0-3.3V\n  float voltage = (float)analogValue / 4095.0 * 3.3;\n  Serial.print(&quot;Estimated Voltage: &quot;);\n  Serial.print(voltage);\n  Serial.println(&quot; V&quot;);\n\n\n  Serial.println(&quot;-----------------------&quot;);\n\n  delay(500); // Read every 0.5 seconds\n}\n</code></pre>\n<p><strong>Exercise:</strong> Upload this sketch. If you have a potentiometer, wire its ends to 3.3V and GND, and the middle pin to GPIO 34. Turn the knob and see the values change. If you don&#39;t have a potentiometer, just upload it and see the values fluctuate slightly due to electrical noise on the unconnected pin.</p>\n<h4>2.7 Introduction to Libraries</h4>\n<p>Libraries are collections of pre-written code that provide functions and tools to make your life easier. Instead of writing complex code from scratch to control a specific sensor, a communication protocol like Bluetooth, or a display, you can often use a library.</p>\n<ul>\n<li><strong>What they are:</strong> A bundle of <code>.h</code> (header) and <code>.cpp</code> (source) files. The header file declares what&#39;s available (functions, classes, variables), and the source file contains the actual implementation.</li>\n<li><strong>Why use them:</strong><ul>\n<li><strong>Save Time:</strong> Don&#39;t reinvent the wheel for common tasks.</li>\n<li><strong>Abstraction:</strong> Hide complex low-level details behind simple function calls.</li>\n<li><strong>Reliability:</strong> Libraries are often tested and maintained by communities.</li>\n</ul>\n</li>\n<li><strong>Including Libraries:</strong> You add <code>#include &lt;LibraryName.h&gt;</code> at the top of your sketch. This tells the compiler to make the functions and objects defined in that library available to your code.<pre><code class=\"language-cpp\">#include &lt;Wire.h&gt; // Include the Wire library for I2C communication\n#include &lt;BluetoothSerial.h&gt; // Example: Include a library for Bluetooth Classic Serial Port Profile\n// For BLE, we&#39;ll use a specific library like ESP32-BLE-Arduino later:\n// #include &lt;BLEDevice.h&gt;\n</code></pre>\n</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: module_3</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve unboxed, we&#39;ve blinked an LED, and we&#39;ve got our basic coding muscles warmed up. Now, we&#39;re stepping into the <em>truly</em> invisible world – the airwaves buzzing with Bluetooth signals all around us. This is where the &quot;recon&quot; part of our tool starts to take shape, and it&#39;s fascinating!</p>\n<p>Module 3 is all about understanding the language these devices speak. We won&#39;t be writing much code <em>yet</em> in this module – this is our deep dive into the <em>theory</em> that makes everything else possible. Think of it as learning the anatomy of the signals before we start dissecting them with our ESP32 scanner.</p>\n<p>Let&#39;s dive in!</p>\n<hr>\n<h2>Module 3: Bluetooth Deep Dive: Protocols, Packets, and Presence</h2>\n<ul>\n<li><strong>Module Title:</strong> Understanding Bluetooth: BLE vs. Classic, Advertising, and Identification</li>\n<li><strong>Module Objective:</strong> Gain a solid theoretical understanding of Bluetooth, focusing on the concepts essential for reconnaissance and detection.</li>\n</ul>\n<hr>\n<h3>Introduction: The Air is Alive!</h3>\n<p>You might think of Bluetooth only when you pair your headphones or connect to a car stereo. But the reality is, there are <em>thousands</em> of Bluetooth devices constantly chattering in the air around you, especially in populated areas. Smartwatches, fitness trackers, phones (even when not actively connected), beacons in stores, industrial sensors, medical devices – they&#39;re all broadcasting their presence.</p>\n<p>Our goal in this module is to understand <em>how</em> they do this, what information they broadcast, and how we can listen in. This foundational knowledge is absolutely critical before we start coding our scanner in Module 4.</p>\n<h3>3.1 Bluetooth Classic (BR/EDR) vs. Bluetooth Low Energy (BLE)</h3>\n<p>Okay, let&#39;s clear this up first. When people say &quot;Bluetooth,&quot; they often mean Bluetooth Classic (the original standard, sometimes called BR/EDR - Basic Rate/Enhanced Data Rate). This is what you use for streaming audio, transferring files, or connecting peripherals like keyboards and mice that need a constant, higher-bandwidth connection.</p>\n<p>Then there&#39;s Bluetooth Low Energy (BLE), introduced in the Bluetooth 4.0 specification. As the name suggests, its primary goal is <em>minimal power consumption</em>.</p>\n<p>Here&#39;s a breakdown of the key differences:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Feature</th>\n<th align=\"left\">Bluetooth Classic (BR/EDR)</th>\n<th align=\"left\">Bluetooth Low Energy (BLE)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Primary Goal</strong></td>\n<td align=\"left\">Data streaming, continuous connection</td>\n<td align=\"left\">Low power, periodic data transfer</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Topology</strong></td>\n<td align=\"left\">Piconet (Master/Slave)</td>\n<td align=\"left\">Star, Mesh, Broadcast</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Connection</strong></td>\n<td align=\"left\">Connection-oriented (requires pairing)</td>\n<td align=\"left\">Connection-oriented <em>or</em> Connectionless</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Data Throughput</strong></td>\n<td align=\"left\">Higher (up to ~2.1 Mbps)</td>\n<td align=\"left\">Lower (optimized for small data packets)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Power Usage</strong></td>\n<td align=\"left\">Higher</td>\n<td align=\"left\"><em>Significantly</em> lower (can run on coin cell for years)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Complexity</strong></td>\n<td align=\"left\">More complex protocol stack</td>\n<td align=\"left\">Simpler protocol stack</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Use Cases</strong></td>\n<td align=\"left\">Audio streaming, file transfer, peripherals</td>\n<td align=\"left\">Wearables, beacons, sensors, smart home, tracking</td>\n</tr>\n</tbody></table>\n<p><strong>Think of it this way:</strong></p>\n<ul>\n<li><strong>Bluetooth Classic:</strong> Like a continuous phone call. You establish a connection, and data flows back and forth constantly. Great for conversations (audio) or sustained tasks. Uses more battery.</li>\n<li><strong>Bluetooth Low Energy:</strong> Like sending postcards periodically. Devices can broadcast small bits of information without needing a persistent connection. Great for sending sensor readings, notifications, or just announcing &quot;Hey, I&#39;m here!&quot; Uses very little battery.</li>\n</ul>\n<p><strong>Why are we focusing on BLE for reconnaissance?</strong></p>\n<p>Simple: <strong>Advertising.</strong></p>\n<p>BLE devices are designed to spend most of their time asleep, waking up only periodically to send out small packets of data called <strong>Advertising Packets</strong>. This connectionless broadcast mechanism is perfect for devices that need to be discoverable or send out alerts without the power overhead of maintaining a constant connection.</p>\n<p>These advertising packets are the <em>primary source of information</em> we&#39;ll be capturing and analyzing with our ESP32 tool. We&#39;re essentially becoming a passive listener, collecting these &quot;postcards&quot; from nearby devices.</p>\n<h3>3.2 BLE Roles: Who&#39;s Talking to Whom?</h3>\n<p>In the BLE world, devices take on different roles depending on what they&#39;re doing. Understanding these roles is key to understanding how scanning and advertising work.</p>\n<p>The two main pairs of roles are:</p>\n<ol>\n<li><p><strong>Peripheral vs. Central:</strong></p>\n<ul>\n<li><strong>Peripheral:</strong> A device that provides data and waits for a Central device to connect. Think of a heart rate monitor, a smart lock, or a BLE sensor. It typically advertises its presence.</li>\n<li><strong>Central:</strong> A device that scans for Peripherals and initiates connections to them to consume their data. Think of your smartphone or a smart home hub.</li>\n</ul>\n</li>\n<li><p><strong>Broadcaster vs. Observer:</strong></p>\n<ul>\n<li><strong>Broadcaster:</strong> A device that sends out advertising packets but <em>does not</em> accept connections. Think of a simple beacon in a store. It just announces information.</li>\n<li><strong>Observer:</strong> A device that scans for advertising packets but <em>does not</em> initiate connections. It just listens to the broadcasts.</li>\n</ul>\n</li>\n</ol>\n<p><strong>For our project:</strong></p>\n<ul>\n<li>When our ESP32 is scanning for devices (like trackers or for baseline analysis), it will act as an <strong>Observer</strong> (or sometimes a Central in scanning mode, but the key is it&#39;s <em>listening</em>).</li>\n<li>The devices we are trying to detect (trackers, phones, etc.) will primarily be acting as <strong>Broadcasters</strong> or <strong>Peripherals</strong> that are currently advertising.</li>\n<li>In Module 7, when we make our ESP32 <em>send</em> signals for advertising flooding, it will act as a <strong>Broadcaster</strong>.</li>\n</ul>\n<p>The crucial point for reconnaissance is the <strong>Broadcaster/Observer</strong> relationship and the <strong>Advertising Process</strong>.</p>\n<h3>3.3 The BLE Advertising Process</h3>\n<p>This is the core mechanism for discovery in BLE. Devices that want to be found or want to broadcast information periodically send out advertising packets.</p>\n<ul>\n<li><strong>How it works:</strong> A Broadcaster/Peripheral wakes up from a low-power state, transmits the same advertising packet on three specific advertising channels (channels 37, 38, and 39 in the 2.4 GHz band), and then goes back to sleep.</li>\n<li><strong>Why three channels?</strong> This hopping helps avoid interference and increases the chance that an Observer/Central will hear the advertisement.</li>\n<li><strong>Advertising Interval:</strong> Devices advertise at a set interval (e.g., every 100ms, 1 second, etc.). A shorter interval makes the device more discoverable but uses slightly more power.</li>\n<li><strong>Advertising Packet Types:</strong> There are different types, but the most common for simple broadcasts are <code>ADV_IND</code> (connectable undirected advertising) and <code>ADV_NONCONN_IND</code> (non-connectable undirected advertising). Our scanner will pick up both.</li>\n</ul>\n<p>An Observer/Central device scans these three channels, listening for any advertising packets. When it hears one, it captures the packet and processes the data within it.</p>\n<h3>3.4 Advertising Packets: What&#39;s Inside?</h3>\n<p>This is where we get to the actual data we can extract! An advertising packet contains several pieces of information structured in a specific way.</p>\n<p>The payload of a BLE advertising packet consists of one or more <strong>Advertising Data (AD) structures</strong>. Each AD structure follows a simple <strong>Length-Type-Value (LTV)</strong> format:</p>\n<ul>\n<li><strong>Length (L):</strong> A single byte indicating the length of the Value field + 1 (for the Type byte).</li>\n<li><strong>Type (T):</strong> A single byte indicating the type of data in the Value field (e.g., &quot;This is the device name,&quot; &quot;This is the manufacturer data&quot;). These types are defined by the Bluetooth SIG.</li>\n<li><strong>Value (V):</strong> The actual data payload, with a length of L-1 bytes.</li>\n</ul>\n<pre><code>[ Length (1 byte) | Type (1 byte) | Value (Length-1 bytes) ]\n</code></pre>\n<p>A full advertising packet is just a sequence of these LTV structures.</p>\n<pre><code>[ AD Structure 1 ] [ AD Structure 2 ] [ AD Structure 3 ] ...\n</code></pre>\n<p><strong>Common Advertising Data (AD) Types you&#39;ll encounter (and look for!):</strong></p>\n<ul>\n<li><strong>Flags (Type 0x01):</strong> Indicates the device&#39;s capabilities (e.g., discoverable mode, whether it supports BLE and Classic).</li>\n<li><strong>Service UUIDs (Type 0x02, 0x03, 0x04, 0x05, 0x06, 0x07):</strong> Identifies the services the device offers (e.g., Heart Rate Service, Battery Service). These can be 16-bit (standard BLE services), 32-bit, or 128-bit (custom services).</li>\n<li><strong>Local Name (Type 0x08 - Shortened, 0x09 - Complete):</strong> The human-readable name of the device (e.g., &quot;My Headphones,&quot; &quot;John&#39;s Phone&quot;). Not all devices include a name in advertising.</li>\n<li><strong>TX Power Level (Type 0x0A):</strong> The transmit power of the advertising signal (in dBm). Can sometimes be used for rough distance estimation calibration.</li>\n<li><strong>Manufacturer Specific Data (Type 0xFF):</strong> This is a <em>very important</em> type for reconnaissance! It allows manufacturers to include custom data formats. This is where you&#39;ll often find unique identifiers used by specific ecosystems (like Apple&#39;s Find My protocol data, Tile identifiers, etc.). The format inside the Value field is manufacturer-specific, but it usually starts with a 2-byte Manufacturer ID assigned by the Bluetooth SIG.</li>\n</ul>\n<p><strong>Example (Conceptual Packet):</strong></p>\n<p>Imagine an advertising packet that contains the device name and some manufacturer data. The raw bytes might look <em>something</em> like this (simplified):</p>\n<pre><code>0x05, 0x09, 0x4D, 0x79, 0x44, 0x65, 0x76,  // Length=5, Type=0x09 (Complete Local Name), Value=&quot;MyDev&quot;\n0x06, 0xFF, 0x00, 0x4C, 0x01, 0x02, 0x03   // Length=6, Type=0xFF (Manufacturer Specific Data), Value=0x004C (Apple&#39;s ID), 0x01, 0x02, 0x03 (custom data)\n</code></pre>\n<p>Our ESP32 BLE library will parse these bytes for us, presenting the data in a more usable format (like strings for names, byte arrays for manufacturer data). But understanding this underlying structure is key to knowing what you&#39;re looking at when you see raw scan results.</p>\n<h3>3.5 Device Identification: MAC Addresses and Privacy</h3>\n<p>Every Bluetooth device has a unique identifier called a <strong>Bluetooth Address</strong> (similar in concept to a Wi-Fi MAC address). This is a 48-bit (6-byte) number. It&#39;s often the primary way we identify a <em>specific</em> device during scanning.</p>\n<p>However, thanks to privacy features in BLE, it&#39;s not always a static, globally unique address. There are different types:</p>\n<ol>\n<li><strong>Public Device Address:</strong> This is the device&#39;s true, globally unique IEEE 802-registered address. It&#39;s static and assigned by the manufacturer. If a device uses a Public address, it&#39;s easy to track its presence over time just by looking for that address.</li>\n<li><strong>Random Device Address:</strong> Devices can use randomly generated addresses instead of their Public address. This is a privacy feature to prevent passive tracking. There are subtypes of Random addresses:<ul>\n<li><strong>Random Static Address:</strong> A randomly generated address that <em>doesn&#39;t change</em> after it&#39;s set (until maybe the device is factory reset). While random, it&#39;s still static, so you <em>can</em> track a device using this address over time <em>until</em> it changes (which might be never, or rarely).</li>\n<li><strong>Random Resolvable Private Address (RPA):</strong> This is the most privacy-focused type for devices that <em>do</em> connect. The address changes frequently (e.g., every 15 minutes). However, a trusted Central device (like your phone that&#39;s paired with your smartwatch) has a special key called the Identity Resolving Key (IRK). Using the IRK, the Central can calculate whether a received RPA belongs to a known device. An <em>untrusted</em> Observer (like our scanner, which doesn&#39;t have the IRK) <em>cannot</em> link a new RPA back to a previously seen RPA or the device&#39;s Public address. This makes passive tracking difficult <em>if RPAs are used correctly</em>.</li>\n<li><strong>Random Non-Resolvable Private Address:</strong> A randomly generated address that changes frequently and <em>cannot</em> be resolved back to a Public address or IRK. Used when a device doesn&#39;t expect to be connected to (e.g., some types of pure Broadcasters).</li>\n</ul>\n</li>\n</ol>\n<p><strong>Implications for Reconnaissance:</strong></p>\n<ul>\n<li>If a device uses a <strong>Public</strong> or <strong>Random Static</strong> address, we can easily identify and track it over time using its address alone.</li>\n<li>If a device uses <strong>RPAs</strong>, we can still detect its <em>presence</em> when it advertises, but each advertisement might appear to come from a <em>new, different</em> address to our scanner. We <em>cannot</em> reliably track its movement or history based on the address alone unless we have the IRK (which we won&#39;t). We might have to rely on other identifying data in the advertising packet (like specific Manufacturer Specific Data patterns, though this is less reliable and can also change).</li>\n<li>If a device uses <strong>Random Non-Resolvable</strong> addresses, it&#39;s even harder to track.</li>\n</ul>\n<p>This is a key concept for our &quot;Personal Tracker Detection&quot; mode. We need to understand that seeing a new MAC address doesn&#39;t necessarily mean a <em>new device</em>, especially if RPAs are in play. However, many simple trackers or older devices might still use static addresses, or they might include consistent data <em>within</em> the advertising packet even if the address changes.</p>\n<h3>3.6 Signal Strength (RSSI): An Indicator, Not a Ruler</h3>\n<p><strong>RSSI</strong> stands for <strong>Received Signal Strength Indicator</strong>. When our ESP32 receives a Bluetooth advertising packet, it can measure the strength of that signal. This value is typically reported in <strong>dBm</strong> (decibels relative to one milliwatt), which is a negative number (e.g., -40 dBm is a strong signal, -90 dBm is a weak signal). A signal of 0 dBm would mean the received power is 1 milliwatt.</p>\n<p><strong>How does RSSI relate to distance?</strong></p>\n<p>Generally, the <em>closer</em> a device is, the <em>stronger</em> the signal (less negative RSSI). The <em>further away</em> a device is, the <em>weaker</em> the signal (more negative RSSI).</p>\n<p><strong>BUT, and this is a big BUT:</strong> RSSI is <em>not</em> a precise measure of distance. Many factors affect signal strength:</p>\n<ul>\n<li><strong>Obstacles:</strong> Walls, furniture, people, water bodies (including human bodies!) absorb and reflect RF signals, weakening them significantly.</li>\n<li><strong>Interference:</strong> Other 2.4 GHz devices (Wi-Fi, microwaves) can interfere with the Bluetooth signal.</li>\n<li><strong>Antenna Orientation:</strong> The way the transmitting and receiving antennas are oriented relative to each other impacts signal strength.</li>\n<li><strong>Transmit Power:</strong> Devices can advertise at different power levels, affecting the maximum range and received strength.</li>\n</ul>\n<p><strong>For our tool:</strong></p>\n<p>We will use RSSI as an <em>indicator</em> of relative proximity.</p>\n<ul>\n<li>A sudden increase in RSSI for a known device might suggest it&#39;s moving closer.</li>\n<li>A device appearing with a very strong RSSI might be very close.</li>\n<li>We can use RSSI to filter out very distant devices.</li>\n</ul>\n<p>Just don&#39;t expect to calculate &quot;exactly 3.5 meters away&quot; based on RSSI alone. It&#39;s more like &quot;very close,&quot; &quot;nearby,&quot; &quot;further away,&quot; &quot;at the edge of detection.&quot;</p>\n<h3>3.7 Introduction to Bluetooth Scanning</h3>\n<p>Now that we understand what&#39;s being broadcast, let&#39;s briefly touch on how our scanner will work (this is the lead-in to Module 4!).</p>\n<p>An Observer or Central device performs a <strong>scan</strong>. This involves:</p>\n<ol>\n<li>Tuning its radio to the three BLE advertising channels (37, 38, 39).</li>\n<li>Listening for advertising packets on these channels.</li>\n<li>When a packet is detected, the radio captures it.</li>\n<li>The captured packet&#39;s data (MAC address, RSSI, advertising data) is passed up the software stack for processing.</li>\n</ol>\n<p>There are two main types of scanning:</p>\n<ul>\n<li><strong>Passive Scanning:</strong> The scanner just listens. It captures advertising packets (<code>ADV_IND</code>, <code>ADV_NONCONN_IND</code>, etc.) but does not transmit anything back. This is stealthier and lower power for the scanner.</li>\n<li><strong>Active Scanning:</strong> The scanner listens for <code>ADV_IND</code> packets. When it receives one, it sends a <code>SCAN_REQ</code> packet back to the advertiser. The advertiser can then respond with a <code>SCAN_RSP</code> packet, which can contain <em>additional</em> advertising data that didn&#39;t fit in the initial <code>ADV_IND</code> (often includes the full device name if it was truncated). Active scanning gets more information but is less stealthy as the scanner transmits.</li>\n</ul>\n<p>For our reconnaissance tool, we&#39;ll likely use <strong>passive scanning</strong> initially, as it&#39;s simpler to implement and sufficient for capturing basic presence, MAC addresses, RSSI, and common AD types like Manufacturer Specific Data. We can explore active scanning later if needed for specific data extraction (like full names).</p>\n<h3>3.8 Case Study: Tracking Devices (AirTags, Tiles, Fitness Trackers)</h3>\n<p>Let&#39;s apply what we&#39;ve learned to real-world examples. How do devices like Apple AirTags, Tile trackers, or even many fitness watches announce their presence?</p>\n<p>They heavily rely on <strong>BLE Advertising</strong>.</p>\n<ul>\n<li>They act as <strong>Broadcasters</strong>.</li>\n<li>They periodically send out <strong>Advertising Packets</strong>.</li>\n<li>These packets often contain <strong>Manufacturer Specific Data (Type 0xFF)</strong>. This is where the magic happens.<ul>\n<li>For an AirTag, the Manufacturer Specific Data contains Apple&#39;s Manufacturer ID (0x004C) followed by a specific data format related to the Find My network protocol. This data changes frequently (part of Apple&#39;s privacy design) but follows a recognizable pattern that Find My network participants (like iPhones, iPads) can understand and report securely.</li>\n<li>For a Tile, the Manufacturer Specific Data contains Tile&#39;s Manufacturer ID followed by data specific to the Tile network.</li>\n<li>Fitness trackers might include manufacturer data or advertise specific service UUIDs related to health profiles.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Crucially for our tool:</strong> While we won&#39;t be able to <em>resolve</em> the identity of an AirTag or Tile (because we don&#39;t have the cryptographic keys the Find My/Tile networks use), we <em>can</em> detect their <em>presence</em> by identifying the specific <em>patterns</em> in their Manufacturer Specific Data. We can also track their relative signal strength (RSSI) to estimate proximity.</p>\n<p>Our &quot;Personal Tracker Detection&quot; mode will look for these <em>patterns</em> in the advertising data and monitor the RSSI of devices exhibiting these patterns.</p>\n<h3>Conclusion: You&#39;ve Seen the Signals!</h3>\n<p>You&#39;ve just completed a crucial step! You now understand:</p>\n<ul>\n<li>The fundamental difference between Bluetooth Classic and BLE.</li>\n<li>Why BLE&#39;s low power and advertising make it ideal for reconnaissance.</li>\n<li>The roles devices play (Broadcaster/Observer are key for us).</li>\n<li>The structure of BLE Advertising Packets (LTV format) and common data types (especially Manufacturer Specific Data!).</li>\n<li>The different types of MAC addresses and their privacy implications for tracking.</li>\n<li>How RSSI gives us clues about proximity (and its limitations).</li>\n<li>The basic process of BLE scanning.</li>\n</ul>\n<p>This theoretical foundation is absolutely essential. In the next module, we&#39;ll translate this understanding into code and make our ESP32 start listening to these signals and showing us what&#39;s out there!</p>\n<hr>\n<h3>Suggested Resources or Prerequisites:</h3>\n<ul>\n<li>Completion of Module 2 (Basic ESP32 coding).</li>\n<li>Links to official Bluetooth SIG specifications (browse the Core Specification, particularly the Generic Access Profile - GAP - section, but be warned, it&#39;s dense! Focus on introductory summaries first).</li>\n<li>Online tutorials explaining BLE roles and advertising (search for &quot;BLE Peripheral Central Broadcaster Observer&quot; or &quot;BLE Advertising Packet Structure&quot;).</li>\n<li>Visual aids explaining packet structure and roles (images/diagrams are very helpful here!).</li>\n</ul>\n<hr>\n<h3>Module Project/Exercise:</h3>\n<p>This module is theory-heavy, so the project is research and reflection:</p>\n<ol>\n<li><strong>Summarize:</strong> Write a short summary (a paragraph or two) explaining the core difference between BLE and Classic Bluetooth and why the BLE advertising process is fundamental for finding low-power devices.</li>\n<li><strong>Research AD Types:</strong> Spend 15-20 minutes online researching common BLE Advertising Data (AD) Types (beyond the ones listed here). Look for resources that list the &quot;Assigned Numbers&quot; for AD Types. Identify at least three <em>other</em> AD types and briefly describe what kind of information they carry. This will give you a broader sense of the data you might encounter.</li>\n</ol>\n<p>Bring your summaries and research notes to the next module! We&#39;ll be ready to put this knowledge into practice.</p>\n<hr>\n<p>Alright, take a breath! That was a deep dive, but you&#39;ve absorbed some critical concepts. Feel free to revisit sections if they felt complex. Understanding these fundamentals makes the coding in the next modules much more intuitive.</p>\n<p>Ready to make the ESP32 <em>see</em> these signals? Module 4 awaits!</p>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, class! Welcome back. We&#39;ve set up our ESP32 workshop and mastered the basics of embedded programming in the last two modules. We even took a theoretical deep dive into the world of Bluetooth, understanding the difference between Classic and BLE, and the critical role of advertising packets.</p>\n<p>Now, it&#39;s time to put that theory into practice. Imagine the air around you is buzzing with invisible signals – Bluetooth devices constantly announcing their presence. In this module, we&#39;re going to give our ESP32 the ability to <em>see</em> and <em>interpret</em> these signals. We&#39;ll program it to become a <strong>BLE Observer</strong>, actively scanning the airwaves for advertising packets and pulling out the juicy bits of information they contain. This is where our reconnaissance journey truly begins!</p>\n<hr>\n<h2>Module 4: Scanning the Airwaves: Programming the ESP32 as a BLE Observer</h2>\n<ul>\n<li><p><strong>Module Objective:</strong> By the end of this module, you will be able to program the ESP32 to actively scan for nearby Bluetooth Low Energy (BLE) devices and extract basic information (MAC address, name, RSSI) from their advertising packets, displaying these results on the Serial Monitor.</p>\n</li>\n<li><p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Successful completion of Module 3 (understanding of BLE, advertising packets, MAC addresses, RSSI).</li>\n<li>Your ESP32 DevkitC successfully set up and programmable (Module 1).</li>\n<li>Basic familiarity with C++ and Arduino IDE structure (Module 2).</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4.1 Introduction to the ESP32 BLE Library</h3>\n<p>Interacting with the ESP32&#39;s sophisticated Bluetooth hardware directly would be incredibly complex. Thankfully, the Arduino core for the ESP32 provides powerful libraries that abstract away the low-level details, allowing us to focus on the logic.</p>\n<p>For BLE operations on the ESP32 within the Arduino environment, the standard and widely used library is the one included with the ESP32 Arduino core itself. It&#39;s often referred to or accessed via includes like <code>&lt;BLEDevice.h&gt;</code>, <code>&lt;BLEUtils.h&gt;</code>, and <code>&lt;BLEScan.h&gt;</code>.</p>\n<p>This library provides classes and functions to:</p>\n<ol>\n<li>Initialize the BLE hardware.</li>\n<li>Configure the device as a BLE Central/Observer or Peripheral/Broadcaster.</li>\n<li>Start and stop BLE scanning.</li>\n<li>Handle discovered devices and their advertising data.</li>\n<li>Initiate connections (though we won&#39;t focus on connecting in this module).</li>\n<li>Manage BLE services and characteristics (relevant for later interaction, but not scanning).</li>\n</ol>\n<p><strong>How to ensure you have it:</strong> If you installed the ESP32 board support in the Arduino IDE&#39;s Boards Manager back in Module 1, you already have this library! It&#39;s part of the core package. You just need to include the necessary header files in your sketch.</p>\n<h3>4.2 Setting Up the BLE Scan Process</h3>\n<p>Before we can scan, we need to initialize the BLE subsystem on the ESP32 and configure the scanner. This typically happens in the <code>setup()</code> function of your Arduino sketch.</p>\n<p>Here are the key steps:</p>\n<ol>\n<li><strong>Include Libraries:</strong> Add the necessary header files at the top of your sketch.</li>\n<li><strong>Initialize BLE Device:</strong> Call <code>BLEDevice::init()</code>. This wakes up and configures the ESP32&#39;s BLE radio. You usually give your device a name here, although for scanning, the name isn&#39;t strictly necessary unless you plan to advertise yourself later.</li>\n<li><strong>Get a Scanner Instance:</strong> Obtain a reference to the BLE scanner object using <code>BLEDevice::getScan()</code>. The ESP32 hardware has one BLE scanner instance, so you get a pointer to this singleton object.</li>\n<li><strong>Configure Scan Parameters (Optional but Recommended):</strong> You can set various parameters, such as:<ul>\n<li><code>setActiveScan(bool)</code>: Determines if the scanner sends out scan requests (active) or just passively listens for advertisements (passive). Active scanning can get more information but uses slightly more power and makes your scanner detectable. Passive is often sufficient for just detecting presence and basic data. We&#39;ll start with passive.</li>\n<li><code>setInterval(uint16_t)</code> and <code>setWindow(uint16_t)</code>: These control the scanning timing (how often and for how long the radio is on within a scan interval). Default values are usually fine to start, but you can tweak them for performance or power saving. The values are in units of 0.625ms.</li>\n<li><code>setScanCallbacks()</code>: <em>Crucially</em>, this is where you tell the scanner <em>what to do</em> when it finds a device. This leads us to the next topic: handling scan results.</li>\n</ul>\n</li>\n</ol>\n<p>Let&#39;s look at the basic <code>setup()</code> structure:</p>\n<pre><code class=\"language-cpp\">#include &lt;Arduino.h&gt; // Always good practice\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEScan.h&gt;\n#include &lt;BLEAdvertisedDevice.h&gt;\n\n// Define scan time in seconds\n#define SCAN_DURATION 10\n\n// Create a pointer to the BLE Scan object\nBLEScan* pBLEScan;\n\nvoid setup() {\n  Serial.begin(115200); // Start serial communication for output\n  Serial.println(&quot;ESP32 BLE Scanner Starting...&quot;);\n\n  // 1. Initialize the BLE Device\n  // The string argument is an optional device name, not strictly needed for scanning only\n  BLEDevice::init(&quot;&quot;);\n\n  // 2. Retrieve the BLE Scan object\n  pBLEScan = BLEDevice::getScan();\n\n  // 3. Configure Scan Parameters\n  // Set active scan to false for passive scanning (just listening)\n  pBLEScan-&gt;setActiveScan(false);\n\n  // Set scan interval and window (optional, default values often work)\n  // pBLEScan-&gt;setInterval(100); // Scan interval 100 * 0.625ms = 62.5ms\n  // pBLEScan-&gt;setWindow(99);   // Scan window 99 * 0.625ms = 61.875ms\n  // Note: window &lt;= interval\n\n  // At this point, the scanner is configured, but not running yet.\n  // We still need to tell it how to handle results!\n}\n\nvoid loop() {\n  // The loop function will contain the actual scanning command later\n  // For now, it can be empty or just delay\n  delay(1000);\n}\n</code></pre>\n<p>This code sets up the BLE environment and gets the scanner object ready. But it doesn&#39;t <em>do</em> anything with the scan results yet.</p>\n<h3>4.3 Handling Scan Results: The <code>onResult</code> Callback</h3>\n<p>When the BLE scanner finds an advertising packet, it needs to process it. The ESP32 BLE library uses a <strong>callback function</strong> mechanism for this. You define a specific function that the library will automatically call <em>every time</em> it discovers a new device or receives an advertisement from a device it&#39;s already seen during the current scan session.</p>\n<p>To implement this, you create a class that inherits from <code>BLEAdvertisedDeviceCallbacks</code> and override its <code>onResult()</code> method.</p>\n<p>Here&#39;s how you define the callback class:</p>\n<pre><code class=\"language-cpp\">// In your sketch, typically before setup()\n\n// Callback class to handle the advertising results\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n      // This function is called whenever a new device is found\n      // or an advertisement from an existing device is received.\n\n      Serial.printf(&quot;Advertised Device found: %s \\n&quot;, advertisedDevice.toString().c_str());\n\n      // We will refine this output later\n    }\n};\n</code></pre>\n<p>Now, you need to create an instance of this callback class and tell the scanner to use it in your <code>setup()</code> function:</p>\n<pre><code class=\"language-cpp\">// In your sketch, typically before setup()\n\n// ... (Includes and BLEScan pointer) ...\n\n// Create an instance of our callback class\nMyAdvertisedDeviceCallbacks myCallbacks;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;ESP32 BLE Scanner Starting...&quot;);\n\n  BLEDevice::init(&quot;&quot;);\n  pBLEScan = BLEDevice::getScan();\n  pBLEScan-&gt;setActiveScan(false);\n\n  // Set the callback object for the scanner\n  pBLEScan-&gt;setAdvertisedDeviceCallbacks(&amp;myCallbacks);\n\n  // Now the scanner knows what function to call when it finds a device\n}\n\n// ... loop() ...\n</code></pre>\n<p>With this, whenever an advertising packet is detected, the <code>onResult</code> method of your <code>myCallbacks</code> object will be executed.</p>\n<h3>4.4 Extracting Key Information from Scan Results</h3>\n<p>The <code>onResult</code> function receives a <code>BLEAdvertisedDevice</code> object. This object is a treasure trove of information parsed from the advertising packet. Let&#39;s learn how to pull out the most important pieces for our reconnaissance tool:</p>\n<ul>\n<li><strong>Device Address (MAC):</strong> Every Bluetooth device has a unique address. For BLE, these can be public static addresses or various types of random addresses (Module 3 recap!). The <code>BLEAdvertisedDevice</code> object provides methods to get this.<ul>\n<li><code>advertisedDevice.getAddress()</code>: Returns a <code>BLEAddress</code> object.</li>\n<li><code>advertisedDevice.getAddress().toString()</code>: Returns the address as a <code>std::string</code>.</li>\n</ul>\n</li>\n<li><strong>Device Name:</strong> Many devices broadcast a human-readable name (e.g., &quot;My Headphones&quot;, &quot;Tile&quot;).<ul>\n<li><code>advertisedDevice.haveName()</code>: Returns <code>true</code> if a name was included in the advertisement.</li>\n<li><code>advertisedDevice.getName()</code>: Returns the name as a <code>std::string</code>.</li>\n</ul>\n</li>\n<li><strong>RSSI (Received Signal Strength Indicator):</strong> This value indicates how strong the signal from the device is at the scanner&#39;s location. Higher (closer to 0) means stronger, lower (more negative) means weaker. It&#39;s a rough indicator of distance.<ul>\n<li><code>advertisedDevice.getRSSI()</code>: Returns the RSSI value as an <code>int8_t</code>.</li>\n</ul>\n</li>\n</ul>\n<p>Let&#39;s modify our <code>onResult</code> callback to extract and print these specific details instead of just the full <code>toString()</code> output.</p>\n<pre><code class=\"language-cpp\">// In your sketch, typically before setup()\n\n// ... (Includes and BLEScan pointer) ...\n\n// Callback class to handle the advertising results\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n      Serial.print(&quot;Device Found: &quot;);\n\n      // Print MAC Address\n      Serial.print(&quot;Address: &quot;);\n      Serial.print(advertisedDevice.getAddress().toString().c_str());\n\n      // Print Device Name (if available)\n      if (advertisedDevice.haveName()) {\n        Serial.print(&quot;, Name: &quot;);\n        Serial.print(advertisedDevice.getName().c_str());\n      } else {\n        Serial.print(&quot;, Name: N/A&quot;);\n      }\n\n      // Print RSSI\n      Serial.print(&quot;, RSSI: &quot;);\n      Serial.print(advertisedDevice.getRSSI());\n      Serial.println(&quot; dBm&quot;);\n\n      // You could also check for other data types here, e.g.:\n      // if (advertisedDevice.hasServiceUUID()) { ... }\n      // if (advertisedDevice.hasManufacturerData()) { ... }\n    }\n};\n\n// ... (Instance of callback class and setup() function) ...\n</code></pre>\n<p>Now, when the scanner detects a device, it will print a line like: <code>Device Found: Address: 1A:2B:3C:4D:5E:6F, Name: MyPhone, RSSI: -55 dBm</code>.</p>\n<h3>4.5 Starting and Stopping the Scan</h3>\n<p>The final piece is to actually <em>start</em> the scan. This is done using the <code>start()</code> method of the <code>BLEScan</code> object.</p>\n<p>The <code>start()</code> method has a few variations:</p>\n<ul>\n<li><code>pBLEScan-&gt;start(uint32_t duration, bool isContinuous = false)</code>: Starts a scan for a specified <code>duration</code> in seconds.<ul>\n<li>If <code>isContinuous</code> is <code>false</code> (the default when omitted or explicitly set), the function will block (pause your program) until the scan duration is over. This is simple for a basic scan.</li>\n<li>If <code>isContinuous</code> is <code>true</code>, the function returns immediately, and the scan runs in the background until you explicitly call <code>pBLEScan-&gt;stop()</code>. This is useful if you want your <code>loop()</code> to do other things while scanning.</li>\n</ul>\n</li>\n<li><code>pBLEScan-&gt;start(uint32_t duration, void (*scanCompleteCB)(BLEScan*), bool isContinuous = false)</code>: Similar to the above, but also takes a pointer to a callback function (<code>scanCompleteCB</code>) that will be called when the scan finishes (either by duration or by calling <code>stop()</code>).</li>\n</ul>\n<p>For our first simple scanner, let&#39;s use the blocking version (<code>isContinuous = false</code>) within the <code>loop()</code> function. This means the <code>loop()</code> will start a scan, wait for it to finish, and then potentially start another one after a delay.</p>\n<pre><code class=\"language-cpp\">// ... (Includes, callback class, callback instance, BLEScan pointer) ...\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;ESP32 BLE Scanner Starting...&quot;);\n\n  BLEDevice::init(&quot;&quot;);\n  pBLEScan = BLEDevice::getScan();\n  pBLEScan-&gt;setActiveScan(false); // Passive scan\n  pBLEScan-&gt;setAdvertisedDeviceCallbacks(&amp;myCallbacks);\n\n  // We will start the scan in the loop()\n}\n\nvoid loop() {\n  Serial.println(&quot;Starting BLE scan for 10 seconds...&quot;);\n\n  // Start the scan.\n  // The &#39;true&#39; parameter here (or default &#39;false&#39; for the 2-param version)\n  // determines if the function blocks.\n  // Let&#39;s use the 2-parameter version, where default is false (blocking for duration)\n  BLEScanResults foundDevices = pBLEScan-&gt;start(SCAN_DURATION, false); // Scan for SCAN_DURATION seconds, blocking\n\n  Serial.printf(&quot;Scan finished. Found %d devices during this scan session.\\n&quot;, foundDevices.getCount());\n  Serial.println(&quot;--------------------&quot;);\n\n  // The scan results are handled by the onResult callback while the scan is running.\n  // After the scan finishes, foundDevices.getCount() tells you how many *unique*\n  // devices were seen during this specific start() call. The onResult callback\n  // might have fired multiple times for the same device if it advertised frequently.\n\n  // Wait a bit before starting the next scan (optional, but good practice)\n  delay(5000); // Wait 5 seconds before starting another scan\n}\n</code></pre>\n<p><strong>Putting it all together:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;Arduino.h&gt;\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEScan.h&gt;\n#include &lt;BLEAdvertisedDevice.h&gt;\n\n// Define scan time in seconds\n#define SCAN_DURATION 10\n\n// Create a pointer to the BLE Scan object\nBLEScan* pBLEScan;\n\n// Callback class to handle the advertising results\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n      // This function is called whenever a new device is found\n      // or an advertisement from an existing device is received.\n\n      Serial.print(&quot;Device Found: &quot;);\n\n      // Print MAC Address\n      Serial.print(&quot;Address: &quot;);\n      Serial.print(advertisedDevice.getAddress().toString().c_str());\n\n      // Print Device Name (if available)\n      if (advertisedDevice.haveName()) {\n        Serial.print(&quot;, Name: &quot;);\n        Serial.print(advertisedDevice.getName().c_str());\n      } else {\n        Serial.print(&quot;, Name: N/A&quot;);\n      }\n\n      // Print RSSI\n      Serial.print(&quot;, RSSI: &quot;);\n      Serial.print(advertisedDevice.getRSSI());\n      Serial.println(&quot; dBm&quot;);\n\n      // You could also check for other data types here, e.g.:\n      // if (advertisedDevice.hasServiceUUID()) { ... }\n      // if (advertisedDevice.hasManufacturerData()) { ... }\n    }\n};\n\n// Create an instance of our callback class\nMyAdvertisedDeviceCallbacks myCallbacks;\n\nvoid setup() {\n  Serial.begin(115200); // Start serial communication for output\n  Serial.println(&quot;ESP32 BLE Scanner Starting...&quot;);\n\n  // 1. Initialize the BLE Device\n  BLEDevice::init(&quot;&quot;); // Optional device name\n\n  // 2. Retrieve the BLE Scan object\n  pBLEScan = BLEDevice::getScan();\n\n  // 3. Configure Scan Parameters\n  pBLEScan-&gt;setActiveScan(false); // Set active scan to false for passive scanning\n  // pBLEScan-&gt;setInterval(100); // Optional: set scan interval\n  // pBLEScan-&gt;setWindow(99);   // Optional: set scan window\n\n  // 4. Set the callback object for the scanner\n  pBLEScan-&gt;setAdvertisedDeviceCallbacks(&amp;myCallbacks);\n\n  // Scan will be started in loop()\n}\n\nvoid loop() {\n  Serial.println(&quot;--------------------&quot;);\n  Serial.printf(&quot;Starting BLE scan for %d seconds...\\n&quot;, SCAN_DURATION);\n\n  // Start the scan.\n  // The second parameter &#39;false&#39; means the function will block until the scan duration is over.\n  BLEScanResults foundDevices = pBLEScan-&gt;start(SCAN_DURATION, false);\n\n  // Note: The onResult callback prints devices as they are found *during* the scan.\n  // foundDevices.getCount() here gives the number of *unique* devices whose *first*\n  // advertisement triggered the onResult callback during this specific scan period.\n  // The total number of onResult calls might be higher if devices advertise frequently.\n\n  Serial.printf(&quot;Scan finished after %d seconds. Total unique devices seen in this scan session: %d\\n&quot;, SCAN_DURATION, foundDevices.getCount());\n  Serial.println(&quot;--------------------&quot;);\n\n  // Optional: Wait before starting the next scan\n  delay(5000); // Wait 5 seconds\n}\n</code></pre>\n<p>Upload this sketch to your ESP32. Open the Serial Monitor (make sure the baud rate is set to 115200). You should see the scanner start, and as it detects BLE devices nearby, you&#39;ll see their information printed in the Serial Monitor. Try having your phone with Bluetooth enabled nearby, or turn on some Bluetooth headphones, speakers, or fitness trackers.</p>\n<h3>4.6 Scan Parameters: Active vs. Passive Scanning</h3>\n<p>We touched on <code>setActiveScan()</code>. Let&#39;s clarify this:</p>\n<ul>\n<li><strong>Passive Scanning (<code>setActiveScan(false)</code>):</strong> The scanner simply listens for advertising packets being broadcast by devices. It does not send out any packets itself. This is lower power and stealthier, as your scanner isn&#39;t announcing its presence. However, you only get the information included in the standard advertising packet.</li>\n<li><strong>Active Scanning (<code>setActiveScan(true)</code>):</strong> When the scanner sees an advertising packet (specifically, a <code>CONNECTABLE_SCANNABLE</code> or <code>NON_CONNECTABLE_SCANNABLE</code> type), it sends back a &quot;scan request&quot; packet to the advertising device. The device <em>may</em> then respond with a &quot;scan response&quot; packet, which can contain additional information (like a longer version of the device name, or more complex service data) that didn&#39;t fit in the initial advertising packet. Active scanning gives you potentially more data but uses slightly more power and, importantly, means your ESP32 is <em>transmitting</em> and can therefore be detected as a scanner.</li>\n</ul>\n<p>For our initial reconnaissance purposes, passive scanning is often sufficient and recommended for lower power consumption and less impact on the environment. We used <code>setActiveScan(false)</code> in our example sketch.</p>\n<p>The <code>setInterval()</code> and <code>setWindow()</code> parameters control the <em>timing</em> of the scan. The ESP32 radio doesn&#39;t scan 100% of the time to save power. It scans for a short &quot;window&quot; within a larger &quot;interval&quot;. Setting these can optimize for faster discovery (shorter interval/longer window) or lower power (longer interval/shorter window). The default values are usually a good balance.</p>\n<h3>4.7 Filtering Scan Results (Briefly)</h3>\n<p>Our current <code>onResult</code> callback prints <em>every</em> device it sees. For a reconnaissance tool, you often want to focus on specific types of devices or filter out known ones.</p>\n<p>You can add simple filtering logic directly within the <code>onResult</code> callback. For example, to only print devices with a specific name:</p>\n<pre><code class=\"language-cpp\">// Inside the onResult(BLEAdvertisedDevice advertisedDevice) method:\n\n// Example: Only print devices named &quot;TargetDevice&quot;\nif (advertisedDevice.haveName() &amp;&amp; advertisedDevice.getName() == &quot;TargetDevice&quot;) {\n    Serial.print(&quot;Target Device Found! &quot;);\n    Serial.print(&quot;Address: &quot;);\n    Serial.print(advertisedDevice.getAddress().toString().c_str());\n    Serial.print(&quot;, RSSI: &quot;);\n    Serial.print(advertisedDevice.getRSSI());\n    Serial.println(&quot; dBm&quot;);\n}\n\n// Example: Only print devices with RSSI stronger than -70 dBm (closer devices)\nif (advertisedDevice.getRSSI() &gt; -70) {\n    Serial.print(&quot;Strong Signal Device: &quot;);\n    Serial.print(&quot;Address: &quot;);\n    Serial.print(advertisedDevice.getAddress().toString().c_str());\n    if (advertisedDevice.haveName()) { Serial.print(&quot;, Name: &quot;); Serial.print(advertisedDevice.getName().c_str()); }\n    Serial.print(&quot;, RSSI: &quot;);\n    Serial.print(advertisedDevice.getRSSI());\n    Serial.println(&quot; dBm&quot;);\n}\n\n// You can combine conditions\n// if (advertisedDevice.haveName() &amp;&amp; advertisedDevice.getName().find(&quot;Headphones&quot;) != std::string::npos &amp;&amp; advertisedDevice.getRSSI() &gt; -60) {\n//     Serial.println(&quot;Possible nearby headphones detected!&quot;);\n// }\n</code></pre>\n<p>For more complex filtering or managing a list of devices seen over time, we&#39;ll need more sophisticated data structures and logic, which is the focus of Module 5. For now, printing everything gives us a good overview of the BLE environment.</p>\n<h3>4.8 Real-world Example: What Will You See?</h3>\n<p>When you run the scanner, you&#39;ll likely see a variety of devices.</p>\n<ul>\n<li><strong>Your Phone/Laptop:</strong> If Bluetooth is on, they often advertise, though they might use random, changing MAC addresses for privacy.</li>\n<li><strong>Headphones/Speakers:</strong> Many advertise their presence, sometimes with their model name.</li>\n<li><strong>Fitness Trackers/Smartwatches:</strong> These frequently advertise, often with manufacturer data or service UUIDs related to health profiles.</li>\n<li><strong>Smart Home Devices:</strong> Many use BLE for initial setup or low-power control.</li>\n<li><strong>Beacons:</strong> Devices specifically designed to broadcast advertisements for location services (like iBeacon or Eddystone - we might touch on these later).</li>\n<li><strong>Unknown Devices:</strong> You&#39;ll see plenty of addresses without names. These could be anything from anonymous tracking tags to industrial sensors or simply devices configured not to broadcast a name. Pay attention to the MAC address patterns – some ranges are assigned to specific manufacturers.</li>\n</ul>\n<p>Observe how the RSSI changes as you move your ESP32 closer to or further from a known device. Notice how frequently some devices appear in the <code>onResult</code> callback – this indicates how often they are advertising.</p>\n<h3>Module Project/Exercise</h3>\n<p>Your task for this module is to implement the core BLE scanning sketch we developed.</p>\n<ol>\n<li><strong>Create a new Arduino sketch.</strong></li>\n<li><strong>Include the necessary BLE libraries.</strong></li>\n<li><strong>Define the <code>SCAN_DURATION</code> constant (e.g., 10 seconds).</strong></li>\n<li><strong>Create a pointer for the <code>BLEScan</code> object.</strong></li>\n<li><strong>Define a class that inherits from <code>BLEAdvertisedDeviceCallbacks</code> and implements the <code>onResult</code> method.</strong> Inside <code>onResult</code>, extract and print the Device Address (MAC), Device Name (if available), and RSSI for each detected device to the Serial Monitor. Format the output clearly.</li>\n<li><strong>Create an instance of your callback class.</strong></li>\n<li><strong>In the <code>setup()</code> function:</strong><ul>\n<li>Initialize Serial communication.</li>\n<li>Initialize the BLE device.</li>\n<li>Get the <code>BLEScan</code> object.</li>\n<li>Set <code>setActiveScan(false)</code> for passive scanning.</li>\n<li>Set your custom callback object using <code>setAdvertisedDeviceCallbacks()</code>.</li>\n</ul>\n</li>\n<li><strong>In the <code>loop()</code> function:</strong><ul>\n<li>Print a message indicating the start of the scan.</li>\n<li>Call <code>pBLEScan-&gt;start(SCAN_DURATION, false)</code> to perform a blocking scan for the defined duration.</li>\n<li>Print a message indicating the scan has finished and optionally the number of unique devices reported by <code>getCount()</code>.</li>\n<li>Add a <code>delay()</code> (e.g., 5 seconds) before the next scan starts, so the output isn&#39;t overwhelming.</li>\n</ul>\n</li>\n<li><strong>Upload the sketch to your ESP32.</strong></li>\n<li><strong>Open the Serial Monitor (115200 baud).</strong></li>\n<li><strong>Observe the output.</strong> Note the different devices, their addresses (static vs. random), names (or lack thereof), and fluctuating RSSI values.</li>\n<li><strong>Experiment:</strong> Try moving the ESP32 around. Bring Bluetooth devices closer. Turn Bluetooth on/off on your phone. See how the output changes.</li>\n</ol>\n<p>This project will give you direct, hands-on experience with seeing the invisible BLE signals around you and is the foundational step for building our reconnaissance tool.</p>\n<hr>\n<h3>Summary</h3>\n<p>In this module, we successfully transformed our ESP32 into a basic BLE scanner. We learned how to use the ESP32 BLE library, configure the scanner, implement a callback function to process scan results, and extract key information like MAC address, device name, and RSSI. We also discussed the difference between active and passive scanning.</p>\n<p>You&#39;ve now built the core capability of our reconnaissance tool: the ability to detect and report on nearby BLE devices. In the next module, we&#39;ll tackle the challenge of making sense of this stream of data – storing it, identifying unique devices, and tracking them over time, which is essential for building our detection logic.</p>\n<p>Keep experimenting with your scanner! The more you observe the real-world BLE environment, the better you&#39;ll understand the data we&#39;ll be processing. See you in Module 5!</p>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into Module 5! This is where we transform raw, fleeting Bluetooth signals into structured, meaningful data. We&#39;re moving beyond just <em>seeing</em> devices to <em>knowing</em> them, <em>tracking</em> them, and <em>making sense</em> of their presence over time. Think of it as building the memory and recognition system for our tool.</p>\n<p>As your guide, I&#39;m thrilled to explore this crucial step with you. This module is fundamental for building any kind of detection or analysis logic on the scan data.</p>\n<hr>\n<h2>Module 5: Making Sense of the Signals: Storing, Identifying, and Tracking Devices</h2>\n<p><strong>Module Title:</strong> Making Sense of the Signals: Storing, Identifying, and Tracking Devices</p>\n<p><strong>Module Objective:</strong> Develop techniques to store scan data, identify unique devices, and track their presence or signal strength over time, laying the groundwork for detection modes.</p>\n<p><strong>Why is this module important?</strong> In Module 4, our ESP32 became a pair of digital ears, listening to the Bluetooth airwaves. We could see devices pop up in the Serial Monitor. But each device might advertise multiple times, and the basic scan result is just a snapshot. To build a reconnaissance tool that can detect persistent trackers or changes in the environment, we need to:</p>\n<ol>\n<li><strong>Remember</strong> the devices we&#39;ve seen.</li>\n<li><strong>Identify</strong> if a new advertisement comes from a device we&#39;ve seen before.</li>\n<li><strong>Update</strong> information about that device (like its latest signal strength or when we last saw it).</li>\n<li><strong>Maintain</strong> a current list of unique devices detected.</li>\n</ol>\n<p>This module teaches you how to build that memory and identification system using core C++ programming concepts on the ESP32.</p>\n<hr>\n<h3>Essential Subtopics Deep Dive:</h3>\n<h4>5.1 Data Structures for Storing Device Information</h4>\n<p>Okay, so we&#39;ve got advertising packets coming in. Each packet tells us about <em>one</em> advertisement event from <em>one</em> device at a specific moment. From Module 4, we know we can extract the device&#39;s MAC address, its name (if advertised), and its RSSI.</p>\n<p>To store information about a <em>unique</em> device, we need a way to group these pieces of data together. In C++, the <code>struct</code> (structure) is perfect for this. A <code>struct</code> allows you to bundle different data types under a single name.</p>\n<p>Let&#39;s define a <code>struct</code> to hold the information we care about for a single unique Bluetooth device:</p>\n<pre><code class=\"language-cpp\">// We&#39;ll put this struct definition near the top of our sketch, outside of setup() or loop()\n\nstruct DeviceInfo {\n    BLEAddress  address;        // The unique MAC address of the device\n    std::string name;           // The advertised name (can be empty)\n    int         rssi;           // The last seen RSSI\n    unsigned long lastSeenMillis; // When we last saw this device (using millis())\n    // We could add more fields later, like a history of RSSI values,\n    // advertised service UUIDs, manufacturer data, etc.\n};\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<ul>\n<li><code>struct DeviceInfo { ... };</code>: Defines a new structure type named <code>DeviceInfo</code>.</li>\n<li><code>BLEAddress address;</code>: This will store the device&#39;s MAC address. The <code>BLEAddress</code> type is provided by the ESP32 BLE library and is convenient for handling MAC addresses.</li>\n<li><code>std::string name;</code>: Stores the device&#39;s advertised name. We use <code>std::string</code> from the C++ Standard Library for variable-length text. Remember to <code>#include &lt;string&gt;</code>.</li>\n<li><code>int rssi;</code>: Stores the Received Signal Strength Indicator. It&#39;s an integer, usually negative.</li>\n<li><code>unsigned long lastSeenMillis;</code>: This is a timestamp indicating <em>when</em> (relative to the ESP32 starting up) we last received an advertisement from this device. We&#39;ll use the <code>millis()</code> function, which returns the number of milliseconds since the ESP32 board began running the current program. <code>unsigned long</code> is needed because <code>millis()</code> returns a large number that grows over time.</li>\n</ul>\n<p>Using a <code>struct</code> keeps our code organized. Instead of having separate variables for address, name, RSSI, etc., for potentially many devices, we have one <code>DeviceInfo</code> object per device that holds all its relevant data.</p>\n<h4>5.2 Using <code>std::vector</code> to Store Multiple Devices</h4>\n<p>Now that we know how to represent <em>one</em> device&#39;s information, how do we store a <em>list</em> of these devices? The number of devices we detect will vary depending on the environment and how long we scan. A fixed-size array isn&#39;t ideal.</p>\n<p>Enter <code>std::vector</code>. This is part of the C++ Standard Library and is a dynamic array. It can grow or shrink in size as needed at runtime. It&#39;s perfect for maintaining our list of detected unique devices.</p>\n<p>To use <code>std::vector</code>, you need to <code>#include &lt;vector&gt;</code>.</p>\n<pre><code class=\"language-cpp\">// Declare a vector to hold our unique devices\nstd::vector&lt;DeviceInfo&gt; uniqueDevices;\n</code></pre>\n<p>This line declares a variable <code>uniqueDevices</code> which is a vector capable of holding <code>DeviceInfo</code> objects. Initially, it&#39;s empty.</p>\n<p>We can add a new <code>DeviceInfo</code> object to the vector using the <code>push_back()</code> method:</p>\n<pre><code class=\"language-cpp\">DeviceInfo newDevice;\n// ... fill in newDevice details ...\nuniqueDevices.push_back(newDevice);\n</code></pre>\n<p>We can iterate through the vector to access the stored devices:</p>\n<pre><code class=\"language-cpp\">for (const auto&amp; device : uniqueDevices) {\n    // &#39;device&#39; is a reference to a DeviceInfo object in the vector\n    Serial.printf(&quot;Device: %s, Name: %s, RSSI: %d, Last Seen: %lu ms\\n&quot;,\n                  device.address.toString().c_str(),\n                  device.name.c_str(),\n                  device.rssi,\n                  device.lastSeenMillis);\n}\n</code></pre>\n<p>This range-based for loop is a clean way to go through every item in the <code>uniqueDevices</code> vector. <code>device.address.toString().c_c_str()</code> looks a bit complex, but it&#39;s just converting the <code>BLEAddress</code> object to a C-style string (<code>const char*</code>) which <code>Serial.printf</code> requires.</p>\n<h4>5.3 Handling Duplicate Scan Results &amp; Identifying Unique Devices</h4>\n<p>This is the core challenge we need to solve. When we scan, we might receive multiple advertising packets from the <em>same</em> physical device within a short period. We don&#39;t want to add the same device to our <code>uniqueDevices</code> list over and over. We need a way to check: &quot;Have I seen a device with this MAC address before?&quot;</p>\n<p>The MAC address is the key identifier here. While MAC addresses can be random or change (especially with BLE Privacy features), for many common devices and for the scope of this basic tool, the MAC address is the most reliable way to identify a unique device <em>within a scanning session</em>.</p>\n<p>So, the logic when we get a new scan result (<code>BLEAdvertisedDevice</code> object in our <code>onResult</code> callback) is:</p>\n<ol>\n<li>Get the MAC address from the scan result.</li>\n<li>Iterate through our <code>uniqueDevices</code> vector.</li>\n<li>For each <code>DeviceInfo</code> object in the vector, compare its stored MAC address with the MAC address from the new scan result.</li>\n<li>If a match is found, this is a duplicate advertisement from a device we already know about.</li>\n<li>If no match is found after checking all devices in the vector, this is a <em>new</em> unique device.</li>\n</ol>\n<h4>5.4 Developing a Simple Device List Management System (Add, Find, Update)</h4>\n<p>Based on the logic above, we can create functions to manage our <code>uniqueDevices</code> vector.</p>\n<p>Let&#39;s refine the <code>onResult</code> callback logic from Module 4. Instead of just printing, it will now call a function that handles the &quot;find or add/update&quot; process.</p>\n<p>We&#39;ll need a function that takes a <code>BLEAdvertisedDevice</code> object (the raw scan result) and updates our <code>uniqueDevices</code> list.</p>\n<pre><code class=\"language-cpp\">// Function to find a device by address in our list\n// Returns a pointer to the DeviceInfo if found, nullptr otherwise\nDeviceInfo* findDeviceByAddress(const BLEAddress&amp; address) {\n    for (auto&amp; device : uniqueDevices) { // Use reference &#39;&amp;&#39; to allow potential modification\n        if (device.address.equals(address)) {\n            return &amp;device; // Found the device! Return a pointer to it\n        }\n    }\n    return nullptr; // Device not found\n}\n\n// In our onResult callback...\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n        Serial.printf(&quot;Advertised Device found: %s\\n&quot;, advertisedDevice.toString().c_str()); // Keep initial print for debugging\n\n        // 1. Get the address from the scan result\n        BLEAddress deviceAddress = advertisedDevice.getAddress();\n\n        // 2. Try to find this device in our list\n        DeviceInfo* existingDevice = findDeviceByAddress(deviceAddress);\n\n        // 3. Check if the device was found\n        if (existingDevice != nullptr) {\n            // Device found! This is a duplicate advertisement.\n            // 4a. Update its information (last seen time, RSSI)\n            existingDevice-&gt;rssi = advertisedDevice.getRSSI();\n            existingDevice-&gt;lastSeenMillis = millis();\n            Serial.printf(&quot;  -&gt; Updated existing device: %s\\n&quot;, deviceAddress.toString().c_str());\n\n        } else {\n            // Device not found! This is a new unique device.\n            // 4b. Create a new DeviceInfo object\n            DeviceInfo newDevice;\n            newDevice.address = deviceAddress;\n            newDevice.rssi = advertisedDevice.getRSSI();\n            newDevice.lastSeenMillis = millis();\n            newDevice.name = advertisedDevice.getName().empty() ? &quot;N/A&quot; : advertisedDevice.getName(); // Get name, use &quot;N/A&quot; if empty\n\n            // 5. Add the new device to our list\n            uniqueDevices.push_back(newDevice);\n            Serial.printf(&quot;  -&gt; Added new device: %s\\n&quot;, deviceAddress.toString().c_str());\n        }\n    }\n};\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<ul>\n<li><code>findDeviceByAddress</code>: This function takes a <code>BLEAddress</code> and iterates through the <code>uniqueDevices</code> vector. It uses the <code>equals()</code> method of <code>BLEAddress</code> for reliable comparison. If a match is found, it returns a <em>pointer</em> to that <code>DeviceInfo</code> object in the vector. If not found, it returns <code>nullptr</code>. Using a pointer allows us to directly modify the <code>DeviceInfo</code> object stored within the vector.</li>\n<li><code>onResult</code> modification:<ul>\n<li>It retrieves the <code>BLEAddress</code> from the <code>advertisedDevice</code>.</li>\n<li>It calls <code>findDeviceByAddress</code> to see if we know this device.</li>\n<li>If <code>existingDevice</code> is not <code>nullptr</code>, we found it. We update its <code>rssi</code> and <code>lastSeenMillis</code>. Note the <code>-&gt;</code> operator is used to access members via a pointer.</li>\n<li>If <code>existingDevice</code> <em>is</em> <code>nullptr</code>, it&#39;s a new device. We create a <code>newDevice</code> struct, populate its fields (including getting the name, handling the case where no name is advertised), and add it to the <code>uniqueDevices</code> vector using <code>push_back()</code>.</li>\n</ul>\n</li>\n</ul>\n<p>This setup ensures that our <code>uniqueDevices</code> vector contains only one entry per unique MAC address seen during the scan, and each entry is updated with the latest information whenever a new advertisement is received from that device.</p>\n<h4>5.5 Storing Historical Data (Briefly)</h4>\n<p>The current <code>DeviceInfo</code> struct only stores the <em>last seen</em> RSSI and timestamp. For more advanced analysis (like tracking movement patterns or averaging signal strength), you might want to store a history.</p>\n<p>Instead of <code>int rssi;</code>, you could have <code>std::vector&lt;int&gt; rssiHistory;</code>. When a device is updated, you&#39;d do <code>existingDevice-&gt;rssiHistory.push_back(advertisedDevice.getRSSI());</code>. Similarly, you could store a list of timestamps.</p>\n<pre><code class=\"language-cpp\">// Example of a struct with history (more complex, optional for capstone)\nstruct DeviceInfoAdvanced {\n    BLEAddress  address;\n    std::string name;\n    std::vector&lt;int&gt; rssiHistory; // Store multiple RSSI readings\n    std::vector&lt;unsigned long&gt; timestampHistory; // Store timestamps for RSSI readings\n    // ... other fields\n};\n</code></pre>\n<p>For the Module 5 project and the initial capstone, storing just the <em>last</em> seen RSSI and timestamp is sufficient and simpler. We&#39;ll stick to the first <code>DeviceInfo</code> struct definition.</p>\n<h4>5.6 Estimating Proximity Based on RSSI (Understanding Limitations)</h4>\n<p>We&#39;ve stored RSSI. Can we use it to determine how close a device is?</p>\n<p><strong>Yes, but with significant caveats!</strong></p>\n<ul>\n<li><strong>The Theory:</strong> In a perfect, obstacle-free environment, radio signal strength decreases predictably with distance. A stronger (less negative) RSSI generally means the device is closer.</li>\n<li><strong>The Reality:</strong> The real world is <em>not</em> perfect. Walls, furniture, people, other radio signals (Wi-Fi, microwaves, etc.), even the orientation of the antennas on the ESP32 and the target device <em>all</em> affect RSSI. A device behind a wall might have a weaker signal than a device further away in the open. A device held in someone&#39;s hand might have a different RSSI than one sitting on a table.</li>\n<li><strong>Transmit Power:</strong> Devices advertise with different power levels. A device far away transmitting strongly might have the same RSSI as a device nearby transmitting weakly.</li>\n</ul>\n<p><strong>Conclusion:</strong> You can use RSSI as a <em>rough indicator</em> of relative proximity within a stable environment, <em>comparing the same device to itself over time</em>. For example, if the RSSI of a specific device goes from -90 dBm to -50 dBm, it&#39;s almost certainly getting closer. However, you <em>cannot</em> reliably say &quot;this device is exactly X meters away&quot; based solely on RSSI, nor can you reliably say &quot;device A is closer than device B&quot; based only on a single RSSI reading if they are different types of devices or in different locations relative to obstacles.</p>\n<p>For our tool, we&#39;ll mainly use RSSI changes for the Personal Tracker mode (is a <em>specific</em> device getting closer?) and as just one piece of information in the Environmental Baseline mode.</p>\n<h4>5.7 Implementing a &quot;Last Seen&quot; Timestamp</h4>\n<p>We already incorporated this into our <code>DeviceInfo</code> struct and the update logic in <code>onResult</code>.</p>\n<p><code>unsigned long lastSeenMillis;</code> stores the value returned by <code>millis()</code> when we last saw the device.</p>\n<p>The <code>millis()</code> function is great for relative timing. If <code>millis()</code> now is 10000 and <code>lastSeenMillis</code> for a device is 8000, we know we last saw it 2000 milliseconds (2 seconds) ago.</p>\n<p><strong>Important Note:</strong> <code>millis()</code> will eventually overflow (wrap around) after about 49.7 days. For a long-running device, you might need to handle this wrap-around if you&#39;re calculating durations across the overflow point, but for typical scanning sessions of minutes or hours, <code>millis()</code> is perfectly fine.</p>\n<h4>5.8 Putting It All Together: Refactoring the Module 4 Code</h4>\n<p>Let&#39;s integrate these concepts into a complete ESP32 sketch based on our Module 4 scanner.</p>\n<p>We&#39;ll need:</p>\n<ol>\n<li>Necessary includes (<code>BLEDevice</code>, <code>BLEUtils</code>, <code>BLEScan</code>, <code>BLEAdvertisedDevice</code>, <code>vector</code>, <code>string</code>).</li>\n<li>The <code>DeviceInfo</code> struct definition.</li>\n<li>The global <code>std::vector&lt;DeviceInfo&gt; uniqueDevices;</code>.</li>\n<li>The <code>findDeviceByAddress</code> helper function.</li>\n<li>The <code>MyAdvertisedDeviceCallbacks</code> class with the modified <code>onResult</code> method that uses <code>findDeviceByAddress</code> and updates/adds devices to <code>uniqueDevices</code>.</li>\n<li>The <code>setup()</code> function to initialize BLE and start the scan, setting our custom callback.</li>\n<li>The <code>loop()</code> function. For this module&#39;s project, we&#39;ll let the scan run for a set time, then stop it, print the list of unique devices, and maybe wait before scanning again (or just run one scan as per the project).</li>\n</ol>\n<p>Here&#39;s a skeletal structure:</p>\n<pre><code class=\"language-cpp\">#include &lt;Arduino.h&gt;\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEScan.h&gt;\n#include &lt;BLEAdvertisedDevice.h&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt; // Required for std::string\n\n// The scan time in seconds. 0 = continuous scan\n#define SCAN_TIME_SECONDS 10\n\n// --- Data Structure for Device Information ---\nstruct DeviceInfo {\n    BLEAddress  address;\n    std::string name;\n    int         rssi;\n    unsigned long lastSeenMillis;\n};\n\n// --- Vector to store unique devices ---\nstd::vector&lt;DeviceInfo&gt; uniqueDevices;\n\n// --- Helper function to find a device in the vector ---\nDeviceInfo* findDeviceByAddress(const BLEAddress&amp; address) {\n    for (auto&amp; device : uniqueDevices) {\n        if (device.address.equals(address)) {\n            return &amp;device;\n        }\n    }\n    return nullptr; // Device not found\n}\n\n// --- Callback class for scan results ---\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n        // Serial.printf(&quot;Advertised Device found: %s\\n&quot;, advertisedDevice.toString().c_str()); // Optional: Keep for verbose debugging\n\n        BLEAddress deviceAddress = advertisedDevice.getAddress();\n        DeviceInfo* existingDevice = findDeviceByAddress(deviceAddress);\n\n        if (existingDevice != nullptr) {\n            // Device found, update info\n            existingDevice-&gt;rssi = advertisedDevice.getRSSI();\n            existingDevice-&gt;lastSeenMillis = millis();\n            // Serial.printf(&quot;  -&gt; Updated existing device: %s\\n&quot;, deviceAddress.toString().c_str()); // Optional debug\n        } else {\n            // New device, add it\n            DeviceInfo newDevice;\n            newDevice.address = deviceAddress;\n            newDevice.rssi = advertisedDevice.getRSSI();\n            newDevice.lastSeenMillis = millis();\n            newDevice.name = advertisedDevice.getName().empty() ? &quot;N/A&quot; : advertisedDevice.getName();\n\n            uniqueDevices.push_back(newDevice);\n            Serial.printf(&quot;  -&gt; Added new device: %s (Name: %s, RSSI: %d)\\n&quot;,\n                          newDevice.address.toString().c_str(),\n                          newDevice.name.c_str(),\n                          newDevice.rssi);\n        }\n    }\n};\n\n// --- BLE Objects ---\nBLEScan* pBLEScan;\nMyAdvertisedDeviceCallbacks myCallbacks;\n\n// --- Setup Function ---\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Starting BLE Scan...&quot;);\n\n    // Initialize BLE\n    BLEDevice::init(&quot;&quot;); // You can give your device a name here if needed later\n\n    // Create the BLE Scanner\n    pBLEScan = BLEDevice::getScan();\n    pBLEScan-&gt;setAdvertisedDeviceCallbacks(&amp;myCallbacks); // Set our custom callback\n    pBLEScan-&gt;setActiveScan(true);                       // Active scan gets scan response data (like full name)\n    pBLEScan-&gt;setInterval(100);                          // Scan interval in ms\n    pBLEScan-&gt;setWindow(99);                             // Scan window in ms (should be &lt;= interval)\n\n    Serial.printf(&quot;Starting scan for %d seconds...\\n&quot;, SCAN_TIME_SECONDS);\n    pBLEScan-&gt;start(SCAN_TIME_SECONDS, false); // Start scan, &#39;false&#39; means don&#39;t stop when a device is found\n}\n\n// --- Loop Function ---\nvoid loop() {\n    // In this design, the scan runs for SCAN_TIME_SECONDS set in setup.\n    // When the scan time is up, the scan automatically stops and a &#39;scan complete&#39; event occurs\n    // (though we don&#39;t explicitly handle that event callback here, start() with a duration handles it).\n    // We will print the list *after* the scan finishes.\n\n    // Check if the scan is running. If not, print results and potentially restart or stop.\n    if (pBLEScan-&gt;getResults().getCount() &gt; 0 &amp;&amp; !pBLEScan-&gt;isScanning()) {\n        Serial.println(&quot;\\nScan finished.&quot;);\n        Serial.printf(&quot;Found %zu unique devices:\\n&quot;, uniqueDevices.size()); // Use %zu for size_t\n\n        // Sort the unique devices list by address for consistent output (optional but nice)\n        std::sort(uniqueDevices.begin(), uniqueDevices.end(), [](const DeviceInfo&amp; a, const DeviceInfo&amp; b) {\n            return a.address.toString() &lt; b.address.toString();\n        });\n\n        // Print the list of unique devices\n        for (const auto&amp; device : uniqueDevices) {\n            Serial.printf(&quot;- %s (Name: %s, RSSI: %d, Last Seen: %lu ms ago)\\n&quot;,\n                          device.address.toString().c_str(),\n                          device.name.c_str(),\n                          device.rssi,\n                          millis() - device.lastSeenMillis); // Calculate time ago\n        }\n\n        // Clear the list for the next scan if needed, or just stop here for the project\n        // uniqueDevices.clear();\n\n        // For this module&#39;s project, we just run one scan and stop.\n        // In future modules, we might loop scans or change modes.\n        Serial.println(&quot;Module 5 Project Scan Complete. Board can be reset for another scan.&quot;);\n\n        // Prevent the loop from running this block repeatedly\n        while(true) { delay(1000); } // Halt the loop indefinitely\n    }\n\n    // Small delay to prevent watchdog timer issues if loop is empty or runs too fast\n    delay(10);\n}\n\n// Need to include the algorithm header for std::sort\n#include &lt;algorithm&gt;\n</code></pre>\n<p><strong>Key Changes from Module 4:</strong></p>\n<ul>\n<li>Added <code>#include &lt;vector&gt;</code>, <code>#include &lt;string&gt;</code>, <code>#include &lt;algorithm&gt;</code>.</li>\n<li>Defined the <code>DeviceInfo</code> struct.</li>\n<li>Declared <code>std::vector&lt;DeviceInfo&gt; uniqueDevices;</code>.</li>\n<li>Implemented <code>findDeviceByAddress</code>.</li>\n<li>Modified <code>MyAdvertisedDeviceCallbacks::onResult</code> to use <code>findDeviceByAddress</code> and update/add to <code>uniqueDevices</code>.</li>\n<li>Removed the direct print of <code>advertisedDevice.toString()</code> from <code>onResult</code> (or commented it out) to avoid spamming the Serial Monitor with duplicates. We now only print when a <em>new</em> unique device is added, and print the full list at the end.</li>\n<li>Added logic in <code>loop()</code> to check if the scan has finished (<code>!pBLEScan-&gt;isScanning()</code>) and if results were found (<code>pBLEScan-&gt;getResults().getCount() &gt; 0</code>). This is a simple way to trigger the &quot;print unique devices&quot; phase after the timed scan.</li>\n<li>Added code in <code>loop()</code> to iterate through <code>uniqueDevices</code> and print the stored information, including the calculated &quot;time since last seen&quot;.</li>\n<li>Added optional sorting of the list before printing for cleaner output.</li>\n<li>Added a <code>while(true) { delay(1000); }</code> loop at the end of <code>loop()</code> to effectively stop the program after the scan and printing are done, fulfilling the project requirement of a single scan run.</li>\n</ul>\n<hr>\n<h3>Suggested Resources or Prerequisites:</h3>\n<ul>\n<li>Completion of Module 4.</li>\n<li>ESP32 DevkitC with Arduino IDE setup.</li>\n<li>A device that advertises via BLE (smartphone with BLE enabled, fitness tracker, smart watch, other ESP32 advertising, etc.).</li>\n<li>Familiarity with basic C++ data structures (structs) and the concept of vectors/dynamic arrays.</li>\n<li>Links:<ul>\n<li><a href=\"https://github.com/nkolban/esp32-snippets/blob/master/Documentation/BLE%20C%2B%2B11%20Interface.md\">ESP32-BLE-Arduino Library Documentation</a> (Focus on BLEScan and BLEAdvertisedDevice)</li>\n<li><a href=\"https://www.cplusplus.com/reference/vector/vector/\">C++ <code>std::vector</code> Reference</a></li>\n<li><a href=\"https://www.cplusplus.com/doc/tutorial/structures/\">C++ <code>struct</code> Tutorial</a></li>\n<li><a href=\"https://www.arduino.cc/reference/en/language/functions/time/millis/\">Arduino <code>millis()</code> Reference</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>Module Project/Exercise:</h3>\n<p><strong>Objective:</strong> Modify your Module 4 scanning sketch to store unique devices in a list (<code>std::vector&lt;DeviceInfo&gt;</code>). For each scan result, check if the device is already in the list using its MAC address. If new, add it. If existing, update its <code>lastSeenMillis</code> and <code>rssi</code>. After a set scan duration (e.g., 10 seconds), stop the scan and print the list of unique devices found, including their MAC address, name (if available), last seen RSSI, and how long ago (in milliseconds) they were last seen.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Start with your working sketch from Module 4 that performs a BLE scan using the <code>ESP32-BLE-Arduino</code> library and prints scan results in the <code>onResult</code> callback.</li>\n<li>Add the necessary <code>#include</code> statements for <code>vector</code>, <code>string</code>, and <code>algorithm</code>.</li>\n<li>Define the <code>DeviceInfo</code> struct as shown above.</li>\n<li>Declare the global <code>std::vector&lt;DeviceInfo&gt; uniqueDevices;</code>.</li>\n<li>Implement the <code>findDeviceByAddress</code> helper function.</li>\n<li>Modify the <code>onResult</code> method in your <code>BLEAdvertisedDeviceCallbacks</code> class:<ul>\n<li>Get the <code>BLEAddress</code> from the <code>advertisedDevice</code>.</li>\n<li>Call <code>findDeviceByAddress</code> to look for it in <code>uniqueDevices</code>.</li>\n<li>If found, update the <code>rssi</code> and <code>lastSeenMillis</code> fields of the found <code>DeviceInfo</code> object.</li>\n<li>If not found, create a new <code>DeviceInfo</code> object, populate its fields (address, name, rssi, lastSeenMillis), and add it to <code>uniqueDevices</code> using <code>push_back()</code>.</li>\n<li>(Optional but recommended) Add Serial print statements inside <code>onResult</code> only when a <em>new</em> device is added, to see the list grow live.</li>\n</ul>\n</li>\n<li>In <code>setup()</code>, configure and start the scan with a specific duration (e.g., <code>pBLEScan-&gt;start(10, false);</code> for 10 seconds).</li>\n<li>Modify the <code>loop()</code> function:<ul>\n<li>Add logic to detect when the scan has finished (`!p</li>\n</ul>\n</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, SME hat on, teacher mode engaged! This is where the rubber meets the road. We&#39;ve learned to scan and process data; now we apply that to <em>detect</em> things. Module 6 is incredibly satisfying because you start seeing your ESP32 act as a real reconnaissance tool.</p>\n<p>Let&#39;s dive deep into Module 6!</p>\n<hr>\n<h2>Module 6: Building Detection Modes I: Personal Tracker &amp; Environmental Baseline</h2>\n<p><strong>Module Title:</strong> Implementing Reconnaissance Logic: Tracking and Baselining</p>\n<p><strong>Module Objective:</strong> Program the ESP32 to implement the Personal Tracker Detection and Environmental Baseline &amp; Anomaly Detection modes using the scanning and data processing skills acquired in Modules 4 and 5. By the end, your ESP32 won&#39;t just <em>see</em> devices; it will start <em>interpreting</em> their presence based on different rules.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Successful completion of Module 1-5. You should be comfortable setting up the ESP32, writing basic Arduino sketches, understand BLE advertising and scanning, and have implemented code to scan and manage a list of unique devices (likely using <code>std::vector</code> and a struct/class like <code>DeviceInfo</code> or similar).</li>\n<li>Basic understanding of control flow (<code>if</code>, <code>else</code>, <code>switch</code>, loops) and how to structure code using functions.</li>\n</ul>\n<p><strong>Learning the &quot;Why&quot;: Turning Data into Intelligence</strong></p>\n<p>Remember in Module 3 we talked about <em>why</em> we scan Bluetooth? Not just to see what&#39;s there, but to understand the <em>context</em> of the signals. This module is about defining different &quot;contexts&quot; or &quot;modes&quot; of analysis.</p>\n<ul>\n<li><strong>Personal Tracker Detection:</strong> The goal isn&#39;t just to see an AirTag once, but to detect devices that seem to be <em>following</em> you or are persistently present <em>wherever you go</em>. This requires looking at devices that are seen repeatedly over time and potentially monitoring their signal strength changes relative to your location (or, more simply for the ESP32, relative to the scanner&#39;s location).</li>\n<li><strong>Environmental Baseline:</strong> Imagine you want to know if any <em>new</em> Bluetooth devices appear in your office overnight, or if someone brings an unauthorized device into a sensitive area. This requires establishing a &quot;normal&quot; state (the baseline) and then comparing the current state against it.</li>\n</ul>\n<p>These are two distinct logical operations performed on the <em>same underlying scan data</em>. This immediately tells us we need a way to switch between these different operational modes within our single ESP32 sketch.</p>\n<h3>6.1 Structuring the Application: Modes and State</h3>\n<p>Our ESP32 sketch currently probably runs in a continuous loop, maybe scanning repeatedly. To implement different detection modes, we need a structure that allows us to:</p>\n<ol>\n<li>Know which mode we are currently in.</li>\n<li>Execute the appropriate code block for that mode.</li>\n<li>Potentially switch between modes based on user input.</li>\n</ol>\n<p>The simplest way to manage this in an embedded system like the ESP32 is using a variable to represent the current <code>mode</code> and a <code>switch</code> statement (or <code>if/else if</code>) within the main <code>loop()</code> function. A more formal approach is a State Machine, which is excellent for complex interactions, but for 2-3 modes, a simple <code>switch</code> is perfectly adequate and easier to grasp initially.</p>\n<p>Let&#39;s think about the flow:</p>\n<ul>\n<li>The <code>setup()</code> function initializes the Serial port, BLE, and potentially sets an initial mode.</li>\n<li>The <code>loop()</code> function runs continuously.</li>\n<li>Inside <code>loop()</code>, we&#39;ll check if there&#39;s any user input on the Serial port (e.g., typing &#39;1&#39; for Tracker mode, &#39;2&#39; for Baseline mode).</li>\n<li>If input is received, we update the <code>mode</code> variable.</li>\n<li>Then, based on the current <code>mode</code> variable, we call a specific function (e.g., <code>runTrackerMode()</code>, <code>runBaselineMode()</code>).</li>\n<li>Each mode function will contain the scanning and logic specific to that mode.</li>\n</ul>\n<p><strong>Code Snippet: Basic Mode Structure</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;Arduino.h&gt;\n// Include other necessary libraries (BLE, vector, etc.)\n\n// Define constants for modes\nenum AppMode {\n    MODE_IDLE,\n    MODE_TRACKER_DETECT,\n    MODE_BASELINE_SCAN,\n    MODE_BASELINE_COMPARE\n    // We&#39;ll add MODE_ADVERTISING_FLOOD in Module 8\n};\n\nAppMode currentMode = MODE_IDLE;\n\n// Function prototypes for mode logic (we&#39;ll define these later)\nvoid printMenu();\nvoid handleSerialInput();\nvoid runTrackerMode();\nvoid runBaselineScan();\nvoid runBaselineCompare();\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;ESP32 Bluetooth Recon Tool&quot;);\n    // Initialize BLE scanner here (from Module 4)\n    // ... BLE setup code ...\n\n    printMenu(); // Show options on startup\n}\n\nvoid loop() {\n    handleSerialInput(); // Check if user wants to change mode\n\n    switch (currentMode) {\n        case MODE_IDLE:\n            // Do nothing, or maybe print a waiting message occasionally\n            delay(1000);\n            break;\n        case MODE_TRACKER_DETECT:\n            runTrackerMode();\n            break;\n        case MODE_BASELINE_SCAN:\n            runBaselineScan();\n            // After baseline scan, maybe switch to IDLE or wait for compare command\n            // For now, let&#39;s switch back to IDLE after completing the scan phase\n            currentMode = MODE_IDLE;\n            printMenu(); // Show menu again\n            break;\n        case MODE_BASELINE_COMPARE:\n            runBaselineCompare();\n            // After comparison, switch back to IDLE\n            currentMode = MODE_IDLE;\n            printMenu(); // Show menu again\n            break;\n        // Add other modes here later\n    }\n}\n\nvoid printMenu() {\n    Serial.println(&quot;\\n--- Select Mode ---&quot;);\n    Serial.println(&quot;1: Personal Tracker Detection&quot;);\n    Serial.println(&quot;2: Environmental Baseline Scan (Set Baseline)&quot;);\n    Serial.println(&quot;3: Environmental Baseline Compare (Check against Baseline)&quot;);\n    Serial.println(&quot;0: Go to Idle&quot;);\n    Serial.println(&quot;-------------------&quot;);\n    Serial.print(&quot;Enter command: &quot;);\n}\n\nvoid handleSerialInput() {\n    if (Serial.available()) {\n        String command = Serial.readStringUntil(&#39;\\n&#39;);\n        command.trim(); // Remove leading/trailing whitespace\n\n        if (command == &quot;1&quot;) {\n            currentMode = MODE_TRACKER_DETECT;\n            Serial.println(&quot;Switched to: Personal Tracker Detection&quot;);\n        } else if (command == &quot;2&quot;) {\n            currentMode = MODE_BASELINE_SCAN;\n            Serial.println(&quot;Switched to: Environmental Baseline Scan&quot;);\n        } else if (command == &quot;3&quot;) {\n            // We need a baseline first! Let&#39;s add a check.\n            // For now, assume baseline exists or just run it.\n             currentMode = MODE_BASELINE_COMPARE;\n             Serial.println(&quot;Switched to: Environmental Baseline Compare&quot;);\n        } else if (command == &quot;0&quot;) {\n            currentMode = MODE_IDLE;\n            Serial.println(&quot;Switched to: Idle&quot;);\n        } else {\n            Serial.println(&quot;Invalid command.&quot;);\n        }\n        // You might want to print the menu again after handling input,\n        // or only when switching *to* IDLE or after a mode completes.\n        // Let&#39;s print it when switching TO idle or after modes that complete\n    }\n}\n\n// Placeholder functions - we&#39;ll fill these in next!\nvoid runTrackerMode() {\n    Serial.println(&quot;Tracker mode logic goes here...&quot;);\n    // Need to scan, process results, look for persistent devices\n    // This mode typically runs scans repeatedly\n    delay(5000); // Simulate doing work, prevent crashing without real code\n}\n\nvoid runBaselineScan() {\n    Serial.println(&quot;Baseline Scan logic goes here...&quot;);\n    // Need to scan for a duration and store devices\n    delay(5000); // Simulate scan\n    Serial.println(&quot;Baseline Scan complete.&quot;);\n}\n\nvoid runBaselineCompare() {\n    Serial.println(&quot;Baseline Compare logic goes here...&quot;);\n    // Need to scan and compare against stored baseline\n    delay(5000); // Simulate scan and compare\n    Serial.println(&quot;Baseline Compare complete.&quot;);\n}\n</code></pre>\n<p>This structure provides the basic framework. Now, let&#39;s fill in the logic for each mode, reusing and building upon the scanning and device management code from previous modules.</p>\n<h3>6.2 Personal Tracker Detection Mode (<code>runTrackerMode</code>)</h3>\n<p>The goal here is to identify devices that appear consistently over time, potentially indicating they are associated with the scanner&#39;s movement.</p>\n<p><strong>Logic:</strong></p>\n<ol>\n<li><strong>Scan:</strong> Perform a BLE scan.</li>\n<li><strong>Process Results:</strong> Use the <code>onResult</code> callback (from Module 4/5) to update our central list of unique devices (from Module 5). This list should contain the device&#39;s MAC address, name, last seen timestamp, and perhaps a count of how many times it&#39;s been seen.</li>\n<li><strong>Identify Persistent Devices:</strong> Iterate through the list of known devices. A device is considered &quot;persistent&quot; if:<ul>\n<li>It has been seen recently (e.g., <code>lastSeen</code> is within the last 30 seconds).</li>\n<li><em>And</em> it has been seen a sufficient number of times overall (e.g., <code>seenCount</code> &gt; 5). <em>Or</em> perhaps, has been present in a certain percentage of recent scans. A simple approach is just checking the <code>lastSeen</code> timestamp – if it keeps getting updated frequently, the device is likely still nearby.</li>\n</ul>\n</li>\n<li><strong>Alert:</strong> If a device meets the persistence criteria <em>and</em> is not on an &quot;ignore&quot; list (for known devices like your own phone), print an alert. Include its MAC, name, and current RSSI.</li>\n<li><strong>Repeat:</strong> This mode should ideally scan, check, report, and then scan again periodically.</li>\n</ol>\n<p><strong>Revisiting the Device List (<code>DeviceInfo</code>)</strong></p>\n<p>Our device list structure from Module 5 needs to support this. Let&#39;s refine the <code>DeviceInfo</code> struct/class:</p>\n<pre><code class=\"language-cpp\">// Assume this is defined globally or accessible\nstruct DeviceInfo {\n    BLEAddress address;\n    String name;\n    int rssi;\n    unsigned long lastSeen; // millis() timestamp\n    int seenCount;          // How many times seen in total\n    // Add other data like manufacturer data if needed later\n    bool isBaseline = false; // Used for baseline mode, initialized to false\n};\n\n// Global list of unique devices\nstd::vector&lt;DeviceInfo&gt; detectedDevices;\n\n// Function to find or add a device (from Module 5, potentially slightly modified)\nvoid addOrUpdateDevice(BLEAdvertisedDevice* advertisedDevice) {\n    BLEAddress deviceAddress = advertisedDevice-&gt;getAddress();\n    bool found = false;\n    unsigned long currentTime = millis();\n\n    for (size_t i = 0; i &lt; detectedDevices.size(); ++i) {\n        if (detectedDevices[i].address == deviceAddress) {\n            // Found existing device, update info\n            detectedDevices[i].rssi = advertisedDevice-&gt;getRSSI();\n            detectedDevices[i].lastSeen = currentTime;\n            detectedDevices[i].seenCount++; // Increment count\n            // Update name if it wasn&#39;t known before\n            if (detectedDevices[i].name == &quot;&quot; &amp;&amp; advertisedDevice-&gt;getName() != &quot;&quot;) {\n                 detectedDevices[i].name = advertisedDevice-&gt;getName();\n            }\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        // New device, add it to the list\n        DeviceInfo newDevice;\n        newDevice.address = deviceAddress;\n        newDevice.name = advertisedDevice-&gt;getName().c_str(); // getName returns std::string\n        newDevice.rssi = advertisedDevice-&gt;getRSSI();\n        newDevice.lastSeen = currentTime;\n        newDevice.seenCount = 1; // First time seen\n        newDevice.isBaseline = false; // Not a baseline device by default\n\n        detectedDevices.push_back(newDevice);\n        Serial.print(&quot;NEW DEVICE FOUND: &quot;);\n        Serial.print(newDevice.address.toString().c_str());\n        if (newDevice.name != &quot;&quot;) Serial.print(&quot; (&quot;); Serial.print(newDevice.name); Serial.print(&quot;)&quot;);\n        Serial.print(&quot; RSSI: &quot;); Serial.println(newDevice.rssi);\n    }\n}\n\n// The onResult callback function (from Module 4/5)\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice* advertisedDevice) {\n        // When a device is found during scanning, call our handler\n        addOrUpdateDevice(advertisedDevice);\n    }\n};\n\nMyAdvertisedDeviceCallbacks myCallbacks; // Create an instance of the callback class\n\n// In setup(), initialize BLE and set the scan callbacks:\n/*\nBLEDevice::init(&quot;&quot;); // Name can be anything\nBLEScan* pBLEScan = BLEDevice::getScan();\npBLEScan-&gt;setAdvertisedDeviceCallbacks(&amp;myCallbacks);\npBLEScan-&gt;setActiveScan(true); // Active scan requests name, etc.\npBLEScan-&gt;setInterval(100); // Scan interval\npBLEScan-&gt;setWindow(99);  // Scan window (should be &lt;= interval)\n*/\n</code></pre>\n<p>Now, let&#39;s write the <code>runTrackerMode</code> function using this updated structure.</p>\n<p><strong>Code Snippet: <code>runTrackerMode()</code></strong></p>\n<pre><code class=\"language-cpp\">// Constants for tracker detection\nconst unsigned long TRACKER_LAST_SEEN_THRESHOLD_MS = 60000; // Must be seen in last 60 seconds\nconst int TRACKER_SEEN_COUNT_THRESHOLD = 5; // Must have been seen at least 5 times\n\nvoid runTrackerMode() {\n    Serial.println(&quot;\\n--- Tracker Detection Mode ---&quot;);\n    Serial.println(&quot;Scanning for persistent devices...&quot;);\n\n    // --- Step 1 &amp; 2: Perform Scan and Process Results ---\n    // The onResult callback (addOrUpdateDevice) automatically handles updating the list\n    // We just need to start and stop the scan.\n    // Let&#39;s scan for a short period, then process.\n    int scanDuration = 5; // seconds\n    Serial.print(&quot;Scanning for &quot;); Serial.print(scanDuration); Serial.println(&quot; seconds...&quot;);\n    BLEDevice::getScan()-&gt;start(scanDuration, false); // &#39;false&#39; means don&#39;t stop when duration ends, we manage it\n\n    // Important: The scan runs in the background. We need to wait for it to finish\n    // or process results *after* it&#39;s done. The &#39;false&#39; above means start async.\n    // A simple way is to just wait a bit longer than the scan duration,\n    // or check if the scan is still active (pBLEScan-&gt;isScanning()).\n    // For simplicity in this example, let&#39;s just wait. In a real app,\n    // you might use a timer or check isScanning().\n    delay((scanDuration + 1) * 1000); // Wait for scan duration + 1 second\n\n    Serial.println(&quot;Scan complete. Analyzing results...&quot;);\n\n    unsigned long currentTime = millis();\n    int potentialTrackersFound = 0;\n\n    // --- Step 3: Identify Persistent Devices ---\n    Serial.println(&quot;Potential Trackers Found:&quot;);\n    for (const auto&amp; device : detectedDevices) {\n        // Check persistence criteria\n        bool isPersistent = (currentTime - device.lastSeen &lt;= TRACKER_LAST_SEEN_THRESHOLD_MS) &amp;&amp;\n                            (device.seenCount &gt;= TRACKER_SEEN_COUNT_THRESHOLD);\n\n        // --- Step 4: Alert ---\n        // You might add a check here for an &quot;ignore list&quot; if you had one\n        // bool isIgnored = false; // Implement ignore list check if needed\n        // if (isPersistent &amp;&amp; !isIgnored) { ... }\n\n        if (isPersistent) {\n            Serial.print(&quot;  -&gt; &quot;);\n            Serial.print(device.address.toString().c_str());\n            if (device.name != &quot;&quot;) Serial.print(&quot; (&quot;); Serial.print(device.name); Serial.print(&quot;)&quot;);\n            Serial.print(&quot; RSSI: &quot;); Serial.print(device.rssi);\n            Serial.print(&quot; Last Seen (ms ago): &quot;); Serial.print(currentTime - device.lastSeen);\n            Serial.print(&quot; Seen Count: &quot;); Serial.println(device.seenCount);\n            potentialTrackersFound++;\n        }\n    }\n\n    if (potentialTrackersFound == 0) {\n        Serial.println(&quot;  (No persistent devices detected meeting current criteria)&quot;);\n    }\n\n    Serial.println(&quot;--- End Tracker Detection Scan ---&quot;);\n\n    // --- Step 5: Repeat (or wait for next scan cycle in loop) ---\n    // In the main loop, we could add a delay before the next tracker scan cycle\n    // or switch back to IDLE after a single scan/report cycle in this function.\n    // For this example, let&#39;s just return and the main loop will handle delays/re-entry.\n    // A better approach for continuous scanning is to keep this mode active\n    // in the loop and perform scans periodically *within* runTrackerMode or loop.\n    // Let&#39;s modify the loop structure slightly to handle continuous modes.\n}\n</code></pre>\n<p><strong>Refining the Continuous Mode Structure:</strong></p>\n<p>Instead of switching back to <code>IDLE</code> immediately, continuous modes like <code>MODE_TRACKER_DETECT</code> should stay active and perform their cycle (scan, process, report) repeatedly with a delay.</p>\n<pre><code class=\"language-cpp\">// Modify loop() structure slightly\nvoid loop() {\n    handleSerialInput(); // Check if user wants to change mode\n\n    switch (currentMode) {\n        case MODE_IDLE:\n            // Do nothing, or maybe print a waiting message occasionally\n            delay(500); // Small delay to not hammer CPU\n            break;\n        case MODE_TRACKER_DETECT:\n            runTrackerMode(); // This function should perform one scan/report cycle and return\n            delay(1000); // Delay before starting the next tracker scan cycle\n            break;\n        case MODE_BASELINE_SCAN:\n            runBaselineScan();\n            // After baseline scan, switch to IDLE and show menu\n            currentMode = MODE_IDLE;\n            printMenu();\n            break;\n        case MODE_BASELINE_COMPARE:\n            runBaselineCompare();\n            // After comparison, switch back to IDLE and show menu\n            currentMode = MODE_IDLE;\n            printMenu();\n            break;\n        // Add other modes here later\n    }\n}\n\nvoid runTrackerMode() {\n    // ... (Code as above) ...\n    // This function now performs one scan/analysis cycle and returns.\n    // The delay between cycles is in the main loop().\n}\n</code></pre>\n<p>This approach is more flexible for continuous scanning modes.</p>\n<h3>6.3 Environmental Baseline &amp; Anomaly Detection Mode</h3>\n<p>This mode requires two steps: first, establishing the baseline; second, performing a comparison scan.</p>\n<p><strong>Logic - Baseline Scan (<code>runBaselineScan</code>):</strong></p>\n<ol>\n<li><strong>Clear Baseline:</strong> Clear any previously stored baseline data.</li>\n<li><strong>Scan:</strong> Perform a BLE scan for a defined duration (e.g., 30 seconds, 60 seconds). The duration should be long enough to capture most ambient devices.</li>\n<li><strong>Store Baseline:</strong> As devices are found during the scan (via the <code>onResult</code> callback), add them to a <em>separate</em> list specifically for the baseline, or mark them in the main <code>detectedDevices</code> list as <code>isBaseline = true</code>. The latter is simpler as we only need one list, but requires careful handling. Let&#39;s use a separate list for clarity in this explanation, though you could integrate it.</li>\n<li><strong>Report:</strong> Print a summary of how many unique devices were found and stored in the baseline.</li>\n</ol>\n<p><strong>Logic - Comparison Scan (<code>runBaselineCompare</code>):</strong></p>\n<ol>\n<li><strong>Check Baseline:</strong> Ensure a baseline has been set. If not, inform the user.</li>\n<li><strong>Scan:</strong> Perform a BLE scan for a defined duration (could be shorter than the baseline scan).</li>\n<li><strong>Compare and Identify New:</strong> For each device found in <em>this comparison scan</em>:<ul>\n<li>Check if this device&#39;s MAC address exists in the <em>baseline list</em>.</li>\n<li>If the device&#39;s MAC address is <em>not</em> found in the baseline list, it&#39;s a &quot;new&quot; or &quot;anomalous&quot; device.</li>\n</ul>\n</li>\n<li><strong>Alert:</strong> Print an alert for each new device found, including its MAC, name, and RSSI.</li>\n</ol>\n<p><strong>Revisiting the Device List for Baseline</strong></p>\n<p>We can either have a <code>std::vector&lt;DeviceInfo&gt; baselineDevices;</code> or add a flag <code>bool isBaseline = false;</code> to our main <code>DeviceInfo</code> struct and manage this flag. Using the flag in the main list is more memory efficient if the lists are large, but requires careful logic to differentiate. Let&#39;s stick with a separate <code>baselineDevices</code> vector for clarity in this module&#39;s explanation and project.</p>\n<pre><code class=\"language-cpp\">// Global list specifically for baseline devices\nstd::vector&lt;DeviceInfo&gt; baselineDevices;\n\n// Need a flag to know if baseline has been set\nbool baselineSet = false;\n\n// Modify addOrUpdateDevice slightly or create a dedicated function\n// For the baseline scan, we need to populate baselineDevices\n// For the comparison scan, we scan normally (updating detectedDevices)\n// then compare detectedDevices against baselineDevices.\n\n// Let&#39;s keep addOrUpdateDevice as is, and process the results *after* the scan\n// in the baseline functions, rather than modifying the callback.\n// This separates scanning (putting everything into detectedDevices) from the mode logic.\n</code></pre>\n<p><strong>Code Snippet: <code>runBaselineScan()</code></strong></p>\n<pre><code class=\"language-cpp\">void runBaselineScan() {\n    Serial.println(&quot;\\n--- Environmental Baseline Scan Mode ---&quot;);\n    Serial.println(&quot;Setting baseline. Scanning ambient devices...&quot;);\n\n    // --- Step 1: Clear Baseline ---\n    baselineDevices.clear(); // Empty the previous baseline\n    detectedDevices.clear(); // Also clear the main list to get a fresh scan for baseline\n\n    // --- Step 2: Perform Scan ---\n    int scanDuration = 30; // Scan for 30 seconds to capture ambient devices\n    Serial.print(&quot;Scanning for &quot;); Serial.print(scanDuration); Serial.println(&quot; seconds...&quot;);\n\n    // Start the scan. The onResult callback will populate detectedDevices\n    BLEDevice::getScan()-&gt;start(scanDuration, false); // Async scan\n\n    // Wait for the scan to complete\n    delay((scanDuration + 1) * 1000);\n\n    Serial.println(&quot;Scan complete. Storing baseline...&quot;);\n\n    // --- Step 3: Store Baseline ---\n    // detectedDevices now contains all unique devices seen during the scan.\n    // Copy them to the baselineDevices list.\n    baselineDevices = detectedDevices; // Simple copy of the vector\n\n    baselineSet = true; // Mark that a baseline is now available\n\n    // --- Step 4: Report ---\n    Serial.print(&quot;Baseline set with &quot;);\n    Serial.print(baselineDevices.size());\n    Serial.println(&quot; unique devices.&quot;);\n    Serial.println(&quot;--- End Baseline Scan ---&quot;);\n\n    // Note: We don&#39;t print the full list here, just the count.\n    // Could add an option to list baseline devices if desired.\n}\n</code></pre>\n<p><strong>Code Snippet: <code>runBaselineCompare()</code></strong></p>\n<pre><code class=\"language-cpp\">void runBaselineCompare() {\n    Serial.println(&quot;\\n--- Environmental Baseline Compare Mode ---&quot;);\n\n    // --- Step 1: Check Baseline ---\n    if (!baselineSet) {\n        Serial.println(&quot;Error: Baseline has not been set yet.&quot;);\n        Serial.println(&quot;Please run Environmental Baseline Scan first (Option 2).&quot;);\n        Serial.println(&quot;--- End Baseline Compare ---&quot;);\n        return; // Exit the function\n    }\n\n    Serial.print(&quot;Comparing against baseline of &quot;);\n    Serial.print(baselineDevices.size());\n    Serial.println(&quot; devices.&quot;);\n    Serial.println(&quot;Scanning for new devices...&quot;);\n\n    // --- Step 2: Perform Scan ---\n    detectedDevices.clear(); // Clear the main list to get fresh data for comparison\n    int scanDuration = 10; // Shorter scan for comparison\n    Serial.print(&quot;Scanning for &quot;); Serial.print(scanDuration); Serial.println(&quot; seconds...&quot;);\n\n    // Start scan. onResult callback populates detectedDevices\n    BLEDevice::getScan()-&gt;start(scanDuration, false); // Async scan\n\n    // Wait for scan to complete\n    delay((scanDuration + 1) * 1000);\n\n    Serial.println(&quot;Scan complete. Identifying new devices...&quot;);\n\n    int newDevicesFound = 0;\n    Serial.println(&quot;New Devices (Not in Baseline):&quot;);\n\n    // --- Step 3: Compare and Identify New ---\n    // Iterate through the devices found in the *current scan* (detectedDevices)\n    for (const auto&amp; currentDevice : detectedDevices) {\n        bool foundInBaseline = false;\n        // Check if this current device exists in the baseline list\n        for (const auto&amp; baseDevice : baselineDevices) {\n            if (currentDevice.address == baseDevice.address) {\n                foundInBaseline = true;\n                break; // Found it in the baseline, no need to\n</code></pre>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, let&#39;s dive into Module 7! This is where we flip the script from listening to speaking on the Bluetooth airwaves. It&#39;s a fundamental concept for any wireless communication and directly applicable to understanding how devices announce their presence – and how we might simulate or manipulate that.</p>\n<p>Here are the detailed course materials for Module 7:</p>\n<hr>\n<h2>Module 7: Broadcasting Your Presence: Programming the ESP32 as a BLE Advertiser</h2>\n<ul>\n<li><strong>Module Title:</strong> Broadcasting Your Presence: Programming the ESP32 as a BLE Advertiser</li>\n<li><strong>Module Objective:</strong> Learn how to configure the ESP32 to act as a BLE Broadcaster and send out custom advertising packets. By the end, you&#39;ll be able to make your ESP32 visible to other BLE devices and control the information it broadcasts.</li>\n<li><strong>Prerequisites:</strong><ul>\n<li>Completion of Module 6 (While the code isn&#39;t directly dependent, the development environment and basic ESP32 programming skills are assumed).</li>\n<li>ESP32 DevkitC board and USB cable.</li>\n<li>Arduino IDE with ESP32 board support installed.</li>\n<li>A smartphone with a BLE scanning application (e.g., nRF Connect for Android, LightBlue for iOS).</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>Introduction: Stepping from Observer to Broadcaster</h3>\n<p>Welcome back! In the previous modules, we&#39;ve been the quiet observer, scanning the airwaves to see what&#39;s out there. We learned how devices announce themselves through advertising packets. Now, it&#39;s <em>our</em> turn to speak!</p>\n<p>In this module, we&#39;ll configure our ESP32 to become a BLE Broadcaster. This is the role many simple, low-power devices like fitness trackers, beacons (like iBeacons or Eddystone), and even your phone when it&#39;s discoverable, play. They periodically send out advertising packets containing information about themselves or data they want to share, without needing a constant connection.</p>\n<p>Understanding how to <em>create</em> advertising packets is crucial. It solidifies our understanding of their structure (from Module 3) and allows us to:</p>\n<ol>\n<li>Emulate existing devices for testing or research.</li>\n<li>Create our own custom beacons.</li>\n<li>Lay the groundwork for more advanced techniques like advertising flooding (Module 8).</li>\n</ol>\n<p>Let&#39;s get our ESP32 talking!</p>\n<h3>Hardware and Software Setup Refresher</h3>\n<ul>\n<li><strong>Hardware:</strong> Your trusty ESP32 DevkitC connected to your computer via a USB cable.</li>\n<li><strong>Software:</strong><ul>\n<li>Arduino IDE.</li>\n<li>Ensure the ESP32 board support package is installed (Tools &gt; Board &gt; ESP32 Arduino &gt; ESP32 Dev Module).</li>\n<li>We will again use the <code>ESP32-BLE-Arduino</code> library. If you haven&#39;t already installed it (you should have in Module 4, but double-check), go to <code>Sketch &gt; Include Library &gt; Manage Libraries...</code>, search for &quot;ESP32 BLE&quot;, and install the one by Neil Kolban, Evandro Copercini, and others.</li>\n</ul>\n</li>\n</ul>\n<h3>Understanding the ESP32 BLE Library for Advertising</h3>\n<p>The same library we used for scanning (<code>ESP32-BLE-Arduino</code>) also handles the advertising side. It provides classes and functions to initialize the BLE subsystem, configure advertising data, set parameters, and start/stop the advertising process.</p>\n<p>Key classes/objects we&#39;ll interact with:</p>\n<ul>\n<li><strong><code>BLEDevice</code></strong>: Handles the overall BLE subsystem initialization.</li>\n<li><strong><code>BLEAdvertising</code></strong>: The object responsible for managing the advertising process (setting parameters, starting/stopping). You get an instance of this via <code>BLEDevice::getAdvertising()</code>.</li>\n<li><strong><code>BLEAdvertisementData</code></strong>: An object used to build the <em>contents</em> of the advertising packet. This is where you put the device name, service UUIDs, manufacturer data, etc.</li>\n<li><strong><code>BLEScanResponseData</code> (Optional but Good Practice)</strong>: Similar to <code>BLEAdvertisementData</code>, but for the <em>scan response</em> packet. Scanners can request this secondary packet for more data if the initial advertisement is too full or basic. We&#39;ll primarily focus on the main advertising data for this module&#39;s project.</li>\n</ul>\n<h3>Step 1: Initializing the BLE Subsystem</h3>\n<p>Just like with scanning, the first step is to initialize the BLE stack on the ESP32.</p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt; // Often included, though we won&#39;t use server features here\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  // Initialize BLE. You can optionally provide a default device name here.\n  BLEDevice::init(&quot;MyESP32Advertiser&quot;);\n  Serial.println(&quot;BLE initialized.&quot;);\n\n  // The rest of our advertising setup will go here...\n}\n\nvoid loop() {\n  // Advertising runs in the background, so the loop can be simple\n  // or handle other tasks. For now, just a small delay.\n  delay(1000);\n}\n</code></pre>\n<ul>\n<li><code>BLEDevice::init(&quot;MyESP32Advertiser&quot;);</code>: This function initializes the BLE hardware and software stack. The string provided is the <em>default</em> device name, though we&#39;ll show how to set the advertised name specifically in the advertising data.</li>\n</ul>\n<p>Upload this sketch. Open the Serial Monitor. You should see the &quot;Starting BLE Advertiser...&quot; and &quot;BLE initialized.&quot; messages. The ESP32 isn&#39;t advertising <em>yet</em>, we&#39;ve just turned on the engine.</p>\n<h3>Step 2: Getting the Advertising Object</h3>\n<p>We need to get a reference to the <code>BLEAdvertising</code> object to configure and control the advertising process.</p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\nBLEAdvertising *pAdvertising; // Declare a pointer to the advertising object\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  BLEDevice::init(&quot;MyESP32Advertiser&quot;);\n  Serial.println(&quot;BLE initialized.&quot;);\n\n  // Get the advertising object\n  pAdvertising = BLEDevice::getAdvertising();\n  Serial.println(&quot;Advertising object obtained.&quot;);\n\n  // The rest of our advertising setup will go here...\n}\n\nvoid loop() {\n  delay(1000);\n}\n</code></pre>\n<ul>\n<li><code>BLEAdvertising *pAdvertising;</code>: We declare a pointer globally (or within <code>setup</code> if preferred, but global makes it easier if we needed it in <code>loop</code>).</li>\n<li><code>pAdvertising = BLEDevice::getAdvertising();</code>: This gets the singleton instance of the advertising manager.</li>\n</ul>\n<p>Still no advertising, but we&#39;re ready to configure it.</p>\n<h3>Step 3: Configuring the Advertising Data (<code>BLEAdvertisementData</code>)</h3>\n<p>This is where we define <em>what</em> information our ESP32 will broadcast. We create a <code>BLEAdvertisementData</code> object and add the desired data fields.</p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\nBLEAdvertising *pAdvertising;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  BLEDevice::init(&quot;MyESP32Advertiser&quot;); // Default name\n\n  pAdvertising = BLEDevice::getAdvertising();\n  Serial.println(&quot;Advertising object obtained.&quot;);\n\n  // *** Configure the Advertising Data ***\n  BLEAdvertisementData advData;\n\n  // 1. Set Flags (important for discoverability)\n  // BLE_HS_ADV_F_DISC_GEN (0x02) - General Discoverable Mode\n  // BLE_HS_ADV_F_BREDR_UNSUP (0x04) - BR/EDR (Classic) not supported\n  // Combined: 0x02 | 0x04 = 0x06\n  advData.setFlags(0x06);\n  Serial.println(&quot;Flags set.&quot;);\n\n  // 2. Set the complete local device name\n  advData.setCompleteDeviceName(&quot;MyCustomESP32&quot;);\n  Serial.println(&quot;Device name set.&quot;);\n\n  // 3. Add a Service UUID (Optional, but common for identifying device type/service)\n  // This is a standard UUID for the &quot;Device Information Service&quot; (0x180A)\n  // You could add your own custom UUID here if needed.\n  advData.addServiceUUID(&quot;180A&quot;);\n  Serial.println(&quot;Service UUID added.&quot;);\n\n  // --- We will add Manufacturer Data in Step 5 ---\n\n  // Set the configured advertising data to the advertising object\n  pAdvertising-&gt;setAdvertisementData(advData);\n  Serial.println(&quot;Advertising data configured.&quot;);\n\n  // The rest of our advertising setup will go here (parameters, start)...\n}\n\nvoid loop() {\n  delay(1000);\n}\n</code></pre>\n<ul>\n<li><code>BLEAdvertisementData advData;</code>: Creates an object to hold the advertising data.</li>\n<li><code>advData.setFlags(0x06);</code>: Sets the advertising flags. <code>0x06</code> is a common value indicating the device is generally discoverable and doesn&#39;t support Bluetooth Classic.</li>\n<li><code>advData.setCompleteDeviceName(&quot;MyCustomESP32&quot;);</code>: Sets the device name that will appear in the advertising packet. This overrides the name set in <code>BLEDevice::init()</code>.</li>\n<li><code>advData.addServiceUUID(&quot;180A&quot;);</code>: Adds a 16-bit service UUID (0x180A) to the advertising data. This tells scanners that this device offers the Device Information Service.</li>\n<li><code>pAdvertising-&gt;setAdvertisementData(advData);</code>: Attaches the configured <code>advData</code> object to the <code>BLEAdvertising</code> object, preparing it for broadcast.</li>\n</ul>\n<p>Upload and run. Still no visible advertising, but the <em>data</em> is ready to be sent.</p>\n<h3>Step 4: Setting Advertising Parameters and Starting</h3>\n<p>Now that the data is ready, we need to tell the ESP32 <em>how</em> to advertise (how often, how strong) and then tell it to start broadcasting.</p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\nBLEAdvertising *pAdvertising;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  BLEDevice::init(&quot;MyESP32Advertiser&quot;);\n\n  pAdvertising = BLEDevice::getAdvertising();\n\n  BLEAdvertisementData advData;\n  advData.setFlags(0x06);\n  advData.setCompleteDeviceName(&quot;MyCustomESP32&quot;);\n  advData.addServiceUUID(&quot;180A&quot;);\n  // Manufacturer data will be added later\n  pAdvertising-&gt;setAdvertisementData(advData);\n  Serial.println(&quot;Advertising data configured.&quot;);\n\n\n  // *** Configure and Start Advertising Parameters ***\n\n  // Set advertising interval (in units of 0.625ms).\n  // 160 * 0.625ms = 100ms. A common interval.\n  pAdvertising-&gt;setAdvertisingInterval(160);\n  Serial.println(&quot;Advertising interval set to 100ms.&quot;);\n\n  // Set Tx Power (Transmit Power). Range is 0 to 7 for ESP32.\n  // 0: -12dBm (lowest power, shortest range)\n  // 7: +9dBm (highest power, longest range)\n  // Default is often 7. Let&#39;s explicitly set it high for visibility.\n  pAdvertising-&gt;setTxPower(7);\n  Serial.println(&quot;Tx Power set to +9dBm.&quot;);\n\n  // Start advertising!\n  pAdvertising-&gt;startAdvertising();\n  Serial.println(&quot;Advertising started!&quot;);\n\n  // Optional: Stop advertising after a set time (e.g., 30 seconds)\n  // pAdvertising-&gt;startAdvertising(30000); // Advertise for 30 seconds\n}\n\nvoid loop() {\n  // Advertising runs in the background\n  delay(1000);\n  Serial.println(&quot;ESP32 is advertising...&quot;); // Optional: Add a message to show it&#39;s running\n}\n</code></pre>\n<ul>\n<li><code>pAdvertising-&gt;setAdvertisingInterval(160);</code>: Sets how frequently the advertising packets are sent. The unit is 0.625ms. <code>160 * 0.625ms = 100ms</code>, which is a fairly rapid interval. Shorter intervals mean faster discovery but use more power.</li>\n<li><code>pAdvertising-&gt;setTxPower(7);</code>: Sets the transmit power. Higher values mean longer range but consume more power. <code>7</code> is typically the maximum for the ESP32, yielding the longest range.</li>\n<li><code>pAdvertising-&gt;startAdvertising();</code>: This is the command that tells the ESP32 to begin broadcasting the configured advertising data repeatedly at the specified interval.</li>\n<li><code>pAdvertising-&gt;startAdvertising(30000);</code>: An alternative version to start advertising for a specific duration in milliseconds. If you use this, advertising will automatically stop after that time.</li>\n</ul>\n<p>Upload this sketch. Open the Serial Monitor. You should see messages confirming setup and &quot;Advertising started!&quot;.</p>\n<p><strong>Now, grab your smartphone!</strong> Open your BLE scanning app (nRF Connect, LightBlue, etc.). Start scanning for devices. You should see a device named &quot;MyCustomESP32&quot; appear in the list! Tap on it to see its details. You should see the flags, the name, and the 0x180A service UUID in the advertising data section.</p>\n<p>Congratulations, your ESP32 is now a BLE Broadcaster!</p>\n<h3>Step 5: Adding Custom Manufacturer Data (Project Requirement)</h3>\n<p>One of the most flexible parts of BLE advertising is the Manufacturer Specific Data field. This allows manufacturers (or us, in this case) to include arbitrary data in the advertising packet. This is how devices like beacons transmit unique identifiers or sensor data.</p>\n<p>The format for Manufacturer Specific Data is typically:</p>\n<p><code>[Length] [Type (0xFF for Manufacturer Specific)] [Company ID (2 bytes)] [Manufacturer Data (variable length)]</code></p>\n<p>The <code>ESP32-BLE-Arduino</code> library simplifies this. You just provide the <code>Company ID</code> (a standard 16-bit number assigned by the Bluetooth SIG, though you can use vendor-specific ranges like 0xFFFE/0xFFFF for custom/testing) followed by your custom data bytes, all packed into a <code>std::string</code>.</p>\n<p>Let&#39;s modify our code to add some custom manufacturer data. We&#39;ll use <code>0xFFFF</code> as a placeholder Company ID and add a simple sequence of bytes like <code>0x12, 0x34, 0x56, 0x78</code>.</p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\nBLEAdvertising *pAdvertising;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  BLEDevice::init(&quot;MyESP32Advertiser&quot;);\n\n  pAdvertising = BLEDevice::getAdvertising();\n\n  BLEAdvertisementData advData;\n  advData.setFlags(0x06);\n  advData.setCompleteDeviceName(&quot;MyCustomESP32&quot;);\n  advData.addServiceUUID(&quot;180A&quot;);\n  Serial.println(&quot;Basic advertising data set.&quot;);\n\n  // *** Add Custom Manufacturer Data ***\n  // Company ID (2 bytes, e.g., 0xFFFF for testing) followed by custom data bytes.\n  // The library expects this as a std::string.\n  // We need to represent the bytes correctly in the string.\n  // &quot;\\xFF\\xFF&quot; are the two bytes for the Company ID 0xFFFF.\n  // &quot;\\x12\\x34\\x56\\x78&quot; are our custom data bytes.\n  std::string manufacturerData = &quot;&quot;;\n  manufacturerData += (char)0xFF; // First byte of Company ID (LSB)\n  manufacturerData += (char)0xFF; // Second byte of Company ID (MSB)\n  manufacturerData += (char)0x12; // Custom Data Byte 1\n  manufacturerData += (char)0x34; // Custom Data Byte 2\n  manufacturerData += (char)0x56; // Custom Data Byte 3\n  manufacturerData += (char)0x78; // Custom Data Byte 4\n\n  advData.setManufacturerData(manufacturerData);\n  Serial.println(&quot;Manufacturer data added.&quot;);\n\n  pAdvertising-&gt;setAdvertisementData(advData);\n  Serial.println(&quot;Advertising data configured.&quot;);\n\n  pAdvertising-&gt;setAdvertisingInterval(160);\n  pAdvertising-&gt;setTxPower(7);\n\n  pAdvertising-&gt;startAdvertising();\n  Serial.println(&quot;Advertising started!&quot;);\n}\n\nvoid loop() {\n  delay(1000);\n  Serial.println(&quot;ESP32 is advertising...&quot;);\n}\n</code></pre>\n<ul>\n<li><code>std::string manufacturerData = &quot;&quot;;</code>: We create an empty string to build our data payload.</li>\n<li><code>manufacturerData += (char)byte;</code>: We append each byte of our manufacturer data (Company ID + custom data) to the string. Casting to <code>(char)</code> ensures we are adding the raw byte value, not its ASCII representation.</li>\n<li><code>advData.setManufacturerData(manufacturerData);</code>: Attaches this byte sequence as the Manufacturer Specific Data in the advertising packet.</li>\n</ul>\n<p>Upload this sketch. Open the Serial Monitor. Grab your phone and scan again. Find &quot;MyCustomESP32&quot;. Now, when you inspect its details in the BLE scanner app, you should see a section for &quot;Manufacturer Specific Data&quot;. The app should show the Company ID (0xFFFF) and your custom data bytes (12 34 56 78).</p>\n<p>You have successfully programmed your ESP32 to broadcast custom data!</p>\n<h3>Step 6: Broadcasting Different Packet Types (Briefly)</h3>\n<p>BLE advertising can actually involve two types of packets sent by the Broadcaster:</p>\n<ol>\n<li><strong>Advertising Packet:</strong> Sent periodically by the Broadcaster. This is the main packet we&#39;ve been configuring with <code>setAdvertisementData()</code>. It has a limited size (typically 31 bytes payload).</li>\n<li><strong>Scan Response Packet:</strong> Sent <em>only</em> when a Scanner (acting as an Active Scanner) specifically requests more information after seeing the initial advertising packet. This allows the Broadcaster to provide additional data beyond the 31-byte limit of the advertising packet.</li>\n</ol>\n<p>You can configure the scan response data using <code>BLEScanResponseData</code> and <code>pAdvertising-&gt;setScanResponseData()</code>, similar to how we configured the advertising data.</p>\n<pre><code class=\"language-cpp\">// ... inside setup() after setting advData ...\n\n  // Optional: Configure Scan Response Data\n  BLEScanResponseData scanResponseData;\n  scanResponseData.setCompleteLocalName(&quot;MyESP32FullDetails&quot;); // A different name just for scan response\n  scanResponseData.addServiceUUID(&quot;ABCD&quot;); // Another service UUID\n\n  pAdvertising-&gt;setScanResponseData(scanResponseData);\n  Serial.println(&quot;Scan response data configured.&quot;);\n\n// ... rest of setup() ...\n</code></pre>\n<p>If you add the <code>setScanResponseData</code> line, some scanner apps (like nRF Connect) will show the scan response data when you tap on the device entry. Others might just show the advertising data. This is less critical for our main reconnaissance tool, but important to know for completeness.</p>\n<h3>Ethical Considerations (A Preview)</h3>\n<p>We&#39;ve now built a device that broadcasts its presence. Generally, broadcasting is a passive activity, designed to be discovered. However, controlling <em>what</em> you broadcast and <em>how often</em> you broadcast it can have implications.</p>\n<ul>\n<li><strong>What you broadcast:</strong> Could you impersonate another device type by using specific service UUIDs or manufacturer data? Yes. Could you broadcast misleading information? Yes.</li>\n<li><strong>How often you broadcast:</strong> While normal advertising intervals are 100ms or slower, what happens if you advertise as fast as possible? This is the concept of advertising flooding, which we will explore in Module 8. Excessive advertising can potentially disrupt other BLE communications in the area.</li>\n</ul>\n<p>For this module&#39;s project, broadcasting a custom name and data is harmless and educational. But always remember the principle of <strong>&quot;Do no harm&quot;</strong> when experimenting with wireless technologies. We will delve much deeper into ethics in the final module.</p>\n<h3>Module Project/Exercise</h3>\n<p><strong>Goal:</strong> Program your ESP32 to advertise with a custom device name and include custom manufacturer-specific data.</p>\n<p><strong>Instructions:</strong></p>\n<ol>\n<li>Start with the code from Step 5.</li>\n<li>Modify the <code>setCompleteDeviceName()</code> call to use your own unique name (e.g., &quot;YourName_ESP32_Beacon&quot;).</li>\n<li>Modify the custom data bytes in the <code>manufacturerData</code> string. Include at least 4 bytes of data that are unique to you (e.g., your initials encoded as hex, or random numbers). Remember the first two bytes are the Company ID (we&#39;ll stick with 0xFFFF for testing).</li>\n<li>Upload the modified sketch to your ESP32.</li>\n<li>Open your BLE scanning app on your smartphone.</li>\n<li>Scan for devices.</li>\n<li>Verify that you see your ESP32 device listed with the custom name you set.</li>\n<li>Tap on the device entry in the app to view its details.</li>\n<li>Locate the &quot;Manufacturer Specific Data&quot; section. Verify that it shows the Company ID (0xFFFF) and the custom data bytes you included in your sketch.</li>\n</ol>\n<p><strong>Code Structure Hint:</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\nBLEAdvertising *pAdvertising;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(&quot;Starting BLE Advertiser...&quot;);\n\n  BLEDevice::init(&quot;DefaultESP32Name&quot;); // You can keep or change this, setCompleteDeviceName overrides it\n\n  pAdvertising = BLEDevice::getAdvertising();\n\n  BLEAdvertisementData advData;\n  advData.setFlags(0x06);\n\n  // --- MODIFY THIS LINE ---\n  advData.setCompleteDeviceName(&quot;YourName_ESP32_Beacon&quot;); // &lt;-- Put your custom name here!\n\n  advData.addServiceUUID(&quot;180A&quot;); // Keep or change this UUID\n\n  // --- MODIFY THESE BYTES ---\n  // Company ID (0xFFFF) + your custom data bytes\n  std::string manufacturerData = &quot;&quot;;\n  manufacturerData += (char)0xFF; // Company ID Byte 1 (LSB)\n  manufacturerData += (char)0xFF; // Company ID Byte 2 (MSB)\n  manufacturerData += (char)0xAA; // &lt;-- Replace with your custom data byte 1\n  manufacturerData += (char)0xBB; // &lt;-- Replace with your custom data byte 2\n  manufacturerData += (char)0xCC; // &lt;-- Replace with your custom data byte 3\n  manufacturerData += (char)0xDD; // &lt;-- Replace with your custom data byte 4\n  // Add more bytes if you like!\n\n  advData.setManufacturerData(manufacturerData);\n  Serial.println(&quot;Manufacturer data added.&quot;);\n\n  pAdvertising-&gt;setAdvertisementData(advData);\n  Serial.println(&quot;Advertising data configured.&quot;);\n\n  pAdvertising-&gt;setAdvertisingInterval(160); // 100ms interval\n  pAdvertising-&gt;setTxPower(7); // Max power\n\n  pAdvertising-&gt;startAdvertising();\n  Serial.println(&quot;Advertising started!&quot;);\n  Serial.println(&quot;Scan for &#39;YourName_ESP32_Beacon&#39; with a BLE scanner app.&quot;);\n  Serial.println(&quot;Check manufacturer data for 0xFFFF followed by your custom bytes.&quot;);\n}\n\nvoid loop() {\n  delay(1000);\n  // Advertising continues in the background\n}\n</code></pre>\n<p>This exercise confirms your understanding of configuring and starting BLE advertising with specific data payloads.</p>\n<h3>Summary</h3>\n<p>In this module, we successfully transformed our ESP32 from a passive BLE scanner into an active BLE Broadcaster. We learned how to:</p>\n<ul>\n<li>Initialize the ESP32&#39;s BLE subsystem for advertising.</li>\n<li>Obtain and use the <code>BLEAdvertising</code> object.</li>\n<li>Build an advertising packet payload using <code>BLEAdvertisementData</code>, including setting flags, device name, service UUIDs, and crucially, custom manufacturer data.</li>\n<li>Set advertising parameters like interval and transmit power.</li>\n<li>Start the advertising process.</li>\n<li>Verify our ESP32&#39;s advertisements using a smartphone BLE scanning app.</li>\n</ul>\n<p>You now have the fundamental skill of making a BLE device announce its presence and transmit custom information wirelessly. This is the other half of the BLE communication coin and sets the stage for more advanced techniques in the next module.</p>\n<h3>Suggested Resources or Prerequisites</h3>\n<ul>\n<li>The official documentation or examples for the <code>ESP32-BLE-Arduino</code> library (search for &quot;ESP32 BLE Advertise example&quot;).</li>\n<li>Bluetooth SIG documentation overview on BLE Advertising Data types (AD Types).</li>\n<li>Experiment with different advertising intervals and Tx Power settings to see how it affects discovery speed and range.</li>\n<li>Explore adding <code>BLEScanResponseData</code> to your sketch and see how it appears in your scanner app.</li>\n</ul>\n<p>Onwards to the final module, where we integrate our scanning and advertising knowledge and explore the powerful (and ethically sensitive) concept of advertising flooding!</p>\n<hr>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into the final, culminating module! This is where we bring everything together, add a powerful (and ethically sensitive) new mode, and wrap up our journey by building the complete multi-mode tool.</p>\n<p>As your guide and fellow enthusiast, I&#39;m thrilled to help you synthesize all the knowledge and code we&#39;ve built. Remember, with powerful tools comes great responsibility. This module will equip you with the skills and the crucial understanding of when and <em>how</em> to use them ethically.</p>\n<hr>\n<h1>Module 8: Building the Multi-Mode Tool and Ethical Considerations</h1>\n<p><strong>Module Title:</strong> Building the Multi-Mode Tool and Ethical Considerations</p>\n<p><strong>Module Objective:</strong> Integrate all three operational modes into a single application, implement the advertising flooding mode, and understand the ethical implications of using such tools.</p>\n<p><strong>Learning Outcomes:</strong> By the end of this module, you will be able to:</p>\n<ul>\n<li>Structure an embedded application to support multiple distinct operating modes.</li>\n<li>Implement a simple menu system for user interaction via the Serial Monitor.</li>\n<li>Successfully integrate the Personal Tracker and Environmental Baseline detection logic into a unified codebase.</li>\n<li>Program the ESP32 to perform rapid and potentially randomized Bluetooth Low Energy (BLE) advertising (Advertising Flooding).</li>\n<li>Explain the potential impacts (intended and unintended) of BLE advertising flooding.</li>\n<li>Articulate the critical ethical and legal considerations associated with using RF reconnaissance and disruption tools.</li>\n<li>Refine and optimize your ESP32 code for better performance and resource usage.</li>\n<li>Complete the final capstone project: a functional multi-mode ESP32 Bluetooth Recon Tool.</li>\n</ul>\n<hr>\n<h2>8.1 Recap and Preparation: Gathering Your Code Assets</h2>\n<p>Welcome to the final stage! Over the past seven modules, you&#39;ve built foundational skills:</p>\n<ul>\n<li>Setting up the ESP32 environment (Module 1).</li>\n<li>Embedded C++ programming (Module 2).</li>\n<li>Deeply understanding Bluetooth, especially BLE advertising (Module 3).</li>\n<li>Programming the ESP32 to scan for BLE devices (Module 4).</li>\n<li>Processing scan results, identifying unique devices, and managing a device list (Module 5).</li>\n<li>Implementing the core logic for Personal Tracker and Environmental Baseline detection modes (Module 6).</li>\n<li>Programming the ESP32 to act as a BLE advertiser (Module 7).</li>\n</ul>\n<p>Your task now is to take the key code components from Modules 4, 5, 6, and 7 and integrate them into a single, cohesive application.</p>\n<p><strong>Action:</strong></p>\n<ol>\n<li>Open the Arduino sketches you developed for Modules 4, 5, 6, and 7.</li>\n<li>Identify the core functions and data structures from each:<ul>\n<li>BLE scanning setup (<code>BLEDevice::init()</code>, <code>pBLEScan-&gt;setAdvertisedDeviceCallbacks()</code>, <code>pBLEScan-&gt;start()</code>).</li>\n<li>The <code>onResult</code> callback function (handling incoming scan data).</li>\n<li>Your device data structure (<code>struct</code> or <code>class</code> for storing MAC, name, RSSI, last seen, etc.).</li>\n<li>Your device list management functions (<code>findDevice</code>, <code>addDevice</code>, <code>updateDevice</code>, potentially <code>printDeviceList</code>).</li>\n<li>The core logic within your Module 6 sketches for the Tracker mode (checking persistence, RSSI changes) and Baseline mode (storing baseline, comparing).</li>\n<li>The BLE advertising setup and start/stop functions from Module 7.</li>\n</ul>\n</li>\n<li>Create a <em>new</em> empty sketch for Module 8. This will be your final project file.</li>\n</ol>\n<h2>8.2 Designing the Multi-Mode Structure: The Serial Menu</h2>\n<p>How will the user tell the ESP32 which mode to run? The outline suggests a menu system via the Serial Monitor. This is a common and simple way to interact with embedded projects without adding extra hardware like buttons or screens.</p>\n<p>We&#39;ll structure the code around a variable that holds the current operating mode and use the <code>loop()</code> function to check this variable and execute the code corresponding to that mode. We&#39;ll also add logic to read input from the Serial Monitor to change the mode.</p>\n<p><strong>Core Concepts:</strong></p>\n<ul>\n<li><strong>Mode Variable:</strong> A global variable (e.g., an <code>enum</code> or simple <code>int</code>) to store the current mode.</li>\n<li><strong>Menu Function:</strong> A function to print the available options to the Serial Monitor.</li>\n<li><strong>Input Handling:</strong> Code in <code>loop()</code> (or a dedicated function) to read user input from Serial and update the mode variable.</li>\n<li><strong>Mode Execution:</strong> A <code>switch</code> statement or <code>if/else if</code> chain in <code>loop()</code> to call the appropriate function for the current mode.</li>\n</ul>\n<p><strong>Example Structure (Pseudocode):</strong></p>\n<pre><code class=\"language-cpp\">// Define modes\nenum AppMode {\n    MODE_MENU,\n    MODE_TRACKER,\n    MODE_BASELINE_SCAN, // Baseline requires two steps\n    MODE_BASELINE_COMPARE,\n    MODE_FLOODING,\n    MODE_STOPPED // A neutral state\n};\n\nAppMode currentMode = MODE_MENU;\nbool baselineSet = false; // Needed for baseline mode state\n\n// --- Function Prototypes (Declare functions before using them) ---\nvoid printMenu();\nvoid handleSerialInput();\nvoid runTrackerMode();\nvoid runBaselineModeScan();\nvoid runBaselineModeCompare();\nvoid runFloodingMode();\n// ... other helper functions\n\n// --- Setup ---\nvoid setup() {\n    Serial.begin(115200);\n    // Initialize BLE (common for scanning/advertising)\n    BLEDevice::init(&quot;&quot;); // Name not needed for scanning/advertising init\n    printMenu(); // Show menu on startup\n}\n\n// --- Main Loop ---\nvoid loop() {\n    handleSerialInput(); // Check for user input to change mode\n\n    switch (currentMode) {\n        case MODE_MENU:\n            // Menu is passive, just waits for input handled by handleSerialInput\n            delay(10); // Small delay to avoid watchdog timer issues\n            break;\n        case MODE_TRACKER:\n            runTrackerMode();\n            break;\n        case MODE_BASELINE_SCAN:\n            runBaselineModeScan(); // This function should transition to MENU or COMPARE after scan\n            break;\n        case MODE_BASELINE_COMPARE:\n             runBaselineModeCompare(); // This function should transition to MENU after scan\n             break;\n        case MODE_FLOODING:\n            runFloodingMode(); // This function runs continuously until mode changes\n            break;\n        case MODE_STOPPED:\n            // Do nothing, just wait for input\n            delay(100);\n            break;\n    }\n\n    // Note: Some modes (like scanning) might block or take time.\n    // We&#39;ll need to adjust the mode functions to be non-blocking if possible,\n    // or accept that a mode runs until complete or interrupted by input.\n    // For simplicity in this capstone, modes like scanning or flooding might\n    // run for a set duration or until a new mode is selected via Serial.\n}\n\n// --- Menu and Input Handling ---\nvoid printMenu() {\n    Serial.println(F(&quot;\\n--- ESP32 Bluetooth Reconnaissance Tool ---&quot;));\n    Serial.println(F(&quot;Select a mode:&quot;));\n    Serial.println(F(&quot;1. Personal Tracker Detection&quot;));\n    Serial.println(F(&quot;2. Environmental Baseline Analysis (Scan)&quot;));\n    Serial.println(F(&quot;3. Environmental Baseline Analysis (Compare)&quot;));\n    Serial.println(F(&quot;4. Bluetooth Advertising Flooding (USE ETHICALLY!)&quot;));\n    Serial.println(F(&quot;5. Stop Current Mode&quot;));\n    Serial.println(F(&quot;M. Print Menu&quot;));\n    Serial.print(F(&quot;Enter selection: &quot;));\n}\n\nvoid handleSerialInput() {\n    if (Serial.available()) {\n        char input = Serial.read();\n        // Consume the rest of the line if needed (e.g., newline characters)\n        while(Serial.available()) Serial.read();\n\n        Serial.print(F(&quot;Input received: &quot;));\n        Serial.println(input);\n\n        // Stop any ongoing mode before changing\n        // (Need functions to stop scanning/advertising)\n        // Example: BLEDevice::getScan()-&gt;stop(); BLEDevice::getAdvertising()-&gt;stop();\n        // We&#39;ll add these stop calls within the mode change logic.\n\n        switch (input) {\n            case &#39;1&#39;:\n                Serial.println(F(&quot;Switching to Personal Tracker Mode...&quot;));\n                // Stop any previous activity\n                BLEDevice::getScan()-&gt;stop(); // Stop scan if running\n                BLEDevice::getAdvertising()-&gt;stop(); // Stop advertising if running\n                currentMode = MODE_TRACKER;\n                break;\n            case &#39;2&#39;:\n                Serial.println(F(&quot;Starting Baseline Scan...&quot;));\n                 // Stop any previous activity\n                BLEDevice::getScan()-&gt;stop(); // Stop scan if running\n                BLEDevice::getAdvertising()-&gt;stop(); // Stop advertising if running\n                baselineSet = false; // Reset baseline state\n                currentMode = MODE_BASELINE_SCAN;\n                break;\n             case &#39;3&#39;:\n                if (!baselineSet) {\n                    Serial.println(F(&quot;Error: Baseline not set yet. Run Baseline Scan (Option 2) first.&quot;));\n                    currentMode = MODE_MENU; // Stay in menu or go back to menu\n                    printMenu();\n                } else {\n                    Serial.println(F(&quot;Starting Baseline Comparison...&quot;));\n                     // Stop any previous activity\n                    BLEDevice::getScan()-&gt;stop(); // Stop scan if running\n                    BLEDevice::getAdvertising()-&gt;stop(); // Stop advertising if running\n                    currentMode = MODE_BASELINE_COMPARE;\n                }\n                break;\n            case &#39;4&#39;:\n                Serial.println(F(&quot;WARNING: Switching to Advertising Flooding Mode. Use ETHICALLY and with PERMISSION ONLY!&quot;));\n                 // Stop any previous activity\n                BLEDevice::getScan()-&gt;stop(); // Stop scan if running\n                BLEDevice::getAdvertising()-&gt;stop(); // Stop advertising if running\n                // Add a confirmation step here for safety!\n                Serial.println(F(&quot;Type &#39;YES&#39; to confirm flooding or anything else to cancel:&quot;));\n                // We&#39;ll need to read another line for confirmation... this complicates handleSerialInput.\n                // Alternative: A simpler confirmation like &#39;4Y&#39; to start flooding. Let&#39;s go with that for simplicity.\n                // Refined logic: if input is &#39;4&#39;, print warning, expect &#39;Y&#39; next.\n                // For now, let&#39;s assume &#39;4&#39; directly triggers it, but we&#39;ll add the warning print.\n                currentMode = MODE_FLOODING;\n                break;\n            case &#39;5&#39;:\n                Serial.println(F(&quot;Stopping current mode.&quot;));\n                BLEDevice::getScan()-&gt;stop(); // Stop scan if running\n                BLEDevice::getAdvertising()-&gt;stop(); // Stop advertising if running\n                currentMode = MODE_STOPPED;\n                printMenu(); // Show menu after stopping\n                break;\n            case &#39;M&#39;:\n            case &#39;m&#39;:\n                printMenu();\n                currentMode = MODE_MENU; // Ensure we are in menu state\n                break;\n            default:\n                Serial.println(F(&quot;Invalid selection.&quot;));\n                printMenu();\n                currentMode = MODE_MENU; // Ensure we are in menu state\n                break;\n        }\n    }\n}\n\n// --- Mode Functions (Implement these based on previous modules) ---\n\nvoid runTrackerMode() {\n    // Your Module 6 Tracker logic goes here.\n    // It should likely involve:\n    // 1. Starting a BLE scan.\n    // 2. The onResult callback populating/updating your device list.\n    // 3. Periodically (or within onResult, carefully) checking the device list\n    //    for persistence/RSSI changes and printing alerts.\n    // 4. Decide how long the scan runs before restarting or if it runs continuously.\n    //    Continuous scanning is typical for tracking.\n    //    Need to ensure onResult is registered *before* starting the scan.\n    //    The scan itself often runs in the background once started.\n    //    The loop() function can then do other checks or just yield/delay.\n\n    static bool scanStarted = false; // Use static to track state within the function\n    if (!scanStarted) {\n        Serial.println(F(&quot;Tracker mode: Scanning...&quot;));\n        BLEScan* pBLEScan = BLEDevice::getScan();\n        pBLEScan-&gt;setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Your callback class from M4/M5\n        pBLEScan-&gt;setActiveScan(true); // Active scan gets scan response data\n        pBLEScan-&gt;setInterval(100); // Scan interval in ms\n        pBLEScan-&gt;setWindow(99);  // Scan window in ms (should be &lt;= interval)\n        pBLEScan-&gt;start(0, false); // 0 = scan until stopped, false = don&#39;t return results here, use callback\n        scanStarted = true;\n        // Need logic to process the deviceList periodically in the loop\n        // Or have the onResult callback trigger processing (be careful of processing time in callback!)\n    }\n\n    // In the main loop(), when currentMode is MODE_TRACKER, you&#39;d call this function.\n    // This function itself might just configure and start the scan once,\n    // and the actual tracking logic runs via the onResult callback and/or\n    // a periodic check within loop() or a separate task.\n\n    // Simple approach for now: just start scan and let onResult print.\n    // More advanced: have a timer/counter in loop() that, when currentMode is TRACKER,\n    // triggers a check of the global device list for tracking conditions.\n    // For capstone, let&#39;s keep it simpler: onResult adds/updates list, loop() periodically checks list.\n\n    // Example periodic check in loop() when currentMode == MODE_TRACKER:\n    // Check deviceList for tracking conditions (e.g., seen in last X seconds, RSSI changing rapidly)\n    // Print alerts.\n    // Need a mechanism to manage the device list over time (remove old devices).\n\n    // Placeholder:\n    Serial.println(F(&quot;Tracker mode running. Scanning in background...&quot;));\n    // Add your tracking logic here - likely needs access to the global device list\n    // and possibly timekeeping.\n    // Example: check deviceList for devices seen recently, analyze RSSI trend.\n    // This part is highly dependent on your Module 6 implementation.\n    // Make sure your device list is accessible globally or passed appropriately.\n    delay(1000); // Small delay in loop while scanning runs async\n\n}\n\nvoid runBaselineModeScan() {\n    // Your Module 6 Baseline Scan logic goes here.\n    // 1. Clear the baseline device list.\n    // 2. Start a BLE scan for a fixed duration (e.g., 60 seconds).\n    // 3. The onResult callback populates/updates a TEMPORARY device list for this scan.\n    // 4. After the scan duration, copy the temporary list to the BASELINE list.\n    // 5. Set baselineSet = true.\n    // 6. Print scan results and transition back to the menu or STOPPED mode.\n\n    Serial.println(F(&quot;Baseline Scan mode: Scanning for baseline...&quot;));\n    // Need to clear the baseline device list here.\n    // Need to set up and start a scan for a *fixed* duration (e.g., pBLEScan-&gt;start(60, false)).\n    // onResult callback needs to populate a *different* list than the tracker mode might use,\n    // or the callback needs to know which mode is active.\n    // Let&#39;s use separate lists: `trackerDeviceList` and `baselineDeviceList`.\n    // The onResult callback will need access to both and update the appropriate one based on `currentMode`.\n\n    // Placeholder:\n    Serial.println(F(&quot;Scanning for 60 seconds to establish baseline...&quot;));\n    // Start scan for 60 seconds\n    BLEScan* pBLEScan = BLEDevice::getScan();\n    pBLEScan-&gt;setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Same callback, needs mode awareness\n    pBLEScan-&gt;setActiveScan(true);\n    pBLEScan-&gt;setInterval(100);\n    pBLEScan-&gt;setWindow(99);\n    BLEScanResults scanResults = pBLEScan-&gt;start(60, true); // Blocking scan for simplicity here\n\n    // After blocking scan finishes:\n    Serial.println(F(&quot;Baseline scan finished. Found &quot;) + String(scanResults.getCount()) + F(&quot; devices during scan.&quot;));\n\n    // Process scanResults to build the baselineDeviceList\n    // This needs to be done *after* the scan completes if using blocking start.\n    // If using non-blocking start(0, false), you&#39;d need a timer to stop the scan\n    // and then process the results *then*. Blocking is simpler for this example.\n\n    // Clear previous baseline\n    baselineDeviceList.clear();\n    // Iterate scanResults and populate baselineDeviceList (using your add/find/update logic)\n    for (int i = 0; i &lt; scanResults.getCount(); i++) {\n        BLEAdvertisedDevice device = scanResults.getDevice(i);\n        // Add device to baselineDeviceList if not already present, or update if needed (though baseline is snapshot)\n        // Simple baseline: just store unique devices by address seen during the scan\n        addOrUpdateDeviceInList(baselineDeviceList, device); // Needs implementation\n    }\n\n    baselineSet = true;\n    Serial.println(F(&quot;Baseline set with &quot;) + String(baselineDeviceList.size()) + F(&quot; unique devices.&quot;));\n    currentMode = MODE_MENU; // Return to menu\n    printMenu();\n}\n\nvoid runBaselineModeCompare() {\n    // Your Module 6 Baseline Compare logic goes here.\n    // 1. Clear a TEMPORARY list for the comparison scan.\n    // 2. Start a BLE scan for a fixed duration (e.g., 30 seconds).\n    // 3. The onResult callback populates/updates the TEMPORARY comparison list.\n    // 4. After the scan duration, compare the TEMPORARY list against the BASELINE list.\n    // 5. Identify devices in the TEMPORARY list that are *not* in the BASELINE list.\n    // 6. Print alerts for these &quot;new&quot; devices.\n    // 7. Transition back to the menu or STOPPED mode.\n\n    if (!baselineSet) {\n        Serial.println(F(&quot;Error: Baseline not set. Cannot compare.&quot;));\n        currentMode = MODE_MENU;\n        printMenu();\n        return;\n    }\n\n    Serial.println(F(&quot;Baseline Compare mode: Scanning for comparison...&quot;));\n    // Need a temporary list for the comparison scan\n    std::vector&lt;DeviceInfo&gt; comparisonDeviceList;\n\n    // Start scan for a duration (e.g., 30 seconds)\n    BLEScan* pBLEScan = BLEDevice::getScan();\n    // The onResult callback needs to populate comparisonDeviceList when in this mode.\n    // This means onResult needs access to both lists and the current mode.\n    pBLEScan-&gt;setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Same callback\n    pBLEScan-&gt;setActiveScan(true);\n    pBLEScan-&gt;setInterval(100);\n    pBLEScan-&gt;setWindow(99);\n    BLEScanResults scanResults = pBLEScan-&gt;start(30, true); // Blocking scan for simplicity\n\n     // After blocking scan finishes:\n    Serial.println(F(&quot;Comparison scan finished. Found &quot;) + String(scanResults.getCount()) + F(&quot; devices during scan.&quot;));\n\n    // Process scanResults to build the comparisonDeviceList\n     for (int i = 0; i &lt; scanResults.getCount(); i++) {\n        BLEAdvertisedDevice device = scanResults.getDevice(i);\n        addOrUpdateDeviceInList(comparisonDeviceList, device); // Populate comparison list\n    }\n\n\n    // Compare comparisonDeviceList against baselineDeviceList\n    Serial.println(F(&quot;Comparing scan results against baseline...&quot;));\n    bool foundNew = false;\n    for (const auto&amp; compDevice : comparisonDeviceList) {\n        bool foundInBaseline = false;\n        for (const auto&amp; baseDevice : baselineDeviceList) {\n            if (compDevice.address.equals(baseDevice.address)) { // Assuming address is BLEAddress object\n                foundInBaseline = true;\n                break;\n            }\n        }\n        if (!foundInBaseline) {\n            Serial.println(F(&quot;!!! NEW DEVICE DETECTED: &quot;) + String(compDevice.address.toString().c_str()) +\n                           F(&quot; (Name: &quot;) + (compDevice.name.length() &gt; 0 ? String(compDevice.name.c_str()) : F(&quot;N/A&quot;)) +\n                           F(&quot;, RSSI: &quot;) + String(compDevice.rssi) + F(&quot; dBm)&quot;));\n            foundNew = true;\n        }\n    }\n\n    if (!foundNew) {\n        Serial.println(F(&quot;No new devices detected compared to baseline.&quot;));\n    }\n\n    currentMode = MODE_MENU; // Return to menu\n    printMenu();\n}\n\n// --- Device List Management (Needs to be accessible globally) ---\n// Your DeviceInfo struct/class and vector declaration from Module 5\nstruct DeviceInfo {\n    BLEAddress address;\n    String name;\n    int rssi;\n    unsigned long lastSeen;\n    // Add other fields as needed (e.g., history of RSSI, flags)\n};\n\nstd::vector&lt;DeviceInfo&gt; trackerDeviceList;\nstd::vector&lt;DeviceInfo&gt; baselineDeviceList; // Separate list for baseline\n// MyAdvertisedDeviceCallbacks class needs access to these lists and currentMode\n\n// Helper function to add or update a device in a given list\nvoid addOrUpdateDeviceInList(std::vector&lt;DeviceInfo&gt;&amp; deviceList, BLEAdvertisedDevice&amp; device) {\n    bool found = false;\n    for (auto&amp; dev : deviceList) {\n        if (dev.address.equals(device.getAddress())) {\n            // Update existing device info\n            dev.rssi = device.getRSSI();\n            dev.lastSeen = millis();\n            if (device.getName().length() &gt; 0) {\n                 // Only update name if the new advertisement has one\n                 dev.name = device.getName().c_str();\n            }\n            // Add RSSI to a history if tracking that\n            // dev.rssiHistory.push_back(device.getRSSI()); // Example if you added rssiHistory\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        // Add new device\n        DeviceInfo newDevice;\n        newDevice.address = device.getAddress();\n        newDevice.name = device.getName().length() &gt; 0 ? String(device.getName().c_str()) : &quot;&quot;;\n        newDevice.rssi = device.getRSSI();\n        newDevice.lastSeen = millis();\n        // Initialize other fields (e.g., newDevice.rssiHistory = {device.getRSSI()};)\n        deviceList.push_back(newDevice);\n        // Optional: Print when a new device is *added* to the list (useful for debugging)\n        // Serial.println(F(&quot;Added new device to list: &quot;) + String(newDevice.address.toString().c_str()));\n    }\n}\n\n// Your MyAdvertisedDeviceCallbacks class from Module 4/5, modified to know the mode\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\n        // This callback runs whenever an advertisement is received.\n        // It must be FAST! Avoid complex logic here. Just add/update the list.\n        // Processing (tracking logic, baseline comparison) should happen outside this callback.\n\n        // Need access to currentMode and device lists.\n        // Make these global or pass pointers/references (global is simpler for capstone).\n\n        // Example:\n        // if (currentMode == MODE_TRACKER) {\n        //     addOrUpdateDeviceInList(trackerDeviceList, advertisedDevice);\n        //     // Optional: Print basic info for each device seen in tracker mode\n        //      Serial.print(F(&quot;TRACKER SCAN: Device Found: &quot;));\n        //      Serial.print(advertisedDevice.getAddress().toString().c_str());\n        //      Serial.print(F(&quot;, RSSI: &quot;));\n        //      Serial.print(advertisedDevice.getRSSI());\n        //      if (advertisedDevice.haveName()) {\n        //        Serial.print(F(&quot;, Name: &quot;));\n        //        Serial.println(advertisedDevice.getName().c_str());\n        //      } else {\n        //        Serial.println();\n        //      }\n        // } else if (currentMode == MODE_BASELINE_SCAN) {\n        //     // Add to a temporary list or the baselineDeviceList directly if blocking scan\n        //     // If using blocking scan (pBLEScan-&gt;start(duration, true)), onResult is often NOT called.\n        //     // The results are returned as BLEScanResults object *after* the scan finishes.\n        //     // So, for blocking scans, onResult might be unused.\n</code></pre>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Alright, team! Let's dive headfirst into the fascinating world of RF and embedded systems, specifically through the lens of our trusty ESP32. This isn't just about blinking lights; it's about understanding the invisible conversations happening all around us and learning how to listen in (ethically, of course!).\r\n\r\nI'm thrilled to guide you through this. Module 1 is all about getting our hands dirty, setting up our workspace, and getting that vital first connection to our hardware. Think of it as laying the foundation for our future reconnaissance rig.\r\n\r\n---\r\n\r\n## Module 1: Welcome to the Invisible World - Setting Up Your ESP32 Workshop\r\n\r\n*   **Module Title:** Getting Started: Unboxing, Setup, and Your First Blinky\r\n*   **Module Objective:** By the end of this module, you will have successfully set up your hardware and software development environment for the ESP32, uploaded your first program (\"Blink\") to verify connectivity and toolchain setup, and learned how to use the Serial Monitor for basic communication and debugging. This builds the essential confidence needed to proceed!\r\n\r\n### 1.1 Introduction: Stepping into the Invisible Spectrum\r\n\r\nWelcome! We live in a world saturated with radio waves. Your Wi-Fi, your phone signal, FM radio, GPS – they all operate on different parts of the electromagnetic (EM) spectrum. Most of this activity is invisible to our eyes, but it's constantly buzzing with data.\r\n\r\nOur journey begins by exploring a particularly ubiquitous part of this spectrum: **Bluetooth**. Why Bluetooth? Because it's *everywhere*. From headphones and speakers to smartwatches, fitness trackers, and even modern personal item trackers like AirTags and Tiles, Bluetooth is a key player in how devices connect and, importantly for us, how they *announce their presence*.\r\n\r\nWe're going to use the **ESP32 DevkitC** as our main tool. This little board is a powerhouse! It's a microcontroller (a tiny computer designed to control things), but crucially for us, it has built-in **Wi-Fi** and **Bluetooth** capabilities. This makes it perfect for exploring the wireless world around us.\r\n\r\nIn this module, we'll get this powerful board talking to your computer and running its first instructions. This might seem basic, but mastering the setup and deployment process is absolutely fundamental to everything we'll do later.\r\n\r\n### 1.2 Required Hardware: Gathering Your Tools\r\n\r\nBefore we start, let's make sure you have everything you need.\r\n\r\n1.  **ESP32 DevkitC Board:** This is our main target hardware. There are many variations of ESP32 boards, but the DevkitC is standard, widely available, and well-supported. It typically has a USB port for power and programming, two rows of pins along the sides, and maybe a button or two.\r\n2.  **Micro USB Cable (or USB-C, depending on your board version):** This is crucial for both powering the ESP32 and uploading code. *Pro Tip:* Not all USB cables are created equal! Some are \"charge only\" and don't transfer data. Make sure you have a *data* cable. If you have issues later, trying a different cable is often the first troubleshooting step.\r\n3.  **Your Computer:** Windows, macOS, or Linux – the setup process is similar across platforms, though driver installation might vary slightly.\r\n4.  **Internet Connection:** Needed for downloading software and libraries.\r\n\r\nThat's it for Module 1! Keep these handy.\r\n\r\n### 1.3 Setting Up Your Software Environment: The Arduino IDE\r\n\r\nWhile more advanced developers might use command-line tools or other IDEs, the **Arduino IDE** is fantastic for getting started with microcontrollers like the ESP32. It's relatively simple, has a huge community, and makes uploading code straightforward. It's written in C/C++, which is what we'll primarily use for performance and direct hardware control in this course.\r\n\r\n*   *(Alternative: MicroPython)*: The ESP32 can also be programmed with MicroPython, which is great for rapid prototyping and higher-level logic. However, for direct control over hardware and the specific BLE operations we'll perform later, C++ via the Arduino framework offers more flexibility and closer access to the ESP-IDF (Espressif IoT Development Framework) features. This course will focus on the Arduino/C++ path, but feel free to explore MicroPython on your own later!\r\n\r\n**Step-by-Step Arduino IDE Setup:**\r\n\r\n1.  **Download the Arduino IDE:**\r\n    *   Go to the official Arduino website: [https://www.arduino.cc/en/software](https://www.arduino.cc/en/software)\r\n    *   Download the latest version for your operating system (Windows, macOS, Linux).\r\n    *   Choose the installer (.exe for Windows, .dmg for macOS, etc.). You can often download it for free (\"Just Download\") or contribute.\r\n2.  **Install the Arduino IDE:**\r\n    *   Run the downloaded installer.\r\n    *   Follow the on-screen instructions. Accept the license agreement.\r\n    *   Pay attention during the Windows installation – it might ask about installing drivers. Let it install them; they are often helpful.\r\n    *   Choose the installation location (default is usually fine).\r\n    *   Click \"Install\".\r\n    *   Once finished, launch the Arduino IDE.\r\n\r\n### 1.4 Adding ESP32 Board Support to the Arduino IDE\r\n\r\nBy default, the Arduino IDE only knows about official Arduino boards. We need to tell it how to compile code for the ESP32. This is done by adding a \"Board Manager URL\" and then installing the ESP32 package.\r\n\r\n**Step-by-Step ESP32 Integration:**\r\n\r\n1.  **Open Preferences:**\r\n    *   In the Arduino IDE, go to `File > Preferences` (on Windows/Linux) or `Arduino IDE > Settings` (on macOS).\r\n2.  **Add the ESP32 Boards Manager URL:**\r\n    *   Look for the \"Additional Boards Manager URLs\" field at the bottom of the Preferences window.\r\n    *   If there are other URLs already there, add a comma (`,`) at the end and then paste the following URL:\r\n        ```\r\n        https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\r\n        ```\r\n    *   *Important:* Copy the *entire* line, including `https://`.\r\n    *   Click \"OK\" to close the Preferences window.\r\n3.  **Open the Boards Manager:**\r\n    *   Go to `Tools > Board > Boards Manager...`\r\n    *   This will open a new window and update its list of available boards (this might take a moment, requiring an internet connection).\r\n4.  **Search for and Install ESP32:**\r\n    *   In the search bar at the top of the Boards Manager window, type `esp32`.\r\n    *   You should see an entry like \"esp32 by Espressif Systems\".\r\n    *   Click on this entry.\r\n    *   Click the \"Install\" button. This will download and install all the necessary files for compiling code for the ESP32. This might also take a few minutes depending on your internet speed.\r\n    *   Once installed, it will say \"INSTALLED\".\r\n    *   Click \"Close\" on the Boards Manager window.\r\n\r\nNow your Arduino IDE knows how to talk to the ESP32!\r\n\r\n### 1.5 Tour of the Arduino IDE\r\n\r\nLet's quickly get familiar with the main parts of the IDE:\r\n\r\n![Conceptual Diagram of Arduino IDE layout]\r\n(Imagine a simple diagram: Top Menu Bar, Sketch Area (large text editor), Output Console (bottom area), Buttons (Verify, Upload, New, Open, Save, Serial Monitor icon))\r\n\r\n*   **Menu Bar (Top):** Standard menus (`File`, `Edit`, `Sketch`, `Tools`, `Help`). We'll use `Tools` extensively to select our board and port.\r\n*   **Buttons:**\r\n    *   **Verify (Checkmark):** Compiles your code. This checks for syntax errors without uploading to the board. Good first step after writing/editing code.\r\n    *   **Upload (Right Arrow):** Compiles your code *and* uploads it to the connected board. This is what makes your program run on the ESP32.\r\n    *   **New, Open, Save:** Standard file operations.\r\n    *   **Serial Monitor (Magnifying Glass):** Opens a separate window to view output from your ESP32 and send input to it. Essential for debugging and interaction.\r\n*   **Sketch Area (Large White Space):** This is where you write your code, called a \"sketch\" in Arduino terms.\r\n*   **Output Console (Bottom Area):** This area shows compilation progress, error messages, upload status, and other feedback from the IDE. Crucial for troubleshooting!\r\n\r\n### 1.6 Connecting Your ESP32 and Finding the Port\r\n\r\nNow, let's connect your ESP32 to your computer using the USB cable.\r\n\r\n1.  Plug the Micro USB end into the ESP32 board.\r\n2.  Plug the standard USB end into your computer.\r\n3.  The ESP32 should power on, and you might see a power LED light up.\r\n\r\nYour computer needs to recognize the ESP32 as a serial device. This usually happens automatically with modern operating systems, but sometimes drivers are needed (especially on older Windows versions or if your board uses a specific USB-to-Serial chip like the CP2102 or CH340). If your computer doesn't seem to recognize the board, search online for \"CP2102 driver\" or \"CH340 driver\" and install the one relevant to your board (you might need to look at the small black chip near the USB port on your ESP32 to identify it).\r\n\r\nOnce connected and recognized, you need to tell the Arduino IDE which communication port your ESP32 is connected to.\r\n\r\n1.  In the Arduino IDE, go to `Tools > Port`.\r\n2.  You should see a list of available serial ports (e.g., `COM3`, `COM4` on Windows, `/dev/ttyUSB0`, `/dev/cu.SLAB_USBtoUART` on Linux/macOS).\r\n3.  Select the port that corresponds to your ESP32. If you're unsure, unplug the ESP32, check the list, then plug it back in and see which new port appears. *This is the one you want.*\r\n\r\n**Finally, select the correct board type:**\r\n\r\n1.  Go to `Tools > Board > ESP32 Arduino`.\r\n2.  Select `ESP32 Dev Module`. This is a generic option that works for most standard DevkitC boards.\r\n\r\nOkay, your environment is set up, your board is connected, and the IDE knows how to talk to it! Time for the classic test.\r\n\r\n### 1.7 Your First Program: The \"Blink\" Sketch\r\n\r\nThe \"Blink\" sketch is the \"Hello World\" of microcontrollers. It simply turns an LED on and off repeatedly. This verifies that you can compile code, upload it to the board, and make the board *do* something physical.\r\n\r\nMost ESP32 DevkitC boards have a built-in LED connected to a specific GPIO (General Purpose Input/Output) pin. Often this is GPIO2, but it can vary slightly between boards. We'll use GPIO2 for this example.\r\n\r\nHere is the standard Blink sketch:\r\n\r\n```cpp\r\n// The pin number for the built-in LED on most ESP32 DevkitC boards\r\nconst int ledPin = 2;\r\n\r\n// setup() runs once when the ESP32 starts\r\nvoid setup() {\r\n  // Initialize the digital pin ledPin as an output.\r\n  pinMode(ledPin, OUTPUT);\r\n}\r\n\r\n// loop() runs over and over repeatedly\r\nvoid loop() {\r\n  // Turn the LED on (HIGH is the voltage level)\r\n  digitalWrite(ledPin, HIGH);\r\n  // Wait for a second (1000 milliseconds)\r\n  delay(1000);\r\n  // Turn the LED off by making the voltage LOW\r\n  digitalWrite(ledPin, LOW);\r\n  // Wait for a second\r\n  delay(1000);\r\n}\r\n```\r\n\r\n**Understanding the Code:**\r\n\r\n*   `const int ledPin = 2;`: We define a constant variable `ledPin` and set it to `2`. This makes the code easier to read; instead of using `2` directly everywhere, we use `ledPin`.\r\n*   `void setup()`: This function runs *once* when the ESP32 is powered on or reset. It's used for initial configuration.\r\n*   `pinMode(ledPin, OUTPUT);`: This line configures the specified pin (`ledPin`, which is 2) to act as an output pin. This means we can send signals *from* the ESP32 *to* whatever is connected to that pin (in this case, the LED).\r\n*   `void loop()`: This function runs *repeatedly* forever after `setup()` finishes. This is where the main logic of your program goes.\r\n*   `digitalWrite(ledPin, HIGH);`: This sets the voltage on the `ledPin` to a high level (typically 3.3V or 5V, depending on the board logic level). For an LED connected correctly, this turns it *on*.\r\n*   `delay(1000);`: This pauses the program execution for 1000 milliseconds (1 second).\r\n*   `digitalWrite(ledPin, LOW);`: This sets the voltage on the `ledPin` to a low level (0V). This turns the LED *off*.\r\n*   `delay(1000);`: Another 1-second pause.\r\n\r\nSo, the `loop` function turns the LED on, waits, turns it off, waits, and then repeats!\r\n\r\n**Uploading the Sketch:**\r\n\r\n1.  Copy the code above and paste it into the main sketch area of the Arduino IDE, replacing any default code that's there.\r\n2.  Click the **Verify** button (checkmark). Watch the Output Console at the bottom. It should say \"Compiling sketch...\" and eventually \"Done compiling.\" If there are errors, the console will show red text explaining them. Fix any errors before proceeding.\r\n3.  Click the **Upload** button (right arrow).\r\n    *   The console will show \"Compiling sketch...\" again, then \"Uploading...\".\r\n    *   You might see dots or progress percentages.\r\n    *   On some ESP32 boards, you might need to press and hold the **BOOT** button while the IDE is trying to connect and upload, and then release it once the upload starts. Watch the console for messages like \"Connecting...\" – that's the time to press BOOT if needed. *Most modern DevkitC boards don't require this anymore; they have auto-reset circuitry.*\r\n    *   If the upload is successful, you'll see messages like \"Hard resetting via RTS pin...\" and \"Done uploading.\"\r\n4.  Look at your ESP32 board! The built-in LED (usually near the Wi-Fi antenna or USB port) should now be blinking on and off with a 1-second interval.\r\n\r\nCongratulations! You've successfully set up your environment and uploaded your first code. This is a huge first step!\r\n\r\n### 1.8 Using the Serial Monitor\r\n\r\nThe Serial Monitor is your window into what the ESP32 is thinking. It allows the ESP32 to send text messages back to your computer, which is invaluable for debugging and seeing the output of your programs.\r\n\r\nLet's write a simple sketch that prints a message.\r\n\r\n```cpp\r\n// setup() runs once\r\nvoid setup() {\r\n  // Initialize serial communication at 115200 bits per second:\r\n  Serial.begin(115200);\r\n  // Wait a moment for the Serial Monitor to connect (optional but good practice)\r\n  delay(1000);\r\n}\r\n\r\n// loop() runs repeatedly\r\nvoid loop() {\r\n  // Print a message to the Serial Monitor\r\n  Serial.println(\"Hello, ESP32 Recon!\");\r\n\r\n  // Wait for a few seconds before printing again\r\n  delay(3000); // Wait 3 seconds\r\n}\r\n```\r\n\r\n**Understanding the Code:**\r\n\r\n*   `Serial.begin(115200);`: This line is essential for using the Serial Monitor. It initializes serial communication and sets the \"baud rate\" (the speed of communication) to 115200 bits per second. *The baud rate in your code MUST match the baud rate selected in the Serial Monitor window.* 115200 is a common and good speed for the ESP32.\r\n*   `Serial.println(\"Hello, ESP32 Recon!\");`: This is the command to print text to the Serial Monitor. `println` adds a newline character at the end, so each message appears on a new line. You can also use `Serial.print()` to print without a newline.\r\n\r\n**Using the Serial Monitor:**\r\n\r\n1.  Upload the sketch above to your ESP32 (remember the Verify and Upload steps).\r\n2.  Once uploaded successfully, click the **Serial Monitor** icon (magnifying glass) in the top-right corner of the Arduino IDE. A new window will pop up.\r\n3.  In the bottom-right corner of the Serial Monitor window, make sure the baud rate is set to `115200 baud`.\r\n4.  You should start seeing \"Hello, ESP32 Recon!\" printed in the Serial Monitor window every 3 seconds.\r\n\r\nIf you don't see anything, double-check:\r\n*   Is the correct Port selected in `Tools > Port`?\r\n*   Is the baud rate in the Serial Monitor window set to 115200?\r\n*   Did the sketch upload successfully?\r\n*   Is the ESP32 powered?\r\n\r\nThe Serial Monitor is your primary tool for debugging throughout this course. Get comfortable using it!\r\n\r\n### 1.9 Module Project/Exercise\r\n\r\nTime to solidify your understanding and test your setup!\r\n\r\n1.  **Successfully upload and run the \"Blink\" sketch on your ESP32.**\r\n    *   Find the LED blinking on your board.\r\n2.  **Modify the blink rate:** Change the `delay()` values in the `loop()` function of the Blink sketch. For example, make it blink faster (e.g., `delay(200);`). Upload the modified sketch and verify the LED blinks at the new rate.\r\n3.  **Write a simple sketch that prints \"Hello, ESP32 Recon!\" to the Serial Monitor.**\r\n    *   Start a new sketch (`File > New`).\r\n    *   Implement the code from section 1.8 (the `Serial.begin()` in `setup()` and `Serial.println()` in `loop()`).\r\n    *   Upload the sketch.\r\n    *   Open the Serial Monitor and verify that the message is being printed correctly at the specified interval (e.g., every 3 seconds).\r\n\r\nThese exercises confirm that your hardware is working, your software is configured, you can compile and upload code, and you can receive output from the ESP32. These are the absolute bedrock skills for the rest of the course.\r\n\r\n### 1.10 Suggested Resources\r\n\r\n*   **Official ESP32 Arduino Core Documentation:** [https://docs.espressif.com/projects/arduino-esp32/en/latest/](https://docs.espressif.com/projects/arduino-esp32/en/latest/) - The definitive source for ESP32-specific functions in the Arduino framework.\r\n*   **Arduino Core Reference:** [https://www.arduino.cc/reference/en/](https://www.arduino.cc/reference/en/) - Explains standard Arduino functions like `pinMode()`, `digitalWrite()`, `delay()`, `Serial.begin()`, `Serial.println()`.\r\n*   **ESP32 Datasheet (for the brave!):** [https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf) - Deep technical details about the chip itself. Not necessary for this module, but good to know it exists.\r\n*   **USB-to-Serial Driver Links:** Search for \"CP2102 driver\" or \"CH340 driver\" if your computer doesn't recognize the ESP32 initially. Silicon Labs (for CP210x) and WCH (for CH340/CH341) are the common manufacturers.\r\n\r\n### 1.11 Conclusion\r\n\r\nYou've done it! You've taken the crucial first step. You've unboxed your hardware, navigated the sometimes-tricky waters of software setup, and successfully communicated with your ESP32. You've made an LED blink and gotten the board to talk to you via the Serial Monitor.\r\n\r\nThis might feel simple, but mastering this initial setup saves *so much* frustration down the line. You now have a working development environment and a basic understanding of how to load code onto your ESP32.\r\n\r\nIn Module 2, we'll build on this by diving deeper into the fundamental programming concepts you'll need specifically for embedded systems like the ESP32. We'll look at variables, control flow, and interacting with other pins. Get ready to expand your coding toolkit!\r\n\r\nKeep your ESP32 and USB cable handy. You're officially on your way to building your own Bluetooth Recon Tool. Fantastic work!"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Okay, let's dive deep into Module 2! This is where we get our hands dirty with the actual code that makes the ESP32 do our bidding. Think of Module 1 as setting up the laboratory; Module 2 is learning how to use the basic tools and understand the fundamental laws of this embedded world.\r\n\r\nAs your guide, I'm excited to break down these core programming concepts specifically for microcontrollers like the ESP32. We'll focus on the Arduino framework using C++, as it's widely accessible and has excellent library support, which we'll definitely need for Bluetooth!\r\n\r\n---\r\n\r\n## Module 2: Embedded Programming Essentials for the ESP32\r\n\r\n**Module Title:** Coding for the Microcontroller: Variables, Control Flow, and Libraries\r\n\r\n**Module Objective:** Understand fundamental embedded programming concepts relevant to the ESP32 using the chosen development environment (primarily Arduino/C++ for this course). By the end of this module, you'll be comfortable writing basic programs that interact with the ESP32's hardware and lay the foundation for more complex projects.\r\n\r\n---\r\n\r\n### Introduction: Why Embedded Programming is Different (and Awesome!)\r\n\r\nWelcome back! In Module 1, we got our ESP32 blinking – a classic first step. But how did that happen? We uploaded code! Now, we're going to peel back the layers and understand the building blocks of that code and how it interacts with the microcontroller.\r\n\r\nEmbedded programming isn't quite like writing a Python script on your laptop. You're working directly with limited resources (memory, processing power) and need to control specific hardware pins at a very low level. This is where the real fun begins – making silicon bend to your will!\r\n\r\nWe'll be primarily using the **Arduino framework**, which provides a relatively friendly C++ environment for microcontrollers. It abstracts away some of the most complex low-level details while still giving you powerful access to the hardware.\r\n\r\n### Essential Subtopics:\r\n\r\nLet's break down the core concepts we need to master.\r\n\r\n#### 2.1 Review of Basic C++ Syntax\r\n\r\nYou might have seen C++ before, or maybe only languages like Python or JavaScript. Don't worry, we'll cover the essentials needed for Arduino sketches. C++ is a powerful language, and the Arduino environment simplifies it significantly.\r\n\r\n*   **Variables:** Think of variables as named containers for storing data.\r\n    *   **Declaration:** You must tell the compiler what kind of data the variable will hold (its *data type*) and give it a name.\r\n        ```cpp\r\n        int sensorValue; // Declares an integer variable named sensorValue\r\n        float temperature; // Declares a floating-point variable\r\n        bool isPressed; // Declares a boolean (true/false) variable\r\n        char commandChar; // Declares a single character variable\r\n        ```\r\n    *   **Data Types:** Common types you'll use:\r\n        *   `int`: Integers (whole numbers, positive or negative). On ESP32, typically 32-bit.\r\n        *   `float`: Floating-point numbers (numbers with decimal points).\r\n        *   `bool`: Boolean (stores `true` or `false`).\r\n        *   `char`: Single characters (like 'A', '5', '#').\r\n        *   `long`: Larger integers.\r\n        *   `byte`: An 8-bit unsigned integer (0 to 255). Useful for raw data.\r\n        *   `String`: A sequence of characters (text). *Caution:* While convenient, `String` objects can sometimes cause memory fragmentation issues on microcontrollers. For simple text, C-style character arrays (`char[]`) are often preferred in performance-critical code, but `String` is fine for our initial Serial output.\r\n    *   **Assignment:** Giving a variable a value.\r\n        ```cpp\r\n        sensorValue = 1023; // Assigns the value 1023 to sensorValue\r\n        temperature = 25.5;\r\n        isPressed = true;\r\n        commandChar = 'S';\r\n        ```\r\n    *   **Initialization:** Declaring and assigning a value at the same time.\r\n        ```cpp\r\n        int ledPin = 16; // Declares an int and sets its initial value\r\n        const int buttonPin = 4; // const means the value cannot be changed later - good practice for pin numbers!\r\n        ```\r\n*   **Operators:** Symbols that perform operations on variables and values.\r\n    *   **Arithmetic:** `+`, `-`, `*`, `/`, `%` (modulo - remainder).\r\n    *   **Comparison:** `==` (equal to), `!=` (not equal to), `<` (less than), `>` (greater than), `<=` (less than or equal to), `>=` (greater than or equal to). These are used in conditional statements.\r\n    *   **Logical:** `&&` (AND), `||` (OR), `!` (NOT). Used to combine or negate boolean expressions.\r\n*   **Comments:** Lines of code ignored by the compiler, used to explain your code.\r\n    *   Single-line: `// This is a single-line comment`\r\n    *   Multi-line:\r\n        ```cpp\r\n        /*\r\n        This is a\r\n        multi-line\r\n        comment\r\n        */\r\n        ```\r\n\r\n**Code Example: Variables and Basic Output**\r\n\r\nLet's write a quick sketch to demonstrate variables and print them to the Serial Monitor.\r\n\r\n```cpp\r\n// Module 2.1 - Variables and Basic Output\r\n\r\n// Use constants for things that won't change, like pin numbers (good practice!)\r\nconst int myNumber = 42;\r\nconst float piValue = 3.14159;\r\nconst bool isActive = true;\r\nconst char initial = 'E';\r\n\r\n// Variables that might change\r\nint counter = 0;\r\nfloat measurement = 0.0;\r\nString message = \"Hello ESP32!\";\r\n\r\nvoid setup() {\r\n  // Initialize Serial communication at 115200 bits per second\r\n  // This speed needs to match the Serial Monitor setting\r\n  Serial.begin(115200);\r\n\r\n  // Give the Serial Monitor a moment to connect (optional but good for boot)\r\n  delay(1000);\r\n  Serial.println(\"--- Module 2.1 Demo ---\");\r\n}\r\n\r\nvoid loop() {\r\n  // Print constant values\r\n  Serial.print(\"My constant number: \");\r\n  Serial.println(myNumber); // println adds a newline at the end\r\n\r\n  Serial.print(\"Value of Pi: \");\r\n  Serial.println(piValue);\r\n\r\n  Serial.print(\"Is active? \");\r\n  Serial.println(isActive); // Prints 1 for true, 0 for false\r\n\r\n  Serial.print(\"Initial character: \");\r\n  Serial.println(initial);\r\n\r\n  // Print and update changing variables\r\n  Serial.print(\"Counter: \");\r\n  Serial.println(counter);\r\n  counter = counter + 1; // Increment counter (can also use counter++)\r\n\r\n  // Simulate a measurement change\r\n  measurement = measurement + 0.1;\r\n  Serial.print(\"Measurement: \");\r\n  Serial.println(measurement);\r\n\r\n  // Print a String\r\n  Serial.println(message);\r\n\r\n  Serial.println(\"-----------------------\");\r\n\r\n  // Wait a bit before the next loop iteration\r\n  delay(2000); // Wait for 2 seconds\r\n}\r\n```\r\nUpload this sketch, open the Serial Monitor (make sure the baud rate is set to 115200), and watch the output. You'll see your variables printed repeatedly.\r\n\r\n#### 2.2 Control Flow\r\n\r\nControl flow statements determine the order in which your code executes. This is how your program makes decisions and repeats actions.\r\n\r\n*   **`if`, `else if`, `else`:** Execute blocks of code only if certain conditions are true.\r\n    ```cpp\r\n    int temperature = 28;\r\n    if (temperature > 30) {\r\n      Serial.println(\"It's hot!\");\r\n    } else if (temperature > 20) { // This block is checked only if the first condition is false\r\n      Serial.println(\"It's warm.\");\r\n    } else { // This block executes if none of the above conditions are true\r\n      Serial.println(\"It's cool.\");\r\n    }\r\n    ```\r\n*   **`switch`:** A cleaner way to handle multiple `if/else if` statements when checking a single variable against several constant values.\r\n    ```cpp\r\n    char command = 'B';\r\n    switch (command) {\r\n      case 'A':\r\n        Serial.println(\"Command A received.\");\r\n        break; // Important! Exits the switch block\r\n      case 'B':\r\n        Serial.println(\"Command B received.\");\r\n        break;\r\n      case 'C':\r\n        Serial.println(\"Command C received.\");\r\n        break;\r\n      default: // Executes if none of the cases match\r\n        Serial.println(\"Unknown command.\");\r\n        break;\r\n    }\r\n    ```\r\n*   **`for` loops:** Repeat a block of code a fixed number of times.\r\n    ```cpp\r\n    // Structure: for (initialization; condition; increment/decrement)\r\n    for (int i = 0; i < 5; i++) {\r\n      Serial.print(\"Iteration: \");\r\n      Serial.println(i);\r\n    }\r\n    // Output: Iteration: 0, Iteration: 1, Iteration: 2, Iteration: 3, Iteration: 4\r\n    ```\r\n*   **`while` loops:** Repeat a block of code as long as a condition is true. Use with caution to avoid infinite loops that freeze your microcontroller!\r\n    ```cpp\r\n    int timer = 3;\r\n    while (timer > 0) {\r\n      Serial.print(\"Countdown: \");\r\n      Serial.println(timer);\r\n      timer = timer - 1; // Must change the condition inside the loop!\r\n      delay(1000);\r\n    }\r\n    Serial.println(\"Lift off!\");\r\n    ```\r\n\r\n**Code Example: Control Flow**\r\n\r\n```cpp\r\n// Module 2.2 - Control Flow Demo\r\n\r\nint sensorReading = 750; // Simulate reading from a sensor (e.g., 0-1023)\r\nint loopCounter = 0;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  delay(1000);\r\n  Serial.println(\"--- Module 2.2 Demo (Control Flow) ---\");\r\n}\r\n\r\nvoid loop() {\r\n  Serial.print(\"Loop iteration: \");\r\n  Serial.println(loopCounter);\r\n\r\n  // --- if/else example ---\r\n  if (sensorReading > 800) {\r\n    Serial.println(\"Sensor reading is high.\");\r\n  } else if (sensorReading > 500) {\r\n    Serial.println(\"Sensor reading is medium.\");\r\n  } else {\r\n    Serial.println(\"Sensor reading is low.\");\r\n  }\r\n\r\n  // --- switch example (using loopCounter modulo 3) ---\r\n  int mode = loopCounter % 3; // Gives 0, 1, or 2\r\n  switch (mode) {\r\n    case 0:\r\n      Serial.println(\"Current mode: Scan.\");\r\n      break;\r\n    case 1:\r\n      Serial.println(\"Current mode: Analyze.\");\r\n      break;\r\n    case 2:\r\n      Serial.println(\"Current mode: Report.\");\r\n      break;\r\n    default: // Should not happen with modulo, but good practice\r\n      Serial.println(\"Current mode: Unknown.\");\r\n      break;\r\n  }\r\n\r\n  // --- for loop example (runs once per loop() iteration) ---\r\n  Serial.print(\"Counting up: \");\r\n  for (int i = 0; i < 3; i++) {\r\n    Serial.print(i);\r\n    Serial.print(\" \");\r\n  }\r\n  Serial.println(); // Newline after the numbers\r\n\r\n  // --- while loop example (simulated) ---\r\n  // Be careful with while loops in loop()!\r\n  // This one is commented out to avoid blocking loop()\r\n  /*\r\n  int countdown = 2;\r\n  while(countdown > 0){\r\n    Serial.print(\"Inner countdown: \");\r\n    Serial.println(countdown);\r\n    countdown--;\r\n    delay(500); // Small delay\r\n  }\r\n  */\r\n\r\n  Serial.println(\"-----------------------\");\r\n\r\n  // Simulate sensor reading changing slightly\r\n  sensorReading = sensorReading - 10;\r\n  if (sensorReading < 400) {\r\n    sensorReading = 800; // Reset simulation\r\n  }\r\n\r\n  loopCounter++;\r\n\r\n  delay(1000); // Wait 1 second before next main loop() iteration\r\n}\r\n```\r\nUpload this and observe how the output changes based on the simulated `sensorReading` and the `loopCounter`.\r\n\r\n#### 2.3 Functions\r\n\r\nFunctions are blocks of code that perform a specific task. They help organize your code, make it reusable, and easier to read and debug.\r\n\r\n*   **Defining a function:**\r\n    ```cpp\r\n    // Structure: returnType functionName(parameter1Type parameter1Name, ...) { // code block }\r\n\r\n    void printGreeting() { // void means the function doesn't return a value\r\n      Serial.println(\"Greetings from a function!\");\r\n    }\r\n\r\n    int addNumbers(int a, int b) { // Takes two integers, returns an integer\r\n      int sum = a + b;\r\n      return sum; // Send the result back\r\n    }\r\n    ```\r\n*   **Calling a function:** Using the function's name followed by parentheses (and arguments if it takes parameters).\r\n    ```cpp\r\n    printGreeting(); // Calls the printGreeting function\r\n\r\n    int result = addNumbers(5, 3); // Calls addNumbers, stores the returned value in 'result'\r\n    Serial.print(\"Sum is: \");\r\n    Serial.println(result); // Output: Sum is: 8\r\n    ```\r\n\r\n#### 2.4 Understanding `setup()` and `loop()` in Arduino\r\n\r\nThese are the two fundamental functions in every Arduino sketch.\r\n\r\n*   **`void setup()`:**\r\n    *   This function runs **exactly once** when the ESP32 starts up (either on power-on or reset).\r\n    *   It's used for **initialization tasks**:\r\n        *   Setting up Serial communication (`Serial.begin()`).\r\n        *   Configuring pin modes (`pinMode()`).\r\n        *   Initializing libraries or sensors.\r\n        *   Setting initial variable values.\r\n*   **`void loop()`:**\r\n    *   This function runs **continuously** after `setup()` has finished.\r\n    *   It's where your main program logic resides.\r\n    *   You place the code here that you want to run repeatedly, like checking sensors, responding to input, updating outputs, or, in our case, scanning for Bluetooth devices!\r\n\r\nThink of `setup()` as getting everything ready in your lab, and `loop()` as the actual ongoing experiment you're running.\r\n\r\n**Code Example: `setup()` and `loop()` (Blink Revisited)**\r\n\r\nLet's look at the classic Blink sketch again, highlighting `setup` and `loop`.\r\n\r\n```cpp\r\n// Module 2.4 - setup() and loop() - Blink Revisited\r\n\r\nconst int ledPin = 2; // Onboard LED on most ESP32 Devkits (often labeled D2)\r\n\r\nvoid setup() {\r\n  // put your setup code here, to run once:\r\n  Serial.begin(115200); // Initialize serial communication\r\n  delay(1000); // Wait for Serial Monitor\r\n\r\n  Serial.println(\"--- Module 2.4 Demo (Blink setup/loop) ---\");\r\n  Serial.print(\"Configuring LED pin \");\r\n  Serial.print(ledPin);\r\n  Serial.println(\" as OUTPUT.\");\r\n\r\n  // Configure the LED pin as an OUTPUT\r\n  pinMode(ledPin, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n  // put your main code here, to run repeatedly:\r\n\r\n  Serial.println(\"LED ON\");\r\n  // Turn the LED on (HIGH voltage)\r\n  digitalWrite(ledPin, HIGH);\r\n  delay(1000); // Wait for 1 second\r\n\r\n  Serial.println(\"LED OFF\");\r\n  // Turn the LED off (LOW voltage)\r\n  digitalWrite(ledPin, LOW);\r\n  delay(1000); // Wait for 1 second\r\n}\r\n```\r\nIn `setup()`, we tell the ESP32 that `ledPin` will be used for *outputting* a voltage. In `loop()`, we repeatedly set the voltage on that pin HIGH (on) and then LOW (off), with delays in between. This simple structure is the heart of most embedded applications.\r\n\r\n#### 2.5 Working with GPIO Pins (Digital)\r\n\r\nGPIO stands for General Purpose Input/Output. These are the physical pins on the ESP32 chip (and exposed on the DevkitC board) that you can control from your code to interact with the outside world.\r\n\r\n*   **Digital Pins:** Can be set to one of two states: HIGH (typically 3.3V on ESP32) or LOW (0V). They can also read digital signals (HIGH/LOW).\r\n*   **Pin Numbering:** Refer to your specific ESP32 DevkitC pinout diagram. Common pins used for general I/O include 2, 4, 12-19, 21-23, 25-27, 32-33. Some pins have limitations or default roles (e.g., pins 6-11 are used for flash memory, pin 0 often used for boot mode, pins 34-39 are input-only). We'll stick to common, safe pins like 2, 4, 16, 17 for examples.\r\n*   **Pin Modes:** Before using a digital pin, you must tell the ESP32 how you intend to use it using the `pinMode()` function in `setup()`.\r\n    *   `pinMode(pin, OUTPUT);`: Configure the pin to send voltage out (like controlling an LED).\r\n    *   `pinMode(pin, INPUT);`: Configure the pin to read voltage in (like reading a sensor or button). The pin is high impedance.\r\n    *   `pinMode(pin, INPUT_PULLUP);`: Configure the pin as input, but also activate an internal pull-up resistor. This is *extremely useful* for connecting buttons directly between the pin and ground. When the button is open, the internal resistor pulls the pin HIGH. When the button is pressed, it connects the pin directly to LOW (ground). This avoids the need for an external resistor.\r\n*   **Digital Write:** Use `digitalWrite(pin, state);` to set an `OUTPUT` pin to `HIGH` or `LOW`.\r\n*   **Digital Read:** Use `digitalRead(pin);` to read the state (`HIGH` or `LOW`) of an `INPUT` or `INPUT_PULLUP` pin.\r\n\r\n**Connecting Components:**\r\n\r\n*   **LED:** LEDs only allow current in one direction. The *anode* (longer leg) connects to the ESP32 pin (via a resistor!), and the *cathode* (shorter leg) connects to Ground (GND). A resistor (e.g., 220 Ohm to 1k Ohm) is *essential* to limit current and prevent burning out the LED or the ESP32 pin.\r\n*   **Button:** A simple momentary button has two terminals. Connect one terminal to an ESP32 digital pin configured as `INPUT_PULLUP`. Connect the other terminal to Ground (GND). When pressed, the button connects the pin to ground, causing `digitalRead()` to return `LOW`. When released, the pull-up resistor pulls the pin HIGH.\r\n\r\n**Code Example: Digital Read/Write (Button & LED)**\r\n\r\nThis is very close to our module project!\r\n\r\n```cpp\r\n// Module 2.5 - Digital Read/Write Demo (Button & LED)\r\n\r\n// Define pins using constants\r\nconst int ledPin = 16;   // Connect LED (with resistor) to GPIO 16\r\nconst int buttonPin = 4; // Connect Button between GPIO 4 and GND\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  delay(1000);\r\n  Serial.println(\"--- Module 2.5 Demo (Button & LED) ---\");\r\n\r\n  // Configure pins\r\n  pinMode(ledPin, OUTPUT);       // LED pin is an output\r\n  pinMode(buttonPin, INPUT_PULLUP); // Button pin is an input with internal pull-up\r\n}\r\n\r\nvoid loop() {\r\n  // Read the state of the button pin\r\n  int buttonState = digitalRead(buttonPin);\r\n\r\n  // Note: With INPUT_PULLUP, the button is LOW when pressed\r\n  if (buttonState == LOW) {\r\n    // Button is pressed\r\n    Serial.println(\"Button PRESSED! Turning LED ON.\");\r\n    digitalWrite(ledPin, HIGH); // Turn LED ON\r\n  } else {\r\n    // Button is not pressed\r\n    Serial.println(\"Button released. Turning LED OFF.\");\r\n    digitalWrite(ledPin, LOW);  // Turn LED OFF\r\n  }\r\n\r\n  // Add a small delay to prevent flooding the Serial Monitor and for basic debouncing\r\n  delay(50);\r\n}\r\n```\r\n**Exercise:** Wire up an LED (with resistor!) and a button as described. Upload this sketch and test it. Observe the Serial output and the LED behavior as you press and release the button.\r\n\r\n#### 2.6 Basic Analog Read\r\n\r\nWhile not strictly needed for the final project *modes*, the outline mentions it, and it's a fundamental embedded concept. Analog pins can read a *range* of voltages, not just HIGH/LOW.\r\n\r\n*   **ADC (Analog-to-Digital Converter):** The hardware inside the ESP32 that converts an analog voltage level into a digital number.\r\n*   **`analogRead(pin);`:** Reads the voltage on a specific analog-capable pin and returns a digital value.\r\n*   **Resolution:** The ESP32's ADC is typically 12-bit, meaning it can represent 4096 different values (0 to 4095).\r\n*   **Analog Pins:** On the ESP32 DevkitC, pins 32-39 are typically ADC-capable.\r\n*   **Voltage Range:** The default input voltage range for the ADC pins is 0V to 3.3V. The `analogRead()` value will map proportionally within the 0-4095 range.\r\n\r\n**Code Example: Basic Analog Read**\r\n\r\n```cpp\r\n// Module 2.6 - Basic Analog Read Demo\r\n\r\n// ESP32 ADC pins are typically 32-39\r\nconst int analogPin = 34; // Use an ADC-capable pin, e.g., GPIO 34\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  delay(1000);\r\n  Serial.println(\"--- Module 2.6 Demo (Analog Read) ---\");\r\n  Serial.print(\"Reading analog value from pin: \");\r\n  Serial.println(analogPin);\r\n\r\n  // No pinMode needed for analogRead()!\r\n}\r\n\r\nvoid loop() {\r\n  // Read the analog value from the pin\r\n  int analogValue = analogRead(analogPin);\r\n\r\n  // Print the raw analog value\r\n  Serial.print(\"Raw Analog Value: \");\r\n  Serial.println(analogValue);\r\n\r\n  // Optional: Convert the value to voltage (if a voltage is applied)\r\n  // Assuming 0-4095 maps to 0-3.3V\r\n  float voltage = (float)analogValue / 4095.0 * 3.3;\r\n  Serial.print(\"Estimated Voltage: \");\r\n  Serial.print(voltage);\r\n  Serial.println(\" V\");\r\n\r\n\r\n  Serial.println(\"-----------------------\");\r\n\r\n  delay(500); // Read every 0.5 seconds\r\n}\r\n```\r\n**Exercise:** Upload this sketch. If you have a potentiometer, wire its ends to 3.3V and GND, and the middle pin to GPIO 34. Turn the knob and see the values change. If you don't have a potentiometer, just upload it and see the values fluctuate slightly due to electrical noise on the unconnected pin.\r\n\r\n#### 2.7 Introduction to Libraries\r\n\r\nLibraries are collections of pre-written code that provide functions and tools to make your life easier. Instead of writing complex code from scratch to control a specific sensor, a communication protocol like Bluetooth, or a display, you can often use a library.\r\n\r\n*   **What they are:** A bundle of `.h` (header) and `.cpp` (source) files. The header file declares what's available (functions, classes, variables), and the source file contains the actual implementation.\r\n*   **Why use them:**\r\n    *   **Save Time:** Don't reinvent the wheel for common tasks.\r\n    *   **Abstraction:** Hide complex low-level details behind simple function calls.\r\n    *   **Reliability:** Libraries are often tested and maintained by communities.\r\n*   **Including Libraries:** You add `#include <LibraryName.h>` at the top of your sketch. This tells the compiler to make the functions and objects defined in that library available to your code.\r\n    ```cpp\r\n    #include <Wire.h> // Include the Wire library for I2C communication\r\n    #include <BluetoothSerial.h> // Example: Include a library for Bluetooth Classic Serial Port Profile\r\n    // For BLE, we'll use a specific library like ESP32-BLE-Arduino later:\r\n    // #include <BLEDevice.h>"
    },
    {
      "title": "module_3",
      "description": "module_3 Overview",
      "order": 3,
      "content": "Alright team, buckle up! We've unboxed, we've blinked an LED, and we've got our basic coding muscles warmed up. Now, we're stepping into the *truly* invisible world – the airwaves buzzing with Bluetooth signals all around us. This is where the \"recon\" part of our tool starts to take shape, and it's fascinating!\r\n\r\nModule 3 is all about understanding the language these devices speak. We won't be writing much code *yet* in this module – this is our deep dive into the *theory* that makes everything else possible. Think of it as learning the anatomy of the signals before we start dissecting them with our ESP32 scanner.\r\n\r\nLet's dive in!\r\n\r\n---\r\n\r\n## Module 3: Bluetooth Deep Dive: Protocols, Packets, and Presence\r\n\r\n*   **Module Title:** Understanding Bluetooth: BLE vs. Classic, Advertising, and Identification\r\n*   **Module Objective:** Gain a solid theoretical understanding of Bluetooth, focusing on the concepts essential for reconnaissance and detection.\r\n\r\n---\r\n\r\n### Introduction: The Air is Alive!\r\n\r\nYou might think of Bluetooth only when you pair your headphones or connect to a car stereo. But the reality is, there are *thousands* of Bluetooth devices constantly chattering in the air around you, especially in populated areas. Smartwatches, fitness trackers, phones (even when not actively connected), beacons in stores, industrial sensors, medical devices – they're all broadcasting their presence.\r\n\r\nOur goal in this module is to understand *how* they do this, what information they broadcast, and how we can listen in. This foundational knowledge is absolutely critical before we start coding our scanner in Module 4.\r\n\r\n### 3.1 Bluetooth Classic (BR/EDR) vs. Bluetooth Low Energy (BLE)\r\n\r\nOkay, let's clear this up first. When people say \"Bluetooth,\" they often mean Bluetooth Classic (the original standard, sometimes called BR/EDR - Basic Rate/Enhanced Data Rate). This is what you use for streaming audio, transferring files, or connecting peripherals like keyboards and mice that need a constant, higher-bandwidth connection.\r\n\r\nThen there's Bluetooth Low Energy (BLE), introduced in the Bluetooth 4.0 specification. As the name suggests, its primary goal is *minimal power consumption*.\r\n\r\nHere's a breakdown of the key differences:\r\n\r\n| Feature         | Bluetooth Classic (BR/EDR)                 | Bluetooth Low Energy (BLE)                     |\r\n| :-------------- | :----------------------------------------- | :--------------------------------------------- |\r\n| **Primary Goal** | Data streaming, continuous connection      | Low power, periodic data transfer              |\r\n| **Topology**    | Piconet (Master/Slave)                     | Star, Mesh, Broadcast                          |\r\n| **Connection**  | Connection-oriented (requires pairing)     | Connection-oriented *or* Connectionless        |\r\n| **Data Throughput**| Higher (up to ~2.1 Mbps)                   | Lower (optimized for small data packets)       |\r\n| **Power Usage** | Higher                                     | *Significantly* lower (can run on coin cell for years) |\r\n| **Complexity**  | More complex protocol stack                | Simpler protocol stack                         |\r\n| **Use Cases**   | Audio streaming, file transfer, peripherals | Wearables, beacons, sensors, smart home, tracking |\r\n\r\n**Think of it this way:**\r\n\r\n*   **Bluetooth Classic:** Like a continuous phone call. You establish a connection, and data flows back and forth constantly. Great for conversations (audio) or sustained tasks. Uses more battery.\r\n*   **Bluetooth Low Energy:** Like sending postcards periodically. Devices can broadcast small bits of information without needing a persistent connection. Great for sending sensor readings, notifications, or just announcing \"Hey, I'm here!\" Uses very little battery.\r\n\r\n**Why are we focusing on BLE for reconnaissance?**\r\n\r\nSimple: **Advertising.**\r\n\r\nBLE devices are designed to spend most of their time asleep, waking up only periodically to send out small packets of data called **Advertising Packets**. This connectionless broadcast mechanism is perfect for devices that need to be discoverable or send out alerts without the power overhead of maintaining a constant connection.\r\n\r\nThese advertising packets are the *primary source of information* we'll be capturing and analyzing with our ESP32 tool. We're essentially becoming a passive listener, collecting these \"postcards\" from nearby devices.\r\n\r\n### 3.2 BLE Roles: Who's Talking to Whom?\r\n\r\nIn the BLE world, devices take on different roles depending on what they're doing. Understanding these roles is key to understanding how scanning and advertising work.\r\n\r\nThe two main pairs of roles are:\r\n\r\n1.  **Peripheral vs. Central:**\r\n    *   **Peripheral:** A device that provides data and waits for a Central device to connect. Think of a heart rate monitor, a smart lock, or a BLE sensor. It typically advertises its presence.\r\n    *   **Central:** A device that scans for Peripherals and initiates connections to them to consume their data. Think of your smartphone or a smart home hub.\r\n\r\n2.  **Broadcaster vs. Observer:**\r\n    *   **Broadcaster:** A device that sends out advertising packets but *does not* accept connections. Think of a simple beacon in a store. It just announces information.\r\n    *   **Observer:** A device that scans for advertising packets but *does not* initiate connections. It just listens to the broadcasts.\r\n\r\n**For our project:**\r\n\r\n*   When our ESP32 is scanning for devices (like trackers or for baseline analysis), it will act as an **Observer** (or sometimes a Central in scanning mode, but the key is it's *listening*).\r\n*   The devices we are trying to detect (trackers, phones, etc.) will primarily be acting as **Broadcasters** or **Peripherals** that are currently advertising.\r\n*   In Module 7, when we make our ESP32 *send* signals for advertising flooding, it will act as a **Broadcaster**.\r\n\r\nThe crucial point for reconnaissance is the **Broadcaster/Observer** relationship and the **Advertising Process**.\r\n\r\n### 3.3 The BLE Advertising Process\r\n\r\nThis is the core mechanism for discovery in BLE. Devices that want to be found or want to broadcast information periodically send out advertising packets.\r\n\r\n*   **How it works:** A Broadcaster/Peripheral wakes up from a low-power state, transmits the same advertising packet on three specific advertising channels (channels 37, 38, and 39 in the 2.4 GHz band), and then goes back to sleep.\r\n*   **Why three channels?** This hopping helps avoid interference and increases the chance that an Observer/Central will hear the advertisement.\r\n*   **Advertising Interval:** Devices advertise at a set interval (e.g., every 100ms, 1 second, etc.). A shorter interval makes the device more discoverable but uses slightly more power.\r\n*   **Advertising Packet Types:** There are different types, but the most common for simple broadcasts are `ADV_IND` (connectable undirected advertising) and `ADV_NONCONN_IND` (non-connectable undirected advertising). Our scanner will pick up both.\r\n\r\nAn Observer/Central device scans these three channels, listening for any advertising packets. When it hears one, it captures the packet and processes the data within it.\r\n\r\n### 3.4 Advertising Packets: What's Inside?\r\n\r\nThis is where we get to the actual data we can extract! An advertising packet contains several pieces of information structured in a specific way.\r\n\r\nThe payload of a BLE advertising packet consists of one or more **Advertising Data (AD) structures**. Each AD structure follows a simple **Length-Type-Value (LTV)** format:\r\n\r\n*   **Length (L):** A single byte indicating the length of the Value field + 1 (for the Type byte).\r\n*   **Type (T):** A single byte indicating the type of data in the Value field (e.g., \"This is the device name,\" \"This is the manufacturer data\"). These types are defined by the Bluetooth SIG.\r\n*   **Value (V):** The actual data payload, with a length of L-1 bytes.\r\n\r\n```\r\n[ Length (1 byte) | Type (1 byte) | Value (Length-1 bytes) ]\r\n```\r\n\r\nA full advertising packet is just a sequence of these LTV structures.\r\n\r\n```\r\n[ AD Structure 1 ] [ AD Structure 2 ] [ AD Structure 3 ] ...\r\n```\r\n\r\n**Common Advertising Data (AD) Types you'll encounter (and look for!):**\r\n\r\n*   **Flags (Type 0x01):** Indicates the device's capabilities (e.g., discoverable mode, whether it supports BLE and Classic).\r\n*   **Service UUIDs (Type 0x02, 0x03, 0x04, 0x05, 0x06, 0x07):** Identifies the services the device offers (e.g., Heart Rate Service, Battery Service). These can be 16-bit (standard BLE services), 32-bit, or 128-bit (custom services).\r\n*   **Local Name (Type 0x08 - Shortened, 0x09 - Complete):** The human-readable name of the device (e.g., \"My Headphones,\" \"John's Phone\"). Not all devices include a name in advertising.\r\n*   **TX Power Level (Type 0x0A):** The transmit power of the advertising signal (in dBm). Can sometimes be used for rough distance estimation calibration.\r\n*   **Manufacturer Specific Data (Type 0xFF):** This is a *very important* type for reconnaissance! It allows manufacturers to include custom data formats. This is where you'll often find unique identifiers used by specific ecosystems (like Apple's Find My protocol data, Tile identifiers, etc.). The format inside the Value field is manufacturer-specific, but it usually starts with a 2-byte Manufacturer ID assigned by the Bluetooth SIG.\r\n\r\n**Example (Conceptual Packet):**\r\n\r\nImagine an advertising packet that contains the device name and some manufacturer data. The raw bytes might look *something* like this (simplified):\r\n\r\n```\r\n0x05, 0x09, 0x4D, 0x79, 0x44, 0x65, 0x76,  // Length=5, Type=0x09 (Complete Local Name), Value=\"MyDev\"\r\n0x06, 0xFF, 0x00, 0x4C, 0x01, 0x02, 0x03   // Length=6, Type=0xFF (Manufacturer Specific Data), Value=0x004C (Apple's ID), 0x01, 0x02, 0x03 (custom data)\r\n```\r\n\r\nOur ESP32 BLE library will parse these bytes for us, presenting the data in a more usable format (like strings for names, byte arrays for manufacturer data). But understanding this underlying structure is key to knowing what you're looking at when you see raw scan results.\r\n\r\n### 3.5 Device Identification: MAC Addresses and Privacy\r\n\r\nEvery Bluetooth device has a unique identifier called a **Bluetooth Address** (similar in concept to a Wi-Fi MAC address). This is a 48-bit (6-byte) number. It's often the primary way we identify a *specific* device during scanning.\r\n\r\nHowever, thanks to privacy features in BLE, it's not always a static, globally unique address. There are different types:\r\n\r\n1.  **Public Device Address:** This is the device's true, globally unique IEEE 802-registered address. It's static and assigned by the manufacturer. If a device uses a Public address, it's easy to track its presence over time just by looking for that address.\r\n2.  **Random Device Address:** Devices can use randomly generated addresses instead of their Public address. This is a privacy feature to prevent passive tracking. There are subtypes of Random addresses:\r\n    *   **Random Static Address:** A randomly generated address that *doesn't change* after it's set (until maybe the device is factory reset). While random, it's still static, so you *can* track a device using this address over time *until* it changes (which might be never, or rarely).\r\n    *   **Random Resolvable Private Address (RPA):** This is the most privacy-focused type for devices that *do* connect. The address changes frequently (e.g., every 15 minutes). However, a trusted Central device (like your phone that's paired with your smartwatch) has a special key called the Identity Resolving Key (IRK). Using the IRK, the Central can calculate whether a received RPA belongs to a known device. An *untrusted* Observer (like our scanner, which doesn't have the IRK) *cannot* link a new RPA back to a previously seen RPA or the device's Public address. This makes passive tracking difficult *if RPAs are used correctly*.\r\n    *   **Random Non-Resolvable Private Address:** A randomly generated address that changes frequently and *cannot* be resolved back to a Public address or IRK. Used when a device doesn't expect to be connected to (e.g., some types of pure Broadcasters).\r\n\r\n**Implications for Reconnaissance:**\r\n\r\n*   If a device uses a **Public** or **Random Static** address, we can easily identify and track it over time using its address alone.\r\n*   If a device uses **RPAs**, we can still detect its *presence* when it advertises, but each advertisement might appear to come from a *new, different* address to our scanner. We *cannot* reliably track its movement or history based on the address alone unless we have the IRK (which we won't). We might have to rely on other identifying data in the advertising packet (like specific Manufacturer Specific Data patterns, though this is less reliable and can also change).\r\n*   If a device uses **Random Non-Resolvable** addresses, it's even harder to track.\r\n\r\nThis is a key concept for our \"Personal Tracker Detection\" mode. We need to understand that seeing a new MAC address doesn't necessarily mean a *new device*, especially if RPAs are in play. However, many simple trackers or older devices might still use static addresses, or they might include consistent data *within* the advertising packet even if the address changes.\r\n\r\n### 3.6 Signal Strength (RSSI): An Indicator, Not a Ruler\r\n\r\n**RSSI** stands for **Received Signal Strength Indicator**. When our ESP32 receives a Bluetooth advertising packet, it can measure the strength of that signal. This value is typically reported in **dBm** (decibels relative to one milliwatt), which is a negative number (e.g., -40 dBm is a strong signal, -90 dBm is a weak signal). A signal of 0 dBm would mean the received power is 1 milliwatt.\r\n\r\n**How does RSSI relate to distance?**\r\n\r\nGenerally, the *closer* a device is, the *stronger* the signal (less negative RSSI). The *further away* a device is, the *weaker* the signal (more negative RSSI).\r\n\r\n**BUT, and this is a big BUT:** RSSI is *not* a precise measure of distance. Many factors affect signal strength:\r\n\r\n*   **Obstacles:** Walls, furniture, people, water bodies (including human bodies!) absorb and reflect RF signals, weakening them significantly.\r\n*   **Interference:** Other 2.4 GHz devices (Wi-Fi, microwaves) can interfere with the Bluetooth signal.\r\n*   **Antenna Orientation:** The way the transmitting and receiving antennas are oriented relative to each other impacts signal strength.\r\n*   **Transmit Power:** Devices can advertise at different power levels, affecting the maximum range and received strength.\r\n\r\n**For our tool:**\r\n\r\nWe will use RSSI as an *indicator* of relative proximity.\r\n*   A sudden increase in RSSI for a known device might suggest it's moving closer.\r\n*   A device appearing with a very strong RSSI might be very close.\r\n*   We can use RSSI to filter out very distant devices.\r\n\r\nJust don't expect to calculate \"exactly 3.5 meters away\" based on RSSI alone. It's more like \"very close,\" \"nearby,\" \"further away,\" \"at the edge of detection.\"\r\n\r\n### 3.7 Introduction to Bluetooth Scanning\r\n\r\nNow that we understand what's being broadcast, let's briefly touch on how our scanner will work (this is the lead-in to Module 4!).\r\n\r\nAn Observer or Central device performs a **scan**. This involves:\r\n\r\n1.  Tuning its radio to the three BLE advertising channels (37, 38, 39).\r\n2.  Listening for advertising packets on these channels.\r\n3.  When a packet is detected, the radio captures it.\r\n4.  The captured packet's data (MAC address, RSSI, advertising data) is passed up the software stack for processing.\r\n\r\nThere are two main types of scanning:\r\n\r\n*   **Passive Scanning:** The scanner just listens. It captures advertising packets (`ADV_IND`, `ADV_NONCONN_IND`, etc.) but does not transmit anything back. This is stealthier and lower power for the scanner.\r\n*   **Active Scanning:** The scanner listens for `ADV_IND` packets. When it receives one, it sends a `SCAN_REQ` packet back to the advertiser. The advertiser can then respond with a `SCAN_RSP` packet, which can contain *additional* advertising data that didn't fit in the initial `ADV_IND` (often includes the full device name if it was truncated). Active scanning gets more information but is less stealthy as the scanner transmits.\r\n\r\nFor our reconnaissance tool, we'll likely use **passive scanning** initially, as it's simpler to implement and sufficient for capturing basic presence, MAC addresses, RSSI, and common AD types like Manufacturer Specific Data. We can explore active scanning later if needed for specific data extraction (like full names).\r\n\r\n### 3.8 Case Study: Tracking Devices (AirTags, Tiles, Fitness Trackers)\r\n\r\nLet's apply what we've learned to real-world examples. How do devices like Apple AirTags, Tile trackers, or even many fitness watches announce their presence?\r\n\r\nThey heavily rely on **BLE Advertising**.\r\n\r\n*   They act as **Broadcasters**.\r\n*   They periodically send out **Advertising Packets**.\r\n*   These packets often contain **Manufacturer Specific Data (Type 0xFF)**. This is where the magic happens.\r\n    *   For an AirTag, the Manufacturer Specific Data contains Apple's Manufacturer ID (0x004C) followed by a specific data format related to the Find My network protocol. This data changes frequently (part of Apple's privacy design) but follows a recognizable pattern that Find My network participants (like iPhones, iPads) can understand and report securely.\r\n    *   For a Tile, the Manufacturer Specific Data contains Tile's Manufacturer ID followed by data specific to the Tile network.\r\n    *   Fitness trackers might include manufacturer data or advertise specific service UUIDs related to health profiles.\r\n\r\n**Crucially for our tool:** While we won't be able to *resolve* the identity of an AirTag or Tile (because we don't have the cryptographic keys the Find My/Tile networks use), we *can* detect their *presence* by identifying the specific *patterns* in their Manufacturer Specific Data. We can also track their relative signal strength (RSSI) to estimate proximity.\r\n\r\nOur \"Personal Tracker Detection\" mode will look for these *patterns* in the advertising data and monitor the RSSI of devices exhibiting these patterns.\r\n\r\n### Conclusion: You've Seen the Signals!\r\n\r\nYou've just completed a crucial step! You now understand:\r\n\r\n*   The fundamental difference between Bluetooth Classic and BLE.\r\n*   Why BLE's low power and advertising make it ideal for reconnaissance.\r\n*   The roles devices play (Broadcaster/Observer are key for us).\r\n*   The structure of BLE Advertising Packets (LTV format) and common data types (especially Manufacturer Specific Data!).\r\n*   The different types of MAC addresses and their privacy implications for tracking.\r\n*   How RSSI gives us clues about proximity (and its limitations).\r\n*   The basic process of BLE scanning.\r\n\r\nThis theoretical foundation is absolutely essential. In the next module, we'll translate this understanding into code and make our ESP32 start listening to these signals and showing us what's out there!\r\n\r\n---\r\n\r\n### Suggested Resources or Prerequisites:\r\n\r\n*   Completion of Module 2 (Basic ESP32 coding).\r\n*   Links to official Bluetooth SIG specifications (browse the Core Specification, particularly the Generic Access Profile - GAP - section, but be warned, it's dense! Focus on introductory summaries first).\r\n*   Online tutorials explaining BLE roles and advertising (search for \"BLE Peripheral Central Broadcaster Observer\" or \"BLE Advertising Packet Structure\").\r\n*   Visual aids explaining packet structure and roles (images/diagrams are very helpful here!).\r\n\r\n---\r\n\r\n### Module Project/Exercise:\r\n\r\nThis module is theory-heavy, so the project is research and reflection:\r\n\r\n1.  **Summarize:** Write a short summary (a paragraph or two) explaining the core difference between BLE and Classic Bluetooth and why the BLE advertising process is fundamental for finding low-power devices.\r\n2.  **Research AD Types:** Spend 15-20 minutes online researching common BLE Advertising Data (AD) Types (beyond the ones listed here). Look for resources that list the \"Assigned Numbers\" for AD Types. Identify at least three *other* AD types and briefly describe what kind of information they carry. This will give you a broader sense of the data you might encounter.\r\n\r\nBring your summaries and research notes to the next module! We'll be ready to put this knowledge into practice.\r\n\r\n---\r\n\r\nAlright, take a breath! That was a deep dive, but you've absorbed some critical concepts. Feel free to revisit sections if they felt complex. Understanding these fundamentals makes the coding in the next modules much more intuitive.\r\n\r\nReady to make the ESP32 *see* these signals? Module 4 awaits!"
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Okay, class! Welcome back. We've set up our ESP32 workshop and mastered the basics of embedded programming in the last two modules. We even took a theoretical deep dive into the world of Bluetooth, understanding the difference between Classic and BLE, and the critical role of advertising packets.\r\n\r\nNow, it's time to put that theory into practice. Imagine the air around you is buzzing with invisible signals – Bluetooth devices constantly announcing their presence. In this module, we're going to give our ESP32 the ability to *see* and *interpret* these signals. We'll program it to become a **BLE Observer**, actively scanning the airwaves for advertising packets and pulling out the juicy bits of information they contain. This is where our reconnaissance journey truly begins!\r\n\r\n---\r\n\r\n## Module 4: Scanning the Airwaves: Programming the ESP32 as a BLE Observer\r\n\r\n*   **Module Objective:** By the end of this module, you will be able to program the ESP32 to actively scan for nearby Bluetooth Low Energy (BLE) devices and extract basic information (MAC address, name, RSSI) from their advertising packets, displaying these results on the Serial Monitor.\r\n\r\n*   **Prerequisites:**\r\n    *   Successful completion of Module 3 (understanding of BLE, advertising packets, MAC addresses, RSSI).\r\n    *   Your ESP32 DevkitC successfully set up and programmable (Module 1).\r\n    *   Basic familiarity with C++ and Arduino IDE structure (Module 2).\r\n\r\n---\r\n\r\n### 4.1 Introduction to the ESP32 BLE Library\r\n\r\nInteracting with the ESP32's sophisticated Bluetooth hardware directly would be incredibly complex. Thankfully, the Arduino core for the ESP32 provides powerful libraries that abstract away the low-level details, allowing us to focus on the logic.\r\n\r\nFor BLE operations on the ESP32 within the Arduino environment, the standard and widely used library is the one included with the ESP32 Arduino core itself. It's often referred to or accessed via includes like `<BLEDevice.h>`, `<BLEUtils.h>`, and `<BLEScan.h>`.\r\n\r\nThis library provides classes and functions to:\r\n\r\n1.  Initialize the BLE hardware.\r\n2.  Configure the device as a BLE Central/Observer or Peripheral/Broadcaster.\r\n3.  Start and stop BLE scanning.\r\n4.  Handle discovered devices and their advertising data.\r\n5.  Initiate connections (though we won't focus on connecting in this module).\r\n6.  Manage BLE services and characteristics (relevant for later interaction, but not scanning).\r\n\r\n**How to ensure you have it:** If you installed the ESP32 board support in the Arduino IDE's Boards Manager back in Module 1, you already have this library! It's part of the core package. You just need to include the necessary header files in your sketch.\r\n\r\n### 4.2 Setting Up the BLE Scan Process\r\n\r\nBefore we can scan, we need to initialize the BLE subsystem on the ESP32 and configure the scanner. This typically happens in the `setup()` function of your Arduino sketch.\r\n\r\nHere are the key steps:\r\n\r\n1.  **Include Libraries:** Add the necessary header files at the top of your sketch.\r\n2.  **Initialize BLE Device:** Call `BLEDevice::init()`. This wakes up and configures the ESP32's BLE radio. You usually give your device a name here, although for scanning, the name isn't strictly necessary unless you plan to advertise yourself later.\r\n3.  **Get a Scanner Instance:** Obtain a reference to the BLE scanner object using `BLEDevice::getScan()`. The ESP32 hardware has one BLE scanner instance, so you get a pointer to this singleton object.\r\n4.  **Configure Scan Parameters (Optional but Recommended):** You can set various parameters, such as:\r\n    *   `setActiveScan(bool)`: Determines if the scanner sends out scan requests (active) or just passively listens for advertisements (passive). Active scanning can get more information but uses slightly more power and makes your scanner detectable. Passive is often sufficient for just detecting presence and basic data. We'll start with passive.\r\n    *   `setInterval(uint16_t)` and `setWindow(uint16_t)`: These control the scanning timing (how often and for how long the radio is on within a scan interval). Default values are usually fine to start, but you can tweak them for performance or power saving. The values are in units of 0.625ms.\r\n    *   `setScanCallbacks()`: *Crucially*, this is where you tell the scanner *what to do* when it finds a device. This leads us to the next topic: handling scan results.\r\n\r\nLet's look at the basic `setup()` structure:\r\n\r\n```cpp\r\n#include <Arduino.h> // Always good practice\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEScan.h>\r\n#include <BLEAdvertisedDevice.h>\r\n\r\n// Define scan time in seconds\r\n#define SCAN_DURATION 10\r\n\r\n// Create a pointer to the BLE Scan object\r\nBLEScan* pBLEScan;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200); // Start serial communication for output\r\n  Serial.println(\"ESP32 BLE Scanner Starting...\");\r\n\r\n  // 1. Initialize the BLE Device\r\n  // The string argument is an optional device name, not strictly needed for scanning only\r\n  BLEDevice::init(\"\");\r\n\r\n  // 2. Retrieve the BLE Scan object\r\n  pBLEScan = BLEDevice::getScan();\r\n\r\n  // 3. Configure Scan Parameters\r\n  // Set active scan to false for passive scanning (just listening)\r\n  pBLEScan->setActiveScan(false);\r\n\r\n  // Set scan interval and window (optional, default values often work)\r\n  // pBLEScan->setInterval(100); // Scan interval 100 * 0.625ms = 62.5ms\r\n  // pBLEScan->setWindow(99);   // Scan window 99 * 0.625ms = 61.875ms\r\n  // Note: window <= interval\r\n\r\n  // At this point, the scanner is configured, but not running yet.\r\n  // We still need to tell it how to handle results!\r\n}\r\n\r\nvoid loop() {\r\n  // The loop function will contain the actual scanning command later\r\n  // For now, it can be empty or just delay\r\n  delay(1000);\r\n}\r\n```\r\n\r\nThis code sets up the BLE environment and gets the scanner object ready. But it doesn't *do* anything with the scan results yet.\r\n\r\n### 4.3 Handling Scan Results: The `onResult` Callback\r\n\r\nWhen the BLE scanner finds an advertising packet, it needs to process it. The ESP32 BLE library uses a **callback function** mechanism for this. You define a specific function that the library will automatically call *every time* it discovers a new device or receives an advertisement from a device it's already seen during the current scan session.\r\n\r\nTo implement this, you create a class that inherits from `BLEAdvertisedDeviceCallbacks` and override its `onResult()` method.\r\n\r\nHere's how you define the callback class:\r\n\r\n```cpp\r\n// In your sketch, typically before setup()\r\n\r\n// Callback class to handle the advertising results\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n      // This function is called whenever a new device is found\r\n      // or an advertisement from an existing device is received.\r\n\r\n      Serial.printf(\"Advertised Device found: %s \\n\", advertisedDevice.toString().c_str());\r\n\r\n      // We will refine this output later\r\n    }\r\n};\r\n```\r\n\r\nNow, you need to create an instance of this callback class and tell the scanner to use it in your `setup()` function:\r\n\r\n```cpp\r\n// In your sketch, typically before setup()\r\n\r\n// ... (Includes and BLEScan pointer) ...\r\n\r\n// Create an instance of our callback class\r\nMyAdvertisedDeviceCallbacks myCallbacks;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"ESP32 BLE Scanner Starting...\");\r\n\r\n  BLEDevice::init(\"\");\r\n  pBLEScan = BLEDevice::getScan();\r\n  pBLEScan->setActiveScan(false);\r\n\r\n  // Set the callback object for the scanner\r\n  pBLEScan->setAdvertisedDeviceCallbacks(&myCallbacks);\r\n\r\n  // Now the scanner knows what function to call when it finds a device\r\n}\r\n\r\n// ... loop() ...\r\n```\r\n\r\nWith this, whenever an advertising packet is detected, the `onResult` method of your `myCallbacks` object will be executed.\r\n\r\n### 4.4 Extracting Key Information from Scan Results\r\n\r\nThe `onResult` function receives a `BLEAdvertisedDevice` object. This object is a treasure trove of information parsed from the advertising packet. Let's learn how to pull out the most important pieces for our reconnaissance tool:\r\n\r\n*   **Device Address (MAC):** Every Bluetooth device has a unique address. For BLE, these can be public static addresses or various types of random addresses (Module 3 recap!). The `BLEAdvertisedDevice` object provides methods to get this.\r\n    *   `advertisedDevice.getAddress()`: Returns a `BLEAddress` object.\r\n    *   `advertisedDevice.getAddress().toString()`: Returns the address as a `std::string`.\r\n*   **Device Name:** Many devices broadcast a human-readable name (e.g., \"My Headphones\", \"Tile\").\r\n    *   `advertisedDevice.haveName()`: Returns `true` if a name was included in the advertisement.\r\n    *   `advertisedDevice.getName()`: Returns the name as a `std::string`.\r\n*   **RSSI (Received Signal Strength Indicator):** This value indicates how strong the signal from the device is at the scanner's location. Higher (closer to 0) means stronger, lower (more negative) means weaker. It's a rough indicator of distance.\r\n    *   `advertisedDevice.getRSSI()`: Returns the RSSI value as an `int8_t`.\r\n\r\nLet's modify our `onResult` callback to extract and print these specific details instead of just the full `toString()` output.\r\n\r\n```cpp\r\n// In your sketch, typically before setup()\r\n\r\n// ... (Includes and BLEScan pointer) ...\r\n\r\n// Callback class to handle the advertising results\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n      Serial.print(\"Device Found: \");\r\n\r\n      // Print MAC Address\r\n      Serial.print(\"Address: \");\r\n      Serial.print(advertisedDevice.getAddress().toString().c_str());\r\n\r\n      // Print Device Name (if available)\r\n      if (advertisedDevice.haveName()) {\r\n        Serial.print(\", Name: \");\r\n        Serial.print(advertisedDevice.getName().c_str());\r\n      } else {\r\n        Serial.print(\", Name: N/A\");\r\n      }\r\n\r\n      // Print RSSI\r\n      Serial.print(\", RSSI: \");\r\n      Serial.print(advertisedDevice.getRSSI());\r\n      Serial.println(\" dBm\");\r\n\r\n      // You could also check for other data types here, e.g.:\r\n      // if (advertisedDevice.hasServiceUUID()) { ... }\r\n      // if (advertisedDevice.hasManufacturerData()) { ... }\r\n    }\r\n};\r\n\r\n// ... (Instance of callback class and setup() function) ...\r\n```\r\n\r\nNow, when the scanner detects a device, it will print a line like: `Device Found: Address: 1A:2B:3C:4D:5E:6F, Name: MyPhone, RSSI: -55 dBm`.\r\n\r\n### 4.5 Starting and Stopping the Scan\r\n\r\nThe final piece is to actually *start* the scan. This is done using the `start()` method of the `BLEScan` object.\r\n\r\nThe `start()` method has a few variations:\r\n\r\n*   `pBLEScan->start(uint32_t duration, bool isContinuous = false)`: Starts a scan for a specified `duration` in seconds.\r\n    *   If `isContinuous` is `false` (the default when omitted or explicitly set), the function will block (pause your program) until the scan duration is over. This is simple for a basic scan.\r\n    *   If `isContinuous` is `true`, the function returns immediately, and the scan runs in the background until you explicitly call `pBLEScan->stop()`. This is useful if you want your `loop()` to do other things while scanning.\r\n*   `pBLEScan->start(uint32_t duration, void (*scanCompleteCB)(BLEScan*), bool isContinuous = false)`: Similar to the above, but also takes a pointer to a callback function (`scanCompleteCB`) that will be called when the scan finishes (either by duration or by calling `stop()`).\r\n\r\nFor our first simple scanner, let's use the blocking version (`isContinuous = false`) within the `loop()` function. This means the `loop()` will start a scan, wait for it to finish, and then potentially start another one after a delay.\r\n\r\n```cpp\r\n// ... (Includes, callback class, callback instance, BLEScan pointer) ...\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"ESP32 BLE Scanner Starting...\");\r\n\r\n  BLEDevice::init(\"\");\r\n  pBLEScan = BLEDevice::getScan();\r\n  pBLEScan->setActiveScan(false); // Passive scan\r\n  pBLEScan->setAdvertisedDeviceCallbacks(&myCallbacks);\r\n\r\n  // We will start the scan in the loop()\r\n}\r\n\r\nvoid loop() {\r\n  Serial.println(\"Starting BLE scan for 10 seconds...\");\r\n\r\n  // Start the scan.\r\n  // The 'true' parameter here (or default 'false' for the 2-param version)\r\n  // determines if the function blocks.\r\n  // Let's use the 2-parameter version, where default is false (blocking for duration)\r\n  BLEScanResults foundDevices = pBLEScan->start(SCAN_DURATION, false); // Scan for SCAN_DURATION seconds, blocking\r\n\r\n  Serial.printf(\"Scan finished. Found %d devices during this scan session.\\n\", foundDevices.getCount());\r\n  Serial.println(\"--------------------\");\r\n\r\n  // The scan results are handled by the onResult callback while the scan is running.\r\n  // After the scan finishes, foundDevices.getCount() tells you how many *unique*\r\n  // devices were seen during this specific start() call. The onResult callback\r\n  // might have fired multiple times for the same device if it advertised frequently.\r\n\r\n  // Wait a bit before starting the next scan (optional, but good practice)\r\n  delay(5000); // Wait 5 seconds before starting another scan\r\n}\r\n```\r\n\r\n**Putting it all together:**\r\n\r\n```cpp\r\n#include <Arduino.h>\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEScan.h>\r\n#include <BLEAdvertisedDevice.h>\r\n\r\n// Define scan time in seconds\r\n#define SCAN_DURATION 10\r\n\r\n// Create a pointer to the BLE Scan object\r\nBLEScan* pBLEScan;\r\n\r\n// Callback class to handle the advertising results\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n      // This function is called whenever a new device is found\r\n      // or an advertisement from an existing device is received.\r\n\r\n      Serial.print(\"Device Found: \");\r\n\r\n      // Print MAC Address\r\n      Serial.print(\"Address: \");\r\n      Serial.print(advertisedDevice.getAddress().toString().c_str());\r\n\r\n      // Print Device Name (if available)\r\n      if (advertisedDevice.haveName()) {\r\n        Serial.print(\", Name: \");\r\n        Serial.print(advertisedDevice.getName().c_str());\r\n      } else {\r\n        Serial.print(\", Name: N/A\");\r\n      }\r\n\r\n      // Print RSSI\r\n      Serial.print(\", RSSI: \");\r\n      Serial.print(advertisedDevice.getRSSI());\r\n      Serial.println(\" dBm\");\r\n\r\n      // You could also check for other data types here, e.g.:\r\n      // if (advertisedDevice.hasServiceUUID()) { ... }\r\n      // if (advertisedDevice.hasManufacturerData()) { ... }\r\n    }\r\n};\r\n\r\n// Create an instance of our callback class\r\nMyAdvertisedDeviceCallbacks myCallbacks;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200); // Start serial communication for output\r\n  Serial.println(\"ESP32 BLE Scanner Starting...\");\r\n\r\n  // 1. Initialize the BLE Device\r\n  BLEDevice::init(\"\"); // Optional device name\r\n\r\n  // 2. Retrieve the BLE Scan object\r\n  pBLEScan = BLEDevice::getScan();\r\n\r\n  // 3. Configure Scan Parameters\r\n  pBLEScan->setActiveScan(false); // Set active scan to false for passive scanning\r\n  // pBLEScan->setInterval(100); // Optional: set scan interval\r\n  // pBLEScan->setWindow(99);   // Optional: set scan window\r\n\r\n  // 4. Set the callback object for the scanner\r\n  pBLEScan->setAdvertisedDeviceCallbacks(&myCallbacks);\r\n\r\n  // Scan will be started in loop()\r\n}\r\n\r\nvoid loop() {\r\n  Serial.println(\"--------------------\");\r\n  Serial.printf(\"Starting BLE scan for %d seconds...\\n\", SCAN_DURATION);\r\n\r\n  // Start the scan.\r\n  // The second parameter 'false' means the function will block until the scan duration is over.\r\n  BLEScanResults foundDevices = pBLEScan->start(SCAN_DURATION, false);\r\n\r\n  // Note: The onResult callback prints devices as they are found *during* the scan.\r\n  // foundDevices.getCount() here gives the number of *unique* devices whose *first*\r\n  // advertisement triggered the onResult callback during this specific scan period.\r\n  // The total number of onResult calls might be higher if devices advertise frequently.\r\n\r\n  Serial.printf(\"Scan finished after %d seconds. Total unique devices seen in this scan session: %d\\n\", SCAN_DURATION, foundDevices.getCount());\r\n  Serial.println(\"--------------------\");\r\n\r\n  // Optional: Wait before starting the next scan\r\n  delay(5000); // Wait 5 seconds\r\n}\r\n```\r\n\r\nUpload this sketch to your ESP32. Open the Serial Monitor (make sure the baud rate is set to 115200). You should see the scanner start, and as it detects BLE devices nearby, you'll see their information printed in the Serial Monitor. Try having your phone with Bluetooth enabled nearby, or turn on some Bluetooth headphones, speakers, or fitness trackers.\r\n\r\n### 4.6 Scan Parameters: Active vs. Passive Scanning\r\n\r\nWe touched on `setActiveScan()`. Let's clarify this:\r\n\r\n*   **Passive Scanning (`setActiveScan(false)`):** The scanner simply listens for advertising packets being broadcast by devices. It does not send out any packets itself. This is lower power and stealthier, as your scanner isn't announcing its presence. However, you only get the information included in the standard advertising packet.\r\n*   **Active Scanning (`setActiveScan(true)`):** When the scanner sees an advertising packet (specifically, a `CONNECTABLE_SCANNABLE` or `NON_CONNECTABLE_SCANNABLE` type), it sends back a \"scan request\" packet to the advertising device. The device *may* then respond with a \"scan response\" packet, which can contain additional information (like a longer version of the device name, or more complex service data) that didn't fit in the initial advertising packet. Active scanning gives you potentially more data but uses slightly more power and, importantly, means your ESP32 is *transmitting* and can therefore be detected as a scanner.\r\n\r\nFor our initial reconnaissance purposes, passive scanning is often sufficient and recommended for lower power consumption and less impact on the environment. We used `setActiveScan(false)` in our example sketch.\r\n\r\nThe `setInterval()` and `setWindow()` parameters control the *timing* of the scan. The ESP32 radio doesn't scan 100% of the time to save power. It scans for a short \"window\" within a larger \"interval\". Setting these can optimize for faster discovery (shorter interval/longer window) or lower power (longer interval/shorter window). The default values are usually a good balance.\r\n\r\n### 4.7 Filtering Scan Results (Briefly)\r\n\r\nOur current `onResult` callback prints *every* device it sees. For a reconnaissance tool, you often want to focus on specific types of devices or filter out known ones.\r\n\r\nYou can add simple filtering logic directly within the `onResult` callback. For example, to only print devices with a specific name:\r\n\r\n```cpp\r\n// Inside the onResult(BLEAdvertisedDevice advertisedDevice) method:\r\n\r\n// Example: Only print devices named \"TargetDevice\"\r\nif (advertisedDevice.haveName() && advertisedDevice.getName() == \"TargetDevice\") {\r\n    Serial.print(\"Target Device Found! \");\r\n    Serial.print(\"Address: \");\r\n    Serial.print(advertisedDevice.getAddress().toString().c_str());\r\n    Serial.print(\", RSSI: \");\r\n    Serial.print(advertisedDevice.getRSSI());\r\n    Serial.println(\" dBm\");\r\n}\r\n\r\n// Example: Only print devices with RSSI stronger than -70 dBm (closer devices)\r\nif (advertisedDevice.getRSSI() > -70) {\r\n    Serial.print(\"Strong Signal Device: \");\r\n    Serial.print(\"Address: \");\r\n    Serial.print(advertisedDevice.getAddress().toString().c_str());\r\n    if (advertisedDevice.haveName()) { Serial.print(\", Name: \"); Serial.print(advertisedDevice.getName().c_str()); }\r\n    Serial.print(\", RSSI: \");\r\n    Serial.print(advertisedDevice.getRSSI());\r\n    Serial.println(\" dBm\");\r\n}\r\n\r\n// You can combine conditions\r\n// if (advertisedDevice.haveName() && advertisedDevice.getName().find(\"Headphones\") != std::string::npos && advertisedDevice.getRSSI() > -60) {\r\n//     Serial.println(\"Possible nearby headphones detected!\");\r\n// }\r\n```\r\n\r\nFor more complex filtering or managing a list of devices seen over time, we'll need more sophisticated data structures and logic, which is the focus of Module 5. For now, printing everything gives us a good overview of the BLE environment.\r\n\r\n### 4.8 Real-world Example: What Will You See?\r\n\r\nWhen you run the scanner, you'll likely see a variety of devices.\r\n\r\n*   **Your Phone/Laptop:** If Bluetooth is on, they often advertise, though they might use random, changing MAC addresses for privacy.\r\n*   **Headphones/Speakers:** Many advertise their presence, sometimes with their model name.\r\n*   **Fitness Trackers/Smartwatches:** These frequently advertise, often with manufacturer data or service UUIDs related to health profiles.\r\n*   **Smart Home Devices:** Many use BLE for initial setup or low-power control.\r\n*   **Beacons:** Devices specifically designed to broadcast advertisements for location services (like iBeacon or Eddystone - we might touch on these later).\r\n*   **Unknown Devices:** You'll see plenty of addresses without names. These could be anything from anonymous tracking tags to industrial sensors or simply devices configured not to broadcast a name. Pay attention to the MAC address patterns – some ranges are assigned to specific manufacturers.\r\n\r\nObserve how the RSSI changes as you move your ESP32 closer to or further from a known device. Notice how frequently some devices appear in the `onResult` callback – this indicates how often they are advertising.\r\n\r\n### Module Project/Exercise\r\n\r\nYour task for this module is to implement the core BLE scanning sketch we developed.\r\n\r\n1.  **Create a new Arduino sketch.**\r\n2.  **Include the necessary BLE libraries.**\r\n3.  **Define the `SCAN_DURATION` constant (e.g., 10 seconds).**\r\n4.  **Create a pointer for the `BLEScan` object.**\r\n5.  **Define a class that inherits from `BLEAdvertisedDeviceCallbacks` and implements the `onResult` method.** Inside `onResult`, extract and print the Device Address (MAC), Device Name (if available), and RSSI for each detected device to the Serial Monitor. Format the output clearly.\r\n6.  **Create an instance of your callback class.**\r\n7.  **In the `setup()` function:**\r\n    *   Initialize Serial communication.\r\n    *   Initialize the BLE device.\r\n    *   Get the `BLEScan` object.\r\n    *   Set `setActiveScan(false)` for passive scanning.\r\n    *   Set your custom callback object using `setAdvertisedDeviceCallbacks()`.\r\n8.  **In the `loop()` function:**\r\n    *   Print a message indicating the start of the scan.\r\n    *   Call `pBLEScan->start(SCAN_DURATION, false)` to perform a blocking scan for the defined duration.\r\n    *   Print a message indicating the scan has finished and optionally the number of unique devices reported by `getCount()`.\r\n    *   Add a `delay()` (e.g., 5 seconds) before the next scan starts, so the output isn't overwhelming.\r\n9.  **Upload the sketch to your ESP32.**\r\n10. **Open the Serial Monitor (115200 baud).**\r\n11. **Observe the output.** Note the different devices, their addresses (static vs. random), names (or lack thereof), and fluctuating RSSI values.\r\n12. **Experiment:** Try moving the ESP32 around. Bring Bluetooth devices closer. Turn Bluetooth on/off on your phone. See how the output changes.\r\n\r\nThis project will give you direct, hands-on experience with seeing the invisible BLE signals around you and is the foundational step for building our reconnaissance tool.\r\n\r\n---\r\n\r\n### Summary\r\n\r\nIn this module, we successfully transformed our ESP32 into a basic BLE scanner. We learned how to use the ESP32 BLE library, configure the scanner, implement a callback function to process scan results, and extract key information like MAC address, device name, and RSSI. We also discussed the difference between active and passive scanning.\r\n\r\nYou've now built the core capability of our reconnaissance tool: the ability to detect and report on nearby BLE devices. In the next module, we'll tackle the challenge of making sense of this stream of data – storing it, identifying unique devices, and tracking them over time, which is essential for building our detection logic.\r\n\r\nKeep experimenting with your scanner! The more you observe the real-world BLE environment, the better you'll understand the data we'll be processing. See you in Module 5!"
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Okay, let's dive deep into Module 5! This is where we transform raw, fleeting Bluetooth signals into structured, meaningful data. We're moving beyond just *seeing* devices to *knowing* them, *tracking* them, and *making sense* of their presence over time. Think of it as building the memory and recognition system for our tool.\r\n\r\nAs your guide, I'm thrilled to explore this crucial step with you. This module is fundamental for building any kind of detection or analysis logic on the scan data.\r\n\r\n---\r\n\r\n## Module 5: Making Sense of the Signals: Storing, Identifying, and Tracking Devices\r\n\r\n**Module Title:** Making Sense of the Signals: Storing, Identifying, and Tracking Devices\r\n\r\n**Module Objective:** Develop techniques to store scan data, identify unique devices, and track their presence or signal strength over time, laying the groundwork for detection modes.\r\n\r\n**Why is this module important?** In Module 4, our ESP32 became a pair of digital ears, listening to the Bluetooth airwaves. We could see devices pop up in the Serial Monitor. But each device might advertise multiple times, and the basic scan result is just a snapshot. To build a reconnaissance tool that can detect persistent trackers or changes in the environment, we need to:\r\n\r\n1.  **Remember** the devices we've seen.\r\n2.  **Identify** if a new advertisement comes from a device we've seen before.\r\n3.  **Update** information about that device (like its latest signal strength or when we last saw it).\r\n4.  **Maintain** a current list of unique devices detected.\r\n\r\nThis module teaches you how to build that memory and identification system using core C++ programming concepts on the ESP32.\r\n\r\n---\r\n\r\n### Essential Subtopics Deep Dive:\r\n\r\n#### 5.1 Data Structures for Storing Device Information\r\n\r\nOkay, so we've got advertising packets coming in. Each packet tells us about *one* advertisement event from *one* device at a specific moment. From Module 4, we know we can extract the device's MAC address, its name (if advertised), and its RSSI.\r\n\r\nTo store information about a *unique* device, we need a way to group these pieces of data together. In C++, the `struct` (structure) is perfect for this. A `struct` allows you to bundle different data types under a single name.\r\n\r\nLet's define a `struct` to hold the information we care about for a single unique Bluetooth device:\r\n\r\n```cpp\r\n// We'll put this struct definition near the top of our sketch, outside of setup() or loop()\r\n\r\nstruct DeviceInfo {\r\n    BLEAddress  address;        // The unique MAC address of the device\r\n    std::string name;           // The advertised name (can be empty)\r\n    int         rssi;           // The last seen RSSI\r\n    unsigned long lastSeenMillis; // When we last saw this device (using millis())\r\n    // We could add more fields later, like a history of RSSI values,\r\n    // advertised service UUIDs, manufacturer data, etc.\r\n};\r\n```\r\n\r\n**Explanation:**\r\n\r\n*   `struct DeviceInfo { ... };`: Defines a new structure type named `DeviceInfo`.\r\n*   `BLEAddress address;`: This will store the device's MAC address. The `BLEAddress` type is provided by the ESP32 BLE library and is convenient for handling MAC addresses.\r\n*   `std::string name;`: Stores the device's advertised name. We use `std::string` from the C++ Standard Library for variable-length text. Remember to `#include <string>`.\r\n*   `int rssi;`: Stores the Received Signal Strength Indicator. It's an integer, usually negative.\r\n*   `unsigned long lastSeenMillis;`: This is a timestamp indicating *when* (relative to the ESP32 starting up) we last received an advertisement from this device. We'll use the `millis()` function, which returns the number of milliseconds since the ESP32 board began running the current program. `unsigned long` is needed because `millis()` returns a large number that grows over time.\r\n\r\nUsing a `struct` keeps our code organized. Instead of having separate variables for address, name, RSSI, etc., for potentially many devices, we have one `DeviceInfo` object per device that holds all its relevant data.\r\n\r\n#### 5.2 Using `std::vector` to Store Multiple Devices\r\n\r\nNow that we know how to represent *one* device's information, how do we store a *list* of these devices? The number of devices we detect will vary depending on the environment and how long we scan. A fixed-size array isn't ideal.\r\n\r\nEnter `std::vector`. This is part of the C++ Standard Library and is a dynamic array. It can grow or shrink in size as needed at runtime. It's perfect for maintaining our list of detected unique devices.\r\n\r\nTo use `std::vector`, you need to `#include <vector>`.\r\n\r\n```cpp\r\n// Declare a vector to hold our unique devices\r\nstd::vector<DeviceInfo> uniqueDevices;\r\n```\r\n\r\nThis line declares a variable `uniqueDevices` which is a vector capable of holding `DeviceInfo` objects. Initially, it's empty.\r\n\r\nWe can add a new `DeviceInfo` object to the vector using the `push_back()` method:\r\n\r\n```cpp\r\nDeviceInfo newDevice;\r\n// ... fill in newDevice details ...\r\nuniqueDevices.push_back(newDevice);\r\n```\r\n\r\nWe can iterate through the vector to access the stored devices:\r\n\r\n```cpp\r\nfor (const auto& device : uniqueDevices) {\r\n    // 'device' is a reference to a DeviceInfo object in the vector\r\n    Serial.printf(\"Device: %s, Name: %s, RSSI: %d, Last Seen: %lu ms\\n\",\r\n                  device.address.toString().c_str(),\r\n                  device.name.c_str(),\r\n                  device.rssi,\r\n                  device.lastSeenMillis);\r\n}\r\n```\r\n\r\nThis range-based for loop is a clean way to go through every item in the `uniqueDevices` vector. `device.address.toString().c_c_str()` looks a bit complex, but it's just converting the `BLEAddress` object to a C-style string (`const char*`) which `Serial.printf` requires.\r\n\r\n#### 5.3 Handling Duplicate Scan Results & Identifying Unique Devices\r\n\r\nThis is the core challenge we need to solve. When we scan, we might receive multiple advertising packets from the *same* physical device within a short period. We don't want to add the same device to our `uniqueDevices` list over and over. We need a way to check: \"Have I seen a device with this MAC address before?\"\r\n\r\nThe MAC address is the key identifier here. While MAC addresses can be random or change (especially with BLE Privacy features), for many common devices and for the scope of this basic tool, the MAC address is the most reliable way to identify a unique device *within a scanning session*.\r\n\r\nSo, the logic when we get a new scan result (`BLEAdvertisedDevice` object in our `onResult` callback) is:\r\n\r\n1.  Get the MAC address from the scan result.\r\n2.  Iterate through our `uniqueDevices` vector.\r\n3.  For each `DeviceInfo` object in the vector, compare its stored MAC address with the MAC address from the new scan result.\r\n4.  If a match is found, this is a duplicate advertisement from a device we already know about.\r\n5.  If no match is found after checking all devices in the vector, this is a *new* unique device.\r\n\r\n#### 5.4 Developing a Simple Device List Management System (Add, Find, Update)\r\n\r\nBased on the logic above, we can create functions to manage our `uniqueDevices` vector.\r\n\r\nLet's refine the `onResult` callback logic from Module 4. Instead of just printing, it will now call a function that handles the \"find or add/update\" process.\r\n\r\nWe'll need a function that takes a `BLEAdvertisedDevice` object (the raw scan result) and updates our `uniqueDevices` list.\r\n\r\n```cpp\r\n// Function to find a device by address in our list\r\n// Returns a pointer to the DeviceInfo if found, nullptr otherwise\r\nDeviceInfo* findDeviceByAddress(const BLEAddress& address) {\r\n    for (auto& device : uniqueDevices) { // Use reference '&' to allow potential modification\r\n        if (device.address.equals(address)) {\r\n            return &device; // Found the device! Return a pointer to it\r\n        }\r\n    }\r\n    return nullptr; // Device not found\r\n}\r\n\r\n// In our onResult callback...\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n        Serial.printf(\"Advertised Device found: %s\\n\", advertisedDevice.toString().c_str()); // Keep initial print for debugging\r\n\r\n        // 1. Get the address from the scan result\r\n        BLEAddress deviceAddress = advertisedDevice.getAddress();\r\n\r\n        // 2. Try to find this device in our list\r\n        DeviceInfo* existingDevice = findDeviceByAddress(deviceAddress);\r\n\r\n        // 3. Check if the device was found\r\n        if (existingDevice != nullptr) {\r\n            // Device found! This is a duplicate advertisement.\r\n            // 4a. Update its information (last seen time, RSSI)\r\n            existingDevice->rssi = advertisedDevice.getRSSI();\r\n            existingDevice->lastSeenMillis = millis();\r\n            Serial.printf(\"  -> Updated existing device: %s\\n\", deviceAddress.toString().c_str());\r\n\r\n        } else {\r\n            // Device not found! This is a new unique device.\r\n            // 4b. Create a new DeviceInfo object\r\n            DeviceInfo newDevice;\r\n            newDevice.address = deviceAddress;\r\n            newDevice.rssi = advertisedDevice.getRSSI();\r\n            newDevice.lastSeenMillis = millis();\r\n            newDevice.name = advertisedDevice.getName().empty() ? \"N/A\" : advertisedDevice.getName(); // Get name, use \"N/A\" if empty\r\n\r\n            // 5. Add the new device to our list\r\n            uniqueDevices.push_back(newDevice);\r\n            Serial.printf(\"  -> Added new device: %s\\n\", deviceAddress.toString().c_str());\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**Explanation:**\r\n\r\n*   `findDeviceByAddress`: This function takes a `BLEAddress` and iterates through the `uniqueDevices` vector. It uses the `equals()` method of `BLEAddress` for reliable comparison. If a match is found, it returns a *pointer* to that `DeviceInfo` object in the vector. If not found, it returns `nullptr`. Using a pointer allows us to directly modify the `DeviceInfo` object stored within the vector.\r\n*   `onResult` modification:\r\n    *   It retrieves the `BLEAddress` from the `advertisedDevice`.\r\n    *   It calls `findDeviceByAddress` to see if we know this device.\r\n    *   If `existingDevice` is not `nullptr`, we found it. We update its `rssi` and `lastSeenMillis`. Note the `->` operator is used to access members via a pointer.\r\n    *   If `existingDevice` *is* `nullptr`, it's a new device. We create a `newDevice` struct, populate its fields (including getting the name, handling the case where no name is advertised), and add it to the `uniqueDevices` vector using `push_back()`.\r\n\r\nThis setup ensures that our `uniqueDevices` vector contains only one entry per unique MAC address seen during the scan, and each entry is updated with the latest information whenever a new advertisement is received from that device.\r\n\r\n#### 5.5 Storing Historical Data (Briefly)\r\n\r\nThe current `DeviceInfo` struct only stores the *last seen* RSSI and timestamp. For more advanced analysis (like tracking movement patterns or averaging signal strength), you might want to store a history.\r\n\r\nInstead of `int rssi;`, you could have `std::vector<int> rssiHistory;`. When a device is updated, you'd do `existingDevice->rssiHistory.push_back(advertisedDevice.getRSSI());`. Similarly, you could store a list of timestamps.\r\n\r\n```cpp\r\n// Example of a struct with history (more complex, optional for capstone)\r\nstruct DeviceInfoAdvanced {\r\n    BLEAddress  address;\r\n    std::string name;\r\n    std::vector<int> rssiHistory; // Store multiple RSSI readings\r\n    std::vector<unsigned long> timestampHistory; // Store timestamps for RSSI readings\r\n    // ... other fields\r\n};\r\n```\r\n\r\nFor the Module 5 project and the initial capstone, storing just the *last* seen RSSI and timestamp is sufficient and simpler. We'll stick to the first `DeviceInfo` struct definition.\r\n\r\n#### 5.6 Estimating Proximity Based on RSSI (Understanding Limitations)\r\n\r\nWe've stored RSSI. Can we use it to determine how close a device is?\r\n\r\n**Yes, but with significant caveats!**\r\n\r\n*   **The Theory:** In a perfect, obstacle-free environment, radio signal strength decreases predictably with distance. A stronger (less negative) RSSI generally means the device is closer.\r\n*   **The Reality:** The real world is *not* perfect. Walls, furniture, people, other radio signals (Wi-Fi, microwaves, etc.), even the orientation of the antennas on the ESP32 and the target device *all* affect RSSI. A device behind a wall might have a weaker signal than a device further away in the open. A device held in someone's hand might have a different RSSI than one sitting on a table.\r\n*   **Transmit Power:** Devices advertise with different power levels. A device far away transmitting strongly might have the same RSSI as a device nearby transmitting weakly.\r\n\r\n**Conclusion:** You can use RSSI as a *rough indicator* of relative proximity within a stable environment, *comparing the same device to itself over time*. For example, if the RSSI of a specific device goes from -90 dBm to -50 dBm, it's almost certainly getting closer. However, you *cannot* reliably say \"this device is exactly X meters away\" based solely on RSSI, nor can you reliably say \"device A is closer than device B\" based only on a single RSSI reading if they are different types of devices or in different locations relative to obstacles.\r\n\r\nFor our tool, we'll mainly use RSSI changes for the Personal Tracker mode (is a *specific* device getting closer?) and as just one piece of information in the Environmental Baseline mode.\r\n\r\n#### 5.7 Implementing a \"Last Seen\" Timestamp\r\n\r\nWe already incorporated this into our `DeviceInfo` struct and the update logic in `onResult`.\r\n\r\n`unsigned long lastSeenMillis;` stores the value returned by `millis()` when we last saw the device.\r\n\r\nThe `millis()` function is great for relative timing. If `millis()` now is 10000 and `lastSeenMillis` for a device is 8000, we know we last saw it 2000 milliseconds (2 seconds) ago.\r\n\r\n**Important Note:** `millis()` will eventually overflow (wrap around) after about 49.7 days. For a long-running device, you might need to handle this wrap-around if you're calculating durations across the overflow point, but for typical scanning sessions of minutes or hours, `millis()` is perfectly fine.\r\n\r\n#### 5.8 Putting It All Together: Refactoring the Module 4 Code\r\n\r\nLet's integrate these concepts into a complete ESP32 sketch based on our Module 4 scanner.\r\n\r\nWe'll need:\r\n\r\n1.  Necessary includes (`BLEDevice`, `BLEUtils`, `BLEScan`, `BLEAdvertisedDevice`, `vector`, `string`).\r\n2.  The `DeviceInfo` struct definition.\r\n3.  The global `std::vector<DeviceInfo> uniqueDevices;`.\r\n4.  The `findDeviceByAddress` helper function.\r\n5.  The `MyAdvertisedDeviceCallbacks` class with the modified `onResult` method that uses `findDeviceByAddress` and updates/adds devices to `uniqueDevices`.\r\n6.  The `setup()` function to initialize BLE and start the scan, setting our custom callback.\r\n7.  The `loop()` function. For this module's project, we'll let the scan run for a set time, then stop it, print the list of unique devices, and maybe wait before scanning again (or just run one scan as per the project).\r\n\r\nHere's a skeletal structure:\r\n\r\n```cpp\r\n#include <Arduino.h>\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEScan.h>\r\n#include <BLEAdvertisedDevice.h>\r\n#include <vector>\r\n#include <string> // Required for std::string\r\n\r\n// The scan time in seconds. 0 = continuous scan\r\n#define SCAN_TIME_SECONDS 10\r\n\r\n// --- Data Structure for Device Information ---\r\nstruct DeviceInfo {\r\n    BLEAddress  address;\r\n    std::string name;\r\n    int         rssi;\r\n    unsigned long lastSeenMillis;\r\n};\r\n\r\n// --- Vector to store unique devices ---\r\nstd::vector<DeviceInfo> uniqueDevices;\r\n\r\n// --- Helper function to find a device in the vector ---\r\nDeviceInfo* findDeviceByAddress(const BLEAddress& address) {\r\n    for (auto& device : uniqueDevices) {\r\n        if (device.address.equals(address)) {\r\n            return &device;\r\n        }\r\n    }\r\n    return nullptr; // Device not found\r\n}\r\n\r\n// --- Callback class for scan results ---\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n        // Serial.printf(\"Advertised Device found: %s\\n\", advertisedDevice.toString().c_str()); // Optional: Keep for verbose debugging\r\n\r\n        BLEAddress deviceAddress = advertisedDevice.getAddress();\r\n        DeviceInfo* existingDevice = findDeviceByAddress(deviceAddress);\r\n\r\n        if (existingDevice != nullptr) {\r\n            // Device found, update info\r\n            existingDevice->rssi = advertisedDevice.getRSSI();\r\n            existingDevice->lastSeenMillis = millis();\r\n            // Serial.printf(\"  -> Updated existing device: %s\\n\", deviceAddress.toString().c_str()); // Optional debug\r\n        } else {\r\n            // New device, add it\r\n            DeviceInfo newDevice;\r\n            newDevice.address = deviceAddress;\r\n            newDevice.rssi = advertisedDevice.getRSSI();\r\n            newDevice.lastSeenMillis = millis();\r\n            newDevice.name = advertisedDevice.getName().empty() ? \"N/A\" : advertisedDevice.getName();\r\n\r\n            uniqueDevices.push_back(newDevice);\r\n            Serial.printf(\"  -> Added new device: %s (Name: %s, RSSI: %d)\\n\",\r\n                          newDevice.address.toString().c_str(),\r\n                          newDevice.name.c_str(),\r\n                          newDevice.rssi);\r\n        }\r\n    }\r\n};\r\n\r\n// --- BLE Objects ---\r\nBLEScan* pBLEScan;\r\nMyAdvertisedDeviceCallbacks myCallbacks;\r\n\r\n// --- Setup Function ---\r\nvoid setup() {\r\n    Serial.begin(115200);\r\n    Serial.println(\"Starting BLE Scan...\");\r\n\r\n    // Initialize BLE\r\n    BLEDevice::init(\"\"); // You can give your device a name here if needed later\r\n\r\n    // Create the BLE Scanner\r\n    pBLEScan = BLEDevice::getScan();\r\n    pBLEScan->setAdvertisedDeviceCallbacks(&myCallbacks); // Set our custom callback\r\n    pBLEScan->setActiveScan(true);                       // Active scan gets scan response data (like full name)\r\n    pBLEScan->setInterval(100);                          // Scan interval in ms\r\n    pBLEScan->setWindow(99);                             // Scan window in ms (should be <= interval)\r\n\r\n    Serial.printf(\"Starting scan for %d seconds...\\n\", SCAN_TIME_SECONDS);\r\n    pBLEScan->start(SCAN_TIME_SECONDS, false); // Start scan, 'false' means don't stop when a device is found\r\n}\r\n\r\n// --- Loop Function ---\r\nvoid loop() {\r\n    // In this design, the scan runs for SCAN_TIME_SECONDS set in setup.\r\n    // When the scan time is up, the scan automatically stops and a 'scan complete' event occurs\r\n    // (though we don't explicitly handle that event callback here, start() with a duration handles it).\r\n    // We will print the list *after* the scan finishes.\r\n\r\n    // Check if the scan is running. If not, print results and potentially restart or stop.\r\n    if (pBLEScan->getResults().getCount() > 0 && !pBLEScan->isScanning()) {\r\n        Serial.println(\"\\nScan finished.\");\r\n        Serial.printf(\"Found %zu unique devices:\\n\", uniqueDevices.size()); // Use %zu for size_t\r\n\r\n        // Sort the unique devices list by address for consistent output (optional but nice)\r\n        std::sort(uniqueDevices.begin(), uniqueDevices.end(), [](const DeviceInfo& a, const DeviceInfo& b) {\r\n            return a.address.toString() < b.address.toString();\r\n        });\r\n\r\n        // Print the list of unique devices\r\n        for (const auto& device : uniqueDevices) {\r\n            Serial.printf(\"- %s (Name: %s, RSSI: %d, Last Seen: %lu ms ago)\\n\",\r\n                          device.address.toString().c_str(),\r\n                          device.name.c_str(),\r\n                          device.rssi,\r\n                          millis() - device.lastSeenMillis); // Calculate time ago\r\n        }\r\n\r\n        // Clear the list for the next scan if needed, or just stop here for the project\r\n        // uniqueDevices.clear();\r\n\r\n        // For this module's project, we just run one scan and stop.\r\n        // In future modules, we might loop scans or change modes.\r\n        Serial.println(\"Module 5 Project Scan Complete. Board can be reset for another scan.\");\r\n\r\n        // Prevent the loop from running this block repeatedly\r\n        while(true) { delay(1000); } // Halt the loop indefinitely\r\n    }\r\n\r\n    // Small delay to prevent watchdog timer issues if loop is empty or runs too fast\r\n    delay(10);\r\n}\r\n\r\n// Need to include the algorithm header for std::sort\r\n#include <algorithm>\r\n```\r\n\r\n**Key Changes from Module 4:**\r\n\r\n*   Added `#include <vector>`, `#include <string>`, `#include <algorithm>`.\r\n*   Defined the `DeviceInfo` struct.\r\n*   Declared `std::vector<DeviceInfo> uniqueDevices;`.\r\n*   Implemented `findDeviceByAddress`.\r\n*   Modified `MyAdvertisedDeviceCallbacks::onResult` to use `findDeviceByAddress` and update/add to `uniqueDevices`.\r\n*   Removed the direct print of `advertisedDevice.toString()` from `onResult` (or commented it out) to avoid spamming the Serial Monitor with duplicates. We now only print when a *new* unique device is added, and print the full list at the end.\r\n*   Added logic in `loop()` to check if the scan has finished (`!pBLEScan->isScanning()`) and if results were found (`pBLEScan->getResults().getCount() > 0`). This is a simple way to trigger the \"print unique devices\" phase after the timed scan.\r\n*   Added code in `loop()` to iterate through `uniqueDevices` and print the stored information, including the calculated \"time since last seen\".\r\n*   Added optional sorting of the list before printing for cleaner output.\r\n*   Added a `while(true) { delay(1000); }` loop at the end of `loop()` to effectively stop the program after the scan and printing are done, fulfilling the project requirement of a single scan run.\r\n\r\n---\r\n\r\n### Suggested Resources or Prerequisites:\r\n\r\n*   Completion of Module 4.\r\n*   ESP32 DevkitC with Arduino IDE setup.\r\n*   A device that advertises via BLE (smartphone with BLE enabled, fitness tracker, smart watch, other ESP32 advertising, etc.).\r\n*   Familiarity with basic C++ data structures (structs) and the concept of vectors/dynamic arrays.\r\n*   Links:\r\n    *   [ESP32-BLE-Arduino Library Documentation](https://github.com/nkolban/esp32-snippets/blob/master/Documentation/BLE%20C%2B%2B11%20Interface.md) (Focus on BLEScan and BLEAdvertisedDevice)\r\n    *   [C++ `std::vector` Reference](https://www.cplusplus.com/reference/vector/vector/)\r\n    *   [C++ `struct` Tutorial](https://www.cplusplus.com/doc/tutorial/structures/)\r\n    *   [Arduino `millis()` Reference](https://www.arduino.cc/reference/en/language/functions/time/millis/)\r\n\r\n---\r\n\r\n### Module Project/Exercise:\r\n\r\n**Objective:** Modify your Module 4 scanning sketch to store unique devices in a list (`std::vector<DeviceInfo>`). For each scan result, check if the device is already in the list using its MAC address. If new, add it. If existing, update its `lastSeenMillis` and `rssi`. After a set scan duration (e.g., 10 seconds), stop the scan and print the list of unique devices found, including their MAC address, name (if available), last seen RSSI, and how long ago (in milliseconds) they were last seen.\r\n\r\n**Steps:**\r\n\r\n1.  Start with your working sketch from Module 4 that performs a BLE scan using the `ESP32-BLE-Arduino` library and prints scan results in the `onResult` callback.\r\n2.  Add the necessary `#include` statements for `vector`, `string`, and `algorithm`.\r\n3.  Define the `DeviceInfo` struct as shown above.\r\n4.  Declare the global `std::vector<DeviceInfo> uniqueDevices;`.\r\n5.  Implement the `findDeviceByAddress` helper function.\r\n6.  Modify the `onResult` method in your `BLEAdvertisedDeviceCallbacks` class:\r\n    *   Get the `BLEAddress` from the `advertisedDevice`.\r\n    *   Call `findDeviceByAddress` to look for it in `uniqueDevices`.\r\n    *   If found, update the `rssi` and `lastSeenMillis` fields of the found `DeviceInfo` object.\r\n    *   If not found, create a new `DeviceInfo` object, populate its fields (address, name, rssi, lastSeenMillis), and add it to `uniqueDevices` using `push_back()`.\r\n    *   (Optional but recommended) Add Serial print statements inside `onResult` only when a *new* device is added, to see the list grow live.\r\n7.  In `setup()`, configure and start the scan with a specific duration (e.g., `pBLEScan->start(10, false);` for 10 seconds).\r\n8.  Modify the `loop()` function:\r\n    *   Add logic to detect when the scan has finished (`!p"
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Okay, SME hat on, teacher mode engaged! This is where the rubber meets the road. We've learned to scan and process data; now we apply that to *detect* things. Module 6 is incredibly satisfying because you start seeing your ESP32 act as a real reconnaissance tool.\r\n\r\nLet's dive deep into Module 6!\r\n\r\n---\r\n\r\n## Module 6: Building Detection Modes I: Personal Tracker & Environmental Baseline\r\n\r\n**Module Title:** Implementing Reconnaissance Logic: Tracking and Baselining\r\n\r\n**Module Objective:** Program the ESP32 to implement the Personal Tracker Detection and Environmental Baseline & Anomaly Detection modes using the scanning and data processing skills acquired in Modules 4 and 5. By the end, your ESP32 won't just *see* devices; it will start *interpreting* their presence based on different rules.\r\n\r\n**Prerequisites:**\r\n*   Successful completion of Module 1-5. You should be comfortable setting up the ESP32, writing basic Arduino sketches, understand BLE advertising and scanning, and have implemented code to scan and manage a list of unique devices (likely using `std::vector` and a struct/class like `DeviceInfo` or similar).\r\n*   Basic understanding of control flow (`if`, `else`, `switch`, loops) and how to structure code using functions.\r\n\r\n**Learning the \"Why\": Turning Data into Intelligence**\r\n\r\nRemember in Module 3 we talked about *why* we scan Bluetooth? Not just to see what's there, but to understand the *context* of the signals. This module is about defining different \"contexts\" or \"modes\" of analysis.\r\n\r\n*   **Personal Tracker Detection:** The goal isn't just to see an AirTag once, but to detect devices that seem to be *following* you or are persistently present *wherever you go*. This requires looking at devices that are seen repeatedly over time and potentially monitoring their signal strength changes relative to your location (or, more simply for the ESP32, relative to the scanner's location).\r\n*   **Environmental Baseline:** Imagine you want to know if any *new* Bluetooth devices appear in your office overnight, or if someone brings an unauthorized device into a sensitive area. This requires establishing a \"normal\" state (the baseline) and then comparing the current state against it.\r\n\r\nThese are two distinct logical operations performed on the *same underlying scan data*. This immediately tells us we need a way to switch between these different operational modes within our single ESP32 sketch.\r\n\r\n### 6.1 Structuring the Application: Modes and State\r\n\r\nOur ESP32 sketch currently probably runs in a continuous loop, maybe scanning repeatedly. To implement different detection modes, we need a structure that allows us to:\r\n\r\n1.  Know which mode we are currently in.\r\n2.  Execute the appropriate code block for that mode.\r\n3.  Potentially switch between modes based on user input.\r\n\r\nThe simplest way to manage this in an embedded system like the ESP32 is using a variable to represent the current `mode` and a `switch` statement (or `if/else if`) within the main `loop()` function. A more formal approach is a State Machine, which is excellent for complex interactions, but for 2-3 modes, a simple `switch` is perfectly adequate and easier to grasp initially.\r\n\r\nLet's think about the flow:\r\n\r\n*   The `setup()` function initializes the Serial port, BLE, and potentially sets an initial mode.\r\n*   The `loop()` function runs continuously.\r\n*   Inside `loop()`, we'll check if there's any user input on the Serial port (e.g., typing '1' for Tracker mode, '2' for Baseline mode).\r\n*   If input is received, we update the `mode` variable.\r\n*   Then, based on the current `mode` variable, we call a specific function (e.g., `runTrackerMode()`, `runBaselineMode()`).\r\n*   Each mode function will contain the scanning and logic specific to that mode.\r\n\r\n**Code Snippet: Basic Mode Structure**\r\n\r\n```cpp\r\n#include <Arduino.h>\r\n// Include other necessary libraries (BLE, vector, etc.)\r\n\r\n// Define constants for modes\r\nenum AppMode {\r\n    MODE_IDLE,\r\n    MODE_TRACKER_DETECT,\r\n    MODE_BASELINE_SCAN,\r\n    MODE_BASELINE_COMPARE\r\n    // We'll add MODE_ADVERTISING_FLOOD in Module 8\r\n};\r\n\r\nAppMode currentMode = MODE_IDLE;\r\n\r\n// Function prototypes for mode logic (we'll define these later)\r\nvoid printMenu();\r\nvoid handleSerialInput();\r\nvoid runTrackerMode();\r\nvoid runBaselineScan();\r\nvoid runBaselineCompare();\r\n\r\nvoid setup() {\r\n    Serial.begin(115200);\r\n    Serial.println(\"ESP32 Bluetooth Recon Tool\");\r\n    // Initialize BLE scanner here (from Module 4)\r\n    // ... BLE setup code ...\r\n\r\n    printMenu(); // Show options on startup\r\n}\r\n\r\nvoid loop() {\r\n    handleSerialInput(); // Check if user wants to change mode\r\n\r\n    switch (currentMode) {\r\n        case MODE_IDLE:\r\n            // Do nothing, or maybe print a waiting message occasionally\r\n            delay(1000);\r\n            break;\r\n        case MODE_TRACKER_DETECT:\r\n            runTrackerMode();\r\n            break;\r\n        case MODE_BASELINE_SCAN:\r\n            runBaselineScan();\r\n            // After baseline scan, maybe switch to IDLE or wait for compare command\r\n            // For now, let's switch back to IDLE after completing the scan phase\r\n            currentMode = MODE_IDLE;\r\n            printMenu(); // Show menu again\r\n            break;\r\n        case MODE_BASELINE_COMPARE:\r\n            runBaselineCompare();\r\n            // After comparison, switch back to IDLE\r\n            currentMode = MODE_IDLE;\r\n            printMenu(); // Show menu again\r\n            break;\r\n        // Add other modes here later\r\n    }\r\n}\r\n\r\nvoid printMenu() {\r\n    Serial.println(\"\\n--- Select Mode ---\");\r\n    Serial.println(\"1: Personal Tracker Detection\");\r\n    Serial.println(\"2: Environmental Baseline Scan (Set Baseline)\");\r\n    Serial.println(\"3: Environmental Baseline Compare (Check against Baseline)\");\r\n    Serial.println(\"0: Go to Idle\");\r\n    Serial.println(\"-------------------\");\r\n    Serial.print(\"Enter command: \");\r\n}\r\n\r\nvoid handleSerialInput() {\r\n    if (Serial.available()) {\r\n        String command = Serial.readStringUntil('\\n');\r\n        command.trim(); // Remove leading/trailing whitespace\r\n\r\n        if (command == \"1\") {\r\n            currentMode = MODE_TRACKER_DETECT;\r\n            Serial.println(\"Switched to: Personal Tracker Detection\");\r\n        } else if (command == \"2\") {\r\n            currentMode = MODE_BASELINE_SCAN;\r\n            Serial.println(\"Switched to: Environmental Baseline Scan\");\r\n        } else if (command == \"3\") {\r\n            // We need a baseline first! Let's add a check.\r\n            // For now, assume baseline exists or just run it.\r\n             currentMode = MODE_BASELINE_COMPARE;\r\n             Serial.println(\"Switched to: Environmental Baseline Compare\");\r\n        } else if (command == \"0\") {\r\n            currentMode = MODE_IDLE;\r\n            Serial.println(\"Switched to: Idle\");\r\n        } else {\r\n            Serial.println(\"Invalid command.\");\r\n        }\r\n        // You might want to print the menu again after handling input,\r\n        // or only when switching *to* IDLE or after a mode completes.\r\n        // Let's print it when switching TO idle or after modes that complete\r\n    }\r\n}\r\n\r\n// Placeholder functions - we'll fill these in next!\r\nvoid runTrackerMode() {\r\n    Serial.println(\"Tracker mode logic goes here...\");\r\n    // Need to scan, process results, look for persistent devices\r\n    // This mode typically runs scans repeatedly\r\n    delay(5000); // Simulate doing work, prevent crashing without real code\r\n}\r\n\r\nvoid runBaselineScan() {\r\n    Serial.println(\"Baseline Scan logic goes here...\");\r\n    // Need to scan for a duration and store devices\r\n    delay(5000); // Simulate scan\r\n    Serial.println(\"Baseline Scan complete.\");\r\n}\r\n\r\nvoid runBaselineCompare() {\r\n    Serial.println(\"Baseline Compare logic goes here...\");\r\n    // Need to scan and compare against stored baseline\r\n    delay(5000); // Simulate scan and compare\r\n    Serial.println(\"Baseline Compare complete.\");\r\n}\r\n```\r\n\r\nThis structure provides the basic framework. Now, let's fill in the logic for each mode, reusing and building upon the scanning and device management code from previous modules.\r\n\r\n### 6.2 Personal Tracker Detection Mode (`runTrackerMode`)\r\n\r\nThe goal here is to identify devices that appear consistently over time, potentially indicating they are associated with the scanner's movement.\r\n\r\n**Logic:**\r\n\r\n1.  **Scan:** Perform a BLE scan.\r\n2.  **Process Results:** Use the `onResult` callback (from Module 4/5) to update our central list of unique devices (from Module 5). This list should contain the device's MAC address, name, last seen timestamp, and perhaps a count of how many times it's been seen.\r\n3.  **Identify Persistent Devices:** Iterate through the list of known devices. A device is considered \"persistent\" if:\r\n    *   It has been seen recently (e.g., `lastSeen` is within the last 30 seconds).\r\n    *   *And* it has been seen a sufficient number of times overall (e.g., `seenCount` > 5). *Or* perhaps, has been present in a certain percentage of recent scans. A simple approach is just checking the `lastSeen` timestamp – if it keeps getting updated frequently, the device is likely still nearby.\r\n4.  **Alert:** If a device meets the persistence criteria *and* is not on an \"ignore\" list (for known devices like your own phone), print an alert. Include its MAC, name, and current RSSI.\r\n5.  **Repeat:** This mode should ideally scan, check, report, and then scan again periodically.\r\n\r\n**Revisiting the Device List (`DeviceInfo`)**\r\n\r\nOur device list structure from Module 5 needs to support this. Let's refine the `DeviceInfo` struct/class:\r\n\r\n```cpp\r\n// Assume this is defined globally or accessible\r\nstruct DeviceInfo {\r\n    BLEAddress address;\r\n    String name;\r\n    int rssi;\r\n    unsigned long lastSeen; // millis() timestamp\r\n    int seenCount;          // How many times seen in total\r\n    // Add other data like manufacturer data if needed later\r\n    bool isBaseline = false; // Used for baseline mode, initialized to false\r\n};\r\n\r\n// Global list of unique devices\r\nstd::vector<DeviceInfo> detectedDevices;\r\n\r\n// Function to find or add a device (from Module 5, potentially slightly modified)\r\nvoid addOrUpdateDevice(BLEAdvertisedDevice* advertisedDevice) {\r\n    BLEAddress deviceAddress = advertisedDevice->getAddress();\r\n    bool found = false;\r\n    unsigned long currentTime = millis();\r\n\r\n    for (size_t i = 0; i < detectedDevices.size(); ++i) {\r\n        if (detectedDevices[i].address == deviceAddress) {\r\n            // Found existing device, update info\r\n            detectedDevices[i].rssi = advertisedDevice->getRSSI();\r\n            detectedDevices[i].lastSeen = currentTime;\r\n            detectedDevices[i].seenCount++; // Increment count\r\n            // Update name if it wasn't known before\r\n            if (detectedDevices[i].name == \"\" && advertisedDevice->getName() != \"\") {\r\n                 detectedDevices[i].name = advertisedDevice->getName();\r\n            }\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        // New device, add it to the list\r\n        DeviceInfo newDevice;\r\n        newDevice.address = deviceAddress;\r\n        newDevice.name = advertisedDevice->getName().c_str(); // getName returns std::string\r\n        newDevice.rssi = advertisedDevice->getRSSI();\r\n        newDevice.lastSeen = currentTime;\r\n        newDevice.seenCount = 1; // First time seen\r\n        newDevice.isBaseline = false; // Not a baseline device by default\r\n\r\n        detectedDevices.push_back(newDevice);\r\n        Serial.print(\"NEW DEVICE FOUND: \");\r\n        Serial.print(newDevice.address.toString().c_str());\r\n        if (newDevice.name != \"\") Serial.print(\" (\"); Serial.print(newDevice.name); Serial.print(\")\");\r\n        Serial.print(\" RSSI: \"); Serial.println(newDevice.rssi);\r\n    }\r\n}\r\n\r\n// The onResult callback function (from Module 4/5)\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice* advertisedDevice) {\r\n        // When a device is found during scanning, call our handler\r\n        addOrUpdateDevice(advertisedDevice);\r\n    }\r\n};\r\n\r\nMyAdvertisedDeviceCallbacks myCallbacks; // Create an instance of the callback class\r\n\r\n// In setup(), initialize BLE and set the scan callbacks:\r\n/*\r\nBLEDevice::init(\"\"); // Name can be anything\r\nBLEScan* pBLEScan = BLEDevice::getScan();\r\npBLEScan->setAdvertisedDeviceCallbacks(&myCallbacks);\r\npBLEScan->setActiveScan(true); // Active scan requests name, etc.\r\npBLEScan->setInterval(100); // Scan interval\r\npBLEScan->setWindow(99);  // Scan window (should be <= interval)\r\n*/\r\n```\r\n\r\nNow, let's write the `runTrackerMode` function using this updated structure.\r\n\r\n**Code Snippet: `runTrackerMode()`**\r\n\r\n```cpp\r\n// Constants for tracker detection\r\nconst unsigned long TRACKER_LAST_SEEN_THRESHOLD_MS = 60000; // Must be seen in last 60 seconds\r\nconst int TRACKER_SEEN_COUNT_THRESHOLD = 5; // Must have been seen at least 5 times\r\n\r\nvoid runTrackerMode() {\r\n    Serial.println(\"\\n--- Tracker Detection Mode ---\");\r\n    Serial.println(\"Scanning for persistent devices...\");\r\n\r\n    // --- Step 1 & 2: Perform Scan and Process Results ---\r\n    // The onResult callback (addOrUpdateDevice) automatically handles updating the list\r\n    // We just need to start and stop the scan.\r\n    // Let's scan for a short period, then process.\r\n    int scanDuration = 5; // seconds\r\n    Serial.print(\"Scanning for \"); Serial.print(scanDuration); Serial.println(\" seconds...\");\r\n    BLEDevice::getScan()->start(scanDuration, false); // 'false' means don't stop when duration ends, we manage it\r\n\r\n    // Important: The scan runs in the background. We need to wait for it to finish\r\n    // or process results *after* it's done. The 'false' above means start async.\r\n    // A simple way is to just wait a bit longer than the scan duration,\r\n    // or check if the scan is still active (pBLEScan->isScanning()).\r\n    // For simplicity in this example, let's just wait. In a real app,\r\n    // you might use a timer or check isScanning().\r\n    delay((scanDuration + 1) * 1000); // Wait for scan duration + 1 second\r\n\r\n    Serial.println(\"Scan complete. Analyzing results...\");\r\n\r\n    unsigned long currentTime = millis();\r\n    int potentialTrackersFound = 0;\r\n\r\n    // --- Step 3: Identify Persistent Devices ---\r\n    Serial.println(\"Potential Trackers Found:\");\r\n    for (const auto& device : detectedDevices) {\r\n        // Check persistence criteria\r\n        bool isPersistent = (currentTime - device.lastSeen <= TRACKER_LAST_SEEN_THRESHOLD_MS) &&\r\n                            (device.seenCount >= TRACKER_SEEN_COUNT_THRESHOLD);\r\n\r\n        // --- Step 4: Alert ---\r\n        // You might add a check here for an \"ignore list\" if you had one\r\n        // bool isIgnored = false; // Implement ignore list check if needed\r\n        // if (isPersistent && !isIgnored) { ... }\r\n\r\n        if (isPersistent) {\r\n            Serial.print(\"  -> \");\r\n            Serial.print(device.address.toString().c_str());\r\n            if (device.name != \"\") Serial.print(\" (\"); Serial.print(device.name); Serial.print(\")\");\r\n            Serial.print(\" RSSI: \"); Serial.print(device.rssi);\r\n            Serial.print(\" Last Seen (ms ago): \"); Serial.print(currentTime - device.lastSeen);\r\n            Serial.print(\" Seen Count: \"); Serial.println(device.seenCount);\r\n            potentialTrackersFound++;\r\n        }\r\n    }\r\n\r\n    if (potentialTrackersFound == 0) {\r\n        Serial.println(\"  (No persistent devices detected meeting current criteria)\");\r\n    }\r\n\r\n    Serial.println(\"--- End Tracker Detection Scan ---\");\r\n\r\n    // --- Step 5: Repeat (or wait for next scan cycle in loop) ---\r\n    // In the main loop, we could add a delay before the next tracker scan cycle\r\n    // or switch back to IDLE after a single scan/report cycle in this function.\r\n    // For this example, let's just return and the main loop will handle delays/re-entry.\r\n    // A better approach for continuous scanning is to keep this mode active\r\n    // in the loop and perform scans periodically *within* runTrackerMode or loop.\r\n    // Let's modify the loop structure slightly to handle continuous modes.\r\n}\r\n```\r\n\r\n**Refining the Continuous Mode Structure:**\r\n\r\nInstead of switching back to `IDLE` immediately, continuous modes like `MODE_TRACKER_DETECT` should stay active and perform their cycle (scan, process, report) repeatedly with a delay.\r\n\r\n```cpp\r\n// Modify loop() structure slightly\r\nvoid loop() {\r\n    handleSerialInput(); // Check if user wants to change mode\r\n\r\n    switch (currentMode) {\r\n        case MODE_IDLE:\r\n            // Do nothing, or maybe print a waiting message occasionally\r\n            delay(500); // Small delay to not hammer CPU\r\n            break;\r\n        case MODE_TRACKER_DETECT:\r\n            runTrackerMode(); // This function should perform one scan/report cycle and return\r\n            delay(1000); // Delay before starting the next tracker scan cycle\r\n            break;\r\n        case MODE_BASELINE_SCAN:\r\n            runBaselineScan();\r\n            // After baseline scan, switch to IDLE and show menu\r\n            currentMode = MODE_IDLE;\r\n            printMenu();\r\n            break;\r\n        case MODE_BASELINE_COMPARE:\r\n            runBaselineCompare();\r\n            // After comparison, switch back to IDLE and show menu\r\n            currentMode = MODE_IDLE;\r\n            printMenu();\r\n            break;\r\n        // Add other modes here later\r\n    }\r\n}\r\n\r\nvoid runTrackerMode() {\r\n    // ... (Code as above) ...\r\n    // This function now performs one scan/analysis cycle and returns.\r\n    // The delay between cycles is in the main loop().\r\n}\r\n```\r\n\r\nThis approach is more flexible for continuous scanning modes.\r\n\r\n### 6.3 Environmental Baseline & Anomaly Detection Mode\r\n\r\nThis mode requires two steps: first, establishing the baseline; second, performing a comparison scan.\r\n\r\n**Logic - Baseline Scan (`runBaselineScan`):**\r\n\r\n1.  **Clear Baseline:** Clear any previously stored baseline data.\r\n2.  **Scan:** Perform a BLE scan for a defined duration (e.g., 30 seconds, 60 seconds). The duration should be long enough to capture most ambient devices.\r\n3.  **Store Baseline:** As devices are found during the scan (via the `onResult` callback), add them to a *separate* list specifically for the baseline, or mark them in the main `detectedDevices` list as `isBaseline = true`. The latter is simpler as we only need one list, but requires careful handling. Let's use a separate list for clarity in this explanation, though you could integrate it.\r\n4.  **Report:** Print a summary of how many unique devices were found and stored in the baseline.\r\n\r\n**Logic - Comparison Scan (`runBaselineCompare`):**\r\n\r\n1.  **Check Baseline:** Ensure a baseline has been set. If not, inform the user.\r\n2.  **Scan:** Perform a BLE scan for a defined duration (could be shorter than the baseline scan).\r\n3.  **Compare and Identify New:** For each device found in *this comparison scan*:\r\n    *   Check if this device's MAC address exists in the *baseline list*.\r\n    *   If the device's MAC address is *not* found in the baseline list, it's a \"new\" or \"anomalous\" device.\r\n4.  **Alert:** Print an alert for each new device found, including its MAC, name, and RSSI.\r\n\r\n**Revisiting the Device List for Baseline**\r\n\r\nWe can either have a `std::vector<DeviceInfo> baselineDevices;` or add a flag `bool isBaseline = false;` to our main `DeviceInfo` struct and manage this flag. Using the flag in the main list is more memory efficient if the lists are large, but requires careful logic to differentiate. Let's stick with a separate `baselineDevices` vector for clarity in this module's explanation and project.\r\n\r\n```cpp\r\n// Global list specifically for baseline devices\r\nstd::vector<DeviceInfo> baselineDevices;\r\n\r\n// Need a flag to know if baseline has been set\r\nbool baselineSet = false;\r\n\r\n// Modify addOrUpdateDevice slightly or create a dedicated function\r\n// For the baseline scan, we need to populate baselineDevices\r\n// For the comparison scan, we scan normally (updating detectedDevices)\r\n// then compare detectedDevices against baselineDevices.\r\n\r\n// Let's keep addOrUpdateDevice as is, and process the results *after* the scan\r\n// in the baseline functions, rather than modifying the callback.\r\n// This separates scanning (putting everything into detectedDevices) from the mode logic.\r\n```\r\n\r\n**Code Snippet: `runBaselineScan()`**\r\n\r\n```cpp\r\nvoid runBaselineScan() {\r\n    Serial.println(\"\\n--- Environmental Baseline Scan Mode ---\");\r\n    Serial.println(\"Setting baseline. Scanning ambient devices...\");\r\n\r\n    // --- Step 1: Clear Baseline ---\r\n    baselineDevices.clear(); // Empty the previous baseline\r\n    detectedDevices.clear(); // Also clear the main list to get a fresh scan for baseline\r\n\r\n    // --- Step 2: Perform Scan ---\r\n    int scanDuration = 30; // Scan for 30 seconds to capture ambient devices\r\n    Serial.print(\"Scanning for \"); Serial.print(scanDuration); Serial.println(\" seconds...\");\r\n\r\n    // Start the scan. The onResult callback will populate detectedDevices\r\n    BLEDevice::getScan()->start(scanDuration, false); // Async scan\r\n\r\n    // Wait for the scan to complete\r\n    delay((scanDuration + 1) * 1000);\r\n\r\n    Serial.println(\"Scan complete. Storing baseline...\");\r\n\r\n    // --- Step 3: Store Baseline ---\r\n    // detectedDevices now contains all unique devices seen during the scan.\r\n    // Copy them to the baselineDevices list.\r\n    baselineDevices = detectedDevices; // Simple copy of the vector\r\n\r\n    baselineSet = true; // Mark that a baseline is now available\r\n\r\n    // --- Step 4: Report ---\r\n    Serial.print(\"Baseline set with \");\r\n    Serial.print(baselineDevices.size());\r\n    Serial.println(\" unique devices.\");\r\n    Serial.println(\"--- End Baseline Scan ---\");\r\n\r\n    // Note: We don't print the full list here, just the count.\r\n    // Could add an option to list baseline devices if desired.\r\n}\r\n```\r\n\r\n**Code Snippet: `runBaselineCompare()`**\r\n\r\n```cpp\r\nvoid runBaselineCompare() {\r\n    Serial.println(\"\\n--- Environmental Baseline Compare Mode ---\");\r\n\r\n    // --- Step 1: Check Baseline ---\r\n    if (!baselineSet) {\r\n        Serial.println(\"Error: Baseline has not been set yet.\");\r\n        Serial.println(\"Please run Environmental Baseline Scan first (Option 2).\");\r\n        Serial.println(\"--- End Baseline Compare ---\");\r\n        return; // Exit the function\r\n    }\r\n\r\n    Serial.print(\"Comparing against baseline of \");\r\n    Serial.print(baselineDevices.size());\r\n    Serial.println(\" devices.\");\r\n    Serial.println(\"Scanning for new devices...\");\r\n\r\n    // --- Step 2: Perform Scan ---\r\n    detectedDevices.clear(); // Clear the main list to get fresh data for comparison\r\n    int scanDuration = 10; // Shorter scan for comparison\r\n    Serial.print(\"Scanning for \"); Serial.print(scanDuration); Serial.println(\" seconds...\");\r\n\r\n    // Start scan. onResult callback populates detectedDevices\r\n    BLEDevice::getScan()->start(scanDuration, false); // Async scan\r\n\r\n    // Wait for scan to complete\r\n    delay((scanDuration + 1) * 1000);\r\n\r\n    Serial.println(\"Scan complete. Identifying new devices...\");\r\n\r\n    int newDevicesFound = 0;\r\n    Serial.println(\"New Devices (Not in Baseline):\");\r\n\r\n    // --- Step 3: Compare and Identify New ---\r\n    // Iterate through the devices found in the *current scan* (detectedDevices)\r\n    for (const auto& currentDevice : detectedDevices) {\r\n        bool foundInBaseline = false;\r\n        // Check if this current device exists in the baseline list\r\n        for (const auto& baseDevice : baselineDevices) {\r\n            if (currentDevice.address == baseDevice.address) {\r\n                foundInBaseline = true;\r\n                break; // Found it in the baseline, no need to"
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Alright, let's dive into Module 7! This is where we flip the script from listening to speaking on the Bluetooth airwaves. It's a fundamental concept for any wireless communication and directly applicable to understanding how devices announce their presence – and how we might simulate or manipulate that.\r\n\r\nHere are the detailed course materials for Module 7:\r\n\r\n---\r\n\r\n## Module 7: Broadcasting Your Presence: Programming the ESP32 as a BLE Advertiser\r\n\r\n*   **Module Title:** Broadcasting Your Presence: Programming the ESP32 as a BLE Advertiser\r\n*   **Module Objective:** Learn how to configure the ESP32 to act as a BLE Broadcaster and send out custom advertising packets. By the end, you'll be able to make your ESP32 visible to other BLE devices and control the information it broadcasts.\r\n*   **Prerequisites:**\r\n    *   Completion of Module 6 (While the code isn't directly dependent, the development environment and basic ESP32 programming skills are assumed).\r\n    *   ESP32 DevkitC board and USB cable.\r\n    *   Arduino IDE with ESP32 board support installed.\r\n    *   A smartphone with a BLE scanning application (e.g., nRF Connect for Android, LightBlue for iOS).\r\n\r\n---\r\n\r\n### Introduction: Stepping from Observer to Broadcaster\r\n\r\nWelcome back! In the previous modules, we've been the quiet observer, scanning the airwaves to see what's out there. We learned how devices announce themselves through advertising packets. Now, it's *our* turn to speak!\r\n\r\nIn this module, we'll configure our ESP32 to become a BLE Broadcaster. This is the role many simple, low-power devices like fitness trackers, beacons (like iBeacons or Eddystone), and even your phone when it's discoverable, play. They periodically send out advertising packets containing information about themselves or data they want to share, without needing a constant connection.\r\n\r\nUnderstanding how to *create* advertising packets is crucial. It solidifies our understanding of their structure (from Module 3) and allows us to:\r\n\r\n1.  Emulate existing devices for testing or research.\r\n2.  Create our own custom beacons.\r\n3.  Lay the groundwork for more advanced techniques like advertising flooding (Module 8).\r\n\r\nLet's get our ESP32 talking!\r\n\r\n### Hardware and Software Setup Refresher\r\n\r\n*   **Hardware:** Your trusty ESP32 DevkitC connected to your computer via a USB cable.\r\n*   **Software:**\r\n    *   Arduino IDE.\r\n    *   Ensure the ESP32 board support package is installed (Tools > Board > ESP32 Arduino > ESP32 Dev Module).\r\n    *   We will again use the `ESP32-BLE-Arduino` library. If you haven't already installed it (you should have in Module 4, but double-check), go to `Sketch > Include Library > Manage Libraries...`, search for \"ESP32 BLE\", and install the one by Neil Kolban, Evandro Copercini, and others.\r\n\r\n### Understanding the ESP32 BLE Library for Advertising\r\n\r\nThe same library we used for scanning (`ESP32-BLE-Arduino`) also handles the advertising side. It provides classes and functions to initialize the BLE subsystem, configure advertising data, set parameters, and start/stop the advertising process.\r\n\r\nKey classes/objects we'll interact with:\r\n\r\n*   **`BLEDevice`**: Handles the overall BLE subsystem initialization.\r\n*   **`BLEAdvertising`**: The object responsible for managing the advertising process (setting parameters, starting/stopping). You get an instance of this via `BLEDevice::getAdvertising()`.\r\n*   **`BLEAdvertisementData`**: An object used to build the *contents* of the advertising packet. This is where you put the device name, service UUIDs, manufacturer data, etc.\r\n*   **`BLEScanResponseData` (Optional but Good Practice)**: Similar to `BLEAdvertisementData`, but for the *scan response* packet. Scanners can request this secondary packet for more data if the initial advertisement is too full or basic. We'll primarily focus on the main advertising data for this module's project.\r\n\r\n### Step 1: Initializing the BLE Subsystem\r\n\r\nJust like with scanning, the first step is to initialize the BLE stack on the ESP32.\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h> // Often included, though we won't use server features here\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  // Initialize BLE. You can optionally provide a default device name here.\r\n  BLEDevice::init(\"MyESP32Advertiser\");\r\n  Serial.println(\"BLE initialized.\");\r\n\r\n  // The rest of our advertising setup will go here...\r\n}\r\n\r\nvoid loop() {\r\n  // Advertising runs in the background, so the loop can be simple\r\n  // or handle other tasks. For now, just a small delay.\r\n  delay(1000);\r\n}\r\n```\r\n\r\n*   `BLEDevice::init(\"MyESP32Advertiser\");`: This function initializes the BLE hardware and software stack. The string provided is the *default* device name, though we'll show how to set the advertised name specifically in the advertising data.\r\n\r\nUpload this sketch. Open the Serial Monitor. You should see the \"Starting BLE Advertiser...\" and \"BLE initialized.\" messages. The ESP32 isn't advertising *yet*, we've just turned on the engine.\r\n\r\n### Step 2: Getting the Advertising Object\r\n\r\nWe need to get a reference to the `BLEAdvertising` object to configure and control the advertising process.\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h>\r\n\r\nBLEAdvertising *pAdvertising; // Declare a pointer to the advertising object\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  BLEDevice::init(\"MyESP32Advertiser\");\r\n  Serial.println(\"BLE initialized.\");\r\n\r\n  // Get the advertising object\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n  Serial.println(\"Advertising object obtained.\");\r\n\r\n  // The rest of our advertising setup will go here...\r\n}\r\n\r\nvoid loop() {\r\n  delay(1000);\r\n}\r\n```\r\n\r\n*   `BLEAdvertising *pAdvertising;`: We declare a pointer globally (or within `setup` if preferred, but global makes it easier if we needed it in `loop`).\r\n*   `pAdvertising = BLEDevice::getAdvertising();`: This gets the singleton instance of the advertising manager.\r\n\r\nStill no advertising, but we're ready to configure it.\r\n\r\n### Step 3: Configuring the Advertising Data (`BLEAdvertisementData`)\r\n\r\nThis is where we define *what* information our ESP32 will broadcast. We create a `BLEAdvertisementData` object and add the desired data fields.\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h>\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  BLEDevice::init(\"MyESP32Advertiser\"); // Default name\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n  Serial.println(\"Advertising object obtained.\");\r\n\r\n  // *** Configure the Advertising Data ***\r\n  BLEAdvertisementData advData;\r\n\r\n  // 1. Set Flags (important for discoverability)\r\n  // BLE_HS_ADV_F_DISC_GEN (0x02) - General Discoverable Mode\r\n  // BLE_HS_ADV_F_BREDR_UNSUP (0x04) - BR/EDR (Classic) not supported\r\n  // Combined: 0x02 | 0x04 = 0x06\r\n  advData.setFlags(0x06);\r\n  Serial.println(\"Flags set.\");\r\n\r\n  // 2. Set the complete local device name\r\n  advData.setCompleteDeviceName(\"MyCustomESP32\");\r\n  Serial.println(\"Device name set.\");\r\n\r\n  // 3. Add a Service UUID (Optional, but common for identifying device type/service)\r\n  // This is a standard UUID for the \"Device Information Service\" (0x180A)\r\n  // You could add your own custom UUID here if needed.\r\n  advData.addServiceUUID(\"180A\");\r\n  Serial.println(\"Service UUID added.\");\r\n\r\n  // --- We will add Manufacturer Data in Step 5 ---\r\n\r\n  // Set the configured advertising data to the advertising object\r\n  pAdvertising->setAdvertisementData(advData);\r\n  Serial.println(\"Advertising data configured.\");\r\n\r\n  // The rest of our advertising setup will go here (parameters, start)...\r\n}\r\n\r\nvoid loop() {\r\n  delay(1000);\r\n}\r\n```\r\n\r\n*   `BLEAdvertisementData advData;`: Creates an object to hold the advertising data.\r\n*   `advData.setFlags(0x06);`: Sets the advertising flags. `0x06` is a common value indicating the device is generally discoverable and doesn't support Bluetooth Classic.\r\n*   `advData.setCompleteDeviceName(\"MyCustomESP32\");`: Sets the device name that will appear in the advertising packet. This overrides the name set in `BLEDevice::init()`.\r\n*   `advData.addServiceUUID(\"180A\");`: Adds a 16-bit service UUID (0x180A) to the advertising data. This tells scanners that this device offers the Device Information Service.\r\n*   `pAdvertising->setAdvertisementData(advData);`: Attaches the configured `advData` object to the `BLEAdvertising` object, preparing it for broadcast.\r\n\r\nUpload and run. Still no visible advertising, but the *data* is ready to be sent.\r\n\r\n### Step 4: Setting Advertising Parameters and Starting\r\n\r\nNow that the data is ready, we need to tell the ESP32 *how* to advertise (how often, how strong) and then tell it to start broadcasting.\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h>\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  BLEDevice::init(\"MyESP32Advertiser\");\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n\r\n  BLEAdvertisementData advData;\r\n  advData.setFlags(0x06);\r\n  advData.setCompleteDeviceName(\"MyCustomESP32\");\r\n  advData.addServiceUUID(\"180A\");\r\n  // Manufacturer data will be added later\r\n  pAdvertising->setAdvertisementData(advData);\r\n  Serial.println(\"Advertising data configured.\");\r\n\r\n\r\n  // *** Configure and Start Advertising Parameters ***\r\n\r\n  // Set advertising interval (in units of 0.625ms).\r\n  // 160 * 0.625ms = 100ms. A common interval.\r\n  pAdvertising->setAdvertisingInterval(160);\r\n  Serial.println(\"Advertising interval set to 100ms.\");\r\n\r\n  // Set Tx Power (Transmit Power). Range is 0 to 7 for ESP32.\r\n  // 0: -12dBm (lowest power, shortest range)\r\n  // 7: +9dBm (highest power, longest range)\r\n  // Default is often 7. Let's explicitly set it high for visibility.\r\n  pAdvertising->setTxPower(7);\r\n  Serial.println(\"Tx Power set to +9dBm.\");\r\n\r\n  // Start advertising!\r\n  pAdvertising->startAdvertising();\r\n  Serial.println(\"Advertising started!\");\r\n\r\n  // Optional: Stop advertising after a set time (e.g., 30 seconds)\r\n  // pAdvertising->startAdvertising(30000); // Advertise for 30 seconds\r\n}\r\n\r\nvoid loop() {\r\n  // Advertising runs in the background\r\n  delay(1000);\r\n  Serial.println(\"ESP32 is advertising...\"); // Optional: Add a message to show it's running\r\n}\r\n```\r\n\r\n*   `pAdvertising->setAdvertisingInterval(160);`: Sets how frequently the advertising packets are sent. The unit is 0.625ms. `160 * 0.625ms = 100ms`, which is a fairly rapid interval. Shorter intervals mean faster discovery but use more power.\r\n*   `pAdvertising->setTxPower(7);`: Sets the transmit power. Higher values mean longer range but consume more power. `7` is typically the maximum for the ESP32, yielding the longest range.\r\n*   `pAdvertising->startAdvertising();`: This is the command that tells the ESP32 to begin broadcasting the configured advertising data repeatedly at the specified interval.\r\n*   `pAdvertising->startAdvertising(30000);`: An alternative version to start advertising for a specific duration in milliseconds. If you use this, advertising will automatically stop after that time.\r\n\r\nUpload this sketch. Open the Serial Monitor. You should see messages confirming setup and \"Advertising started!\".\r\n\r\n**Now, grab your smartphone!** Open your BLE scanning app (nRF Connect, LightBlue, etc.). Start scanning for devices. You should see a device named \"MyCustomESP32\" appear in the list! Tap on it to see its details. You should see the flags, the name, and the 0x180A service UUID in the advertising data section.\r\n\r\nCongratulations, your ESP32 is now a BLE Broadcaster!\r\n\r\n### Step 5: Adding Custom Manufacturer Data (Project Requirement)\r\n\r\nOne of the most flexible parts of BLE advertising is the Manufacturer Specific Data field. This allows manufacturers (or us, in this case) to include arbitrary data in the advertising packet. This is how devices like beacons transmit unique identifiers or sensor data.\r\n\r\nThe format for Manufacturer Specific Data is typically:\r\n\r\n`[Length] [Type (0xFF for Manufacturer Specific)] [Company ID (2 bytes)] [Manufacturer Data (variable length)]`\r\n\r\nThe `ESP32-BLE-Arduino` library simplifies this. You just provide the `Company ID` (a standard 16-bit number assigned by the Bluetooth SIG, though you can use vendor-specific ranges like 0xFFFE/0xFFFF for custom/testing) followed by your custom data bytes, all packed into a `std::string`.\r\n\r\nLet's modify our code to add some custom manufacturer data. We'll use `0xFFFF` as a placeholder Company ID and add a simple sequence of bytes like `0x12, 0x34, 0x56, 0x78`.\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h>\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  BLEDevice::init(\"MyESP32Advertiser\");\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n\r\n  BLEAdvertisementData advData;\r\n  advData.setFlags(0x06);\r\n  advData.setCompleteDeviceName(\"MyCustomESP32\");\r\n  advData.addServiceUUID(\"180A\");\r\n  Serial.println(\"Basic advertising data set.\");\r\n\r\n  // *** Add Custom Manufacturer Data ***\r\n  // Company ID (2 bytes, e.g., 0xFFFF for testing) followed by custom data bytes.\r\n  // The library expects this as a std::string.\r\n  // We need to represent the bytes correctly in the string.\r\n  // \"\\xFF\\xFF\" are the two bytes for the Company ID 0xFFFF.\r\n  // \"\\x12\\x34\\x56\\x78\" are our custom data bytes.\r\n  std::string manufacturerData = \"\";\r\n  manufacturerData += (char)0xFF; // First byte of Company ID (LSB)\r\n  manufacturerData += (char)0xFF; // Second byte of Company ID (MSB)\r\n  manufacturerData += (char)0x12; // Custom Data Byte 1\r\n  manufacturerData += (char)0x34; // Custom Data Byte 2\r\n  manufacturerData += (char)0x56; // Custom Data Byte 3\r\n  manufacturerData += (char)0x78; // Custom Data Byte 4\r\n\r\n  advData.setManufacturerData(manufacturerData);\r\n  Serial.println(\"Manufacturer data added.\");\r\n\r\n  pAdvertising->setAdvertisementData(advData);\r\n  Serial.println(\"Advertising data configured.\");\r\n\r\n  pAdvertising->setAdvertisingInterval(160);\r\n  pAdvertising->setTxPower(7);\r\n\r\n  pAdvertising->startAdvertising();\r\n  Serial.println(\"Advertising started!\");\r\n}\r\n\r\nvoid loop() {\r\n  delay(1000);\r\n  Serial.println(\"ESP32 is advertising...\");\r\n}\r\n```\r\n\r\n*   `std::string manufacturerData = \"\";`: We create an empty string to build our data payload.\r\n*   `manufacturerData += (char)byte;`: We append each byte of our manufacturer data (Company ID + custom data) to the string. Casting to `(char)` ensures we are adding the raw byte value, not its ASCII representation.\r\n*   `advData.setManufacturerData(manufacturerData);`: Attaches this byte sequence as the Manufacturer Specific Data in the advertising packet.\r\n\r\nUpload this sketch. Open the Serial Monitor. Grab your phone and scan again. Find \"MyCustomESP32\". Now, when you inspect its details in the BLE scanner app, you should see a section for \"Manufacturer Specific Data\". The app should show the Company ID (0xFFFF) and your custom data bytes (12 34 56 78).\r\n\r\nYou have successfully programmed your ESP32 to broadcast custom data!\r\n\r\n### Step 6: Broadcasting Different Packet Types (Briefly)\r\n\r\nBLE advertising can actually involve two types of packets sent by the Broadcaster:\r\n\r\n1.  **Advertising Packet:** Sent periodically by the Broadcaster. This is the main packet we've been configuring with `setAdvertisementData()`. It has a limited size (typically 31 bytes payload).\r\n2.  **Scan Response Packet:** Sent *only* when a Scanner (acting as an Active Scanner) specifically requests more information after seeing the initial advertising packet. This allows the Broadcaster to provide additional data beyond the 31-byte limit of the advertising packet.\r\n\r\nYou can configure the scan response data using `BLEScanResponseData` and `pAdvertising->setScanResponseData()`, similar to how we configured the advertising data.\r\n\r\n```cpp\r\n// ... inside setup() after setting advData ...\r\n\r\n  // Optional: Configure Scan Response Data\r\n  BLEScanResponseData scanResponseData;\r\n  scanResponseData.setCompleteLocalName(\"MyESP32FullDetails\"); // A different name just for scan response\r\n  scanResponseData.addServiceUUID(\"ABCD\"); // Another service UUID\r\n\r\n  pAdvertising->setScanResponseData(scanResponseData);\r\n  Serial.println(\"Scan response data configured.\");\r\n\r\n// ... rest of setup() ...\r\n```\r\n\r\nIf you add the `setScanResponseData` line, some scanner apps (like nRF Connect) will show the scan response data when you tap on the device entry. Others might just show the advertising data. This is less critical for our main reconnaissance tool, but important to know for completeness.\r\n\r\n### Ethical Considerations (A Preview)\r\n\r\nWe've now built a device that broadcasts its presence. Generally, broadcasting is a passive activity, designed to be discovered. However, controlling *what* you broadcast and *how often* you broadcast it can have implications.\r\n\r\n*   **What you broadcast:** Could you impersonate another device type by using specific service UUIDs or manufacturer data? Yes. Could you broadcast misleading information? Yes.\r\n*   **How often you broadcast:** While normal advertising intervals are 100ms or slower, what happens if you advertise as fast as possible? This is the concept of advertising flooding, which we will explore in Module 8. Excessive advertising can potentially disrupt other BLE communications in the area.\r\n\r\nFor this module's project, broadcasting a custom name and data is harmless and educational. But always remember the principle of **\"Do no harm\"** when experimenting with wireless technologies. We will delve much deeper into ethics in the final module.\r\n\r\n### Module Project/Exercise\r\n\r\n**Goal:** Program your ESP32 to advertise with a custom device name and include custom manufacturer-specific data.\r\n\r\n**Instructions:**\r\n\r\n1.  Start with the code from Step 5.\r\n2.  Modify the `setCompleteDeviceName()` call to use your own unique name (e.g., \"YourName_ESP32_Beacon\").\r\n3.  Modify the custom data bytes in the `manufacturerData` string. Include at least 4 bytes of data that are unique to you (e.g., your initials encoded as hex, or random numbers). Remember the first two bytes are the Company ID (we'll stick with 0xFFFF for testing).\r\n4.  Upload the modified sketch to your ESP32.\r\n5.  Open your BLE scanning app on your smartphone.\r\n6.  Scan for devices.\r\n7.  Verify that you see your ESP32 device listed with the custom name you set.\r\n8.  Tap on the device entry in the app to view its details.\r\n9.  Locate the \"Manufacturer Specific Data\" section. Verify that it shows the Company ID (0xFFFF) and the custom data bytes you included in your sketch.\r\n\r\n**Code Structure Hint:**\r\n\r\n```cpp\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEServer.h>\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  Serial.println(\"Starting BLE Advertiser...\");\r\n\r\n  BLEDevice::init(\"DefaultESP32Name\"); // You can keep or change this, setCompleteDeviceName overrides it\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n\r\n  BLEAdvertisementData advData;\r\n  advData.setFlags(0x06);\r\n\r\n  // --- MODIFY THIS LINE ---\r\n  advData.setCompleteDeviceName(\"YourName_ESP32_Beacon\"); // <-- Put your custom name here!\r\n\r\n  advData.addServiceUUID(\"180A\"); // Keep or change this UUID\r\n\r\n  // --- MODIFY THESE BYTES ---\r\n  // Company ID (0xFFFF) + your custom data bytes\r\n  std::string manufacturerData = \"\";\r\n  manufacturerData += (char)0xFF; // Company ID Byte 1 (LSB)\r\n  manufacturerData += (char)0xFF; // Company ID Byte 2 (MSB)\r\n  manufacturerData += (char)0xAA; // <-- Replace with your custom data byte 1\r\n  manufacturerData += (char)0xBB; // <-- Replace with your custom data byte 2\r\n  manufacturerData += (char)0xCC; // <-- Replace with your custom data byte 3\r\n  manufacturerData += (char)0xDD; // <-- Replace with your custom data byte 4\r\n  // Add more bytes if you like!\r\n\r\n  advData.setManufacturerData(manufacturerData);\r\n  Serial.println(\"Manufacturer data added.\");\r\n\r\n  pAdvertising->setAdvertisementData(advData);\r\n  Serial.println(\"Advertising data configured.\");\r\n\r\n  pAdvertising->setAdvertisingInterval(160); // 100ms interval\r\n  pAdvertising->setTxPower(7); // Max power\r\n\r\n  pAdvertising->startAdvertising();\r\n  Serial.println(\"Advertising started!\");\r\n  Serial.println(\"Scan for 'YourName_ESP32_Beacon' with a BLE scanner app.\");\r\n  Serial.println(\"Check manufacturer data for 0xFFFF followed by your custom bytes.\");\r\n}\r\n\r\nvoid loop() {\r\n  delay(1000);\r\n  // Advertising continues in the background\r\n}\r\n```\r\n\r\nThis exercise confirms your understanding of configuring and starting BLE advertising with specific data payloads.\r\n\r\n### Summary\r\n\r\nIn this module, we successfully transformed our ESP32 from a passive BLE scanner into an active BLE Broadcaster. We learned how to:\r\n\r\n*   Initialize the ESP32's BLE subsystem for advertising.\r\n*   Obtain and use the `BLEAdvertising` object.\r\n*   Build an advertising packet payload using `BLEAdvertisementData`, including setting flags, device name, service UUIDs, and crucially, custom manufacturer data.\r\n*   Set advertising parameters like interval and transmit power.\r\n*   Start the advertising process.\r\n*   Verify our ESP32's advertisements using a smartphone BLE scanning app.\r\n\r\nYou now have the fundamental skill of making a BLE device announce its presence and transmit custom information wirelessly. This is the other half of the BLE communication coin and sets the stage for more advanced techniques in the next module.\r\n\r\n### Suggested Resources or Prerequisites\r\n\r\n*   The official documentation or examples for the `ESP32-BLE-Arduino` library (search for \"ESP32 BLE Advertise example\").\r\n*   Bluetooth SIG documentation overview on BLE Advertising Data types (AD Types).\r\n*   Experiment with different advertising intervals and Tx Power settings to see how it affects discovery speed and range.\r\n*   Explore adding `BLEScanResponseData` to your sketch and see how it appears in your scanner app.\r\n\r\nOnwards to the final module, where we integrate our scanning and advertising knowledge and explore the powerful (and ethically sensitive) concept of advertising flooding!\r\n\r\n---"
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Okay, let's dive deep into the final, culminating module! This is where we bring everything together, add a powerful (and ethically sensitive) new mode, and wrap up our journey by building the complete multi-mode tool.\r\n\r\nAs your guide and fellow enthusiast, I'm thrilled to help you synthesize all the knowledge and code we've built. Remember, with powerful tools comes great responsibility. This module will equip you with the skills and the crucial understanding of when and *how* to use them ethically.\r\n\r\n---\r\n\r\n# Module 8: Building the Multi-Mode Tool and Ethical Considerations\r\n\r\n**Module Title:** Building the Multi-Mode Tool and Ethical Considerations\r\n\r\n**Module Objective:** Integrate all three operational modes into a single application, implement the advertising flooding mode, and understand the ethical implications of using such tools.\r\n\r\n**Learning Outcomes:** By the end of this module, you will be able to:\r\n\r\n*   Structure an embedded application to support multiple distinct operating modes.\r\n*   Implement a simple menu system for user interaction via the Serial Monitor.\r\n*   Successfully integrate the Personal Tracker and Environmental Baseline detection logic into a unified codebase.\r\n*   Program the ESP32 to perform rapid and potentially randomized Bluetooth Low Energy (BLE) advertising (Advertising Flooding).\r\n*   Explain the potential impacts (intended and unintended) of BLE advertising flooding.\r\n*   Articulate the critical ethical and legal considerations associated with using RF reconnaissance and disruption tools.\r\n*   Refine and optimize your ESP32 code for better performance and resource usage.\r\n*   Complete the final capstone project: a functional multi-mode ESP32 Bluetooth Recon Tool.\r\n\r\n---\r\n\r\n## 8.1 Recap and Preparation: Gathering Your Code Assets\r\n\r\nWelcome to the final stage! Over the past seven modules, you've built foundational skills:\r\n\r\n*   Setting up the ESP32 environment (Module 1).\r\n*   Embedded C++ programming (Module 2).\r\n*   Deeply understanding Bluetooth, especially BLE advertising (Module 3).\r\n*   Programming the ESP32 to scan for BLE devices (Module 4).\r\n*   Processing scan results, identifying unique devices, and managing a device list (Module 5).\r\n*   Implementing the core logic for Personal Tracker and Environmental Baseline detection modes (Module 6).\r\n*   Programming the ESP32 to act as a BLE advertiser (Module 7).\r\n\r\nYour task now is to take the key code components from Modules 4, 5, 6, and 7 and integrate them into a single, cohesive application.\r\n\r\n**Action:**\r\n\r\n1.  Open the Arduino sketches you developed for Modules 4, 5, 6, and 7.\r\n2.  Identify the core functions and data structures from each:\r\n    *   BLE scanning setup (`BLEDevice::init()`, `pBLEScan->setAdvertisedDeviceCallbacks()`, `pBLEScan->start()`).\r\n    *   The `onResult` callback function (handling incoming scan data).\r\n    *   Your device data structure (`struct` or `class` for storing MAC, name, RSSI, last seen, etc.).\r\n    *   Your device list management functions (`findDevice`, `addDevice`, `updateDevice`, potentially `printDeviceList`).\r\n    *   The core logic within your Module 6 sketches for the Tracker mode (checking persistence, RSSI changes) and Baseline mode (storing baseline, comparing).\r\n    *   The BLE advertising setup and start/stop functions from Module 7.\r\n3.  Create a *new* empty sketch for Module 8. This will be your final project file.\r\n\r\n## 8.2 Designing the Multi-Mode Structure: The Serial Menu\r\n\r\nHow will the user tell the ESP32 which mode to run? The outline suggests a menu system via the Serial Monitor. This is a common and simple way to interact with embedded projects without adding extra hardware like buttons or screens.\r\n\r\nWe'll structure the code around a variable that holds the current operating mode and use the `loop()` function to check this variable and execute the code corresponding to that mode. We'll also add logic to read input from the Serial Monitor to change the mode.\r\n\r\n**Core Concepts:**\r\n\r\n*   **Mode Variable:** A global variable (e.g., an `enum` or simple `int`) to store the current mode.\r\n*   **Menu Function:** A function to print the available options to the Serial Monitor.\r\n*   **Input Handling:** Code in `loop()` (or a dedicated function) to read user input from Serial and update the mode variable.\r\n*   **Mode Execution:** A `switch` statement or `if/else if` chain in `loop()` to call the appropriate function for the current mode.\r\n\r\n**Example Structure (Pseudocode):**\r\n\r\n```cpp\r\n// Define modes\r\nenum AppMode {\r\n    MODE_MENU,\r\n    MODE_TRACKER,\r\n    MODE_BASELINE_SCAN, // Baseline requires two steps\r\n    MODE_BASELINE_COMPARE,\r\n    MODE_FLOODING,\r\n    MODE_STOPPED // A neutral state\r\n};\r\n\r\nAppMode currentMode = MODE_MENU;\r\nbool baselineSet = false; // Needed for baseline mode state\r\n\r\n// --- Function Prototypes (Declare functions before using them) ---\r\nvoid printMenu();\r\nvoid handleSerialInput();\r\nvoid runTrackerMode();\r\nvoid runBaselineModeScan();\r\nvoid runBaselineModeCompare();\r\nvoid runFloodingMode();\r\n// ... other helper functions\r\n\r\n// --- Setup ---\r\nvoid setup() {\r\n    Serial.begin(115200);\r\n    // Initialize BLE (common for scanning/advertising)\r\n    BLEDevice::init(\"\"); // Name not needed for scanning/advertising init\r\n    printMenu(); // Show menu on startup\r\n}\r\n\r\n// --- Main Loop ---\r\nvoid loop() {\r\n    handleSerialInput(); // Check for user input to change mode\r\n\r\n    switch (currentMode) {\r\n        case MODE_MENU:\r\n            // Menu is passive, just waits for input handled by handleSerialInput\r\n            delay(10); // Small delay to avoid watchdog timer issues\r\n            break;\r\n        case MODE_TRACKER:\r\n            runTrackerMode();\r\n            break;\r\n        case MODE_BASELINE_SCAN:\r\n            runBaselineModeScan(); // This function should transition to MENU or COMPARE after scan\r\n            break;\r\n        case MODE_BASELINE_COMPARE:\r\n             runBaselineModeCompare(); // This function should transition to MENU after scan\r\n             break;\r\n        case MODE_FLOODING:\r\n            runFloodingMode(); // This function runs continuously until mode changes\r\n            break;\r\n        case MODE_STOPPED:\r\n            // Do nothing, just wait for input\r\n            delay(100);\r\n            break;\r\n    }\r\n\r\n    // Note: Some modes (like scanning) might block or take time.\r\n    // We'll need to adjust the mode functions to be non-blocking if possible,\r\n    // or accept that a mode runs until complete or interrupted by input.\r\n    // For simplicity in this capstone, modes like scanning or flooding might\r\n    // run for a set duration or until a new mode is selected via Serial.\r\n}\r\n\r\n// --- Menu and Input Handling ---\r\nvoid printMenu() {\r\n    Serial.println(F(\"\\n--- ESP32 Bluetooth Reconnaissance Tool ---\"));\r\n    Serial.println(F(\"Select a mode:\"));\r\n    Serial.println(F(\"1. Personal Tracker Detection\"));\r\n    Serial.println(F(\"2. Environmental Baseline Analysis (Scan)\"));\r\n    Serial.println(F(\"3. Environmental Baseline Analysis (Compare)\"));\r\n    Serial.println(F(\"4. Bluetooth Advertising Flooding (USE ETHICALLY!)\"));\r\n    Serial.println(F(\"5. Stop Current Mode\"));\r\n    Serial.println(F(\"M. Print Menu\"));\r\n    Serial.print(F(\"Enter selection: \"));\r\n}\r\n\r\nvoid handleSerialInput() {\r\n    if (Serial.available()) {\r\n        char input = Serial.read();\r\n        // Consume the rest of the line if needed (e.g., newline characters)\r\n        while(Serial.available()) Serial.read();\r\n\r\n        Serial.print(F(\"Input received: \"));\r\n        Serial.println(input);\r\n\r\n        // Stop any ongoing mode before changing\r\n        // (Need functions to stop scanning/advertising)\r\n        // Example: BLEDevice::getScan()->stop(); BLEDevice::getAdvertising()->stop();\r\n        // We'll add these stop calls within the mode change logic.\r\n\r\n        switch (input) {\r\n            case '1':\r\n                Serial.println(F(\"Switching to Personal Tracker Mode...\"));\r\n                // Stop any previous activity\r\n                BLEDevice::getScan()->stop(); // Stop scan if running\r\n                BLEDevice::getAdvertising()->stop(); // Stop advertising if running\r\n                currentMode = MODE_TRACKER;\r\n                break;\r\n            case '2':\r\n                Serial.println(F(\"Starting Baseline Scan...\"));\r\n                 // Stop any previous activity\r\n                BLEDevice::getScan()->stop(); // Stop scan if running\r\n                BLEDevice::getAdvertising()->stop(); // Stop advertising if running\r\n                baselineSet = false; // Reset baseline state\r\n                currentMode = MODE_BASELINE_SCAN;\r\n                break;\r\n             case '3':\r\n                if (!baselineSet) {\r\n                    Serial.println(F(\"Error: Baseline not set yet. Run Baseline Scan (Option 2) first.\"));\r\n                    currentMode = MODE_MENU; // Stay in menu or go back to menu\r\n                    printMenu();\r\n                } else {\r\n                    Serial.println(F(\"Starting Baseline Comparison...\"));\r\n                     // Stop any previous activity\r\n                    BLEDevice::getScan()->stop(); // Stop scan if running\r\n                    BLEDevice::getAdvertising()->stop(); // Stop advertising if running\r\n                    currentMode = MODE_BASELINE_COMPARE;\r\n                }\r\n                break;\r\n            case '4':\r\n                Serial.println(F(\"WARNING: Switching to Advertising Flooding Mode. Use ETHICALLY and with PERMISSION ONLY!\"));\r\n                 // Stop any previous activity\r\n                BLEDevice::getScan()->stop(); // Stop scan if running\r\n                BLEDevice::getAdvertising()->stop(); // Stop advertising if running\r\n                // Add a confirmation step here for safety!\r\n                Serial.println(F(\"Type 'YES' to confirm flooding or anything else to cancel:\"));\r\n                // We'll need to read another line for confirmation... this complicates handleSerialInput.\r\n                // Alternative: A simpler confirmation like '4Y' to start flooding. Let's go with that for simplicity.\r\n                // Refined logic: if input is '4', print warning, expect 'Y' next.\r\n                // For now, let's assume '4' directly triggers it, but we'll add the warning print.\r\n                currentMode = MODE_FLOODING;\r\n                break;\r\n            case '5':\r\n                Serial.println(F(\"Stopping current mode.\"));\r\n                BLEDevice::getScan()->stop(); // Stop scan if running\r\n                BLEDevice::getAdvertising()->stop(); // Stop advertising if running\r\n                currentMode = MODE_STOPPED;\r\n                printMenu(); // Show menu after stopping\r\n                break;\r\n            case 'M':\r\n            case 'm':\r\n                printMenu();\r\n                currentMode = MODE_MENU; // Ensure we are in menu state\r\n                break;\r\n            default:\r\n                Serial.println(F(\"Invalid selection.\"));\r\n                printMenu();\r\n                currentMode = MODE_MENU; // Ensure we are in menu state\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n// --- Mode Functions (Implement these based on previous modules) ---\r\n\r\nvoid runTrackerMode() {\r\n    // Your Module 6 Tracker logic goes here.\r\n    // It should likely involve:\r\n    // 1. Starting a BLE scan.\r\n    // 2. The onResult callback populating/updating your device list.\r\n    // 3. Periodically (or within onResult, carefully) checking the device list\r\n    //    for persistence/RSSI changes and printing alerts.\r\n    // 4. Decide how long the scan runs before restarting or if it runs continuously.\r\n    //    Continuous scanning is typical for tracking.\r\n    //    Need to ensure onResult is registered *before* starting the scan.\r\n    //    The scan itself often runs in the background once started.\r\n    //    The loop() function can then do other checks or just yield/delay.\r\n\r\n    static bool scanStarted = false; // Use static to track state within the function\r\n    if (!scanStarted) {\r\n        Serial.println(F(\"Tracker mode: Scanning...\"));\r\n        BLEScan* pBLEScan = BLEDevice::getScan();\r\n        pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Your callback class from M4/M5\r\n        pBLEScan->setActiveScan(true); // Active scan gets scan response data\r\n        pBLEScan->setInterval(100); // Scan interval in ms\r\n        pBLEScan->setWindow(99);  // Scan window in ms (should be <= interval)\r\n        pBLEScan->start(0, false); // 0 = scan until stopped, false = don't return results here, use callback\r\n        scanStarted = true;\r\n        // Need logic to process the deviceList periodically in the loop\r\n        // Or have the onResult callback trigger processing (be careful of processing time in callback!)\r\n    }\r\n\r\n    // In the main loop(), when currentMode is MODE_TRACKER, you'd call this function.\r\n    // This function itself might just configure and start the scan once,\r\n    // and the actual tracking logic runs via the onResult callback and/or\r\n    // a periodic check within loop() or a separate task.\r\n\r\n    // Simple approach for now: just start scan and let onResult print.\r\n    // More advanced: have a timer/counter in loop() that, when currentMode is TRACKER,\r\n    // triggers a check of the global device list for tracking conditions.\r\n    // For capstone, let's keep it simpler: onResult adds/updates list, loop() periodically checks list.\r\n\r\n    // Example periodic check in loop() when currentMode == MODE_TRACKER:\r\n    // Check deviceList for tracking conditions (e.g., seen in last X seconds, RSSI changing rapidly)\r\n    // Print alerts.\r\n    // Need a mechanism to manage the device list over time (remove old devices).\r\n\r\n    // Placeholder:\r\n    Serial.println(F(\"Tracker mode running. Scanning in background...\"));\r\n    // Add your tracking logic here - likely needs access to the global device list\r\n    // and possibly timekeeping.\r\n    // Example: check deviceList for devices seen recently, analyze RSSI trend.\r\n    // This part is highly dependent on your Module 6 implementation.\r\n    // Make sure your device list is accessible globally or passed appropriately.\r\n    delay(1000); // Small delay in loop while scanning runs async\r\n\r\n}\r\n\r\nvoid runBaselineModeScan() {\r\n    // Your Module 6 Baseline Scan logic goes here.\r\n    // 1. Clear the baseline device list.\r\n    // 2. Start a BLE scan for a fixed duration (e.g., 60 seconds).\r\n    // 3. The onResult callback populates/updates a TEMPORARY device list for this scan.\r\n    // 4. After the scan duration, copy the temporary list to the BASELINE list.\r\n    // 5. Set baselineSet = true.\r\n    // 6. Print scan results and transition back to the menu or STOPPED mode.\r\n\r\n    Serial.println(F(\"Baseline Scan mode: Scanning for baseline...\"));\r\n    // Need to clear the baseline device list here.\r\n    // Need to set up and start a scan for a *fixed* duration (e.g., pBLEScan->start(60, false)).\r\n    // onResult callback needs to populate a *different* list than the tracker mode might use,\r\n    // or the callback needs to know which mode is active.\r\n    // Let's use separate lists: `trackerDeviceList` and `baselineDeviceList`.\r\n    // The onResult callback will need access to both and update the appropriate one based on `currentMode`.\r\n\r\n    // Placeholder:\r\n    Serial.println(F(\"Scanning for 60 seconds to establish baseline...\"));\r\n    // Start scan for 60 seconds\r\n    BLEScan* pBLEScan = BLEDevice::getScan();\r\n    pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Same callback, needs mode awareness\r\n    pBLEScan->setActiveScan(true);\r\n    pBLEScan->setInterval(100);\r\n    pBLEScan->setWindow(99);\r\n    BLEScanResults scanResults = pBLEScan->start(60, true); // Blocking scan for simplicity here\r\n\r\n    // After blocking scan finishes:\r\n    Serial.println(F(\"Baseline scan finished. Found \") + String(scanResults.getCount()) + F(\" devices during scan.\"));\r\n\r\n    // Process scanResults to build the baselineDeviceList\r\n    // This needs to be done *after* the scan completes if using blocking start.\r\n    // If using non-blocking start(0, false), you'd need a timer to stop the scan\r\n    // and then process the results *then*. Blocking is simpler for this example.\r\n\r\n    // Clear previous baseline\r\n    baselineDeviceList.clear();\r\n    // Iterate scanResults and populate baselineDeviceList (using your add/find/update logic)\r\n    for (int i = 0; i < scanResults.getCount(); i++) {\r\n        BLEAdvertisedDevice device = scanResults.getDevice(i);\r\n        // Add device to baselineDeviceList if not already present, or update if needed (though baseline is snapshot)\r\n        // Simple baseline: just store unique devices by address seen during the scan\r\n        addOrUpdateDeviceInList(baselineDeviceList, device); // Needs implementation\r\n    }\r\n\r\n    baselineSet = true;\r\n    Serial.println(F(\"Baseline set with \") + String(baselineDeviceList.size()) + F(\" unique devices.\"));\r\n    currentMode = MODE_MENU; // Return to menu\r\n    printMenu();\r\n}\r\n\r\nvoid runBaselineModeCompare() {\r\n    // Your Module 6 Baseline Compare logic goes here.\r\n    // 1. Clear a TEMPORARY list for the comparison scan.\r\n    // 2. Start a BLE scan for a fixed duration (e.g., 30 seconds).\r\n    // 3. The onResult callback populates/updates the TEMPORARY comparison list.\r\n    // 4. After the scan duration, compare the TEMPORARY list against the BASELINE list.\r\n    // 5. Identify devices in the TEMPORARY list that are *not* in the BASELINE list.\r\n    // 6. Print alerts for these \"new\" devices.\r\n    // 7. Transition back to the menu or STOPPED mode.\r\n\r\n    if (!baselineSet) {\r\n        Serial.println(F(\"Error: Baseline not set. Cannot compare.\"));\r\n        currentMode = MODE_MENU;\r\n        printMenu();\r\n        return;\r\n    }\r\n\r\n    Serial.println(F(\"Baseline Compare mode: Scanning for comparison...\"));\r\n    // Need a temporary list for the comparison scan\r\n    std::vector<DeviceInfo> comparisonDeviceList;\r\n\r\n    // Start scan for a duration (e.g., 30 seconds)\r\n    BLEScan* pBLEScan = BLEDevice::getScan();\r\n    // The onResult callback needs to populate comparisonDeviceList when in this mode.\r\n    // This means onResult needs access to both lists and the current mode.\r\n    pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Same callback\r\n    pBLEScan->setActiveScan(true);\r\n    pBLEScan->setInterval(100);\r\n    pBLEScan->setWindow(99);\r\n    BLEScanResults scanResults = pBLEScan->start(30, true); // Blocking scan for simplicity\r\n\r\n     // After blocking scan finishes:\r\n    Serial.println(F(\"Comparison scan finished. Found \") + String(scanResults.getCount()) + F(\" devices during scan.\"));\r\n\r\n    // Process scanResults to build the comparisonDeviceList\r\n     for (int i = 0; i < scanResults.getCount(); i++) {\r\n        BLEAdvertisedDevice device = scanResults.getDevice(i);\r\n        addOrUpdateDeviceInList(comparisonDeviceList, device); // Populate comparison list\r\n    }\r\n\r\n\r\n    // Compare comparisonDeviceList against baselineDeviceList\r\n    Serial.println(F(\"Comparing scan results against baseline...\"));\r\n    bool foundNew = false;\r\n    for (const auto& compDevice : comparisonDeviceList) {\r\n        bool foundInBaseline = false;\r\n        for (const auto& baseDevice : baselineDeviceList) {\r\n            if (compDevice.address.equals(baseDevice.address)) { // Assuming address is BLEAddress object\r\n                foundInBaseline = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundInBaseline) {\r\n            Serial.println(F(\"!!! NEW DEVICE DETECTED: \") + String(compDevice.address.toString().c_str()) +\r\n                           F(\" (Name: \") + (compDevice.name.length() > 0 ? String(compDevice.name.c_str()) : F(\"N/A\")) +\r\n                           F(\", RSSI: \") + String(compDevice.rssi) + F(\" dBm)\"));\r\n            foundNew = true;\r\n        }\r\n    }\r\n\r\n    if (!foundNew) {\r\n        Serial.println(F(\"No new devices detected compared to baseline.\"));\r\n    }\r\n\r\n    currentMode = MODE_MENU; // Return to menu\r\n    printMenu();\r\n}\r\n\r\n// --- Device List Management (Needs to be accessible globally) ---\r\n// Your DeviceInfo struct/class and vector declaration from Module 5\r\nstruct DeviceInfo {\r\n    BLEAddress address;\r\n    String name;\r\n    int rssi;\r\n    unsigned long lastSeen;\r\n    // Add other fields as needed (e.g., history of RSSI, flags)\r\n};\r\n\r\nstd::vector<DeviceInfo> trackerDeviceList;\r\nstd::vector<DeviceInfo> baselineDeviceList; // Separate list for baseline\r\n// MyAdvertisedDeviceCallbacks class needs access to these lists and currentMode\r\n\r\n// Helper function to add or update a device in a given list\r\nvoid addOrUpdateDeviceInList(std::vector<DeviceInfo>& deviceList, BLEAdvertisedDevice& device) {\r\n    bool found = false;\r\n    for (auto& dev : deviceList) {\r\n        if (dev.address.equals(device.getAddress())) {\r\n            // Update existing device info\r\n            dev.rssi = device.getRSSI();\r\n            dev.lastSeen = millis();\r\n            if (device.getName().length() > 0) {\r\n                 // Only update name if the new advertisement has one\r\n                 dev.name = device.getName().c_str();\r\n            }\r\n            // Add RSSI to a history if tracking that\r\n            // dev.rssiHistory.push_back(device.getRSSI()); // Example if you added rssiHistory\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!found) {\r\n        // Add new device\r\n        DeviceInfo newDevice;\r\n        newDevice.address = device.getAddress();\r\n        newDevice.name = device.getName().length() > 0 ? String(device.getName().c_str()) : \"\";\r\n        newDevice.rssi = device.getRSSI();\r\n        newDevice.lastSeen = millis();\r\n        // Initialize other fields (e.g., newDevice.rssiHistory = {device.getRSSI()};)\r\n        deviceList.push_back(newDevice);\r\n        // Optional: Print when a new device is *added* to the list (useful for debugging)\r\n        // Serial.println(F(\"Added new device to list: \") + String(newDevice.address.toString().c_str()));\r\n    }\r\n}\r\n\r\n// Your MyAdvertisedDeviceCallbacks class from Module 4/5, modified to know the mode\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) {\r\n        // This callback runs whenever an advertisement is received.\r\n        // It must be FAST! Avoid complex logic here. Just add/update the list.\r\n        // Processing (tracking logic, baseline comparison) should happen outside this callback.\r\n\r\n        // Need access to currentMode and device lists.\r\n        // Make these global or pass pointers/references (global is simpler for capstone).\r\n\r\n        // Example:\r\n        // if (currentMode == MODE_TRACKER) {\r\n        //     addOrUpdateDeviceInList(trackerDeviceList, advertisedDevice);\r\n        //     // Optional: Print basic info for each device seen in tracker mode\r\n        //      Serial.print(F(\"TRACKER SCAN: Device Found: \"));\r\n        //      Serial.print(advertisedDevice.getAddress().toString().c_str());\r\n        //      Serial.print(F(\", RSSI: \"));\r\n        //      Serial.print(advertisedDevice.getRSSI());\r\n        //      if (advertisedDevice.haveName()) {\r\n        //        Serial.print(F(\", Name: \"));\r\n        //        Serial.println(advertisedDevice.getName().c_str());\r\n        //      } else {\r\n        //        Serial.println();\r\n        //      }\r\n        // } else if (currentMode == MODE_BASELINE_SCAN) {\r\n        //     // Add to a temporary list or the baselineDeviceList directly if blocking scan\r\n        //     // If using blocking scan (pBLEScan->start(duration, true)), onResult is often NOT called.\r\n        //     // The results are returned as BLEScanResults object *after* the scan finishes.\r\n        //     // So, for blocking scans, onResult might be unused."
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
