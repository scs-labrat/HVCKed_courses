<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireless_Power_Attack</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">← Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>Wireless_Power_Attack</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Alright, let&#39;s dive into the fascinating, slightly spooky world of weaponizing wireless power! This is a topic that perfectly blends the physics of RF with the mindset of an attacker. It&#39;s often overlooked, making it a prime area for novel security research and demonstration.</p>\n<p>Here is a comprehensive 8-module course outline designed to take learners from foundational WPT concepts to building a functional proof-of-concept device for energy theft and data exfiltration, culminating in a full &quot;clone&quot; of the described attack methodology.</p>\n<hr>\n<p><strong>Course Title:</strong> Attacking Wireless Power: Energy Theft and Data Siphoning</p>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will understand the security vulnerabilities of near-field Wireless Power Transfer (WPT) systems and be able to design, build, and demonstrate a functional proof-of-concept device capable of performing unauthorized energy harvesting and covert data exfiltration by manipulating the reflected power signature.</p>\n<hr>\n<p><strong>Module 1: Introduction to Wireless Power &amp; Its Security Landscape</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to explain the fundamental principles of near-field WPT, identify its key components, and understand why its unique physics presents novel security vulnerabilities.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>What is Wireless Power Transfer (WPT)? Near-field vs. Far-field.</li>\n<li>Applications of Near-Field WPT (Qi standard, medical implants, industrial).</li>\n<li>Inductive and Resonant Coupling: The physics behind near-field transfer.</li>\n<li>Key components: Transmitter (Tx) coil, Receiver (Rx) coil, power electronics, control circuitry.</li>\n<li>The &quot;Why Security?&quot;: Examining the traditional security focus (data links) vs. the overlooked physical layer of power transfer.</li>\n<li>Introduction to the attack surface: Manipulating the energy field itself.</li>\n<li>Overview of the course objectives: Building the attacker PoC.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic understanding of electricity and magnetism (Ohm&#39;s law, inductance, capacitance).</li>\n<li>Basic knowledge of RF concepts (frequency, resonance, impedance - introductory level).</li>\n<li>Familiarity with basic electronic components.</li>\n<li>Reading: Introduction to Wireless Power Transfer textbooks or reputable online tutorials. IEEE standards overview (e.g., Qi).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Research and present on a specific real-world application of near-field WPT (e.g., smartphone charging, electric vehicle charging, medical implants) and briefly hypothesize one potential physical-layer security risk based on initial understanding.</li>\n</ul>\n<hr>\n<p><strong>Module 2: The Physics of Reflected Power in WPT</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to explain the concept of reflected power in resonant systems, understand how the receiver&#39;s load affects the transmitter&#39;s perspective, and identify the key measurable parameters related to this interaction.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Resonance and Q Factor in WPT coils.</li>\n<li>Coupling Coefficient (k) and its impact.</li>\n<li>Impedance Matching: Why it&#39;s crucial for efficient power transfer.</li>\n<li>The concept of Impedance: Complex impedance (resistance, reactance).</li>\n<li>Reflected Power and Voltage Standing Wave Ratio (VSWR): What they mean in this context.</li>\n<li>How the load impedance on the <em>Receiver</em> coil is &quot;reflected&quot; back to the <em>Transmitter</em>.</li>\n<li>Analyzing the Tx perspective: How changes in Rx load/presence manifest as changes in Tx coil voltage, current, phase, or power draw.</li>\n<li>Measurement techniques overview: Using oscilloscopes, potentially VNAs (Vector Network Analyzers - conceptually).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Module 1 completed.</li>\n<li>Basic understanding of AC circuits, impedance, and resonance.</li>\n<li>Reading: RF circuit design fundamentals, tutorials on resonant circuits and impedance matching.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Simulate a simple resonant coupled system (using online tools like CircuitLab, LTspice, or even conceptual diagrams) and demonstrate how changing the load resistance on the secondary coil affects the current/voltage on the primary coil. Document your observations.</li>\n</ul>\n<hr>\n<p><strong>Module 3: Understanding the WPT Transmitter (The Attacker&#39;s Target)</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to describe the typical architecture of a WPT transmitter, understand how it senses the receiver&#39;s presence and state, and identify the specific signals or parameters an attacker can monitor or influence.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Tx Architecture: Power source, oscillator, driver circuit, Tx coil.</li>\n<li>Resonant Inverters/Converters (e.g., Class D, E): How the AC field is generated.</li>\n<li>Load Detection Mechanisms: How a Tx knows a receiver is present (often based on reflected impedance/power changes).</li>\n<li>Power Regulation: How the Tx adjusts output power based on the Rx&#39;s needs (and how this relies on Rx feedback/load).</li>\n<li>Monitoring Points: Where in the Tx circuit can reflected power changes be observed (e.g., input current, voltage across tuning capacitors, phase shifts).</li>\n<li>Case Study: Overview of the Qi standard Tx operation and handshake (focusing on the physical layer interactions).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Module 2 completed.</li>\n<li>Basic understanding of power electronics concepts (switching circuits).</li>\n<li>Datasheets of WPT Tx controller ICs (e.g., from Analog Devices, Texas Instruments, NXP - even if not used directly, they show architecture).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Build or simulate a <em>basic</em> WPT transmitter circuit (e.g., a simple oscillator driving a coil). Use an oscilloscope to observe the voltage/current waveforms. Introduce a <em>passive</em> secondary coil nearby and observe how the primary waveform changes. Document the observable effects.</li>\n</ul>\n<hr>\n<p><strong>Module 4: Understanding the WPT Receiver (The Attacker&#39;s Tool/Proxy)</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to describe the typical architecture of a WPT receiver, understand how it extracts power and manages its load, and identify how its load characteristics are communicated back to the transmitter.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Rx Architecture: Rx coil, rectifier, filter, voltage regulator, load.</li>\n<li>Power Extraction: AC-to-DC conversion.</li>\n<li>Load Management: How the Rx regulates power delivered to the connected device/battery.</li>\n<li>Communication Channel: How receivers <em>normally</em> communicate with the transmitter (often via backscatter modulation, which is load modulation!).</li>\n<li>Load Modulation: How changing the impedance on the Rx side affects the reflected impedance at the Tx side. This is the <em>core mechanism</em> for both attacks.</li>\n<li>Types of Load Modulation: Resistive, Capacitive, Inductive.</li>\n<li>Analyzing the Rx perspective: How to <em>intentionally</em> change the Rx load impedance.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Module 3 completed.</li>\n<li>Basic understanding of rectification and filtering.</li>\n<li>Datasheets of WPT Rx controller ICs (e.g., Qi receivers).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Build or simulate a <em>basic</em> WPT receiver circuit (coil, rectifier, filter, simple load like an LED or resistor). Place it near the transmitter from Module 3&#39;s project. Measure the DC voltage output. Experimentally (or via simulation) show how changing the <em>load resistor</em> on the DC side affects the Tx waveform observed previously.</li>\n</ul>\n<hr>\n<p><strong>Module 5: Building the Attacker&#39;s Hardware Platform</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to select and integrate hardware components (microcontroller, coils, power handling, modulation circuitry) to build the core platform for the WPT attack device.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Choosing a Microcontroller (MCU): Requirements for timing, I/O, processing (e.g., Arduino, ESP32, or a more powerful ARM chip).</li>\n<li>Designing/Selecting the Attacker Coil: Matching resonance and coupling with the target Tx.</li>\n<li>Power Extraction Circuitry for Hijacking: Efficient rectification and regulation for drawing power.</li>\n<li>Load Modulation Circuitry for Data Exfiltration: Implementing controllable impedance changes (e.g., using MOSFETs to switch resistors/capacitors).</li>\n<li>Powering the Attacker Device: Low-power operation, potentially harvesting enough power just to run the MCU.</li>\n<li>Integration and Prototyping: Connecting the components on a breadboard or PCB.</li>\n<li>Basic Measurement Setup: Using an oscilloscope to observe the attacker&#39;s coil voltage/current and the modulation signal.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Modules 1-4 completed.</li>\n<li>Basic microcontroller programming (C/C++).</li>\n<li>Understanding of MOSFETs or transistors as switches.</li>\n<li>Components: Chosen MCU dev board, coils (matching target frequency), diodes, capacitors, resistors, MOSFETs, power regulator (LDO or switching), breadboard/prototyping board.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Build the core attacker hardware platform on a breadboard. Program the MCU to toggle a digital output pin controlling a MOSFET connected to a resistive load across the attacker coil&#39;s rectifier output. Verify the MCU can switch the load on/off.</li>\n</ul>\n<hr>\n<p><strong>Module 6: Attack Vector 1: Energy Hijacking Implementation</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to design, build, and demonstrate a device that can draw power from a WPT field without being a legitimate, authorized receiver, and observe its effect on the transmitter.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Designing the Energy Harvesting Circuit: Optimizing for efficiency at the target frequency.</li>\n<li>Coil Placement and Coupling: Finding the optimal position for maximum power transfer.</li>\n<li>Stealth Considerations: How to draw power without triggering Tx errors or significantly disrupting legitimate charging (if present). Analyzing the Tx&#39;s detection mechanisms again.</li>\n<li>Measurement of Harvested Power: Quantifying the amount of power drawn.</li>\n<li>Observing the Tx Response: Monitoring the Tx&#39;s input current or other accessible signals while the attacker device is harvesting.</li>\n<li>Proof-of-Concept Demonstration: Powering a small LED or charging a tiny battery using harvested power.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Module 5 completed.</li>\n<li>Power meter or current sensor for DC measurement.</li>\n<li>Target WPT transmitter and a legitimate receiver (for comparison).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Integrate the energy harvesting circuit with the platform from Module 5. Place the attacker coil near a live WPT transmitter. Measure the harvested DC voltage/current. Observe the Tx&#39;s input power draw with and without the attacker present. Document the power harvested and the change observed at the Tx.</li>\n</ul>\n<hr>\n<p><strong>Module 7: Attack Vector 2: Covert Data Exfiltration Implementation</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to design, build, and demonstrate a device that can encode small amounts of data by modulating its load impedance and understand how this modulation can be observed as changes in the reflected power signature at the transmitter.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Designing the Load Modulation Scheme: Choosing modulation type (e.g., OOK - On-Off Keying by switching a resistor), data rate considerations.</li>\n<li>Implementing the Modulation Circuit: Connecting the MCU to the load switching component.</li>\n<li>Encoding Data: Simple binary encoding of text or sensor data.</li>\n<li>Timing and Synchronization: Challenges of observing brief modulation pulses.</li>\n<li>Observing the Modulation at the Tx: Using an oscilloscope to capture the subtle changes in Tx voltage/current waveforms caused by the attacker&#39;s load modulation.</li>\n<li>Basic Signal Analysis: Identifying the encoded data pulses in the Tx signal.</li>\n<li>Proof-of-Concept Demonstration: Modulating a simple message (e.g., &quot;HI&quot;) and capturing the Tx signal to show the modulation is visible.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Module 6 completed (platform is built).</li>\n<li>Oscilloscope with sufficient bandwidth and sampling rate.</li>\n<li>Data analysis tools (e.g., Python with NumPy/SciPy, or even spreadsheet software).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Program the MCU platform to perform load modulation according to a simple binary pattern (e.g., transmitting the ASCII value of a letter). Place the attacker coil near the Tx. Use an oscilloscope to capture the Tx waveform and visually identify the modulation pulses corresponding to the transmitted data. Document the waveform and the identified data.</li>\n</ul>\n<hr>\n<p><strong>Module 8: Capstone Project &amp; Future Directions</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learners will integrate all components and knowledge to create a comprehensive demonstration of both attack vectors, analyze the results, understand the limitations of the PoC, and explore potential countermeasures and advanced attack/defense strategies.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Integrating Attack Vectors: Combining energy harvesting (potentially to power the MCU) with data exfiltration using the same platform.</li>\n<li>Refining the Proof-of-Concept: Optimizing coil placement, modulation depth, power harvesting efficiency.</li>\n<li>Demonstration Setup: Preparing a clear demonstration of both energy hijacking and data exfiltration.</li>\n<li>Analyzing Results: Quantifying harvested power, successful data exfiltration rate, observed impact on the Tx and legitimate Rx (if present).</li>\n<li>Limitations of the PoC: Discussing range, data rate, power levels, detection avoidance, and reliance on Tx characteristics.</li>\n<li>Potential Countermeasures: How could WPT systems detect or mitigate these attacks? (e.g., active impedance monitoring, encryption of control signals, physical shielding, anomaly detection).</li>\n<li>Advanced Topics &amp; Future Research: Using AI/ML for anomaly detection or optimizing attack signals, attacking specific WPT protocols, higher data rate exfiltration, active interference attacks.</li>\n<li>Responsible Disclosure: Ethical considerations when researching vulnerabilities.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Modules 1-7 completed.</li>\n<li>All hardware and software tools used in previous modules.</li>\n<li>Presentation/documentation tools.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Complete the functional clone of the described attack. Prepare a demonstration showing: 1) The attacker device harvesting power (e.g., lighting an LED). 2) The attacker device performing load modulation. 3) (If possible) Observing the effect of both on the WPT transmitter&#39;s behavior or monitoring signals. Write a final report documenting the design, build process, results, limitations, and potential countermeasures, acting as the &quot;research paper&quot; for your PoC.</li>\n</ul>\n<hr>\n<p>This outline provides a structured path, starting from foundational physics and progressively building towards a practical hardware and software implementation of the described WPT attacks. It emphasizes hands-on projects at each stage, ensuring learners not only understand the theory but can also build and demonstrate the concepts, fulfilling the capstone objective of creating a functional clone of the research topic. Good luck, and remember to always practice responsible security research!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: 3: Understanding the WPT Transmitter (The Attacker's Target)</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">3: Understanding the WPT Transmitter (The Attacker's Target) Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, class! Settle in. Get ready to peel back the curtain on something that feels like science fiction but is very much real, and surprisingly, has a hidden attack surface.</p>\n<p>We&#39;re not just learning about wireless power; we&#39;re learning how to <em>think like an attacker</em> in a domain few have explored deeply. This isn&#39;t about hacking Wi-Fi or breaking crypto. This is about manipulating the <em>physical world</em> – the magnetic fields and energy flow – to achieve offensive goals. It&#39;s elegant, it&#39;s subtle, and it&#39;s highly effective against systems that weren&#39;t designed with this kind of threat in mind.</p>\n<p>Let&#39;s kick off with the absolute essentials in Module 1.</p>\n<hr>\n<h1><strong>Module 1: Introduction to Wireless Power &amp; Its Security Landscape</strong></h1>\n<p>Welcome to the starting line! Before we can weaponize anything, we need to truly understand it. This module lays the groundwork. We&#39;ll cover what wireless power is, how it works <em>at a fundamental level</em>, look at where you see it every day (and maybe don&#39;t even notice), and critically, start asking &quot;what could go wrong?&quot; from a perspective that goes beyond traditional cybersecurity.</p>\n<h2><strong>Module Objective:</strong></h2>\n<p>By the end of this module, you will be able to:</p>\n<ul>\n<li>Explain the fundamental principles of near-field Wireless Power Transfer (WPT).</li>\n<li>Identify the key components of a near-field WPT system (Transmitter &amp; Receiver).</li>\n<li>Understand why the unique physics of near-field WPT presents novel security vulnerabilities compared to traditional data systems.</li>\n</ul>\n<h2><strong>Essential Subtopics: The Foundation</strong></h2>\n<p>Let&#39;s break down the core concepts we need to grasp.</p>\n<h3><strong>1. What is Wireless Power Transfer (WPT)? Near-field vs. Far-field.</strong></h3>\n<p>Think about electricity. Usually, it needs wires, right? WPT is about moving electrical energy from one point to another <em>without</em> a physical conductor connecting them. Magic? Nope, just physics!</p>\n<p>There are two main flavors of WPT, distinguished primarily by distance and the physics they exploit:</p>\n<ul>\n<li><p><strong>Far-Field WPT (Radiative):</strong></p>\n<ul>\n<li>Uses electromagnetic waves (like radio waves, microwaves, light) to carry energy.</li>\n<li>Energy radiates outwards from a source.</li>\n<li>Efficiency decreases rapidly with distance (inverse square law).</li>\n<li>Best suited for <em>low-power</em> transfer over <em>longer distances</em> (meters to kilometers).</li>\n<li>Examples: RF energy harvesting for tiny IoT sensors, potentially solar power satellites beaming energy down (future concept).</li>\n<li><em>Security Note (for context, not our focus):</em> Security here might involve jamming the signal, spoofing the source, or intercepting the radiated energy (though inefficient).</li>\n</ul>\n</li>\n<li><p><strong>Near-Field WPT (Non-Radiative):</strong></p>\n<ul>\n<li>Uses magnetic fields (and sometimes electric fields, but magnetic is dominant for most common applications like phone charging).</li>\n<li>Energy is transferred via the <em>coupling</em> between coils or resonators that are <em>close</em> to each other (typically within a few coil diameters).</li>\n<li>The magnetic field energy stays largely contained within the near-field region, not radiating significantly into space.</li>\n<li>Efficiency is much higher than far-field <em>at close range</em>.</li>\n<li>Examples: Smartphone wireless charging (Qi standard), electric toothbrushes, RFID (data, but uses the same magnetic coupling), medical implants, EV charging pads.</li>\n<li><strong>This is our target!</strong> The physics of <em>coupling</em> and <em>reflected fields</em> in the near-field is what makes our attacks possible.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Key takeaway:</strong> We are focusing <em>exclusively</em> on <strong>Near-Field WPT</strong>, where energy is transferred via magnetic fields between coils in close proximity.</p>\n<h3><strong>2. Applications of Near-Field WPT</strong></h3>\n<p>Near-field WPT is already integrated into our lives, often invisibly:</p>\n<ul>\n<li><strong>Consumer Electronics:</strong> The most common is smartphone charging (Qi standard). Also seen in smartwatches, earbuds, electric toothbrushes, etc.</li>\n<li><strong>Medical Implants:</strong> Pacemakers, neurostimulators, and other implanted devices can be charged wirelessly, reducing the need for surgery to replace batteries. Security is paramount here!</li>\n<li><strong>Industrial Automation:</strong> Powering sensors or actuators in hazardous or hard-to-reach locations without physical connections.</li>\n<li><strong>Electric Vehicles (EVs):</strong> Wireless charging pads for convenience (though currently less common than plug-in).</li>\n<li><strong>RFID:</strong> While primarily for data, RFID readers power the tag using near-field magnetic coupling before reading data.</li>\n</ul>\n<p>The widespread adoption means more potential targets and greater impact if vulnerabilities are exploited.</p>\n<h3><strong>3. Inductive and Resonant Coupling: The Physics Behind Near-Field Transfer</strong></h3>\n<p>How does energy <em>actually</em> move without wires in the near-field?</p>\n<ul>\n<li><p><strong>Inductive Coupling (The Basics):</strong></p>\n<ul>\n<li>Remember your high school physics? A changing current in a wire coil creates a changing magnetic field around it.</li>\n<li>If you place another coil nearby <em>within</em> this changing magnetic field, the field induces a voltage (and thus current) in the second coil (Faraday&#39;s Law of Induction).</li>\n<li>This is how simple transformers work, but with an air gap instead of an iron core.</li>\n<li><em>Limitation:</em> Simple inductive coupling is very sensitive to distance and alignment. Efficiency drops off <em>very</em> quickly as coils move apart.</li>\n</ul>\n</li>\n<li><p><strong>Resonant Coupling (The Game Changer):</strong></p>\n<ul>\n<li>This is where it gets cool and efficient for slightly longer ranges (still near-field, but a bit more flexible than simple induction).</li>\n<li>Imagine adding capacitors to your coils. This turns each coil into an LC circuit (Inductor-Capacitor).</li>\n<li>LC circuits have a <em>resonant frequency</em>. Like a musical instrument, they prefer to &quot;vibrate&quot; or oscillate electrically at this specific frequency.</li>\n<li>If you make the <em>Transmitter</em> coil oscillate at its resonant frequency, it creates a strong, oscillating magnetic field.</li>\n<li>If you place a <em>Receiver</em> coil <em>tuned to the same resonant frequency</em> nearby, it will strongly absorb energy from that oscillating field, like one tuning fork making another one vibrate across the room.</li>\n<li><em>Advantage:</em> Resonant coupling is much more efficient than simple induction over slightly larger distances and is less sensitive to precise alignment. This is the principle behind most modern WPT standards like Qi.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Think of it like this:</strong></p>\n<ul>\n<li>Simple Induction: Yelling across a room – some sound reaches, but it&#39;s weak and scatters.</li>\n<li>Resonant Coupling: Singing a specific note to a tuning fork tuned to that note – the tuning fork vibrates strongly, absorbing the energy efficiently.</li>\n</ul>\n<p>The fact that energy transfer is most efficient at <em>specific frequencies</em> and relies on the <em>interaction</em> between the Tx and Rx resonators is crucial. This interaction is what we can potentially observe and manipulate.</p>\n<h3><strong>4. Key Components of a Near-Field WPT System</strong></h3>\n<p>Let&#39;s look at the building blocks you&#39;ll find in typical WPT systems:</p>\n<ul>\n<li><p><strong>Transmitter (Tx):</strong> The power source side.</p>\n<ul>\n<li><strong>Power Source:</strong> Usually DC (e.g., wall adapter, battery).</li>\n<li><strong>Oscillator/Driver Circuit:</strong> Converts the DC power into high-frequency AC power at the desired WPT frequency (e.g., 100-200 kHz for Qi low power, 6.78 MHz for some resonant systems). Often uses power electronics like MOSFETs in an inverter configuration (e.g., Class D or Class E amplifier).</li>\n<li><strong>Tx Coil:</strong> The inductor that generates the oscillating magnetic field. Often includes tuning capacitors to resonate at the operating frequency.</li>\n<li><strong>Control Circuitry:</strong> The &quot;brain&quot; of the Tx. Manages the power transfer process.<ul>\n<li>Detects the presence of a valid receiver.</li>\n<li>Manages the power level delivered based on receiver requests or load changes.</li>\n<li>Handles communication <em>from</em> the receiver (this is key!).</li>\n<li>Implements safety features (e.g., Foreign Object Detection - FOD).</li>\n</ul>\n</li>\n<li><strong>Matching Network:</strong> Circuitry between the driver and the Tx coil to ensure maximum power transfer efficiency.</li>\n</ul>\n</li>\n<li><p><strong>Receiver (Rx):</strong> The power sink side.</p>\n<ul>\n<li><strong>Rx Coil:</strong> The inductor that captures energy from the magnetic field. Also includes tuning capacitors to resonate at the same frequency as the Tx.</li>\n<li><strong>Rectifier &amp; Filter:</strong> Converts the high-frequency AC voltage induced in the Rx coil back into usable DC voltage. (Diodes, capacitors).</li>\n<li><strong>Voltage Regulator:</strong> Stabilizes the DC voltage to power the connected device (e.g., charge a battery, run electronics).</li>\n<li><strong>Load:</strong> The device consuming the power (battery charger, LED, microcontroller, etc.).</li>\n<li><strong>Control Circuitry:</strong> The &quot;brain&quot; of the Rx.<ul>\n<li>Manages the power drawn by the load.</li>\n<li>Communicates its status and power requests back to the Tx (often <em>by changing its load</em> - hint, hint!).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Diagram Sketch (Conceptual):</strong></p>\n<pre><code>[DC Source] --&gt; [Tx Power Electronics / Oscillator] --&gt; [Tx Coil + Tuning Caps] &lt;--- Magnetic Field ---&gt; [Rx Coil + Tuning Caps] --&gt; [Rectifier + Filter] --&gt; [Voltage Regulator] --&gt; [Load]\n                                                                                                                                  ^                                  ^\n                                                                                                                                  |                                  |\n                                                                                                                                  +------- [Rx Control] &lt;------------+\n                                                                                                                                  |\n                                                                                                                                  +---- Communication (often via Load Modulation) ----&gt; [Tx Control]\n</code></pre>\n<p>Understanding these blocks is essential because our attack will involve <em>interacting</em> with this system, either as a rogue &quot;Receiver&quot; or by observing the &quot;Transmitter&#39;s&quot; behavior.</p>\n<h3><strong>5. The &quot;Why Security?&quot;: Overlooked Physical Layer</strong></h3>\n<p>This is where we pivot from electrical engineering to offensive security.</p>\n<p>Traditional security focuses heavily on software, protocols, and data encryption. We think about SQL injection, buffer overflows, TLS vulnerabilities, phishing, etc.</p>\n<p>When people <em>do</em> think about WPT security, they often focus on:</p>\n<ul>\n<li>Securing the <em>data</em> transmitted <em>over</em> the WPT link (e.g., if the Qi standard includes data packets, are they encrypted?).</li>\n<li>Authentication: How does the Tx know it&#39;s talking to a <em>legitimate</em> Rx? (Though many simple WPT systems don&#39;t do strong authentication).</li>\n<li>Foreign Object Detection (FOD): Preventing metal objects from overheating in the magnetic field.</li>\n</ul>\n<p><strong>What&#39;s often overlooked?</strong> The <em>physical act of power transfer itself</em>.</p>\n<ul>\n<li>The magnetic field is an open medium. Anyone can place a coil in it.</li>\n<li>The <em>interaction</em> between Tx and Rx is based on fundamental physics (resonance, coupling, impedance).</li>\n<li>This physical interaction creates observable side-effects on the Transmitter side.</li>\n</ul>\n<p><strong>The Security Blind Spot:</strong> Most WPT systems are designed for efficiency and convenience, not malicious physical interaction. They assume receivers are cooperative or at least passive power sinks. They might detect <em>gross</em> anomalies (like a large metal object), but not subtle manipulations of the field by another resonant circuit.</p>\n<p>This is our opportunity! We&#39;re attacking the layer <em>below</em> the digital communication, manipulating the very energy flow.</p>\n<h3><strong>6. Introduction to the Attack Surface: Manipulating the Energy Field</strong></h3>\n<p>Based on the components and physics, what can an attacker <em>do</em>?</p>\n<p>Our attack surface is the <strong>magnetic field</strong> and the <strong>physical interaction</strong> it facilitates between Tx and Rx.</p>\n<p>Specifically, the key vulnerability we will exploit centers around <strong>reflected power</strong> or <strong>reflected impedance</strong>.</p>\n<ul>\n<li>When a Receiver coil is placed in the Tx&#39;s magnetic field, it &quot;loads&quot; the field. It draws energy.</li>\n<li>This loading effect isn&#39;t just local to the Rx; it changes the <em>entire system&#39;s</em> characteristics, including what the Transmitter &quot;sees&quot; looking back into its own coil.</li>\n<li>Think of it like pushing on a spring: the way you push affects how the <em>other end</em> of the spring moves, and how the <em>anchor point</em> feels the force.</li>\n<li>Changes in the Rx&#39;s behavior (like how much power it draws, or if it intentionally changes its internal circuitry) directly impact the impedance the Tx &quot;sees&quot;.</li>\n<li>The Tx often <em>relies</em> on observing these changes (e.g., detecting a receiver, regulating power).</li>\n</ul>\n<p><strong>The Attack Hypothesis:</strong></p>\n<ul>\n<li><strong>Energy Theft:</strong> Can we place our <em>own</em> rogue coil in the field and efficiently draw power without being a legitimate or authorized receiver? Can we do it stealthily?</li>\n<li><strong>Data Exfiltration:</strong> Can we <em>intentionally manipulate</em> our rogue receiver&#39;s characteristics (its load) in a way that creates subtle, detectable changes in the Tx&#39;s electrical signals? Can we encode data into these changes?</li>\n</ul>\n<p>This second point is particularly powerful. It means the <em>power transfer channel</em> itself can potentially become a covert <em>data exfiltration channel</em>, even if the WPT system has no official digital communication or that communication is encrypted. The data is modulated onto the <em>energy signature</em>.</p>\n<h3><strong>7. Overview of the Course Objectives: Building the Attacker PoC</strong></h3>\n<p>This course isn&#39;t just theoretical. We&#39;re on a mission to build a working <strong>Proof-of-Concept (PoC)</strong> device.</p>\n<p>The goal is to create a single piece of hardware (likely based around a microcontroller and some custom RF/power electronics) that can:</p>\n<ol>\n<li>Position itself near a standard WPT transmitter (like a Qi charger).</li>\n<li>Harvest energy from the magnetic field, even if it&#39;s not a recognized device.</li>\n<li>Use that harvested energy (or a small internal battery) to power itself.</li>\n<li>Intentionally modulate its electrical load in a specific pattern.</li>\n<li>Demonstrate that this load modulation creates a detectable signal on the Transmitter side.</li>\n<li>Show how this load modulation can encode simple data.</li>\n</ol>\n<p>We will effectively be building a device that acts like a malicious parasite, stealing power and whispering secrets back through the power connection itself.</p>\n<h2><strong>Suggested Resources or Prerequisites:</strong></h2>\n<p>To get the most out of this module (and the rest of the course), having a handle on these basics will be a huge help:</p>\n<ul>\n<li><strong>Basic Electricity &amp; Magnetism:</strong> Concepts like voltage, current, resistance (Ohm&#39;s Law), inductance, capacitance, magnetic fields, how changing magnetic fields induce voltage (Faraday&#39;s Law). If these terms aren&#39;t completely foreign, you&#39;re in good shape.</li>\n<li><strong>Basic Electronic Components:</strong> Familiarity with resistors, capacitors, inductors, diodes, transistors (especially MOSFETs as switches). What they look like, what they generally do.</li>\n<li><strong>Basic RF Concepts (Introductory Level):</strong> Frequency, wavelength, resonance, impedance. Don&#39;t need to be an RF engineer, but knowing that circuits behave differently at high frequencies and that &quot;resonance&quot; is important is key.</li>\n<li><strong>Reading:</strong><ul>\n<li>Search for introductory articles or videos on &quot;Wireless Power Transfer explained,&quot; &quot;Inductive Coupling,&quot; and &quot;Resonant Coupling.&quot;</li>\n<li>Look up the <strong>Qi standard</strong> (pronounced &quot;chee&quot;). You don&#39;t need to read the full specification (it&#39;s long and technical!), but understand its basic principles, frequency range, and how devices interact. Search for &quot;Qi wireless charging principles.&quot;</li>\n<li>Wikipedia pages for &quot;Wireless Power Transfer,&quot; &quot;Inductive Coupling,&quot; &quot;Resonant Coupling,&quot; &quot;Impedance,&quot; and &quot;VSWR&quot; can be good starting points (but be mindful of depth).</li>\n</ul>\n</li>\n</ul>\n<p>Don&#39;t worry if some of the RF/electronics concepts are hazy right now. We&#39;ll reinforce them as we go, especially in Module 2.</p>\n<h2><strong>Module Project/Exercise: Research and Hypothesize</strong></h2>\n<p>Alright, your first mission! This is about applying what we just discussed and starting to think critically.</p>\n<p><strong>Task:</strong></p>\n<ol>\n<li><p><strong>Choose a specific, real-world application of near-field WPT.</strong> Examples:</p>\n<ul>\n<li>Smartphone wireless charging (Qi)</li>\n<li>Wireless charging for electric toothbrushes or shavers</li>\n<li>Wireless charging for medical implants (e.g., a specific type of pacemaker or neurostimulator)</li>\n<li>Wireless charging for an industrial sensor in a factory</li>\n<li>Wireless charging for an electric vehicle</li>\n</ul>\n</li>\n<li><p><strong>Research this application:</strong> Find out (roughly) what WPT standard or technology it uses, its operating frequency range (if possible), and its typical power level. Look for product descriptions, technical reviews, or even academic papers if you&#39;re feeling ambitious. <em>You don&#39;t need deep technical schematics yet.</em></p>\n</li>\n<li><p><strong>Hypothesize ONE potential physical-layer security risk</strong> based <em>only</em> on your understanding from Module 1.</p>\n<ul>\n<li>Given that energy is transferred via a magnetic field in close proximity using coupling/resonance...</li>\n<li>Given that there&#39;s a Transmitter and a Receiver...</li>\n<li>Given that the Tx and Rx interact physically via the field...</li>\n<li><strong>How could someone exploit the <em>energy transfer process itself</em>?</strong></li>\n<li>Think about things like: Could someone steal power? Could someone interfere with the charging? Could someone <em>observe</em> something happening on the Tx side without touching it? Could they potentially send information <em>back</em> to the Tx in an unexpected way?</li>\n<li>Focus on a <em>physical</em> interaction, not hacking the phone&#39;s OS or the car&#39;s software.</li>\n</ul>\n</li>\n<li><p><strong>Present your findings:</strong> Prepare a short summary (a few paragraphs or a slide) covering:</p>\n<ul>\n<li>The chosen application.</li>\n<li>Brief details about its WPT (type, frequency, power if known).</li>\n<li>Your hypothesized physical-layer security risk.</li>\n<li>A brief explanation <em>why</em> you think this risk might be possible based on Module 1 concepts (e.g., &quot;Because it uses a magnetic field, maybe a rogue coil could intercept some energy,&quot; or &quot;Since the Rx affects the Tx via the field, maybe changing the Rx&#39;s behavior could signal something&quot;).</li>\n</ul>\n</li>\n</ol>\n<p><strong>Deliverable:</strong> A short written summary or presentation slide(s) outlining your chosen application, its WPT details, and your hypothesized physical-layer security risk with justification based on Module 1 concepts.</p>\n<p>This exercise is about starting to connect the physics to the &quot;what if?&quot; of security. There are no wrong answers at this stage, as long as your hypothesis relates to the <em>physical</em> WPT process we discussed.</p>\n<h2><strong>Module 1 Summary</strong></h2>\n<p>Phew! We&#39;ve covered a lot of ground, from the basic definition of WPT and the crucial difference between near-field and far-field, to the core physics of inductive and resonant coupling, the essential components of a WPT system, and most importantly, why the physical layer of WPT is a fascinating and often overlooked security attack surface.</p>\n<p>We now know <em>what</em> near-field WPT is, <em>how</em> it generally works via magnetic coupling, and we&#39;ve been introduced to the idea that manipulating this physical interaction is the key to our offensive goals: energy theft and data exfiltration via reflected power.</p>\n<p>In the next module, we&#39;ll double-click on that critical concept: <strong>The Physics of Reflected Power</strong>. How does the Receiver&#39;s actions ripple back and become visible at the Transmitter? That understanding is absolutely vital before we start building anything.</p>\n<p>Get started on that project, ponder the physics, and I&#39;ll see you in Module 2!</p>\n<hr>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, class! Welcome back. Module 1 gave us the lay of the land – what WPT is, its applications, and why we need to think about its <em>physical layer</em> security. Now, we&#39;re going to dive deep into the fundamental physics that makes our planned attacks possible: <strong>the phenomenon of reflected power</strong>.</p>\n<p>This isn&#39;t just theory; it&#39;s the invisible handshake between the WPT transmitter (Tx) and receiver (Rx). Understanding this handshake, how it&#39;s formed, and how to interpret its signals is absolutely crucial for both energy theft (Module 6) and data exfiltration (Module 7). We&#39;re essentially learning to <em>listen</em> to the power field and then <em>speak</em> to the transmitter by manipulating what it hears back.</p>\n<p>Let&#39;s unlock the secrets of reflected power!</p>\n<hr>\n<h2><strong>Module 2: The Physics of Reflected Power in WPT</strong></h2>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, you will be able to explain the concept of reflected power in resonant systems, understand how the receiver&#39;s load affects the transmitter&#39;s perspective, and identify the key measurable parameters related to this interaction that are relevant to our attack.</li>\n</ul>\n<hr>\n<h3><strong>2.1 Resonance and Q Factor in WPT Coils</strong></h3>\n<p>Alright, let&#39;s start with the heart of many near-field WPT systems: <strong>Resonance</strong>.</p>\n<p>Imagine pushing a swing. If you push at just the right time (the swing&#39;s natural frequency), you can build up a large amplitude with very little effort. That&#39;s resonance! In electrical circuits, resonance occurs in circuits containing both inductors (L) and capacitors (C). At a specific frequency, the energy oscillating between the inductor&#39;s magnetic field and the capacitor&#39;s electric field is maximized, and their reactances cancel out.</p>\n<ul>\n<li><p><strong>Resonance Frequency (f₀):</strong> For a simple series or parallel LC circuit, the resonance frequency is given by:</p>\n<pre><code>f₀ = 1 / (2 * π * sqrt(L * C))\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>f₀</code> is the resonant frequency in Hertz (Hz)</li>\n<li><code>π</code> is approximately 3.14159</li>\n<li><code>L</code> is the inductance in Henries (H)</li>\n<li><code>C</code> is the capacitance in Farads (F)</li>\n</ul>\n</li>\n<li><p><strong>Why Resonance in WPT?</strong> WPT systems use resonance to build up high circulating currents/voltages in the Tx and Rx coils, even with relatively low input power. This creates a stronger magnetic field around the Tx coil, enabling more efficient energy transfer to the Rx coil when it&#39;s brought nearby, <em>provided</em> the Rx is also tuned to resonate near the same frequency.</p>\n</li>\n<li><p><strong>Q Factor (Quality Factor):</strong> Resonance isn&#39;t perfect. Real-world components have resistance (R), which dissipates energy (usually as heat). The Q factor quantifies how &quot;good&quot; or &quot;sharp&quot; a resonant circuit is. It&#39;s essentially a ratio of the energy stored in the circuit to the energy lost per cycle.</p>\n<ul>\n<li>For a series RLC circuit: <code>Q = (2 * π * f₀ * L) / R = 1 / (2 * π * f₀ * C * R)</code></li>\n<li>For a parallel RLC circuit: <code>Q = R / (2 * π * f₀ * L) = (2 * π * f₀ * C * R)</code></li>\n<li>In WPT coils, the resistance <code>R</code> primarily comes from the wire resistance and other losses. The <code>L</code> and <code>C</code> are the coil inductance and any tuning capacitance added.</li>\n</ul>\n</li>\n<li><p><strong>Why Q Factor Matters in WPT:</strong></p>\n<ul>\n<li><strong>Efficiency:</strong> Higher Q in the <em>isolated</em> Tx and Rx coils generally means less energy is wasted in the coils themselves, potentially leading to higher overall system efficiency <em>when properly coupled</em>.</li>\n<li><strong>Bandwidth:</strong> The Q factor is inversely related to the circuit&#39;s bandwidth (BW = f₀ / Q). A higher Q means a narrower bandwidth, meaning the circuit is very selective to the resonant frequency.</li>\n<li><strong>Sensitivity to Changes:</strong> Crucially for our attack, a higher Q system is often <em>more sensitive</em> to changes in the coupled load. Small changes on the Rx side can cause larger, more noticeable changes in the Tx circuit&#39;s behavior. This is a double-edged sword: good for efficient power transfer control, but also potentially good for observing subtle attacker manipulations!</li>\n</ul>\n</li>\n</ul>\n<p><strong>Self-Check:</strong> If you increase the resistance in a series RLC circuit, does the Q factor increase or decrease? (Answer: Decrease).</p>\n<h3><strong>2.2 Coupling Coefficient (k) and Its Impact</strong></h3>\n<p>Resonance is about a single circuit. WPT involves <em>two</em> circuits (Tx and Rx) interacting via a magnetic field. This interaction is quantified by the <strong>Coupling Coefficient (k)</strong>.</p>\n<ul>\n<li><p><strong>Mutual Inductance (M):</strong> When current flows through one coil (Tx), it creates a magnetic field. If another coil (Rx) is placed within this field, the changing magnetic field induces a voltage in the Rx coil. This phenomenon is mutual inductance (M), measured in Henries.</p>\n</li>\n<li><p><strong>Coupling Coefficient (k):</strong> <code>k</code> is a dimensionless value ranging from 0 to 1. It describes how much of the magnetic flux produced by one coil links the other coil.</p>\n<pre><code>k = M / sqrt(L₁ * L₂)\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><code>k</code> is the coupling coefficient (0 ≤ k ≤ 1)</li>\n<li><code>M</code> is the mutual inductance</li>\n<li><code>L₁</code> is the self-inductance of the Tx coil</li>\n<li><code>L₂</code> is the self-inductance of the Rx coil</li>\n</ul>\n</li>\n<li><p><strong>Impact of k in WPT:</strong></p>\n<ul>\n<li><strong>Power Transfer:</strong> Higher <code>k</code> means stronger coupling and generally enables more efficient power transfer at a given distance.</li>\n<li><strong>Resonance Frequency Splitting:</strong> When two resonant circuits are strongly coupled (high <code>k</code>), their combined system resonance can split into two distinct frequencies. WPT systems often operate <em>between</em> these split frequencies or dynamically adjust. This is a more advanced topic, but understand that <code>k</code> significantly alters the overall system&#39;s resonant behavior.</li>\n<li><strong>Reflected Impedance:</strong> As we&#39;ll see shortly, <code>k</code> plays a direct role in how the Rx load impedance is &quot;reflected&quot; back to the Tx. Stronger coupling means the Rx has a greater influence on the Tx&#39;s observed impedance.</li>\n</ul>\n</li>\n<li><p><strong>Factors Affecting k:</strong></p>\n<ul>\n<li><strong>Distance:</strong> <code>k</code> decreases rapidly as the distance between coils increases (inverse cube relationship for small loops). This is why near-field WPT has limited range.</li>\n<li><strong>Alignment:</strong> <code>k</code> is maximum when coils are perfectly aligned (coaxial and coplanar). Rotation or misalignment reduces <code>k</code>.</li>\n<li><strong>Coil Geometry:</strong> Size, shape, and number of turns affect <code>L₁</code>, <code>L₂</code>, and <code>M</code>.</li>\n<li><strong>Intervening Materials:</strong> Ferrous materials can increase coupling (core), while conductive materials (like metal plates) can reduce coupling by creating eddy currents.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Self-Check:</strong> If you move the Rx coil further away from the Tx coil, does the coupling coefficient <code>k</code> increase or decrease? (Answer: Decrease).</p>\n<h3><strong>2.3 Impedance Matching: Why It&#39;s Crucial</strong></h3>\n<p>You might have heard the term &quot;impedance matching&quot; in the context of audio systems (matching speaker impedance to amplifier output) or RF systems (matching antenna impedance to transmitter/receiver impedance). The principle is the same in WPT: <strong>for maximum power transfer, the source impedance should ideally match the load impedance.</strong></p>\n<ul>\n<li><strong>What is Impedance?</strong> We&#39;ll cover this in detail next, but briefly, impedance (Z) is the AC equivalent of resistance. It&#39;s a measure of opposition to the flow of alternating current, and it includes both resistance (R, energy dissipation) and reactance (X, energy storage in L and C). <code>Z = R + jX</code>.</li>\n<li><strong>The Goal in WPT:</strong> While a simple resistive load might want its resistance to equal the source resistance for maximum power, WPT systems are dealing with reactive components (coils, capacitors) and complex loads (the Rx circuit). The goal of &quot;matching&quot; in WPT is often to make the <em>total effective impedance</em> seen by the Tx power source such that power is delivered efficiently and safely, often appearing as a primarily resistive load <em>at the operating frequency</em>.</li>\n<li><strong>Why Mismatch is Bad:</strong><ul>\n<li><strong>Reduced Efficiency:</strong> When impedances are mismatched, not all the power delivered by the source is absorbed by the load. Some is <strong>reflected</strong> back towards the source.</li>\n<li><strong>Standing Waves:</strong> In systems with transmission lines, mismatch causes forward and reflected waves to interfere, creating standing waves (points of high and low voltage/current). While WPT often doesn&#39;t use traditional transmission lines, the concept of energy &quot;bouncing back&quot; is valid.</li>\n<li><strong>Stress on Components:</strong> Reflected power can cause excessive voltage or current swings in the source circuit, potentially damaging components.</li>\n<li><strong>Tx Instability/Shutdown:</strong> WPT transmitters monitor the reflected power/impedance. A significant mismatch (like an attacker suddenly appearing) can be interpreted as an error condition (e.g., no legitimate receiver present, or a fault) and cause the Tx to reduce power or shut down.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Self-Check:</strong> If a transmitter expects a 50 Ohm load but sees a 100 Ohm load, will power transfer be maximized? Will there be reflected power? (Answer: No, power transfer will not be maximized. Yes, there will be reflected power).</p>\n<h3><strong>2.4 The Concept of Complex Impedance</strong></h3>\n<p>Let&#39;s formalize impedance. Unlike simple DC resistance (R), AC circuits have components that store energy (inductors and capacitors) and release it later. This storage/release causes a phase shift between voltage and current.</p>\n<ul>\n<li><p><strong>Resistance (R):</strong> Opposition to current flow that dissipates energy (heat). Voltage and current are <em>in phase</em> in a pure resistor. Measured in Ohms (Ω).</p>\n</li>\n<li><p><strong>Reactance (X):</strong> Opposition to current flow due to energy storage in inductors (L) and capacitors (C). Voltage and current are <em>out of phase</em> in pure reactances. Measured in Ohms (Ω).</p>\n<ul>\n<li><strong>Inductive Reactance (X_L):</strong> Increases with frequency and inductance. <code>X_L = 2 * π * f * L</code>. Current <em>lags</em> voltage by 90°.</li>\n<li><strong>Capacitive Reactance (X_C):</strong> Decreases with frequency and capacitance. <code>X_C = 1 / (2 * π * f * C)</code>. Current <em>leads</em> voltage by 90°.</li>\n</ul>\n</li>\n<li><p><strong>Impedance (Z):</strong> The total opposition to AC current, combining resistance and reactance. It&#39;s a <strong>complex number</strong>.</p>\n<ul>\n<li><code>Z = R + jX</code></li>\n<li><code>R</code> is the real part (resistance).</li>\n<li><code>X</code> is the imaginary part (total reactance, <code>X = X_L - X_C</code>).</li>\n<li><code>j</code> is the imaginary unit (sqrt(-1)).</li>\n<li>Impedance can also be expressed in polar form: <code>Z = |Z| ∠ θ</code>, where <code>|Z|</code> is the magnitude (total opposition) and <code>θ</code> is the phase angle between voltage and current (<code>θ = arctan(X/R)</code>).</li>\n</ul>\n</li>\n<li><p><strong>Why Complex Impedance Matters in WPT:</strong> The Tx sees the <em>total complex impedance</em> presented by its own coil, tuning components, and the <em>reflected impedance</em> from the coupled Rx. Changes in the Rx&#39;s load circuit (which contains R, L, and C) alter its own impedance, which in turn alters the <em>complex reflected impedance</em>, and therefore the <em>total complex impedance</em> seen by the Tx. This change in the Tx&#39;s total impedance is what the Tx (and our attacker&#39;s monitoring equipment) can potentially detect.</p>\n</li>\n</ul>\n<p><strong>Self-Check:</strong> If a circuit has a large inductive reactance (<code>X_L</code>) and small resistance (R), will the phase angle (<code>θ</code>) be close to 0°, +90°, or -90°? (Answer: Close to +90°).</p>\n<h3><strong>2.5 Reflected Power and Voltage Standing Wave Ratio (VSWR)</strong></h3>\n<p>Now, let&#39;s directly address the concept of reflected power. When a power source (like our WPT Tx) sends energy towards a load (effectively, the coupled Rx circuit), if the load impedance doesn&#39;t match the source impedance, some of that energy doesn&#39;t get absorbed by the load. Instead, it&#39;s reflected back towards the source.</p>\n<ul>\n<li><p><strong>Incident Power (P_inc):</strong> The power flowing from the source towards the load.</p>\n</li>\n<li><p><strong>Reflected Power (P_ref):</strong> The power flowing back from the load towards the source due to impedance mismatch.</p>\n</li>\n<li><p><strong>Delivered Power (P_delivered):</strong> The power actually absorbed by the load. <code>P_delivered = P_inc - P_ref</code>.</p>\n</li>\n<li><p><strong>Reflection Coefficient (Γ or ρ):</strong> This is a complex number that quantifies the magnitude and phase of the reflected voltage wave relative to the incident voltage wave. It&#39;s calculated based on the load impedance (Z_load) and the characteristic impedance (Z₀) of the transmission medium (or effective source impedance).</p>\n<pre><code>Γ = (Z_load - Z₀) / (Z_load + Z₀)\n</code></pre>\n<p>The magnitude of the reflection coefficient, <code>|Γ|</code>, ranges from 0 (perfect match, no reflection) to 1 (total reflection, e.g., open or short circuit).</p>\n<ul>\n<li>Reflected Power is proportional to <code>|Γ|²</code>. <code>P_ref = P_inc * |Γ|²</code>.</li>\n</ul>\n</li>\n<li><p><strong>Voltage Standing Wave Ratio (VSWR):</strong> In systems with transmission lines, the interference between incident and reflected waves creates a standing wave pattern. VSWR is a measure of the ripple in the voltage magnitude along the line.</p>\n<pre><code>VSWR = (V_max) / (V_min) = (1 + |Γ|) / (1 - |Γ|)\n</code></pre>\n<ul>\n<li>VSWR = 1: Perfect match (<code>|Γ| = 0</code>), no reflection, flat voltage profile.</li>\n<li>VSWR &gt; 1: Mismatch (<code>|Γ| &gt; 0</code>), reflection present, standing wave pattern. Higher VSWR means greater mismatch and more reflected power.</li>\n<li>VSWR = ∞: Total reflection (<code>|Γ| = 1</code>, e.g., open or short circuit).</li>\n</ul>\n</li>\n<li><p><strong>Why Reflected Power/VSWR in WPT Context?</strong> Although WPT isn&#39;t strictly transmission lines, the concepts of impedance mismatch leading to energy not being absorbed and &quot;bouncing back&quot; are directly applicable. The WPT transmitter circuitry effectively &quot;sees&quot; an impedance presented by the coupled Rx and its load. If this effective impedance deviates from what the Tx expects (its &quot;target&quot; load impedance for efficient transfer), it results in a higher &quot;effective reflection&quot; within the Tx&#39;s own circuitry. This manifests as changes in the Tx&#39;s operating parameters – drawing more or less current from the power supply, changes in voltage/current waveforms across its components, or shifts in phase.</p>\n</li>\n</ul>\n<p><strong>Self-Check:</strong> If the magnitude of the reflection coefficient <code>|Γ|</code> is 0.5, what percentage of the incident power is reflected? What is the VSWR? (Answer: Reflected Power = <code>0.5² = 0.25</code>, so 25%. VSWR = (1+0.5)/(1-0.5) = 1.5/0.5 = 3).</p>\n<h3><strong>2.6 How the Load Impedance on the <em>Receiver</em> coil is &quot;Reflected&quot; back to the <em>Transmitter</em></strong></h3>\n<p>This is the core mechanism that allows the attacker to influence the Tx and for the Tx to detect the Rx. The presence and load of the secondary (Rx) coil <em>changes the effective impedance</em> seen by the primary (Tx) coil.</p>\n<p>Think of it like this: The magnetic field produced by the Tx coil induces a current in the Rx coil. This current in the Rx coil then produces its <em>own</em> magnetic field. This secondary magnetic field couples <em>back</em> to the Tx coil, inducing a voltage in it (Lenz&#39;s Law). This induced voltage opposes the change in current in the Tx coil, effectively altering the Tx coil&#39;s impedance from the perspective of the power source.</p>\n<ul>\n<li><p><strong>Mathematical View (Simplified):</strong></p>\n<ul>\n<li>Let Z₁ be the self-impedance of the Tx coil (including tuning capacitance and resistance). Z₁ = R₁ + jωL₁.</li>\n<li>Let Z₂ be the self-impedance of the Rx coil (including tuning capacitance and resistance). Z₂ = R₂ + jωL₂.</li>\n<li>Let Z_load_rx be the impedance of the load connected to the Rx coil (after rectification, or effectively AC impedance presented to the coil).</li>\n<li>Let ω be the angular frequency (ω = 2 * π * f).</li>\n<li>Let M be the mutual inductance between L₁ and L₂.</li>\n</ul>\n<p>The total impedance seen by the Tx power source (Z_in) is approximately:</p>\n<pre><code>Z_in = Z₁ + (ωM)² / (Z₂ + Z_load_rx)\n</code></pre>\n<ul>\n<li>The term <code>(ωM)² / (Z₂ + Z_load_rx)</code> is the <strong>reflected impedance (Z_reflected)</strong>.</li>\n<li>Notice that <code>Z_reflected</code> is inversely proportional to <code>(Z₂ + Z_load_rx)</code>.</li>\n<li>This means that as <code>Z_load_rx</code> changes (e.g., a device drawing more power, or our attacker circuit modulating its load), <code>Z_reflected</code> changes.</li>\n<li>Since <code>Z_in</code> is the sum of <code>Z₁</code> (which is relatively constant) and <code>Z_reflected</code>, changes in <code>Z_load_rx</code> directly cause changes in <code>Z_in</code>.</li>\n</ul>\n</li>\n<li><p><strong>How Changes in Z_in Manifest at the Tx:</strong></p>\n<ul>\n<li><strong>Input Current:</strong> If the Tx is driven by a voltage source, a change in <code>Z_in</code> will cause a change in the current drawn from the source (<code>I_source = V_source / Z_in</code>).</li>\n<li><strong>Voltage/Current Waveforms:</strong> The amplitude and phase of voltage and current waveforms across the Tx coil and tuning components will change as <code>Z_in</code> changes, affecting the Tx&#39;s resonant circuit.</li>\n<li><strong>Phase Shift:</strong> The phase difference between voltage and current at the Tx input or across its coil will change as the complex value of <code>Z_in</code> changes.</li>\n</ul>\n</li>\n</ul>\n<p>This reflected impedance is the <strong>channel</strong> through which the Rx (legitimate or attacker) communicates its presence and state back to the Tx.</p>\n<p><strong>Self-Check:</strong> If the effective load impedance on the Rx (<code>Z_load_rx</code>) increases, does the magnitude of the reflected impedance (<code>Z_reflected</code>) increase or decrease? (Answer: Decrease, because it&#39;s in the denominator).</p>\n<h3><strong>2.7 Analyzing the Tx Perspective: How Changes in Rx Load/Presence Manifest</strong></h3>\n<p>Building on the previous point, let&#39;s be more specific about <em>what</em> a WPT transmitter system actually monitors to understand what the coupled Rx is doing. Commercial WPT controllers are designed to detect a legitimate receiver, regulate power delivery, and potentially receive communication from the receiver (e.g., battery level, desired power). They do this by observing the changes in their own primary circuit caused by the reflected impedance.</p>\n<p>Common parameters monitored by WPT transmitters:</p>\n<ol>\n<li><strong>Input Current/Power Draw:</strong> The most direct indicator. When a legitimate Rx is placed on the Tx, the total load on the Tx power supply increases. More power is being transferred, so the Tx draws more current (or power) from its source. Our attacker device, when harvesting energy, will also cause the Tx to draw more power.</li>\n<li><strong>Tx Coil Voltage/Current Amplitude:</strong> The AC voltage across or current through the Tx coil and its tuning capacitor are key indicators of the resonant circuit&#39;s behavior. Changes in the reflected impedance detune the circuit slightly or change its effective Q, altering the amplitude of these signals.</li>\n<li><strong>Phase Relationship (Voltage vs. Current):</strong> At perfect resonance with no load, the voltage and current in a series resonant circuit are in phase (or 180° out of phase depending on convention), and the impedance is purely resistive. As a load is coupled, the reflected impedance adds a reactive component, causing a phase shift between the Tx voltage and current. Monitoring this phase shift is a very sensitive way for the Tx controller to detect the load and estimate its characteristics.</li>\n<li><strong>Resonance Frequency Shift:</strong> Strong coupling and changes in load can slightly shift the effective resonance frequency of the coupled system. Some advanced Tx designs might monitor or adapt to this shift.</li>\n</ol>\n<p><strong>The Attacker&#39;s Opportunity:</strong> Our goal is to perform actions (harvest energy, modulate load) that cause <em>detectable</em> changes in these parameters. We want to either:</p>\n<ul>\n<li>Cause a sustained change (like increased current draw from energy harvesting) that looks like a legitimate load (or perhaps an <em>unauthorized</em> load).</li>\n<li>Cause rapid, controlled changes (by modulating our load) that encode data, which can be observed as fluctuations in the Tx&#39;s current, voltage, or phase.</li>\n</ul>\n<h3><strong>2.8 Measurement Techniques Overview</strong></h3>\n<p>To observe these phenomena and verify our understanding (and later, our attacks), we need the right tools.</p>\n<ul>\n<li><strong>Oscilloscope:</strong> Your absolute best friend in this course. Essential for:<ul>\n<li>Viewing AC voltage and current waveforms in the Tx and Rx circuits.</li>\n<li>Measuring the amplitude and frequency of signals.</li>\n<li>Observing phase shifts between voltage and current.</li>\n<li>Crucially, seeing the subtle (or not-so-subtle) changes in the Tx waveforms caused by the Rx load, <em>including</em> our attacker&#39;s load modulation. You&#39;ll need probes (voltage probes, and ideally a current probe or shunt resistor setup) and sufficient bandwidth/sampling rate for the WPT frequency you&#39;re working with (e.g., 13.56 MHz requires a scope with bandwidth significantly higher than that, say 50-100 MHz minimum for clean signals, though lower might work for just seeing amplitude changes).</li>\n</ul>\n</li>\n<li><strong>Multimeter:</strong> Useful for DC measurements (power supply voltage, harvested DC voltage) and basic resistance checks, but not for observing the dynamic AC signals and waveforms we&#39;re focusing on here.</li>\n<li><strong>Power Meter / Current Sensor (DC):</strong> For quantifying the <em>total</em> power drawn by the Tx from its source, or the DC power harvested by our Rx circuit (more in Module 6).</li>\n<li><strong>Vector Network Analyzer (VNA):</strong> (Conceptual for this module). A VNA is a sophisticated RF instrument that <em>directly</em> measures impedance (Z) and scattering parameters (S-parameters), including the reflection coefficient (S11). It can show you exactly how the input impedance of the Tx coil changes as you couple an Rx and vary its load, across a range of frequencies. While incredibly useful for analyzing WPT systems and designing coils, they are expensive and complex. For this course&#39;s practical PoC, we will rely on observing the <em>effects</em> of impedance changes (voltage, current, phase) using an oscilloscope, rather than directly measuring the impedance with a VNA. Understand <em>what</em> a VNA measures, as it directly relates to the concepts of impedance and reflection coefficient we discussed.</li>\n</ul>\n<p><strong>Practical Tip:</strong> When using an oscilloscope to observe signals in a switching power circuit like a WPT Tx</p>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: 3: Understanding the WPT Transmitter (The Attacker's Target)</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Welcome back! In Module 2, we delved into the fascinating physics of resonant coupling and the critical concept of reflected power – how changes on the Receiver (Rx) side are &#39;seen&#39; by the Transmitter (Tx). Now, we&#39;re going to put on our attacker&#39;s hat and examine the WPT Transmitter itself. Why? Because to effectively attack a system, you must deeply understand your target. The Tx isn&#39;t just a dumb power source; it&#39;s an active system that senses, regulates, and reacts. Identifying <em>how</em> it does this reveals the vulnerabilities we&#39;ll exploit.</p>\n<p><strong>Module Objective:</strong> By the end of this module, you will be able to describe the typical architecture of a WPT transmitter, understand how it senses the receiver&#39;s presence and state, and identify the specific signals or parameters an attacker can monitor or influence to detect receiver behavior or the presence of their own attack device.</p>\n<h3>3.1 Tx Architecture: The Building Blocks</h3>\n<p>At its core, a WPT transmitter takes a DC power source (like a wall adapter) and converts it into a high-frequency AC signal that drives a coil, generating the oscillating magnetic field. Let&#39;s break down the key components:</p>\n<ol>\n<li><strong>Power Source:</strong> This is typically a DC voltage supply. For consumer electronics like phone chargers, it might be 5V, 9V, or 12V from a USB adapter. For higher power applications (EV charging), it could be much higher DC voltages.</li>\n<li><strong>Inverter/Oscillator:</strong> This is the heart of the AC generation. It takes the DC input and, using switching components (like MOSFETs or transistors), rapidly switches the voltage across the primary circuit to create an AC waveform.<ul>\n<li><strong>Why AC?</strong> Magnetic fields are generated by <em>changing</em> currents. A steady DC current creates a constant magnetic field (useful for electromagnets, not inductive power transfer). We need a rapidly oscillating field to induce a voltage in the secondary coil.</li>\n<li><strong>Frequency:</strong> The operating frequency depends on the WPT standard or design. Qi standard operates in the 100-200 kHz range (lower frequency, larger coils). Resonant systems often operate at higher frequencies (e.g., 6.78 MHz, 13.56 MHz, or even higher) to enable smaller coils and slightly longer ranges due to higher Q factors.</li>\n</ul>\n</li>\n<li><strong>Matching Network / Resonant Circuit:</strong> The Tx coil has inductance. To efficiently transfer power and create a strong oscillating magnetic field at the desired frequency, the coil is typically part of a resonant circuit. This involves adding capacitors in series or parallel with the coil.<ul>\n<li><strong>Resonance:</strong> When the inductive reactance ($X_L = 2\\pi f L$) and capacitive reactance ($X_C = 1/(2\\pi f C)$) are equal at the operating frequency ($f$), the impedance of the circuit is purely resistive (ideally). This allows for maximum current flow through the coil for a given voltage, maximizing the generated magnetic field strength.</li>\n<li><strong>Matching:</strong> This network also helps match the impedance of the resonant circuit to the output impedance of the inverter/driver stage for optimal power transfer <em>into</em> the resonant circuit.</li>\n</ul>\n</li>\n<li><strong>Tx Coil:</strong> The physical coil of wire that generates the primary magnetic field. Its size, shape, and number of turns are critical for determining its inductance and coupling coefficient with the Rx coil. It&#39;s often integrated with the resonant capacitors.</li>\n<li><strong>Control &amp; Sensing Circuitry:</strong> This is the &quot;brain&quot; of the Tx. It monitors the system&#39;s state (often by looking at the voltage, current, or phase relationship in the resonant circuit or the power drawn from the DC source), implements load detection, regulates output power, and in more complex systems (like Qi), handles communication with the Rx.</li>\n</ol>\n<p><strong>Simplified Block Diagram (Conceptual):</strong></p>\n<pre><code>[DC Power Source] --&gt; [Inverter/Oscillator] --&gt; [Matching Network/Resonant Circuit] --&gt; [Tx Coil]\n                               ^                                        |\n                               |----------------------------------------|\n                                        [Control &amp; Sensing Circuitry]\n</code></pre>\n<h3>3.2 Resonant Inverters: Creating the Field</h3>\n<p>Let&#39;s look a bit closer at the Inverter/Oscillator (Subtopic 2). While there are many types, <strong>Class D</strong> and <strong>Class E</strong> inverters are common in WPT due to their high efficiency when driving resonant loads.</p>\n<ul>\n<li><strong>Class D Inverter:</strong> Uses two switching components (like MOSFETs) to create a square wave voltage across the resonant circuit. When one switch is on, voltage is applied in one direction; when the other is on, voltage is applied in the opposite direction. The resonant circuit acts as a filter, smoothing the square wave into a more sinusoidal current through the coil at the resonant frequency.</li>\n<li><strong>Class E Inverter:</strong> Uses a single switching component and relies heavily on the resonant network and timing to achieve high efficiency by minimizing switching losses (e.g., switching when voltage or current is zero - Zero Voltage Switching (ZVS) or Zero Current Switching (ZCS)).</li>\n</ul>\n<p><strong>Why are these important?</strong> The inverter design dictates the waveform shape and efficiency. More importantly for our attack, the <em>control</em> of these inverters (e.g., changing switching frequency, duty cycle, or voltage) is how the Tx regulates the power output. And this regulation is often triggered by the Tx sensing the Rx&#39;s load via reflected power.</p>\n<h3>3.3 Load Detection: How the Tx &quot;Sees&quot; the Rx</h3>\n<p>This is where Module 2&#39;s concepts become directly applicable to the Tx&#39;s function (Subtopic 3). A WPT transmitter needs to know:</p>\n<ol>\n<li>Is a potential receiver present?</li>\n<li>If so, is it a <em>valid</em> receiver? (More relevant for standards like Qi, less so for our basic hijacking attack, but the <em>detection mechanism</em> is the same).</li>\n<li>How much power does the receiver need?</li>\n</ol>\n<p>The primary way the Tx senses a receiver is by detecting the <em>change</em> in the impedance and/or power draw of its own Tx coil circuit when a secondary coil (the Rx) is brought into proximity and coupled.</p>\n<ul>\n<li><strong>Without Rx:</strong> The Tx coil circuit resonates freely (or is driven at resonance). The Tx draws a certain amount of power from the source, primarily to maintain the oscillating field and cover its own losses.</li>\n<li><strong>With Rx Present &amp; Coupled:</strong> Energy is now being transferred from the Tx coil to the Rx coil. This energy transfer represents a <em>load</em> on the Tx&#39;s resonant circuit. From the perspective of the Tx inverter, the <em>effective impedance</em> of the Tx coil changes.<ul>\n<li>Recall from Module 2: The load on the secondary coil is &quot;reflected&quot; back to the primary coil, appearing as a change in impedance.</li>\n<li>This change in impedance means the Tx circuit&#39;s voltage/current relationship changes.</li>\n<li>Consequently, the <em>total power drawn from the DC source</em> by the Tx circuit increases as it delivers power to the Rx.</li>\n</ul>\n</li>\n</ul>\n<p><strong>How the Tx Measures This:</strong> The control circuitry monitors parameters that are sensitive to this reflected impedance change:</p>\n<ul>\n<li><strong>Input DC Current:</strong> A simple way is to measure the total current drawn from the DC power source. When a legitimate Rx starts drawing power, the Tx&#39;s input current will increase.</li>\n<li><strong>Tx Coil Voltage/Current/Phase:</strong> More sophisticated systems directly monitor the AC voltage across the Tx coil, the AC current through it, or the phase difference between them. Changes in reflected impedance alter these AC signals. For example, coupling a loaded Rx might cause the Tx coil voltage to drop or the current to increase, and the phase relationship between voltage and current might shift slightly away from perfect resonance (where voltage and current are in phase).</li>\n</ul>\n<p>This detection mechanism is often used as a &quot;ping&quot; or &quot;polling&quot; method. The Tx might periodically send out short bursts of power and listen for the characteristic change in its own electrical parameters, indicating a receiver is present.</p>\n<h3>3.4 Power Regulation: Adapting to the Load</h3>\n<p>Once a receiver is detected and potentially identified, the Tx needs to regulate the amount of power transferred (Subtopic 4). A phone battery charging at 50% needs more power than one at 90%. The Tx adjusts its output power based on the Rx&#39;s reported needs.</p>\n<p>How does the Tx regulate power? By changing the drive signal to the inverter:</p>\n<ul>\n<li><strong>Changing Frequency:</strong> Shifting the operating frequency slightly away from perfect resonance reduces the efficiency of power transfer.</li>\n<li><strong>Changing Voltage/Duty Cycle:</strong> Modifying the voltage amplitude or the duty cycle of the switching signals in the inverter can control the amount of energy pumped into the resonant circuit per cycle.</li>\n</ul>\n<p>This regulation process is typically a feedback loop:</p>\n<ol>\n<li>Rx communicates its power needs (often via load modulation, which the Tx senses as a specific pattern of reflected impedance changes - foreshadowing Module 4 &amp; 7!).</li>\n<li>Tx senses this communication signal by monitoring its own electrical parameters (voltage, current, etc.).</li>\n<li>Tx adjusts its output power (frequency, voltage, duty cycle).</li>\n<li>Rx receives more or less power and continues to communicate its needs.</li>\n</ol>\n<p><strong>Key Point:</strong> Both load <em>detection</em> and load <em>regulation</em> rely entirely on the Tx&#39;s ability to sense changes in its own circuit caused by the presence and load of the Rx via the physical phenomenon of reflected impedance/power.</p>\n<h3>3.5 Attacker&#39;s Monitoring Points: Where to Look for Signals</h3>\n<p>Based on the Tx architecture and sensing mechanisms, where can an attacker, observing the Tx, look for signs of a receiver (legitimate or their own attack device) and potentially even decode data modulated by the receiver? (Subtopic 5)</p>\n<p>These are the signals or parameters sensitive to reflected power changes:</p>\n<ul>\n<li><strong>DC Input Current/Power:</strong> The easiest to measure externally if the Tx&#39;s power cable is accessible. A legitimate Rx appearing or your attack device harvesting power will cause the total DC power draw to increase.</li>\n<li><strong>Tx Coil Voltage Waveform:</strong> Observing the AC voltage across the Tx coil with an oscilloscope. Changes in reflected load will alter the amplitude and potentially the shape of this waveform.</li>\n<li><strong>Tx Coil Current Waveform:</strong> Observing the AC current through the Tx coil (using a current probe or measuring voltage across a small series sense resistor). Changes in reflected load will alter the amplitude and phase of this waveform relative to the voltage.</li>\n<li><strong>Voltage across Tuning Capacitors:</strong> Similar to Tx coil voltage, these points in the resonant circuit are sensitive to impedance changes.</li>\n<li><strong>Phase Difference (Voltage vs. Current):</strong> Monitoring the phase angle between the voltage and current at the Tx coil. Resonance implies a near-zero phase shift (purely resistive impedance). A reflected load will introduce reactance, causing the phase shift to change.</li>\n</ul>\n<p><strong>Attacker&#39;s Advantage:</strong> While commercial WPT systems might have internal digital communication protocols, the underlying physical layer interaction (reflected power) is <em>always</em> present. By monitoring the analog electrical signals <em>before</em> they are processed by the Tx&#39;s digital control, an attacker can potentially detect <em>any</em> device causing a significant load change in the field, regardless of whether it&#39;s an authorized WPT receiver or a malicious harvesting/modulating device.</p>\n<h3>3.6 Case Study: Qi Standard Tx Operation</h3>\n<p>Let&#39;s briefly look at the Qi standard as a concrete example (Subtopic 6). While Qi has digital communication layers, its foundation is built upon the physical layer interactions we&#39;ve discussed.</p>\n<ol>\n<li><strong>Selection/Ping Phase:</strong> The Qi Tx periodically sends out brief &quot;pings&quot; – short bursts of power at the operating frequency.</li>\n<li><strong>Detection Phase:</strong> A Qi-compatible Rx in the field <em>detects</em> this ping (it receives a small amount of power). The Rx then <em>loads</em> its coil in a specific way (using load modulation - more on this in Module 4) which changes the reflected impedance seen by the Tx.</li>\n<li><strong>Tx Response:</strong> The Qi Tx monitors its coil voltage/current during and after the ping. It looks for the characteristic change caused by the Rx&#39;s loading. If it sees this signature, it knows a potential Rx is present.</li>\n<li><strong>Identification &amp; Configuration Phase:</strong> If a receiver is detected, the Tx might transition to a state where it provides continuous power at a low level. The Rx then uses load modulation (changing its load according to a specific protocol) to send messages back to the Tx, identifying itself and requesting power levels. The Tx decodes these messages by observing the <em>pattern</em> of reflected impedance changes.</li>\n<li><strong>Power Transfer Phase:</strong> Once configured, the Tx provides continuous power. The Rx continues to communicate its battery level and desired power, and the Tx adjusts its output (e.g., by changing the frequency) based on these requests.</li>\n</ol>\n<p><strong>The Attack Relevance:</strong> Notice that steps 2, 3, and 4 rely entirely on the Rx influencing the Tx&#39;s electrical parameters via reflected impedance (load modulation). Our attack will mimic this physical interaction, either to just draw power (causing a load change the Tx <em>might</em> interpret as a legitimate Rx or just an increased load) or to <em>intentionally</em> create patterns of load changes to exfiltrate data.</p>\n<h3>Key Takeaways from Module 3:</h3>\n<ul>\n<li>A WPT transmitter is more than just an oscillator; it&#39;s a system that generates, senses, and regulates the power field.</li>\n<li>The core components are the power source, inverter/oscillator, resonant network, Tx coil, and control/sensing circuitry.</li>\n<li>Load detection and power regulation in WPT rely on the Tx&#39;s ability to sense changes in its own electrical parameters (like input current, coil voltage/current/phase) which are caused by the Rx&#39;s presence and load via <em>reflected impedance</em>.</li>\n<li>These observable electrical parameters on the Tx side are the attacker&#39;s primary targets for monitoring – they reveal information about what&#39;s happening in the power field.</li>\n<li>Understanding how a standard like Qi uses reflected power for detection and communication highlights the vulnerability: the physical channel used for legitimate control can potentially be manipulated for malicious purposes.</li>\n</ul>\n<h3>Module Project/Exercise: Observing Reflected Power on a Basic Tx</h3>\n<p>This project aims to give you hands-on (or simulation-based) experience with how a load on a secondary coil affects the primary side – the core principle we&#39;ve discussed.</p>\n<p><strong>Objective:</strong> Build or simulate a basic resonant WPT transmitter and observe how introducing a passive, loaded secondary coil changes the waveform on the primary side.</p>\n<p><strong>Option A: Simulation (Recommended if you don&#39;t have RF equipment)</strong></p>\n<ul>\n<li><p><strong>Tools:</strong> LTspice, CircuitLab, or any circuit simulator capable of AC analysis and transient simulation.</p>\n</li>\n<li><p><strong>Conceptual Circuit:</strong> We&#39;ll simulate a simple series-resonant primary coupled to a secondary coil with a load resistor.</p>\n<pre><code>[AC Voltage Source] -- [Resistor (Rs)] -- [Inductor (L1)] -- [Capacitor (C1)] -- -- [AC Voltage Source]\n                                                                 |                     |\n                                                                 -- Coupled to L2 --\n                                                                                       |\n                                                                                 [Inductor (L2)] -- [Resistor (Rload)] -- [Ground]\n                                                                                       |\n                                                                                 [Capacitor (C2)] -- -- -- -- -- -- -- -- [Ground]\n</code></pre>\n<ul>\n<li><code>AC Voltage Source</code>: Represents the output of our inverter/driver. Set it to a sine wave at a frequency you&#39;ll resonate L1/C1 at (e.g., 1V amplitude, 130kHz).</li>\n<li><code>Rs</code>: Small series resistor (e.g., 1 Ohm) to represent source impedance and allow easy current measurement (V(Rs)/Rs = Current).</li>\n<li><code>L1</code>, <code>C1</code>: Primary coil inductance and tuning capacitor. Choose values that resonate at your chosen frequency (e.g., for 130kHz, if L1 = 10uH, C1 = 1/( (2<em>pi</em>130e3)^2 * 10e-6 ) ~= 150nF).</li>\n<li><code>L2</code>, <code>C2</code>: Secondary coil inductance and tuning capacitor. For simplicity in this demo, make them the same values as L1/C1 so they resonate at the same frequency.</li>\n<li><code>Rload</code>: The load resistor on the secondary side (e.g., 50 Ohm, 100 Ohm, 1k Ohm). This is what we&#39;ll change or remove.</li>\n<li><code>Coupling</code>: Most simulators allow you to define coupling (Mutual Inductance, M, or Coupling Coefficient, k) between L1 and L2. Start with a moderate coupling, e.g., k=0.5.</li>\n</ul>\n</li>\n<li><p><strong>Step-by-Step Simulation:</strong></p>\n<ol>\n<li>Set up the circuit in your simulator <em>without</em> L2, C2, and Rload connected. Run a transient simulation for a few cycles. Observe the voltage across L1 (V(L1+ node) - V(L1- node)) and the current through L1 (e.g., V(Rs)/Rs). Note the amplitude and phase.</li>\n<li>Now, add L2, C2, and connect Rload (e.g., 100 Ohm). Define the coupling between L1 and L2 (e.g., k=0.5).</li>\n<li>Run the transient simulation again. Observe the voltage across L1 and the current through L1. <em>Compare</em> these waveforms to the case without the secondary load.</li>\n<li>Experiment: Change the value of Rload (e.g., to 50 Ohm, 1k Ohm). How does this affect the primary waveforms? What happens if you set Rload to a very high value (approaching open circuit)?</li>\n<li>Experiment: Change the coupling coefficient &#39;k&#39;. How does stronger/weaker coupling affect the observed changes?</li>\n<li>Experiment (Optional): Change the driving frequency slightly away from resonance. How does this affect the power transfer and the sensitivity of the primary waveforms to the secondary load?</li>\n</ol>\n</li>\n<li><p><strong>Documentation:</strong></p>\n<ul>\n<li>Include the circuit diagram used for simulation.</li>\n<li>Show screenshots of the primary voltage and current waveforms for at least two cases: 1) No secondary load, and 2) Secondary with a moderate load (e.g., 100 Ohm).</li>\n<li>Describe in your own words <em>how</em> the primary waveforms changed when the loaded secondary was introduced.</li>\n<li>Explain <em>why</em> you think these changes occurred, referencing the concept of reflected impedance.</li>\n<li>Note any observations from experimenting with different Rload values or coupling coefficients.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Option B: Basic Hardware Build (Requires basic electronics tools)</strong></p>\n<ul>\n<li><p><strong>Required Components:</strong></p>\n<ul>\n<li>Function Generator (capable of producing sine waves up to ~200kHz or higher, 1-5V amplitude).</li>\n<li>Oscilloscope (2 channels recommended, sufficient bandwidth for your frequency).</li>\n<li>Two coils: You can buy small WPT coils (e.g., Qi coils) or wind your own (e.g., ~20-30 turns of magnet wire on a 5-10cm diameter form). Try to make them similar.</li>\n<li>Capacitors: Various values (e.g., 10nF, 47nF, 100nF, 150nF, 220nF, etc.). You&#39;ll use these to tune the coils to resonance.</li>\n<li>Resistors: Various power resistors (e.g., 1 Ohm, 10 Ohm, 50 Ohm, 100 Ohm, 1k Ohm, 10k Ohm - 0.5W or 1W rating is usually fine for low power tests).</li>\n<li>Breadboard or prototyping board.</li>\n<li>Jumper wires.</li>\n<li>Optional: Small resistor (e.g., 1 Ohm, 0.5W) to use as a current sense resistor in series with the primary coil.</li>\n</ul>\n</li>\n<li><p><strong>Step-by-Step Build &amp; Measurement:</strong></p>\n<ol>\n<li><strong>Build the Primary Resonant Circuit:</strong> Connect your primary coil (L1) in series with a capacitor (C1) and a small sense resistor (Rs) if you have one. Connect this series combination to the output of your function generator.</li>\n<li><strong>Find Resonance:</strong> Set the function generator to a sine wave output (low amplitude, e.g., 2Vpp). Sweep the frequency and/or change the value of C1 until you see the <em>maximum</em> voltage across the series LC combination (or maximum voltage across L1/C1 and minimum voltage across Rs if measuring current). This is your approximate resonance frequency. Note this frequency.</li>\n<li><strong>Observe Primary Waveform (No Secondary Load):</strong> Use your oscilloscope to observe the voltage waveform across the primary coil (or across C1, or the voltage from one side of the series LC-Rs to ground if one side is grounded by the generator). Note the amplitude and shape. If using a current sense resistor, observe the voltage across Rs (representing current).</li>\n<li><strong>Build the Secondary Resonant Circuit:</strong> Connect your secondary coil (L2) in series with a capacitor (C2) and a load resistor (Rload, e.g., 100 Ohm). Again, try to choose C2 to resonate L2 at roughly the same frequency as the primary.</li>\n<li><strong>Introduce the Loaded Secondary:</strong> Place the secondary coil near and aligned with the primary coil (e.g., centered, a few cm apart).</li>\n<li><strong>Observe Primary Waveform (With Loaded Secondary):</strong> Look at the same primary voltage/current waveform(s) on the oscilloscope again. <em>Compare</em> them to the waveforms from step 3.</li>\n<li>Experiment: Change the load resistor Rload on the secondary (e.g., replace 100 Ohm with 1k Ohm, or remove it entirely - open circuit). How does this change the primary waveform?</li>\n<li>Experiment: Change the distance or alignment between the coils. How does coupling affect the observed changes on the primary?</li>\n<li><strong>Safety Note:</strong> Keep the power levels low during this experiment. Function generators typically output low power. Be mindful of component ratings if you use a higher power source later in the course.</li>\n</ol>\n</li>\n<li><p><strong>Documentation:</strong></p>\n<ul>\n<li>Draw a schematic of your primary and secondary circuits.</li>\n<li>Note the component values (L, C, Rload, Rs) and the resonance frequency you found.</li>\n<li>Include oscilloscope screenshots or hand-drawn sketches of the primary voltage and current waveforms for at least two cases: 1) No secondary load, and 2) Secondary with a moderate load (e.g., 100 Ohm). Label axes clearly.</li>\n<li>Describe in your own words <em>how</em> the primary waveforms changed when the loaded secondary was introduced.</li>\n<li>Explain <em>why</em> you think these changes occurred, referencing the concept of reflected impedance.</li>\n<li>Note any observations from experimenting with different Rload values or coil placements.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Expected Outcome:</strong> In both simulation and hardware, you should observe that when a loaded secondary coil is brought near the primary coil, the amplitude of the voltage across the primary coil (and potentially its current) will change. The phase relationship between voltage and current might also shift. This is the direct effect of the reflected impedance caused by the coupled, loaded secondary. You are visually confirming the physical principle that makes WPT load detection and communication possible – and exploitable.</p>\n<hr>\n<p>This concludes Module 3. You now have a foundational understanding of how a WPT transmitter works, how it senses receivers through reflected power, and where an attacker can look to observe these interactions. In Module 4, we&#39;ll shift our focus to the WPT Receiver – understanding its architecture and, crucially, how it uses <em>load modulation</em> to communicate, a technique we will then hijack for data exfiltration. Get ready to build or simulate your Tx and see the physics in action!</p>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, class! Welcome back. We&#39;ve built a solid foundation understanding the physics of WPT and how the transmitter works and senses its environment. Now, we&#39;re going to flip the perspective and dive deep into the <em>receiver</em>. This is critical because, for our attack, the receiver isn&#39;t just the <em>target</em> of power; it&#39;s going to be our <em>tool</em> and <em>proxy</em> for both stealing energy and, more importantly for this module, <em>communicating covertly</em> back to the transmitter.</p>\n<p>Think of it this way: if the transmitter is a radio station broadcasting power, the receiver is usually just a device tuning in to <em>use</em> that power. But a clever attacker can turn that tuning device into a low-power walkie-talkie that talks <em>back</em> to the station, hidden in plain sight within the power signal itself.</p>\n<p>Let&#39;s break down Module 4.</p>\n<hr>\n<h2>Module 4: Understanding the WPT Receiver (The Attacker&#39;s Tool/Proxy)</h2>\n<p><strong>Module Objective:</strong> By the end of this module, you will be able to describe the typical architecture of a WPT receiver, understand how it extracts power and manages its load, and, critically, identify how its load characteristics are communicated back to the transmitter via the very mechanism we&#39;ll hijack: load modulation.</p>\n<p><strong>Recap from Module 3:</strong> We looked at the WPT transmitter (Tx), its components, how it generates the oscillating magnetic field, and how it <em>listens</em> for changes in its coil&#39;s impedance or current draw to detect a receiver and regulate power. This &quot;listening&quot; part is key – the Tx is constantly monitoring its own state, which is influenced by what&#39;s happening at the receiver (Rx).</p>\n<h3>Essential Subtopics:</h3>\n<p>Let&#39;s dissect the WPT Receiver piece by piece.</p>\n<h4>1. Rx Architecture: Rx Coil, Rectifier, Filter, Voltage Regulator, Load</h4>\n<p>Imagine a standard Qi charging receiver inside your phone or a medical implant. It needs to capture the AC energy from the Tx field and convert it into stable DC voltage to power its internal circuitry or charge a battery. Here&#39;s the typical chain:</p>\n<ul>\n<li><strong>Rx Coil:</strong> This is the antenna for receiving power. Just like the Tx coil, it&#39;s usually an inductor tuned to resonate at the same frequency as the Tx (or close to it) to maximize energy transfer. When placed in the oscillating magnetic field generated by the Tx, the changing magnetic flux induces an AC voltage across the Rx coil terminals, thanks to Faraday&#39;s Law of Induction.</li>\n<li><strong>Rectifier:</strong> The induced voltage is AC (alternating current). Most electronic devices need DC (direct current). The rectifier circuit converts the AC voltage into pulsating DC voltage. The most common type for WPT is a full-wave bridge rectifier, using four diodes.</li>\n<li><strong>Filter:</strong> The output of the rectifier is pulsating DC – it goes from zero to a peak voltage, back towards zero, then back to a peak, etc. This isn&#39;t smooth enough for most electronics. A filter, typically a capacitor placed across the rectifier output, smooths out these pulses by storing charge when the voltage is high and releasing it when the voltage dips. This results in a much smoother DC voltage, often with some ripple.</li>\n<li><strong>Voltage Regulator:</strong> Even after filtering, the DC voltage might vary depending on the distance from the Tx, the alignment of the coils, and the power being drawn by the load. A voltage regulator (like an LDO - Low-Dropout Regulator, or a switching regulator) takes this potentially fluctuating DC voltage and provides a stable, constant DC output voltage required by the actual load (e.g., 5V for charging, 3.3V for circuitry).</li>\n<li><strong>Load:</strong> This is the ultimate destination of the power – the battery being charged, the internal electronics of a device, an LED, etc. The load draws current from the voltage regulator.</li>\n</ul>\n<p><strong>Visualizing the Chain:</strong></p>\n<pre><code>[Rx Coil] --&gt; [Rectifier (Diodes)] --&gt; [Filter (Capacitor)] --&gt; [Voltage Regulator] --&gt; [Load (Battery/Circuitry)]\n        (AC Induced)           (Pulsating DC)         (Smoothed DC)          (Stable DC)\n</code></pre>\n<h4>2. Power Extraction: AC-to-DC Conversion</h4>\n<p>Let&#39;s zoom into the rectifier and filter.</p>\n<ul>\n<li><p><strong>Full-Wave Bridge Rectifier:</strong> This configuration uses four diodes arranged in a bridge. During the positive half-cycle of the incoming AC voltage from the Rx coil, two diodes conduct, allowing current to flow through the load. During the negative half-cycle, the <em>other</em> two diodes conduct, again directing current through the load in the <em>same direction</em>. This ensures that current always flows one way through the load, creating a full-wave pulsating DC output.</p>\n<pre><code>(From Rx Coil)\nTerminal A ---|&gt;|--- +V_out ---\n             |   ^             |\n             |   |             |\n             ---|&gt;|--- Load ---\n             |   ^             |\n             |   |             |\nTerminal B --+---|&gt;|----------\n                 |   ^\n                 |   |\n                 ----|&gt;|-------\n                     |\n                     -- -V_out (usually 0V or Ground)\n</code></pre>\n<p><em>(Note: This is a simplified ASCII diagram. A real schematic would show the diodes connected differently, forming the bridge.)</em></p>\n</li>\n<li><p><strong>Filtering Capacitor:</strong> A large capacitor placed in parallel with the load smooths the output. As the pulsating DC voltage rises, the capacitor charges. As the voltage drops (between pulses), the capacitor discharges into the load, filling in the gaps and keeping the voltage relatively constant. The larger the capacitor, the smoother the output (less ripple).</p>\n</li>\n</ul>\n<h4>3. Load Management: How the Rx Regulates Power</h4>\n<p>A simple resistive load would draw current proportional to the voltage. However, real WPT receivers are smarter. They often regulate the power delivered to the final load (like a battery charger IC). This regulation means the <em>effective impedance</em> presented by the Rx circuit to the <em>rectifier</em> changes depending on the load&#39;s needs and the available input power.</p>\n<p>For example, if the Rx is charging a battery that&#39;s nearly full, it draws less current. If the Tx is providing more power than needed, the Rx might increase its internal resistance or even temporarily disconnect the load to manage the voltage and prevent damage. This dynamic load management is a standard feature of WPT receivers.</p>\n<h4>4. Communication Channel: Backscatter Modulation (Load Modulation)</h4>\n<p>This is where things get interesting from an attacker&#39;s perspective. How does a WPT receiver tell the transmitter anything? It doesn&#39;t have a separate Wi-Fi chip or Bluetooth radio for this. Instead, it uses the <em>power link itself</em> as a low-speed communication channel.</p>\n<p>The primary method is <strong>Backscatter Modulation</strong>, often referred to as <strong>Load Modulation</strong> in the context of WPT.</p>\n<ul>\n<li><strong>The Principle:</strong> The receiver intentionally and rapidly changes its electrical load (its impedance). As we learned in Module 2, changing the load impedance on the secondary (Rx) coil affects the <em>reflected impedance</em> seen by the primary (Tx) coil.</li>\n<li><strong>How it Works:</strong> By quickly switching a component (like a resistor or capacitor) in or out of the Rx circuit, the Rx causes tiny, controlled fluctuations in the reflected impedance at the Tx.</li>\n<li><strong>Tx Detection:</strong> The Tx, which is constantly monitoring its own coil current, voltage, or phase, can detect these subtle changes caused by the Rx&#39;s load switching. These changes manifest as small variations on the Tx&#39;s operating waveforms.</li>\n<li><strong>Encoding Data:</strong> The Rx encodes data (like power requests, control packets, or identification signals) by switching the load according to a specific pattern (e.g., turning the load on/off rapidly to represent binary 1s and 0s - On-Off Keying or OOK).</li>\n<li><strong>Low Bandwidth:</strong> Because these changes are subtle and the power transfer frequency is relatively low (compared to Wi-Fi), the data rate achievable via load modulation is typically quite low (tens or hundreds of bits per second in standards like Qi).</li>\n</ul>\n<p><strong>Why is this important for the attacker?</strong> Because this load modulation mechanism is the <em>same method</em> we will use to:</p>\n<ol>\n<li>Signal our presence (or mimic a legitimate Rx).</li>\n<li>Potentially steal power (by presenting a specific load).</li>\n<li><em>Covertly exfiltrate data</em> (by intentionally modulating our <em>own</em> load in a pattern that encodes information). The Tx is <em>already designed</em> to look for these load changes!</li>\n</ol>\n<h4>5. Load Modulation: How Changing Rx Load Affects Tx Reflected Impedance</h4>\n<p>Let&#39;s reiterate this core concept. Imagine the Tx coil as a spring oscillating. When you lightly touch the other end of the spring (representing the Rx with a light load), it only slightly affects the Tx&#39;s oscillation. But if you grab the other end firmly (representing the Rx with a heavier load), it significantly dampens or changes the Tx&#39;s oscillation.</p>\n<p>In electrical terms:</p>\n<ul>\n<li>The impedance of the Rx circuit ($Z_{Rx}$) is transformed through the coupling ($k$) and the coil inductances ($L_1, L_2$) to become a <em>reflected impedance</em> ($Z_{reflected}$) that appears in series with the Tx coil impedance ($Z_{Tx}$).</li>\n<li>A simplified view of the reflected impedance ($Z_{reflected}$) is approximately proportional to $\\frac{k^2 \\omega^2 L_1 L_2}{Z_{Rx}^<em>}$ (where $k$ is coupling, $\\omega$ is frequency, $L_1, L_2$ are inductances, and $Z_{Rx}^</em>$ is the complex conjugate of the Rx impedance).</li>\n<li>This reflected impedance changes the <em>total</em> impedance seen by the Tx power source ($Z_{total} = Z_{Tx} + Z_{reflected}$).</li>\n<li>The Tx&#39;s operating voltage, current, and phase are determined by this total impedance.</li>\n<li>Therefore, by changing $Z_{Rx}$ (via load modulation), the Rx causes a measurable change in $Z_{total}$, which the Tx observes as variations in its own electrical signals.</li>\n</ul>\n<p>This is the fundamental physical channel we will exploit. We don&#39;t need to inject RF signals; we just need to correctly manipulate the load on <em>our</em> attacker coil (which acts as an unauthorized receiver).</p>\n<h4>6. Types of Load Modulation: Resistive, Capacitive, Inductive</h4>\n<p>The Rx can change its load impedance in several ways:</p>\n<ul>\n<li><strong>Resistive Load Modulation:</strong> This is the most common and often simplest to implement. A resistor is switched in parallel or series with the main load or rectifier output. Switching a resistor changes the <em>real</em> part of the Rx impedance. This is often done using a MOSFET acting as a switch controlled by the Rx&#39;s microcontroller.</li>\n<li><strong>Capacitive Load Modulation:</strong> A capacitor is switched in or out. This changes the <em>imaginary</em> (reactive) part of the Rx impedance. This can shift the resonant frequency slightly.</li>\n<li><strong>Inductive Load Modulation:</strong> An inductor is switched in or out. Also changes the <em>imaginary</em> part of the Rx impedance, but with the opposite sign compared to capacitive modulation.</li>\n</ul>\n<p>For our initial Proof-of-Concept (PoC) attack, <strong>resistive load modulation</strong> is the easiest to understand and implement, providing a clear signal change at the Tx.</p>\n<h4>7. Analyzing the Rx Perspective: How to Intentionally Change the Rx Load Impedance</h4>\n<p>From an attacker&#39;s standpoint using our own hardware (not modifying a legitimate device), we need to build an attacker module that <em>looks</em> like a passive WPT receiver but has the capability to <em>actively control</em> its load.</p>\n<p>This means our attacker hardware will need:</p>\n<ul>\n<li>An Rx coil tuned to the target Tx frequency.</li>\n<li>A rectifier and filter to get DC power (for potential energy theft and/or powering our own circuitry).</li>\n<li>A controllable switch (like a MOSFET) connected to a specific load component (like a resistor).</li>\n<li>A microcontroller to control the switch, turning the load component on and off rapidly according to the data we want to exfiltrate.</li>\n</ul>\n<p>By switching this load component, we are intentionally performing load modulation, mimicking the legitimate Rx communication method, but for our own malicious purposes.</p>\n<h3>Connecting to the Attack</h3>\n<p>This module is absolutely foundational for both attack vectors:</p>\n<ul>\n<li><strong>Energy Hijacking:</strong> Our attacker device <em>is</em> essentially an unauthorized WPT receiver designed specifically for power extraction. Understanding the Rx architecture helps us design an efficient harvesting circuit (Module 6).</li>\n<li><strong>Data Exfiltration:</strong> This is where load modulation becomes our covert channel. By understanding how legitimate receivers use load modulation to <em>send data to the Tx</em>, we realize we can use the <em>exact same physical mechanism</em> to send <em>our data</em> (stolen information, attack status, etc.) back to the Tx, where we can then try to observe and decode it (Module 7). The Tx is <em>already listening</em> for these load changes!</li>\n</ul>\n<h3>Suggested Resources or Prerequisites:</h3>\n<ul>\n<li>Module 3 completed (understanding the Tx side of the interaction).</li>\n<li>Basic understanding of rectification (diodes) and filtering (capacitors) in DC power supplies.</li>\n<li>Look at datasheets for WPT receiver controller ICs (e.g., from Analog Devices, Texas Instruments, NXP, IDT/Renesas). Even if we don&#39;t use these specific chips, their block diagrams and application notes illustrate the standard Rx architecture and how load modulation is implemented for legitimate communication. Search for terms like &quot;Qi receiver IC datasheet&quot; or &quot;wireless power receiver controller&quot;. Pay attention to sections on &quot;communication&quot; or &quot;backscatter modulation&quot;.</li>\n</ul>\n<h3>Module Project/Exercise: Observing Load Change Effects</h3>\n<p>Alright, hands-on time! This project directly demonstrates the concept that changing the load on the receiver side has a <em>measurable effect</em> on the transmitter side. This is the physical basis for load modulation.</p>\n<p><strong>Objective:</strong> Build a simple WPT receiver circuit and observe how changing its DC load affects the AC waveform on the transmitter coil.</p>\n<p><strong>Components Needed:</strong></p>\n<ol>\n<li><strong>From Module 3 Project:</strong><ul>\n<li>Your basic WPT transmitter circuit (oscillator driving a coil). Power supply for the Tx.</li>\n<li>Tx Coil.</li>\n<li>Oscilloscope and probes.</li>\n</ul>\n</li>\n<li><strong>For the Basic Receiver:</strong><ul>\n<li>Rx Coil: Needs to be roughly the same size and inductance as your Tx coil, or a standard WPT receiver coil operating at a similar frequency.</li>\n<li>Four rectifier diodes: Small signal diodes like 1N4148 <em>might</em> work for low power, but 1N400x series (e.g., 1N4001) or Schottky diodes (like 1N5817-1N5819) are better for rectification due to lower voltage drop. Schottky diodes are preferred if available.</li>\n<li>Filter Capacitor: Electrolytic capacitor, perhaps 10uF to 100uF, rated for at least the expected peak voltage from the Rx coil (maybe 16V or 25V).</li>\n<li>Load Resistors: You&#39;ll need a few different values to swap. Let&#39;s use:<ul>\n<li>One relatively low value (e.g., 100 Ohm, 1/4W or 1/2W) - Represents a heavier load.</li>\n<li>One relatively high value (e.g., 1 kOhm, 1/4W) - Represents a lighter load.</li>\n<li>(Optional) A very high value (e.g., 10 kOhm or infinite - open circuit) - Represents almost no load.</li>\n</ul>\n</li>\n<li>Breadboard and jumper wires.</li>\n<li>Multimeter (to measure DC voltage on the Rx).</li>\n</ul>\n</li>\n</ol>\n<p><strong>Circuit Diagrams:</strong></p>\n<ul>\n<li><p><strong>Transmitter (Tx):</strong> Use the circuit you built in Module 3. Make sure it&#39;s working and generating an AC field.</p>\n</li>\n<li><p><strong>Receiver (Rx):</strong> Build this simple full-wave bridge rectifier and filter on your breadboard:</p>\n<pre><code>                  +---|&gt;|---+\n                  |         |\n(From Rx Coil)  ---|&gt;|--- Load --- +V_DC (to Capacitor + Load Resistor)\nTerminal A ---+             |\n              |             |\n              |             |\n              +---|&lt;|---+   --- -V_DC (usually Ground)\n                        |   ^\n                        |   |\nTerminal B ---+---------+---|&lt;|---\n              |\n(From Rx Coil)\n</code></pre>\n<ul>\n<li>Connect the Rx coil terminals to points A and B.</li>\n<li>Connect the positive output (+V_DC) to one leg of the filter capacitor and one leg of your load resistor.</li>\n<li>Connect the negative output (-V_DC) to the other leg of the filter capacitor and the other leg of the load resistor.</li>\n<li>Ensure the capacitor&#39;s polarity is correct if using an electrolytic capacitor (+ to +V_DC, - to -V_DC).</li>\n</ul>\n</li>\n</ul>\n<p><strong>Step-by-Step Exercise:</strong></p>\n<ol>\n<li><strong>Set up the Tx:</strong> Power up your Module 3 transmitter circuit. Use your oscilloscope to verify it&#39;s generating an oscillating voltage/current on its coil. Place an oscilloscope probe safely on the Tx circuit where you can observe the waveform (e.g., across the tuning capacitor, or monitor the current indirectly). <strong>Be careful not to short anything or touch high-voltage points if your Tx circuit involves them.</strong></li>\n<li><strong>Build the Basic Rx:</strong> Assemble the full-wave rectifier, filter capacitor, and <em>high-value load resistor (1 kOhm)</em> on your breadboard according to the diagram.</li>\n<li><strong>Initial Placement:</strong> Place the Rx coil near the Tx coil. Start with them relatively close and aligned (like two coasters stacked). Do <em>not</em> connect the Rx to power; it harvests power from the Tx field.</li>\n<li><strong>Observe Rx DC Voltage:</strong> Use your multimeter to measure the DC voltage across the 1 kOhm load resistor (or the filter capacitor). You should see a DC voltage appear, indicating power transfer is happening. Note this voltage.</li>\n<li><strong>Observe Tx Waveform (Light Load):</strong> Look at the waveform on your oscilloscope connected to the Tx circuit. Compare it to the waveform when the Rx coil was <em>not</em> present. You should observe <em>some</em> change just by introducing the Rx coil (due to coupling), but specifically note the characteristics with the 1 kOhm load attached to the Rx rectifier/filter. Note the amplitude, frequency (should be stable), and overall shape.</li>\n<li><strong>Change the Rx Load (Heavier Load):</strong> Carefully <em>remove</em> the 1 kOhm resistor and <em>insert</em> the 100 Ohm resistor as the load on the Rx circuit.</li>\n<li><strong>Observe Rx DC Voltage (Heavier Load):</strong> Measure the DC voltage across the 100 Ohm resistor. It might be lower than with the 1 kOhm load because you&#39;re drawing more current, potentially pulling down the voltage or exceeding the Tx&#39;s capability. Note this voltage.</li>\n<li><strong>Observe Tx Waveform (Heavier Load):</strong> <strong>This is the critical observation.</strong> Look at the waveform on your oscilloscope connected to the Tx circuit again. Compare it to the waveform you saw with the 1 kOhm load. What has changed? You should observe a noticeable difference! The amplitude might drop, the current draw from the Tx power supply will likely increase, and there might be subtle changes in phase or even frequency depending on the Tx design.</li>\n<li><strong>Experiment Further (Optional):</strong><ul>\n<li>Try removing the load resistor entirely (open circuit) and observe the Tx waveform. This represents a very light load.</li>\n<li>If you have a poteniometer (variable resistor), use it as the load and slowly adjust the resistance while watching the Tx waveform on the oscilloscope. See how the waveform changes smoothly.</li>\n</ul>\n</li>\n<li><strong>Document Your Observations:</strong> Record the measured DC voltages for different loads. Take screenshots or draw sketches of the Tx waveforms for the different load conditions (no Rx, Rx with 1k load, Rx with 100 Ohm load). Describe the differences you observe in the Tx waveform (amplitude changes, shape changes, etc.).</li>\n</ol>\n<p><strong>Expected Outcome:</strong> You should clearly see that changing the <em>DC load</em> on the <em>receiver side</em> has a direct and observable impact on the <em>AC waveform</em> on the <em>transmitter side</em>. This is the physical demonstration of how receiver load changes are &quot;reflected&quot; back to the transmitter and why the transmitter can potentially detect them.</p>\n<h3>Review and Conclusion</h3>\n<p>In this module, we&#39;ve dissected the WPT receiver, understanding its core function of capturing and converting AC power to usable DC. Crucially, we&#39;ve uncovered the mechanism of <strong>load modulation</strong> – the ingenious way receivers communicate back to the transmitter by intentionally changing their load impedance.</p>\n<p>We&#39;ve seen how these load changes physically manifest as detectable variations in the transmitter&#39;s electrical signals. This isn&#39;t just a detail of WPT design; it&#39;s the <em>doorway</em> for our data exfiltration attack. By building our own attacker device that can perform controlled load modulation, we can send our own signals back to the Tx, potentially unnoticed among the normal power transfer operations.</p>\n<p>Your project demonstrated this fundamental link. You built a passive Rx, changed its load, and <em>saw</em> the effect on the Tx. This is the physical layer interaction we will manipulate.</p>\n<p><strong>Next Steps:</strong> With this understanding, we are ready to start building our attacker&#39;s hardware platform in Module 5. We&#39;ll select a microcontroller and the necessary components to not just harvest power passively but to <em>actively control</em> our load, preparing for the energy hijacking and data exfiltration implementations in the subsequent modules.</p>\n<p>Keep those coils close and oscilloscopes ready! The hardware build is next.</p>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, aspiring RF attackers and hardware hackers! Welcome to Module 5. This is where the rubber meets the road – or more accurately, where the copper coil meets the breadboard. We&#39;ve spent the last few modules understanding the physics, the target (the Tx), and our tool/proxy (the Rx concept, specifically its load modulation capability). Now, we&#39;re going to physically build the core platform that will enable both our energy hijacking and data exfiltration attacks.</p>\n<p>This module is intensely practical. Get ready to select components, wire them up, and write some basic code to make them do our bidding. We&#39;re building <em>our</em> device, the attacker&#39;s proof-of-concept hardware.</p>\n<hr>\n<h2><strong>Module 5: Building the Attacker&#39;s Hardware Platform</strong></h2>\n<ul>\n<li><p><strong>Module Objective:</strong> Learners will be able to select and integrate hardware components (microcontroller, coils, power handling, modulation circuitry) to build the core platform for the WPT attack device.</p>\n</li>\n<li><p><strong>Learning Outcomes:</strong> By the end of this module, you should be able to:</p>\n<ul>\n<li>Justify the selection of a suitable microcontroller for this project.</li>\n<li>Understand the key parameters for selecting or designing an attacker coil.</li>\n<li>Design and assemble a basic power extraction circuit.</li>\n<li>Design and assemble a basic load modulation circuit using a switching element.</li>\n<li>Integrate these components onto a prototyping board.</li>\n<li>Write basic code to control the load modulation circuit.</li>\n<li>Use an oscilloscope to verify the functionality of the load modulation circuit.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5.1 Introduction: From Theory to Hardware</strong></h3>\n<p>We&#39;ve dissected WPT systems conceptually. We know that changes in the receiver&#39;s load impedance are reflected back to the transmitter, altering its observed impedance, voltage, current, or phase. This reflection is <em>how</em> legitimate WPT systems often detect a receiver and <em>how</em> they communicate (via load modulation).</p>\n<p>Our attacker platform will <em>mimic</em> a receiver in specific ways:</p>\n<ol>\n<li>It needs a coil to pick up the magnetic field.</li>\n<li>It needs circuitry to extract power from that field (for energy hijacking).</li>\n<li>It needs circuitry to <em>intentionally</em> change its load impedance in a controlled way (for data exfiltration via load modulation).</li>\n<li>It needs a brain (a microcontroller) to orchestrate the load modulation and potentially manage power harvesting.</li>\n</ol>\n<p>This module focuses on selecting and integrating these fundamental building blocks into a single, functional prototype platform. Think of this as building the &quot;radio&quot; part of our attack tool.</p>\n<h3><strong>5.2 Choosing the Microcontroller (The Brains)</strong></h3>\n<p>The microcontroller (MCU) is the heart of our attacker device. It will control <em>when</em> and <em>how</em> we modulate the load, potentially read sensors, and in the future, manage harvested power.</p>\n<ul>\n<li><p><strong>Requirements:</strong></p>\n<ul>\n<li><strong>Digital I/O:</strong> We need at least one digital output pin to control our load modulation switch. More pins might be useful for status LEDs, debugging, or future expansions (like reading analog values from the Tx field).</li>\n<li><strong>Processing Speed:</strong> For the basic load modulation we&#39;ll do initially (simple OOK - On-Off Keying), high speed isn&#39;t critical. We&#39;re dealing with modulation frequencies likely in the kHz range, well within the capabilities of most MCUs.</li>\n<li><strong>Memory:</strong> Minimal requirements for basic control code.</li>\n<li><strong>Ease of Use:</strong> For a learning environment, a platform with a simple development environment and lots of community support is highly desirable.</li>\n<li><strong>Power Consumption:</strong> Ideally, the MCU should be relatively low power, especially if we aim to power it from harvested energy later.</li>\n</ul>\n</li>\n<li><p><strong>Candidate Examples:</strong></p>\n<ul>\n<li><strong>Arduino Uno (or Nano/Pro Mini):</strong><ul>\n<li><em>Pros:</em> Extremely popular, vast community support, simple IDE and programming model (C/C++), 5V or 3.3V operation (depending on board). Plenty of digital I/O.</li>\n<li><em>Cons:</em> Relatively slow clock speed compared to newer MCUs, larger physical size (Uno).</li>\n<li><em>Suitability:</em> Excellent for getting started, simple prototyping, and understanding the core concepts.</li>\n</ul>\n</li>\n<li><strong>ESP32 (or ESP8266):</strong><ul>\n<li><em>Pros:</em> Much more powerful (faster CPU, more RAM), built-in Wi-Fi and Bluetooth (useful for future data exfiltration methods or remote control), plenty of I/O (including analog), good community support (Arduino IDE compatible). Relatively low cost.</li>\n<li><em>Cons:</em> Can be slightly more complex to set up initially than Arduino Uno, 3.3V logic requires level shifting if interfacing with 5V components (though less common now).</li>\n<li><em>Suitability:</em> A great choice for a more robust platform, potential for more complex modulation schemes, and integration with other systems.</li>\n</ul>\n</li>\n<li><strong>STM32 (various boards like &#39;Blue Pill&#39;):</strong><ul>\n<li><em>Pros:</em> Powerful ARM Cortex-M processors, high clock speeds, rich peripherals (timers, ADCs, DACs), low power options.</li>\n<li><em>Cons:</em> Can be more complex to program initially (requires setting up toolchains or using CubeIDE), steeper learning curve than Arduino.</li>\n<li><em>Suitability:</em> Good for performance-critical applications or when needing specific advanced peripherals.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Recommendation for this Course:</strong> We will primarily use <strong>Arduino Uno</strong> examples due to its simplicity and accessibility. The concepts and code structure are easily portable to ESP32 or other platforms. If you have an ESP32, feel free to use it – just adjust the pin numbers.</p>\n</li>\n<li><p><strong>Step:</strong> Choose your MCU development board based on availability and preference. An Arduino Uno or equivalent is perfectly sufficient for this module&#39;s project.</p>\n</li>\n</ul>\n<h3><strong>5.3 Designing/Selecting the Attacker Coil (The Antenna)</strong></h3>\n<p>Our attacker coil is the equivalent of a receiver coil in a legitimate WPT system. It needs to efficiently capture the magnetic field energy from the target transmitter.</p>\n<ul>\n<li><p><strong>Key Considerations:</strong></p>\n<ul>\n<li><strong>Operating Frequency:</strong> The coil needs to resonate at or near the operating frequency of the target WPT transmitter. Qi standard is typically 100-205 kHz. Other systems might operate at different frequencies (e.g., higher for some resonant systems, MHz for NFC-based power). You need to know or estimate your target&#39;s frequency.</li>\n<li><strong>Inductance (L) and Capacitance (C):</strong> The coil&#39;s inductance and a parallel tuning capacitor determine its resonant frequency ($f_r = \\frac{1}{2\\pi\\sqrt{LC}}$). You&#39;ll need to select an inductance and then add a capacitor to tune it to the target frequency.</li>\n<li><strong>Q Factor:</strong> A higher Q factor means a sharper resonance, which can lead to more efficient energy capture <em>at</em> the resonant frequency, but less capture if the frequency is slightly off. For a simple PoC, a moderate Q is fine. Q is affected by wire resistance, core losses (if using a core), and the tuning capacitor&#39;s losses.</li>\n<li><strong>Physical Size and Geometry:</strong> The coil&#39;s size and shape affect its inductance and how well it couples with the transmitter coil. Larger coils can often capture more flux, but need to fit within the attack scenario. Flat, spiral coils are common for WPT.</li>\n<li><strong>Wire Type:</strong> Litz wire (multiple insulated strands) is often used in WPT coils to reduce AC resistance (skin and proximity effects) at high frequencies, improving Q. Solid core wire works for basic prototyping but might be less efficient.</li>\n</ul>\n</li>\n<li><p><strong>Methods for Obtaining an Attacker Coil:</strong></p>\n<ol>\n<li><strong>Salvage:</strong> Find old wireless chargers or WPT-enabled devices and desolder their coils. This is often the easiest way to get coils designed for WPT frequencies.</li>\n<li><strong>Buy Off-the-Shelf:</strong> You can purchase WPT receiver coils designed for specific standards (like Qi) from electronic component suppliers (Digi-Key, Mouser, SparkFun, Adafruit, AliExpress, etc.). Look for coils specified for ~100-200 kHz operation.</li>\n<li><strong>Wind Your Own:</strong> You can wind your own coil.<ul>\n<li><em>Process:</em> Get some magnet wire (enameled copper wire, e.g., 24-30 AWG). Find a suitable form (e.g., a 3D printed bobbin, a cardboard tube, or just wind air-core). Wind a specific number of turns.</li>\n<li><em>Estimating Inductance:</em> Use online coil inductance calculators (search for &quot;air core coil inductance calculator&quot;). The number of turns, coil diameter, and coil length/width are key inputs.</li>\n<li><em>Tuning:</em> Once wound, measure its inductance (using an LCR meter or a simple LC resonant circuit with a known capacitor and frequency counter/oscilloscope). Then, calculate the required parallel capacitance to resonate at your target frequency ($C = \\frac{1}{(2\\pi f_r)^2 L}$). Add this capacitor in parallel with the coil.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Step:</strong> Acquire a WPT receiver coil. Salvaging or buying off-the-shelf Qi receiver coils (~5-20 µH inductance) is recommended for simplicity. If winding your own, aim for an inductance that, when paired with a common capacitor value (e.g., 100nF - 1µF), resonates in the 100-200 kHz range.</p>\n</li>\n</ul>\n<h3><strong>5.4 Power Extraction Circuitry (Getting Usable DC)</strong></h3>\n<p>The AC voltage induced in the attacker coil needs to be converted into a stable DC voltage to potentially power the MCU or, at minimum, to power the load we will switch for modulation.</p>\n<ul>\n<li><p><strong>Circuit Components:</strong></p>\n<ul>\n<li><strong>Rectifier:</strong> Converts AC to pulsating DC.<ul>\n<li><em>Option A (Full-Wave Bridge):</em> Uses 4 diodes. Common, simple. Voltage drop is ~2 * diode drop.</li>\n<li><em>Option B (Full-Wave with Center-Tap):</em> Requires a center-tapped coil (less common for off-the-shelf Rx coils) and 2 diodes. Voltage drop is ~1 * diode drop.</li>\n<li><em>Diode Choice:</em> <strong>Schottky diodes</strong> are preferred over standard silicon diodes. They have a much lower forward voltage drop (e.g., 0.2-0.4V vs 0.6-1.0V), which is crucial when dealing with potentially low induced voltages from the WPT field. Look for Schottky diodes with low forward voltage and suitable current rating (e.g., 1N5817, 1N5819, or surface mount equivalents).</li>\n</ul>\n</li>\n<li><strong>Filter Capacitor:</strong> Smooths the pulsating DC output from the rectifier into a more stable DC voltage. A larger capacitor provides better filtering but takes longer to charge. An electrolytic capacitor is typical here (e.g., 10 µF to 100 µF, rated above the expected peak voltage). Place it in parallel with the rectifier output.</li>\n<li><strong>Voltage Regulator:</strong> Provides a stable DC voltage (e.g., 3.3V or 5V) regardless of variations in the harvested power or load.<ul>\n<li><em>Option A (Linear Regulator - LDO):</em> Simple to use (e.g., LM1117, AMS1117). Requires input voltage to be <em>higher</em> than the desired output voltage (dropout voltage). Inefficient if input voltage is much higher than output (dissipates excess power as heat).</li>\n<li><em>Option B (Switching Regulator - Buck/Boost):</em> More efficient than linear regulators, can step voltage up or down. More complex circuitry (inductor, switching IC).</li>\n<li><em>Choice:</em> An LDO is sufficient and simpler for this basic PoC, assuming the rectified voltage is consistently above the required voltage (e.g., &gt;4V for a 3.3V regulator). If harvested voltage is low and variable, a switching regulator might be needed, but complicates the build.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Basic Schematic (Rectifier &amp; Filter):</strong></p>\n<pre><code>Attacker Coil (AC)\n      +---|&gt;|---+--- Filter Capacitor ---+---&gt; Pulsating DC (+)\n      |   D1    |                        |\n----- L_coil ---- C_tune ---- L_coil -----\n      |   D4    |                        |\n      +---|&lt;|---+---|&gt;|----+---|&lt;|-------+---&gt; GND (-)\n          D3        D2\n      (Full-Wave Bridge using Schottky Diodes)\n</code></pre>\n<ul>\n<li><em>Note:</em> The tuning capacitor (C_tune) is in parallel with the coil (L_coil). The rectifier bridge (D1-D4) connects across the coil/capacitor parallel combination.</li>\n</ul>\n</li>\n<li><p><strong>Adding the Regulator:</strong> Connect the positive pulsating DC output from the filter capacitor to the input of your chosen voltage regulator. Connect the regulator&#39;s output to the VCC pin of your MCU and the rest of your circuit. Connect the regulator&#39;s ground pin to the circuit&#39;s ground.</p>\n</li>\n<li><p><strong>Step:</strong> Assemble the rectifier and filter circuit on your breadboard. Use Schottky diodes for the bridge. Add an electrolytic filter capacitor. If you plan to power the MCU from this harvested power <em>eventually</em> (not required for <em>this</em> module&#39;s project, which assumes external MCU power), add a voltage regulator configured for your MCU&#39;s operating voltage (e.g., 5V or 3.3V).</p>\n</li>\n</ul>\n<h3><strong>5.5 Load Modulation Circuitry (The Attacker&#39;s Signal)</strong></h3>\n<p>This is the core mechanism for data exfiltration. We need to be able to rapidly change the load connected to our attacker coil (or its rectified output) under MCU control. This change in load impedance will reflect back to the Tx.</p>\n<ul>\n<li><p><strong>Mechanism:</strong> We&#39;ll connect a resistive load (or potentially capacitive/inductive, but resistive is simplest) across the rectified DC output of our power extraction circuit. We will use a semiconductor switch, controlled by the MCU, to connect or disconnect this load.</p>\n</li>\n<li><p><strong>Switching Element:</strong></p>\n<ul>\n<li><strong>MOSFET:</strong> An N-channel MOSFET is ideal for switching a load connected to ground. They act like voltage-controlled switches, have very low &quot;on&quot; resistance when fully turned on, and can switch quickly.</li>\n<li><em>How it works:</em> Apply a voltage (greater than the Gate Threshold Voltage, Vth) between the Gate and Source pins, and the switch turns &quot;on&quot; (allowing current to flow between Drain and Source). Apply 0V (or &lt; Vth) to the Gate, and the switch turns &quot;off&quot;.</li>\n<li><em>Selection:</em> Choose a logic-level MOSFET if driving directly from a 3.3V or 5V MCU pin (Gate Threshold Voltage Vth should be low, e.g., &lt; 2V). Ensure its Drain-Source voltage rating ($V_{DS}$) is higher than the peak rectified voltage, and its Drain current rating ($I_D$) is higher than the current the load resistor will draw. Common examples: FQP30N06L (logic-level), BS170 (lower current, not logic-level usually). A small signal MOSFET like the 2N7000 might work for very small loads, but a power MOSFET is generally safer.</li>\n</ul>\n</li>\n<li><p><strong>Load Resistor:</strong></p>\n<ul>\n<li>This resistor determines the amount of current drawn when the MOSFET is switched &quot;on&quot;.</li>\n<li><em>Value Selection:</em> The resistance should be low enough to draw a noticeable amount of current from the attacker coil/rectifier when switched on. This current draw needs to be significant enough to cause a detectable change in the reflected impedance at the transmitter. Experimentation is key here. Start with values like 100 Ohms, 50 Ohms, 10 Ohms, or even lower (e.g., 1-5 Ohms) if your rectifier and coil can handle the current. <em>Be cautious with low resistance values – they draw high current and can generate significant heat in the resistor, MOSFET, and even the rectifier diodes and coil.</em> Start high and go lower.</li>\n<li><em>Power Rating:</em> The resistor needs to handle the power dissipated ($P = V^2/R$, where V is the rectified voltage). Use a resistor with a sufficient wattage rating (e.g., 0.25W, 0.5W, 1W+).</li>\n</ul>\n</li>\n<li><p><strong>Basic Schematic (Load Modulation):</strong></p>\n<pre><code>Rectified DC (+) ---+--- Load Resistor ---+--- MOSFET Drain\n                    |                       |\nFilter Capacitor ---+                       |\n                                            |\nRectified DC (-) ---+-----------------------+--- MOSFET Source\n                    |\n                   GND\n\nMCU Digital Output --- Gate Resistor (e.g., 1k-10k Ohm) --- MOSFET Gate\n</code></pre>\n<ul>\n<li><em>Gate Resistor:</em> A small resistor (e.g., 1k to 10k Ohm) is often placed in series with the MOSFET gate to limit current drawn from the MCU pin when charging the gate capacitance. It&#39;s good practice.</li>\n</ul>\n</li>\n<li><p><strong>Step:</strong> Assemble the load modulation circuit on your breadboard. Connect the MOSFET (Source to ground, Drain to the load resistor). Connect one leg of the load resistor to the positive output of your rectifier/filter circuit. Add a gate resistor between your chosen MCU digital output pin and the MOSFET&#39;s Gate pin.</p>\n</li>\n</ul>\n<h3><strong>5.6 Powering the Attacker Device</strong></h3>\n<p>For this module&#39;s project, we will <strong>power the microcontroller externally</strong>. This simplifies testing the load modulation circuit independently of the energy harvesting efficiency.</p>\n<ul>\n<li><p><strong>External Power:</strong> Connect the MCU development board to your computer via USB, or use a separate 5V/3.3V power supply.</p>\n</li>\n<li><p><strong>Future Self-Harvesting (Goal for later modules):</strong> In later modules, we might explore using the harvested power from the WPT field to <em>power the MCU itself</em>. This requires careful design to ensure enough power is available and might involve a power management IC or supercapacitor/battery to handle variations. For now, keep it simple with external power for the MCU.</p>\n</li>\n</ul>\n<h3><strong>5.7 Integration and Prototyping (Putting it on the Breadboard)</strong></h3>\n<p>Now, combine the pieces you&#39;ve designed onto a single breadboard.</p>\n<ul>\n<li><p><strong>Components Needed for Module 5 Project:</strong></p>\n<ul>\n<li>Microcontroller Development Board (e.g., Arduino Uno)</li>\n<li>WPT Receiver Coil (salvaged or purchased)</li>\n<li>Small tuning capacitor for the coil (value depends on coil inductance and target frequency - estimate or measure!)</li>\n<li>4 x Schottky Diodes (e.g., 1N5817)</li>\n<li>1 x Electrolytic Filter Capacitor (e.g., 47 µF - 100 µF, 16V+)</li>\n<li>1 x N-channel Logic-Level MOSFET (e.g., FQP30N06L or similar low Vth)</li>\n<li>1 x Load Resistor (e.g., 10-100 Ohms, 0.5W+) - <em>Start with a higher value like 100 Ohm and work down if needed.</em></li>\n<li>1 x Gate Resistor (e.g., 1k - 10k Ohm, 0.25W)</li>\n<li>Breadboard</li>\n<li>Jumper Wires</li>\n<li>USB Cable (for powering/programming MCU)</li>\n</ul>\n</li>\n<li><p><strong>Assembly Steps (Detailed):</strong></p>\n<ol>\n<li><strong>Place the MCU:</strong> Put your Arduino Uno (or other board) on the breadboard. Note which pins are digital I/O, GND, and 5V/3.3V.</li>\n<li><strong>Create Power Rails:</strong> Use jumper wires to connect the 5V (or 3.3V) pin on the Arduino to the positive rail of the breadboard, and the GND pin to the negative (GND) rail.</li>\n<li><strong>Connect Attacker Coil &amp; Tuning Cap:</strong> Place your WPT coil on the breadboard (or connect it via wires if it&#39;s off-board). Connect the tuning capacitor in parallel with the coil leads. <em>Ensure the capacitor is rated for AC voltage if placed directly across the coil, or use non-polarized ceramic/film caps. If placed after a diode, use polarized electrolytic, observing polarity.</em> For simplicity, place the tuning cap <em>directly</em> across the coil leads.</li>\n<li><strong>Assemble the Rectifier Bridge:</strong> Arrange the 4 Schottky diodes to form a full-wave bridge rectifier. Pay close attention to the diode band (cathode) direction. The two AC input points connect to the coil/capacitor. One output point is the positive DC (+), the other is the negative DC (-).<ul>\n<li><em>Visual Aid:</em> Search online for &quot;diode bridge rectifier breadboard layout&quot;.</li>\n</ul>\n</li>\n<li><strong>Add the Filter Capacitor:</strong> Connect the positive lead of the electrolytic capacitor to the positive DC output of the rectifier, and the negative lead to the negative DC output (GND). <em>Double-check polarity!</em></li>\n<li><strong>Place the MOSFET:</strong> Insert the MOSFET into the breadboard. Identify its pins (Gate, Drain, Source - check the datasheet!). Connect the Source pin to the GND rail.</li>\n<li><strong>Connect the Load Resistor:</strong> Connect one leg of the load resistor to the positive DC output of the rectifier/filter circuit. Connect the other leg of the load resistor to the Drain pin of the MOSFET.</li>\n<li><strong>Connect the Gate Resistor:</strong> Connect one leg of the gate resistor to a chosen digital output pin on your MCU (e.g., pin 8). Connect the other leg of the gate resistor to the Gate pin of the MOSFET.</li>\n<li><strong>Review Connections:</strong> Carefully check all connections against your schematic or the steps above. Pay special attention to diode and capacitor polarity, and MOSFET pinout.</li>\n</ol>\n</li>\n<li><p><strong>Schematic of the Integrated Platform (Conceptual):</strong></p>\n<pre><code>[Arduino Uno]\n(Digital Pin X) --[Gate Resistor]--|&gt;|-- (MOSFET Gate)\n                                        /\n(5V/3.3V) ----&gt; +V Rail -----------&gt;\n                                    |\n(GND) -------&gt; GND Rail ---------&gt; MOSFET Source\n                                    |\n[Attacker Coil] --[Tuning Cap]--[Rectifier]--[Filter Cap]--+--[Load Resistor]-- MOSFET Drain\n                                                          |\n                                                          +-- To +V Rail (if powering circuits from harvested power - NOT for this module&#39;s project)\n                                                          |\n                                                          +-- To MCU V_in/VIN (if powering MCU from harvested power - NOT for this module&#39;s project)\n</code></pre>\n<ul>\n<li><em>Note:</em> For this module&#39;s project, the &quot;+V Rail&quot; powering the MCU comes <em>directly</em> from the Arduino&#39;s USB/VIN power, <em>not</em> from the harvested power circuit. The harvested power circuit (coil, rectifier, filter) only provides voltage to the load resistor/MOSFET part.</li>\n</ul>\n</li>\n</ul>\n<h3><strong>5.8 Basic Measurement Setup</strong></h3>\n<p>Before writing code, understand how you will verify the circuit is working.</p>\n<ul>\n<li><p><strong>Tools:</strong> An oscilloscope is essential. A multimeter is also useful for checking basic continuity and DC voltages.</p>\n</li>\n<li><p><strong>What to Measure (for this module):</strong></p>\n<ol>\n<li><strong>MCU Digital Output:</strong> Connect an oscilloscope probe to the digital pin controlling the MOSFET gate (after the gate resistor is fine, or directly on the MOSFET gate pin). You should see a clear 0V to VCC (5V or 3.3V) square wave when the pin is toggled. This verifies your MCU code is running and controlling the pin.</li>\n<li><strong>Voltage Across the Switched Load:</strong> Connect an oscilloscope probe across the load resistor (between the connection point with the filter capacitor positive and the MOSFET Drain). The ground clip of the probe should be connected to the circuit&#39;s GND rail (MOSFET Source). When the MOSFET is off, you should see the rectified/filtered DC voltage (voltage across the filter cap). When the MOSFET is on, the voltage across the resistor should drop significantly (close to 0V if the MOSFET is ideal and the load is connected directly to ground). This verifies that the MOSFET is switching the load.</li>\n</ol>\n</li>\n<li><p><strong>Safety Note:</strong> When working with WPT systems, be mindful of the power levels. Low-power Qi chargers (5W) are relatively safe, but higher power systems (fast chargers, EV chargers) can be dangerous. For these initial tests, you will interact with the <em>attacker&#39;s</em> circuit, which operates on the voltage induced in <em>your</em> coil. This voltage will depend on the Tx power and coupling, but for a basic PoC with a phone charger, it should be low voltage. <em>Always exercise caution and understand the power sources involved.</em> Do NOT directly probe the primary (Tx) side of a mains-powered WPT system without proper isolation and knowledge.</p>\n</li>\n</ul>\n<h3><strong>5.9 Putting it Together: Module 5 Project</strong></h3>\n<p><strong>Project Objective:</strong> Build the core attacker hardware platform on a breadboard and program the MCU to toggle the load modulation MOSFET. Verify the digital output signal and the switched voltage across the load resistor using an oscilloscope.</p>\n<p><strong>Required Materials:</strong></p>\n<ul>\n<li>All components listed in section 5.7.</li>\n<li>Assembled breadboard circuit as described in section 5.7.</li>\n<li>Computer with Arduino IDE installed.</li>\n<li>USB cable for Arduino.</li>\n<li>Oscilloscope and probes.</li>\n<li>A target WPT transmitter (like a standard Qi wireless phone charger pad). <em>You will place your attacker coil near this Tx for the final verification step, but the MCU is powered externally.</em></li>\n</ul>\n<p><strong>Step-by-Step Project Instructions:</strong></p>\n<ol>\n<li><strong>Assemble the Hardware:</strong> Follow the detailed assembly steps in section 5.7 to build the complete circuit on your breadboard. Double-check all connections, component polarities (diodes, electrolytic cap), and MOSFET pinout.</li>\n<li><strong>Connect MCU:</strong> Connect your Arduino Uno to your computer via the USB cable. This will power the Arduino.</li>\n<li><strong>Open Arduino IDE:</strong> Start the Arduino IDE software.</li>\n<li><strong>Write the Code:</strong> Enter the following basic code into the IDE. This code will simply toggle the digital pin connected to your MOSFET&#39;s gate, turning the MOSFET and thus the load resistor on and off periodically.</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, SME hat on, teacher mode engaged! This is where the rubber meets the road – taking the theoretical understanding of reflected power and turning it into a physical reality to steal energy. This is a classic &quot;side-channel&quot; attack, but instead of leaking data, we&#39;re leaking <em>power</em>. Let&#39;s build this thing, step-by-step.</p>\n<hr>\n<h2><strong>Module 6: Attack Vector 1: Energy Hijacking Implementation</strong></h2>\n<p><strong>Welcome back, future RF hackers!</strong> In Module 5, you built the basic hardware platform – your attacker device&#39;s brain (the MCU) and the potential to switch loads. Now, we&#39;re giving it a purpose: unauthorized energy harvesting. This is the first of our two primary attack vectors. We&#39;ll leverage the physics we discussed in Modules 2 and 4 – specifically, how placing a resonant receiver coil within the Tx field draws energy, and how this changes the Tx&#39;s operating point (its &quot;reflected power signature&quot;).</p>\n<p><strong>Module Objective:</strong> By the end of this module, you will be able to:</p>\n<ul>\n<li>Design and assemble a basic energy harvesting circuit optimized for a specific WPT frequency.</li>\n<li>Integrate this circuit with your attacker platform.</li>\n<li>Experimentally determine optimal coil placement for energy harvesting.</li>\n<li>Measure the amount of power harvested by your device.</li>\n<li>Observe and quantify the effect of your attacker device on the target WPT transmitter&#39;s power draw or signal characteristics.</li>\n<li>Demonstrate energy hijacking by powering a simple load (like an LED) using the harvested energy.</li>\n</ul>\n<p><strong>Let&#39;s Get Started!</strong></p>\n<h3><strong>6.1 Designing the Energy Harvesting Circuit</strong></h3>\n<p>The goal here is simple: capture the oscillating magnetic field energy with our attacker coil and convert it into usable DC voltage to power something.</p>\n<ul>\n<li><p><strong>Components Review:</strong></p>\n<ul>\n<li><strong>Attacker Coil:</strong> You selected/designed this in Module 5. Its inductance (L) and self-capacitance, or added parallel capacitance (C), should ideally resonate near the target WPT transmitter&#39;s operating frequency (e.g., 100-200 kHz for low-frequency Qi, 6.78 MHz or 13.56 MHz for resonant systems). Resonance is key to efficiently capturing energy!</li>\n<li><strong>Rectifier:</strong> The coil produces AC voltage. We need DC to power most electronics. A bridge rectifier is common, using four diodes to convert both halves of the AC cycle into pulsating DC. For low-voltage WPT, use Schottky diodes if possible – they have a lower forward voltage drop (0.2-0.3V vs 0.7V for silicon), meaning less energy is wasted as heat in the diodes.</li>\n<li><strong>Filter Capacitor:</strong> The output of the rectifier is pulsating DC. A capacitor in parallel smooths this out into a more stable DC voltage. The capacitor charges up during the peaks of the rectified voltage and discharges slightly between peaks. A larger capacitance value provides better filtering but takes longer to charge.</li>\n<li><strong>Voltage Regulator (Optional but Recommended):</strong> The DC voltage from the filter capacitor will vary depending on the coupling, the Tx power, and the load. To provide a stable voltage for your MCU or a specific load (like a 5V LED strip or a 3.3V MCU), a voltage regulator is necessary. Simple Linear Dropout (LDO) regulators are easy to use (e.g., LM1117, AMS1117), but inefficient (they burn excess voltage as heat). Switching regulators (Buck/Boost converters) are more efficient but more complex. For a simple PoC powering an LED, you might skip the regulator or use a simple Zener diode setup, but for powering the MCU reliably, a regulator is best.</li>\n</ul>\n</li>\n<li><p><strong>Circuit Diagram Concept:</strong></p>\n<pre><code>Attacker Coil (L) --+----|&gt;|----+---- +V_rectified\n                  |    |       |\n                  |    |&lt;|----|\n                  |    |       |\n                  +----|&lt;|----+---- Filter Cap (C_filter) -- Regulator (Optional) -- +V_out (to load/MCU)\n                       |    |\n                       |    |&gt;|\n                       |    |\n                       +----+---- 0V (Ground)\n</code></pre>\n<p><em>(Note: This is a simplified representation. A full bridge rectifier has 4 diodes arranged in a diamond shape).</em></p>\n</li>\n<li><p><strong>Optimization Considerations:</strong></p>\n<ul>\n<li><strong>Resonance:</strong> Ensure your attacker coil + parallel capacitor resonates near the target Tx frequency. You can calculate this using <code>f = 1 / (2 * pi * sqrt(L * C))</code>. You might need to experiment with capacitor values or use an LC meter/VNA if you have access.</li>\n<li><strong>Diode Selection:</strong> Use low forward voltage diodes (Schottky) for maximum efficiency.</li>\n<li><strong>Capacitor Sizing:</strong> A value in the range of 10uF to 100uF is often sufficient for filtering in basic WPT harvesting circuits at typical frequencies.</li>\n<li><strong>Regulator Choice:</strong> If powering the MCU, ensure the regulator can handle the maximum rectified voltage and provide the required stable voltage and current for the MCU.</li>\n</ul>\n</li>\n</ul>\n<h3><strong>6.2 Coil Placement and Coupling: Finding the Sweet Spot</strong></h3>\n<p>Unlike a legitimate receiver designed to sit squarely on a charging pad, your attacker coil needs to intercept the field <em>from a distance</em> or <em>at an angle</em> where a legitimate receiver might not be. The strength of the captured power depends heavily on the coupling coefficient (k) between the Tx coil and your attacker coil.</p>\n<ul>\n<li><p><strong>Factors Affecting Coupling:</strong></p>\n<ul>\n<li><strong>Distance:</strong> Coupling decreases rapidly with distance. Near-field WPT is very short-range.</li>\n<li><strong>Alignment:</strong> Coils are most strongly coupled when their axes are aligned and they are close. However, you might find optimal harvesting slightly off-axis depending on the Tx field pattern.</li>\n<li><strong>Orientation:</strong> The relative orientation of the coils matters.</li>\n<li><strong>Presence of other objects:</strong> Metal objects can disrupt the field. The legitimate receiver itself will alter the field.</li>\n</ul>\n</li>\n<li><p><strong>Practical Experimentation:</strong></p>\n<ul>\n<li>Power up your target WPT transmitter (e.g., a standard Qi charger).</li>\n<li>Connect your energy harvesting circuit <em>with a simple indicator load</em> (like a low-current LED and resistor, or a multimeter set to measure DC voltage) to the output of the filter capacitor or regulator.</li>\n<li>Slowly move your attacker coil around the Tx coil.</li>\n<li>Observe the indicator (LED brightness or multimeter reading).</li>\n<li>Mentally (or physically, mark it) note the positions and orientations where the indicator is strongest. This is where coupling is highest, and you&#39;re harvesting the most energy.</li>\n<li><em>Important:</em> Note that the optimal position for <em>harvesting</em> might be different from the optimal position for <em>modulating</em> data later (Module 7), or the optimal position for <em>stealth</em>. For this module, focus on maximizing harvested power.</li>\n</ul>\n</li>\n</ul>\n<h3><strong>6.3 Stealth Considerations (Or Lack Thereof for PoC V1)</strong></h3>\n<p>A legitimate WPT system is designed to detect when a compliant receiver is present and adjust its power output accordingly. It also often monitors the reflected impedance to ensure the receiver isn&#39;t faulty or drawing too much power unexpectedly, which could be a safety hazard or damage the Tx.</p>\n<ul>\n<li><p><strong>How the Tx Detects You (Potentially):</strong></p>\n<ul>\n<li><strong>Load Detection:</strong> When you place your coil and start drawing power, you change the overall load impedance seen by the Tx. This is the primary mechanism the Tx uses to detect <em>any</em> receiver.</li>\n<li><strong>Specific Protocol Handshake:</strong> Legitimate receivers often perform a digital handshake (e.g., Qi communication packets sent via load modulation) before the Tx provides full power. Your simple harvesting circuit doesn&#39;t do this.</li>\n<li><strong>Overcurrent/Overpower Protection:</strong> If you suddenly draw a significant amount of power, the Tx might detect an overcurrent condition and shut down.</li>\n<li><strong>Frequency/Phase Shifts:</strong> Drawing power changes the effective impedance, which can slightly detune the Tx resonant circuit, causing shifts in frequency or phase that the Tx controller might detect.</li>\n</ul>\n</li>\n<li><p><strong>Stealth in PoC V1:</strong> For this initial energy hijacking PoC, <em>we are not aiming for stealth</em>. The objective is to <em>demonstrate</em> the ability to harvest power and <em>observe</em> the effect on the Tx. Achieving true stealth is a much more advanced topic requiring detailed knowledge of the target protocol and sophisticated load manipulation. In this module, success is drawing power and seeing the Tx react, even if it throws an error.</p>\n</li>\n</ul>\n<h3><strong>6.4 Measurement of Harvested Power</strong></h3>\n<p>Quantifying what you&#39;ve stolen is crucial for the demonstration.</p>\n<ul>\n<li><p><strong>What to Measure:</strong></p>\n<ul>\n<li><strong>DC Voltage:</strong> The stable DC voltage available after the filter capacitor or regulator.</li>\n<li><strong>DC Current:</strong> The amount of current drawn by your load from the harvesting circuit.</li>\n</ul>\n</li>\n<li><p><strong>Tools:</strong></p>\n<ul>\n<li><strong>Multimeter:</strong> The simplest tool. Measure DC Voltage across the output terminals. To measure current, place the multimeter in series with your load (set to DC Amps).</li>\n<li><strong>Current Sensor Module (e.g., INA219):</strong> For integrating measurement into your MCU platform, modules like the INA219 (I2C interface) can measure voltage and current with reasonable accuracy.</li>\n<li><strong>Dedicated USB Power Meter:</strong> If your load is a USB device or battery charger, a simple inline USB power meter can show voltage, current, and even accumulated energy (mAh/Wh).</li>\n</ul>\n</li>\n<li><p><strong>Calculation:</strong> Once you have voltage (V) and current (I), the harvested power (P) is simply:<br><code>P = V * I</code> (in Watts)</p>\n</li>\n<li><p><strong>Procedure:</strong></p>\n<ol>\n<li>Set up your Tx and attacker coil in the position you found to be optimal for harvesting.</li>\n<li>Connect your harvesting circuit output to your chosen load (e.g., LED, small fan, or just a power resistor).</li>\n<li>Use your multimeter or sensor to measure the DC voltage <em>across</em> the load and the DC current <em>flowing through</em> the load.</li>\n<li>Calculate the power.</li>\n<li>Repeat measurements at slightly different positions/orientations to confirm your &quot;optimal&quot; spot yielded the most power.</li>\n</ol>\n</li>\n</ul>\n<h3><strong>6.5 Observing the Tx Response</strong></h3>\n<p>This is critical evidence that your attacker device is <em>interacting</em> with the WPT system. You need to show that the Tx behaves differently when your device is present and harvesting.</p>\n<ul>\n<li><p><strong>What to Observe:</strong></p>\n<ul>\n<li><strong>Tx Input Current:</strong> This is often the easiest and safest parameter to measure. When the Tx delivers more power (to a legitimate or illegitimate receiver), its input current from the wall adapter or power supply will increase.</li>\n<li><strong>Tx Input Voltage:</strong> Usually stable, but might dip slightly under heavy load.</li>\n<li><strong>Tx Coil Voltage/Current Waveforms:</strong> Using an oscilloscope, you can look at the AC voltage across or current through the Tx coil. When a load is coupled, the amplitude might drop, the frequency might shift slightly, or the phase relationship between voltage and current might change.</li>\n<li><strong>Tx Indicator LEDs/Display:</strong> Some chargers have LEDs indicating charging status or errors. Note how they change.</li>\n<li><strong>Tx Audible Noise:</strong> Some chargers make noise, which can change under load.</li>\n</ul>\n</li>\n<li><p><strong>Tools:</strong></p>\n<ul>\n<li><strong>AC Clamp Meter:</strong> Safest way to measure AC input current without breaking the circuit. Ensure it&#39;s rated for the expected current and frequency (standard clamp meters are for 50/60 Hz, you might need a specialized one for higher frequency Tx waveforms, though input current is usually low frequency).</li>\n<li><strong>Multimeter (for input current):</strong> <em>Requires breaking the circuit!</em> <strong>Only attempt this if you are comfortable and confident working with AC mains voltage, or if the Tx is low-voltage DC powered.</strong> Place the multimeter (set to AC Amps) in series with the Tx&#39;s power input. <strong>THIS CAN BE EXTREMELY DANGEROUS WITH MAINS VOLTAGE.</strong></li>\n<li><strong>Oscilloscope:</strong> Connect probes carefully to the Tx coil or related circuitry. <strong>Again, be extremely cautious with potentially high voltages on the Tx coil.</strong> Look for accessible, lower-voltage test points if available.</li>\n<li><strong>Camera/Phone:</strong> To record Tx indicator changes or oscilloscope screen captures.</li>\n</ul>\n</li>\n<li><p><strong>Procedure:</strong></p>\n<ol>\n<li>Set up the target WPT transmitter as it would normally operate (e.g., plugged in).</li>\n<li>Measure/Observe the chosen parameter (e.g., Tx input current) <em>without</em> your attacker device present. Record this baseline value.</li>\n<li>Place your attacker coil in the optimal harvesting position.</li>\n<li>Measure/Observe the same Tx parameter <em>with</em> your attacker device harvesting power. Record this value.</li>\n<li>Compare the values. Document the change.</li>\n<li><em>Optional:</em> If you have a legitimate WPT receiver, place it on the Tx and observe the parameter. Compare the effect of your attacker vs. a legitimate receiver.</li>\n</ol>\n</li>\n<li><p><strong>Safety First!</strong> Working with power electronics, especially mains-powered devices, carries significant risk. <strong>Always be aware of live voltages.</strong> If you are not comfortable probing a powered Tx circuit, focus on measuring the Tx <em>input current</em> using a clamp meter or by measuring the current drawn from a <em>low-voltage</em> DC power supply if your Tx uses one. <strong>Never open or probe mains-powered devices unless you are qualified and take appropriate safety precautions.</strong></p>\n</li>\n</ul>\n<h3><strong>6.6 Proof-of-Concept Demonstration</strong></h3>\n<p>Bringing it all together! The visible proof that you are successfully hijacking energy.</p>\n<ul>\n<li><p><strong>Simple Loads:</strong></p>\n<ul>\n<li><strong>LED:</strong> Easiest. Connect one or more LEDs (with appropriate current-limiting resistors) to the output of your harvesting circuit (after the regulator if used, or directly from the filtered DC). The LED lighting up when the attacker coil is near the Tx is a clear visual demonstration.</li>\n<li><strong>Small Fan/Motor:</strong> Another visual/audible indicator.</li>\n<li><strong>Small Battery Charger:</strong> Use the harvested power to charge a small battery (e.g., a tiny LiPo for a drone or IoT device) via a suitable charging IC (like TP4056 for LiPo). This demonstrates storing the stolen energy.</li>\n<li><strong>Powering the MCU:</strong> If your harvesting circuit provides enough stable voltage/current, you can use it to power your MCU directly. The MCU running code (e.g., blinking its own LED) becomes the demonstration of harvested energy.</li>\n</ul>\n</li>\n<li><p><strong>Demonstration Setup:</strong></p>\n<ol>\n<li>Have the target WPT transmitter visible and powered.</li>\n<li>Have your attacker device ready, with the harvesting circuit connected to your chosen simple load.</li>\n<li>Show the load is off when the attacker coil is away from the Tx.</li>\n<li>Bring the attacker coil near the Tx.</li>\n<li>Show the load activating (LED lights up, fan spins, MCU powers on and runs code).</li>\n<li><em>Optional:</em> Show the Tx input current change or Tx indicator change simultaneously if you have the setup for it.</li>\n</ol>\n</li>\n</ul>\n<h3><strong>Module Project/Exercise: Implementing and Demonstrating Energy Hijacking</strong></h3>\n<p>Alright, let&#39;s build and test!</p>\n<p><strong>Goal:</strong> Integrate the energy harvesting circuit, find optimal placement, measure harvested power, observe Tx response, and demonstrate power theft using a simple load.</p>\n<p><strong>Materials Needed:</strong></p>\n<ul>\n<li>Completed attacker hardware platform from Module 5 (MCU, prototyping board).</li>\n<li>Attacker coil (from Module 5).</li>\n<li>Rectifier diodes (Schottky recommended, e.g., 1N5817, 1N5819). You&#39;ll need 4 for a bridge rectifier.</li>\n<li>Filter capacitor (e.g., 47uF - 100uF electrolytic, rated for voltage higher than expected peak AC).</li>\n<li>Optional: Voltage regulator (e.g., AMS1117-3.3 or -5.0) and associated capacitors (check datasheet).</li>\n<li>Simple load: LED(s) with appropriate current-limiting resistor(s), or a small buzzer, or a small DC motor, or a small battery charging module + battery.</li>\n<li>Multimeter (for measuring DC voltage/current).</li>\n<li>Optional: AC clamp meter or means to safely measure Tx input current.</li>\n<li>Optional: Oscilloscope (to observe Tx waveforms).</li>\n<li>Target WPT transmitter (e.g., a standard Qi charger).</li>\n<li>Jumper wires, breadboard or perfboard.</li>\n</ul>\n<p><strong>Step-by-Step Instructions:</strong></p>\n<ol>\n<li><p><strong>Assemble the Energy Harvesting Circuit:</strong></p>\n<ul>\n<li>Build the bridge rectifier using the four diodes. Pay close attention to the polarity (the line on the diode indicates the cathode). The AC inputs come from the coil, and the DC output has positive and negative terminals. <em>Refer to online diagrams for a diode bridge if needed.</em></li>\n<li>Connect the attacker coil to the AC input terminals of the bridge rectifier.</li>\n<li>Connect the filter capacitor across the DC output terminals of the bridge rectifier. Ensure correct polarity for electrolytic capacitors (+ to +, - to -).</li>\n<li><em>If using a voltage regulator:</em> Connect the output of the filter capacitor to the input of the voltage regulator. Add any required input/output capacitors as per the regulator&#39;s datasheet. The regulated output is your final +V_out.</li>\n<li><em>If not using a regulator:</em> The output of the filter capacitor is your +V_out. Add a simple current-limiting resistor and LED here for initial testing.</li>\n</ul>\n</li>\n<li><p><strong>Initial Harvesting Test:</strong></p>\n<ul>\n<li>Connect a simple indicator (like an LED with a resistor, or just your multimeter set to DC Volts) to the output of your harvesting circuit (+V_out and Ground).</li>\n<li>Power up your target WPT transmitter.</li>\n<li>Carefully bring your attacker coil near the Tx coil.</li>\n<li>Observe the LED lighting up or the voltage reading appearing on the multimeter. If nothing happens, check your wiring, diode polarity, and coil placement. Ensure the Tx is actually transmitting (some require a legitimate receiver handshake first – if so, you might need to place a legitimate receiver briefly to activate it, then swap quickly, or find a Tx that broadcasts continuously).</li>\n</ul>\n</li>\n<li><p><strong>Integrate with Attacker Platform / Final Load:</strong></p>\n<ul>\n<li>Decide how you will demonstrate power harvesting for the final project.</li>\n<li><em>Option A (Powering MCU):</em> If your harvested voltage is stable and sufficient (e.g., &gt;3.5V for a 3.3V regulator), connect the output of your harvesting circuit (after regulation) to the appropriate power input pins of your MCU development board. Remove any other power source (like USB). If the MCU powers on and runs a simple &quot;heartbeat&quot; sketch (like blinking an onboard LED), you&#39;ve successfully powered it via WPT harvesting.</li>\n<li><em>Option B (Powering Separate Load):</em> Connect your chosen simple load (LED, fan, etc.) to the output of your harvesting circuit. Ensure appropriate current limiting for LEDs/motors.</li>\n</ul>\n</li>\n<li><p><strong>Find Optimal Coil Placement:</strong></p>\n<ul>\n<li>With your harvesting circuit connected to your chosen load/indicator, power up the Tx.</li>\n<li>Slowly move your attacker coil around the Tx coil, varying distance, alignment, and orientation.</li>\n<li>Observe the load&#39;s performance (LED brightness, fan speed, MCU activity) or the voltage reading on a multimeter connected across the load.</li>\n<li>Identify and document the position and orientation where you achieve the maximum performance/voltage. This is your optimal harvesting spot.</li>\n</ul>\n</li>\n<li><p><strong>Measure Harvested Power:</strong></p>\n<ul>\n<li>Place the attacker coil in the optimal position found in Step 4.</li>\n<li>Use your multimeter to measure the DC voltage across your load and the DC current flowing through your load.</li>\n<li>Calculate the harvested power (Watts = Volts * Amps).</li>\n<li>Record this value.</li>\n</ul>\n</li>\n<li><p><strong>Observe and Document Tx Response:</strong></p>\n<ul>\n<li>Set up your measurement of the Tx parameter (e.g., input current).</li>\n<li>Measure the Tx parameter <em>without</em> the attacker coil present. Record the baseline.</li>\n<li>Place the attacker coil in the optimal harvesting position.</li>\n<li>Measure the Tx parameter <em>with</em> the attacker coil harvesting power. Record the new value.</li>\n<li>Calculate the <em>change</em> in the Tx parameter.</li>\n<li><em>If using an oscilloscope:</em> Capture the Tx coil waveform with and without the attacker present and save the images for comparison.</li>\n<li>Document your observations (e.g., &quot;Tx input current increased by 50mA,&quot; &quot;Tx status LED changed from Green to Orange,&quot; &quot;Tx coil voltage amplitude dropped by 10%&quot;).</li>\n</ul>\n</li>\n<li><p><strong>Prepare Your Demonstration:</strong></p>\n<ul>\n<li>Get your setup ready to show someone (or record a video): Tx, attacker device with harvesting circuit and load, and optionally your Tx observation setup (multimeter, oscilloscope).</li>\n<li>Practice the sequence: Show Tx idle -&gt; Place attacker coil -&gt; Show load activating -&gt; Show Tx response (if possible).</li>\n</ul>\n</li>\n<li><p><strong>Document Your Results:</strong></p>\n<ul>\n<li>Write a brief report or create a presentation documenting:<ul>\n<li>Your energy harvesting circuit design (schematic or description).</li>\n<li>The components used.</li>\n<li>Your process for finding the optimal coil placement.</li>\n<li>The maximum harvested voltage, current, and calculated power.</li>\n<li>Your observations of the Tx response (baseline vs. with attacker, include measurements/images).</li>\n<li>A description of your power hijacking demonstration.</li>\n<li>Any challenges encountered and how you overcame them.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Code Examples (Minimal for this module):</strong></p>\n<p>As noted, code isn&#39;t the focus here, hardware is. If you are using the harvested energy to power your MCU (Option A in Step 3), the code is simply whatever sketch you want to run to prove the MCU is alive. A basic LED blink sketch is perfect.</p>\n<pre><code class=\"language-cpp\">// Simple Arduino sketch to prove the MCU is powered and running\n// If powered by harvested energy, the blinking demonstrates successful harvesting\n\nconst int ledPin = LED_BUILTIN; // Use the built-in LED on your board\n\nvoid setup() {\n  // Initialize the LED pin as an output\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // Turn the LED on\n  digitalWrite(ledPin, HIGH);\n  delay(500); // Wait for 500 milliseconds\n\n  // Turn the LED off\n  digitalWrite(ledPin, LOW);\n  delay(500); // Wait for 500 milliseconds\n}\n</code></pre>\n<p><em>Upload this sketch to your MCU <em>before</em> attempting to power it via harvesting. Then, remove the USB cable and connect the harvesting circuit output to the MCU&#39;s power input. If the LED starts blinking, you&#39;ve succeeded in powering it wirelessly!</em></p>\n<p>If you are using the MCU to <em>monitor</em> something (like the INA219 sensor), you would add the necessary I2C code, but that&#39;s beyond the core requirement of <em>demonstrating</em> harvesting. For this module, focus on the analog/power side.</p>\n<h3><strong>Summary &amp; What&#39;s Next</strong></h3>\n<p>You did it! You&#39;ve built a device capable of performing unauthorized energy harvesting from a WPT field. You&#39;ve quantified the power you can steal and, importantly, you&#39;ve gathered evidence that the target Tx <em>reacts</em> to your presence, confirming the interaction at the physical layer.</p>\n<p>This understanding of how your device&#39;s load affects the transmitter is not just for stealing power; it&#39;s the fundamental principle we will exploit for the second attack vector: covert data exfiltration. In the next module (Module 7), we will modify our attacker platform to <em>intentionally</em> manipulate its load in a controlled way to send information back to the Tx, turning the WPT field into a covert communication channel.</p>\n<p>Get your oscilloscope ready, because things are about to get modulated!</p>\n<hr>\n<p><strong>Remember to document your work thoroughly and practice safety in your lab!</strong> Sharing your findings (responsibly) is key to advancing security knowledge.</p>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, class! Welcome back. We&#39;ve laid the groundwork, understood the physics of reflected power, poked around the Tx and Rx, and even built our basic attacker platform and siphoned off some free energy. Now, things get really interesting – and a little bit stealthy.</p>\n<p>In Module 6, we built a device that draws power. That&#39;s one attack vector: energy theft. But what if we want to steal <em>data</em>? Not data transmitted over the <em>data</em> channel (like the Qi communication protocol), but data encoded <em>within the power transfer itself</em>?</p>\n<p>That&#39;s the goal of Module 7. We&#39;re going to turn our energy harvesting coil into a covert communication device, sending information back to anyone monitoring the power source by subtly manipulating the load, and thus, the reflected power signature. Think of it as whispering secrets back through the power cord. Spooky, right? Let&#39;s dive in.</p>\n<hr>\n<h2><strong>Module 7: Attack Vector 2: Covert Data Exfiltration Implementation</strong></h2>\n<ul>\n<li><strong>Module Objective:</strong> Learners will be able to design, build, and demonstrate a device that can encode small amounts of data by modulating its load impedance and understand how this modulation can be observed as changes in the reflected power signature at the transmitter.</li>\n</ul>\n<h3><strong>7.1 Revisiting Load Modulation as a Communication Channel</strong></h3>\n<p>Remember in Module 4 when we discussed how legitimate WPT receivers communicate with the transmitter? A primary method, especially in standards like Qi, is <strong>backscatter modulation</strong>, which is fundamentally <strong>load modulation</strong>.</p>\n<ul>\n<li><strong>How it works (Legitimate):</strong> The receiver intentionally changes its load impedance (often by switching a small resistance or capacitance on/off). This change in load impedance on the secondary (Rx) coil is &quot;reflected&quot; back to the primary (Tx) coil.</li>\n<li><strong>How it&#39;s detected (Legitimate):</strong> The transmitter continuously monitors its own state – things like the current drawn from the power supply, the voltage/current/phase relationship across its Tx coil, or the voltage across tuning capacitors. When the receiver modulates its load, these parameters on the Tx side change ever so slightly, following the pattern of the receiver&#39;s modulation. The Tx circuitry is designed to detect these subtle changes, demodulate them, and interpret them as control signals or data from the receiver (e.g., &quot;I&#39;m here&quot;, &quot;I need more power&quot;, &quot;My battery is full&quot;).</li>\n<li><strong>Our Attack:</strong> We are <em>not</em> a legitimate receiver. We don&#39;t care about the WPT protocol&#39;s defined communication. We are simply placing our attacker coil (our unauthorized Rx) in the field. By building a circuit that <em>intentionally</em> changes the load on <em>our</em> attacker coil, we can cause <em>similar</em> changes in the reflected power signature at the Tx. If we control <em>when</em> and <em>how</em> we change our load, we can encode our <em>own</em> data onto the Tx&#39;s observable signals.</li>\n</ul>\n<p>This is a physical layer attack. We aren&#39;t breaking encryption or injecting packets into a digital stream. We are manipulating the fundamental physics of the power transfer to create a side channel.</p>\n<h3><strong>7.2 Designing the Load Modulation Scheme</strong></h3>\n<p>Okay, we know we need to change our load. How do we encode data using this?</p>\n<ul>\n<li><strong>Simplest Approach: On-Off Keying (OOK):</strong> The easiest way to modulate is to simply switch a load on and off.<ul>\n<li>Load ON = Represents a digital &#39;1&#39; (or &#39;0&#39;, you decide).</li>\n<li>Load OFF = Represents a digital &#39;0&#39; (or &#39;1&#39;).</li>\n</ul>\n</li>\n<li><strong>What Load?</strong> A resistor is the simplest. When connected across the rectified output of our attacker coil, it draws current. When disconnected, it doesn&#39;t.</li>\n<li><strong>Modulation Depth:</strong> This refers to <em>how much</em> the load changes.<ul>\n<li>A large change (switching a very low resistance) creates a strong, easily detectable signal at the Tx. However, it&#39;s also more likely to disrupt the Tx&#39;s operation, potentially triggering error detection or protection mechanisms (like the Tx shutting down), making the attack less covert.</li>\n<li>A small change (switching a higher resistance) is stealthier but much harder to detect and decode at the Tx side.</li>\n<li>The optimal modulation depth depends heavily on the specific WPT transmitter being targeted. You&#39;ll need to experiment.</li>\n</ul>\n</li>\n<li><strong>Data Rate:</strong> How fast can we switch the load?<ul>\n<li>Limited by the WPT system&#39;s bandwidth and the Tx&#39;s control loop response time. The Tx needs time to &quot;see&quot; and react to the load change.</li>\n<li>Attempting to modulate too fast will result in the Tx filtering out the changes or simply not responding quickly enough for the modulation to be observable.</li>\n<li>Start <em>very</em> slow (e.g., 10-100 bits per second) for initial proof-of-concept. Higher speeds are possible but require more sophisticated signal processing and potentially faster switching circuitry.</li>\n</ul>\n</li>\n<li><strong>Encoding:</strong> We need a way to represent the data we want to send as a sequence of ON/OFF pulses. Simple binary encoding is sufficient for a PoC. We can send ASCII characters, sensor readings, or any other small piece of data.</li>\n</ul>\n<h3><strong>7.3 Implementing the Modulation Circuit</strong></h3>\n<p>We already built the foundation for this in Module 5! Our attacker hardware platform includes:</p>\n<ol>\n<li>The attacker Rx coil.</li>\n<li>A rectifier and filter to convert AC to DC.</li>\n<li>A microcontroller (MCU).</li>\n<li>A switching component (like a MOSFET) controllable by the MCU.</li>\n<li>A load (like a resistor).</li>\n</ol>\n<p>We connect the resistor <em>after</em> the rectifier/filter, across the DC bus. The MOSFET is placed in series with the resistor (or the low side of the resistor) to switch it on and off under MCU control.</p>\n<p><strong>Circuit Diagram (Conceptual):</strong></p>\n<pre><code>Attacker Rx Coil\n      |\n      |\n[ Rectifier &amp; Filter ] --&gt; DC Voltage Bus (+)\n      |                          |\n      |                     [ Resistor ]\n      |                          |\n      |                     [ MOSFET ] &lt;--- Gate controlled by MCU Digital Pin\n      |                          |\n-------------------------------------------------- Ground (-)\n</code></pre>\n<p>When the MCU&#39;s digital pin goes HIGH, the MOSFET turns ON, completing the circuit for the resistor and drawing current from the DC bus. When the pin goes LOW, the MOSFET turns OFF, and the resistor draws no current. This switching action modulates the load presented to the attacker Rx coil, which in turn modulates the reflected impedance seen by the Tx.</p>\n<p><strong>Component Considerations:</strong></p>\n<ul>\n<li><strong>MOSFET:</strong> Needs to be able to handle the voltage and current on the DC bus of your attacker Rx. A small N-channel MOSFET (like a 2N7000 or similar logic-level gate MOSFET) is likely sufficient for low-power PoCs. Ensure the MCU&#39;s voltage is sufficient to drive the gate fully ON.</li>\n<li><strong>Resistor:</strong> Choose a value that creates a noticeable load change <em>without</em> causing the Tx to shut down. This requires experimentation. Start with something relatively high (e.g., 100-500 ohms) and decrease it if the modulation isn&#39;t visible, while carefully monitoring the Tx&#39;s behavior.</li>\n</ul>\n<h3><strong>7.4 Encoding and Generating the Modulation (Code)</strong></h3>\n<p>Let&#39;s write some simple code for an Arduino-compatible MCU to perform OOK modulation to transmit a message. We&#39;ll transmit the string &quot;HI&quot;.</p>\n<p>We&#39;ll need functions to:</p>\n<ol>\n<li>Turn the load ON.</li>\n<li>Turn the load OFF.</li>\n<li>Transmit a single bit (with a defined duration).</li>\n<li>Transmit a byte (e.g., an ASCII character), including simple start/stop bits for framing.</li>\n<li>Transmit a string.</li>\n</ol>\n<pre><code class=\"language-cpp\">// Define the digital pin connected to the MOSFET gate\nconst int MOSFET_GATE_PIN = 8; // Example pin, choose one suitable for your board\n\n// Define the duration of a single bit in milliseconds\n// This determines the data rate (e.g., 100 ms = 10 bits/sec)\nconst int BIT_DURATION_MS = 100; // Adjust based on experimentation\n\n// Define the duration of start/stop bits (can be same as bit duration)\nconst int START_STOP_DURATION_MS = 100;\n\nvoid setup() {\n  // Configure the MOSFET gate pin as an output\n  pinMode(MOSFET_GATE_PIN, OUTPUT);\n\n  // Start with the load off\n  digitalWrite(MOSFET_GATE_PIN, LOW);\n\n  // Optional: Add a small delay at startup\n  delay(1000);\n\n  // Initialize Serial communication for debugging (optional)\n  Serial.begin(9600);\n  Serial.println(&quot;Attacker Modulation Device Ready&quot;);\n}\n\nvoid set_load_on() {\n  digitalWrite(MOSFET_GATE_PIN, HIGH);\n}\n\nvoid set_load_off() {\n  digitalWrite(MOSFET_GATE_PIN, LOW);\n}\n\n// Transmit a single bit using OOK\n// bit: 0 or 1\n// duration_ms: how long the load is in the corresponding state\nvoid transmit_bit(int bit, int duration_ms) {\n  if (bit == 1) {\n    set_load_on();\n    // Serial.print(&quot;1&quot;); // Debugging\n  } else { // bit == 0\n    set_load_off();\n    // Serial.print(&quot;0&quot;); // Debugging\n  }\n  delay(duration_ms); // Maintain the state for the bit duration\n}\n\n// Transmit a byte (8 bits) using OOK with start/stop bits\n// Simple framing: Start bit (0), 8 data bits (LSB first), Stop bit (1)\nvoid transmit_byte(byte data, int bit_duration_ms) {\n  // Serial.print(&quot;\\nSending byte: &quot;); // Debugging\n  // Serial.println(data, BIN); // Debugging\n\n  // Send Start Bit (typically 0)\n  // A &#39;0&#39; bit is represented by Load OFF in this example OOK scheme\n  transmit_bit(0, START_STOP_DURATION_MS);\n\n  // Send Data Bits (8 bits, LSB first)\n  for (int i = 0; i &lt; 8; i++) {\n    // Extract the i-th bit (0 or 1)\n    int bit = (data &gt;&gt; i) &amp; 0x01;\n    // A &#39;1&#39; bit is Load ON, &#39;0&#39; bit is Load OFF\n    transmit_bit(bit, bit_duration_ms);\n  }\n\n  // Send Stop Bit (typically 1)\n  // A &#39;1&#39; bit is represented by Load ON in this example OOK scheme\n  transmit_bit(1, START_STOP_DURATION_MS);\n\n  // Optional: Add a short pause between bytes\n  delay(bit_duration_ms * 2);\n}\n\n// Transmit a null-terminated string\nvoid transmit_string(const char* str, int bit_duration_ms) {\n  // Serial.print(&quot;\\nSending string: &quot;); // Debugging\n  // Serial.println(str); // Debugging\n  while (*str) { // Loop until null terminator\n    transmit_byte(*str, bit_duration_ms);\n    str++; // Move to the next character\n  }\n  // Serial.println(&quot;\\nString transmission complete.&quot;); // Debugging\n}\n\nvoid loop() {\n  // String to transmit\n  const char* message = &quot;HI&quot;;\n\n  // Transmit the message repeatedly (or once, depending on goal)\n  transmit_string(message, BIT_DURATION_MS);\n\n  // Optional: Add a longer pause between message repetitions\n  delay(5000); // Wait 5 seconds before repeating\n}\n</code></pre>\n<p><strong>Code Explanation:</strong></p>\n<ul>\n<li><code>MOSFET_GATE_PIN</code>: Set this to the digital pin connected to your MOSFET&#39;s gate.</li>\n<li><code>BIT_DURATION_MS</code>: This is crucial. It defines how long each &#39;1&#39; or &#39;0&#39; state lasts. A value of 100ms means 10 bits per second (ignoring start/stop and pauses). Start with a large value and decrease it.</li>\n<li><code>set_load_on()</code> / <code>set_load_off()</code>: Simple wrappers for <code>digitalWrite</code> to control the MOSFET.</li>\n<li><code>transmit_bit()</code>: Sets the load state for the specified duration using <code>delay()</code>.</li>\n<li><code>transmit_byte()</code>: Implements a basic serial-like protocol: a start bit (0), 8 data bits (Least Significant Bit first is common), and a stop bit (1). This helps delineate bytes when decoding.</li>\n<li><code>transmit_string()</code>: Iterates through the characters of a string, sending each byte.</li>\n<li><code>loop()</code>: Calls <code>transmit_string()</code> with our message &quot;HI&quot; and repeats.</li>\n</ul>\n<p><strong>Important:</strong> This code uses blocking <code>delay()</code>. For more sophisticated modulation or simultaneous tasks (like energy harvesting and modulation), you&#39;d use non-blocking techniques with timers. But for a simple PoC, <code>delay()</code> is fine.</p>\n<h3><strong>7.5 Observing the Modulation at the Transmitter</strong></h3>\n<p>This is often the most challenging part of this attack vector. The changes we induce are subtle, especially if we&#39;re trying to be stealthy. We need to monitor a signal <em>on the Tx side</em> that is sensitive to the reflected impedance.</p>\n<p><strong>Where to Look on the Tx:</strong></p>\n<ul>\n<li><strong>Tx Input Current:</strong> The most common and often easiest place to observe. A change in reflected load on the Tx coil causes the Tx power stage to draw more or less current from its DC power supply. You can measure this with a current probe (preferred, non-invasive) or by inserting a small sense resistor in series with the DC input and measuring the voltage across it.</li>\n<li><strong>Voltage/Current Across Tx Coil:</strong> The amplitude and phase of the high-frequency AC voltage and current in the Tx coil are directly affected by the reflected impedance. Probing these requires care due to high frequencies and potentially high voltages.</li>\n<li><strong>Voltage Across Tuning Capacitors:</strong> Similar to the coil voltage, changes here are indicative of the resonant circuit&#39;s state being affected by the load.</li>\n<li><strong>Voltage/Current in Tx Switching Stage:</strong> Monitoring the waveforms at the switching transistors (MOSFETs) of the Tx inverter can also reveal modulation effects.</li>\n</ul>\n<p><strong>Tools:</strong></p>\n<ul>\n<li><strong>Oscilloscope:</strong> Absolutely essential. You need one with enough bandwidth to see the Tx&#39;s operating frequency (often hundreds of kHz or MHz) and, more importantly, enough sensitivity and sampling rate to capture the <em>envelope</em> changes caused by our much slower load modulation.</li>\n<li><strong>Current Probe:</strong> Highly recommended for safely measuring Tx input current without modifying the circuit significantly.</li>\n<li><strong>Differential Voltage Probe:</strong> Safer for measuring across components like tuning capacitors or MOSFETs if single-ended probing is risky.</li>\n</ul>\n<p><strong>What to Look For:</strong></p>\n<p>You won&#39;t typically see the sharp square wave of your MCU&#39;s digital output. Instead, you&#39;ll see the Tx signal (e.g., the high-frequency input current waveform) whose <em>average level</em> or <em>envelope</em> changes slightly according to your modulation pattern.</p>\n<p>Imagine the Tx input current is normally a certain level. When your attacker Rx switches its load ON, it draws more power from the field, which causes the Tx to work harder and draw slightly <em>more</em> input current (or sometimes less, depending on the system design and operating point). When your attacker Rx switches its load OFF, the Tx input current returns to its baseline.</p>\n<p>You are looking for small, relatively slow (at your bit rate) variations superimposed on the much faster Tx operating frequency waveform.</p>\n<p><strong>Oscilloscope Setup Tips:</strong></p>\n<ol>\n<li><strong>Connect Probe:</strong> Connect your probe (e.g., current probe around the Tx&#39;s DC input wire).</li>\n<li><strong>Set Timebase:</strong> Set the timebase to capture several bits of your modulation (e.g., if <code>BIT_DURATION_MS</code> is 100ms, set timebase to 50ms or 100ms per division).</li>\n<li><strong>Set Vertical Scale:</strong> Start with a coarse scale, then zoom in. You might need millivolts per division if using a sense resistor or current probe output.</li>\n<li><strong>Trigger:</strong> Triggering can be tricky.<ul>\n<li><strong>Auto Trigger:</strong> Might show the signal but won&#39;t sync to your modulation.</li>\n<li><strong>Normal Trigger:</strong> Set the trigger level on the Tx signal. If the modulation causes a significant jump/drop, you might be able to trigger directly on that edge.</li>\n<li><strong>External Trigger:</strong> If your MCU has a spare pin, you could toggle it simultaneously with your modulation signal and use that to trigger the scope. This is the most reliable method for syncing.</li>\n<li><strong>Single Shot:</strong> If the modulation happens predictably (like in our <code>loop</code> function), you can set the scope to single shot and capture one sequence.</li>\n</ul>\n</li>\n<li><strong>Acquisition Mode:</strong> Use &#39;Normal&#39; or &#39;Average&#39; if the signal is noisy. &#39;Peak Detect&#39; can sometimes help capture brief transients.</li>\n</ol>\n<h3><strong>7.6 Basic Signal Analysis</strong></h3>\n<p>Once you&#39;ve captured a waveform on the oscilloscope that shows variations corresponding to your modulation timing, you need to decode it.</p>\n<ol>\n<li><strong>Identify Baseline:</strong> Determine the Tx signal level when your attacker&#39;s load is OFF.</li>\n<li><strong>Identify Modulated Level:</strong> Determine the Tx signal level when your attacker&#39;s load is ON.</li>\n<li><strong>Look for the Pattern:</strong> Scan the captured waveform. Identify the start bit (the dip/bump corresponding to your &#39;0&#39; state), then the sequence of 8 data bits, and finally the stop bit (the opposite state corresponding to your &#39;1&#39; state).</li>\n<li><strong>Measure Durations:</strong> Verify that the pulses and gaps match your expected <code>BIT_DURATION_MS</code> (approximately).</li>\n<li><strong>Decode:</strong> Based on your OOK scheme (e.g., ON=1, OFF=0), read the sequence of 0s and 1s for each byte.</li>\n<li><strong>Convert Binary to ASCII:</strong> Group the bits into 8-bit bytes (remembering if you sent LSB or MSB first) and convert them back to ASCII characters.</li>\n</ol>\n<p><strong>Example (Conceptual):</strong></p>\n<p>If you send the byte for &#39;H&#39; (ASCII 72, binary <code>01001000</code>), and your scheme is:</p>\n<ul>\n<li>Start bit (0) = Load OFF (Tx current low)</li>\n<li>Data bit 0 (0) = Load OFF (Tx current low)</li>\n<li>Data bit 1 (0) = Load OFF (Tx current low)</li>\n<li>Data bit 2 (0) = Load OFF (Tx current low)</li>\n<li>Data bit 3 (1) = Load ON (Tx current high)</li>\n<li>Data bit 4 (0) = Load OFF (Tx current low)</li>\n<li>Data bit 5 (0) = Load OFF (Tx current low)</li>\n<li>Data bit 6 (1) = Load ON (Tx current high)</li>\n<li>Data bit 7 (0) = Load OFF (Tx current low)</li>\n<li>Stop bit (1) = Load ON (Tx current high)</li>\n</ul>\n<p>On the oscilloscope, you&#39;d look for a pattern of Tx current levels changing: Low (Start), Low, Low, Low, High, Low, Low, High, Low (Data), High (Stop). If the timing matches your <code>BIT_DURATION_MS</code>, you&#39;ve likely found your modulated data!</p>\n<p>For more complex analysis or higher data rates, you might export the waveform data from the oscilloscope and process it in software (e.g., Python with libraries like NumPy and SciPy) to perform filtering, thresholding, and automated decoding. But for this module&#39;s PoC, visual identification and manual decoding are sufficient.</p>\n<h3><strong>7.7 Proof-of-Concept Demonstration</strong></h3>\n<p>The culmination of this module is demonstrating that you can actually encode and observe the data transmission.</p>\n<p><strong>Steps for Demonstration:</strong></p>\n<ol>\n<li>Have your attacker hardware platform assembled with the modulation circuit.</li>\n<li>Load the Arduino code that transmits the string &quot;HI&quot;.</li>\n<li>Set up a standard WPT transmitter (like a Qi charger pad).</li>\n<li>Set up your oscilloscope to monitor a suitable point on the Tx (e.g., input current via a probe).</li>\n<li>Power on the WPT transmitter.</li>\n<li>Power on your attacker device (either via harvested power if Module 6 was successful, or a small battery/USB power).</li>\n<li>Place your attacker Rx coil near the WPT Tx coil. Find a position where the Tx remains operational and you can see <em>some</em> effect on the Tx signal when you manually toggle the load (e.g., by briefly connecting/disconnecting the resistor).</li>\n<li>Start the attacker code running.</li>\n<li>Use the oscilloscope to capture the Tx signal during the transmission of &quot;HI&quot;.</li>\n<li>Analyze the captured waveform to identify the pulses corresponding to the start bit, the data bits for &#39;H&#39;, the stop bit, the start bit for &#39;I&#39;, the data bits for &#39;I&#39;, and the stop bit.</li>\n<li>Show the captured waveform and walk through the decoding process to demonstrate that &quot;HI&quot; was successfully transmitted via load modulation and observed on the Tx side.</li>\n</ol>\n<h3><strong>Module Project/Exercise:</strong></h3>\n<p><strong>Goal:</strong> Implement the data exfiltration attack by modulating your attacker device&#39;s load and observing the encoded data on the target WPT transmitter&#39;s signal.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><strong>Review and Refine Hardware:</strong> Ensure your attacker platform from Module 5 is functional and includes the MOSFET switch and a suitable load resistor connected across the rectified DC output of your attacker coil.</li>\n<li><strong>Select and Prepare Tx Monitoring Point:</strong> Identify where on your target WPT transmitter you will probe the signal. <strong>Choose the safest option available!</strong> Measuring DC input current with a clamp probe or a sense resistor is often the least invasive and safest. If you must probe AC points, use differential probes and exercise extreme caution. <strong>Be aware of hazardous voltages and frequencies.</strong></li>\n<li><strong>Install and Adapt Code:</strong> Load the provided Arduino code (or your adaptation) onto your MCU. Adjust the <code>MOSFET_GATE_PIN</code> and crucially, the <code>BIT_DURATION_MS</code>. You will likely need to experiment with <code>BIT_DURATION_MS</code> and the resistor value to find a balance where the modulation is visible but doesn&#39;t crash the Tx.</li>\n<li><strong>Setup Tx and Attacker:</strong> Power on your target WPT transmitter. Power on your attacker device.</li>\n<li><strong>Position Attacker Coil:</strong> Place your attacker Rx coil near the Tx coil. Experiment with distance and alignment. Find a spot where the Tx stays active and you get a good coupling.</li>\n<li><strong>Configure Oscilloscope:</strong> Connect your probe to the chosen monitoring point on the Tx. Configure the timebase, vertical scale, and trigger settings on your oscilloscope to capture the Tx signal and look for the slower modulation pattern. Using an external trigger from the MCU (if available) is highly recommended.</li>\n<li><strong>Execute Attack:</strong> Run the code on your MCU.</li>\n<li><strong>Capture and Analyze Waveform:</strong> Capture the Tx signal on the oscilloscope. Zoom in on the captured waveform. Identify the pattern of highs and lows (or dips and bumps) corresponding to your expected binary sequence for &quot;HI&quot;.</li>\n<li><strong>Decode Data:</strong> Manually decode the captured waveform based on your OOK scheme and bit timing. Confirm that you can identify the start bit, data bits for &#39;H&#39;, stop bit, start bit for &#39;I&#39;, data bits for &#39;I&#39;, and stop bit.</li>\n<li><strong>Document Findings:</strong><ul>\n<li>Record your hardware setup (MCU, MOSFET, resistor value, coils).</li>\n<li>Note the Tx monitoring point used and the probe type.</li>\n<li>Include screenshots of the oscilloscope waveform showing the captured modulation. Annotate the screenshot to show where you identified the start bit, data bits, and stop bits.</li>\n<li>Show your decoding process and the resulting binary and ASCII data.</li>\n<li>Describe any challenges encountered (e.g., Tx shutting down, signal too noisy, difficulty triggering).</li>\n</ul>\n</li>\n</ol>\n<p>By successfully completing this project, you will have built and demonstrated a device capable of covertly transmitting data through a WPT link by manipulating the reflected power signature – a true physical layer attack!</p>\n<hr>\n<p>This concludes Module 7. You&#39;ve now built the core components and demonstrated the feasibility of both energy hijacking and covert data exfiltration via load modulation. In our final module, Module 8, we will integrate these concepts into a single, polished proof-of-concept, discuss the limitations of our current build, explore potential countermeasures WPT systems could employ, and look at exciting future directions for research in this fascinating area. Get ready to wrap it all up!</p>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright everyone, welcome to the grand finale! Module 8. This is where we pull <em>everything</em> together. We&#39;ve walked through the physics, reverse-engineered the concepts of WPT Tx and Rx, built the foundational hardware, and explored the individual attack vectors of energy hijacking and data exfiltration.</p>\n<p>Now, we combine them. We refine our proof-of-concept (PoC). We run the full demonstration. We analyze the heck out of what we built, understand its limits, and then pivot to the crucial part: how would the <em>defenders</em> stop this, and where does the research go next? This is where your &quot;research paper&quot; equivalent comes to life.</p>\n<p>So, let&#39;s gear up. Get your breadboards, your microcontrollers, your coils, and especially your oscilloscopes ready. It&#39;s time to make our attacker device a reality and see the full attack chain in action.</p>\n<hr>\n<h2><strong>Module 8: Capstone Project &amp; Future Directions</strong></h2>\n<ul>\n<li><p><strong>Module Objective:</strong> Learners will integrate all components and knowledge to create a comprehensive demonstration of both attack vectors, analyze the results, understand the limitations of the PoC, and explore potential countermeasures and advanced attack/defense strategies.</p>\n</li>\n<li><p><strong>Estimated Time:</strong> This module is heavily project-based. Allocate significant time for building, testing, debugging, and documentation (easily 8-16+ hours depending on prior experience and debugging needs).</p>\n</li>\n</ul>\n<hr>\n<h3><strong>8.1 Integrating Attack Vectors: Powering the Brains with Stolen Energy</strong></h3>\n<p>We&#39;ve built a platform that <em>can</em> harvest energy (Module 6) and <em>can</em> perform load modulation (Module 7). The elegant next step, especially for a stealthy attacker, is to use the <em>stolen</em> energy to power the <em>brains</em> doing the stealing and modulating – our microcontroller (MCU).</p>\n<p><strong>Concept:</strong><br>The energy harvesting circuit (coil -&gt; rectifier -&gt; filter -&gt; regulator) provides a DC voltage. This voltage needs to be stable and at the correct level for our MCU (e.g., 3.3V or 5V). The load modulation circuit (MCU pin -&gt; MOSFET -&gt; load resistor/capacitor) is controlled by the MCU, switching the load on/off <em>across</em> the harvested power line (or a point downstream of the rectifier but before the final regulator, depending on design).</p>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li><p><strong>Review your Module 5, 6, and 7 Hardware:</strong> You should have:</p>\n<ul>\n<li>Attacker coil.</li>\n<li>Rectification and filtering circuit (diodes, capacitors).</li>\n<li>A voltage regulator (e.g., a Low Dropout Regulator - LDO, or a small switching regulator) to convert the harvested DC (which might fluctuate) to a stable voltage required by your MCU.</li>\n<li>Your chosen MCU development board (e.g., Arduino Nano, ESP32).</li>\n<li>A MOSFET or transistor capable of switching the modulation load.</li>\n<li>The modulation load component(s) (e.g., resistor, capacitor).</li>\n</ul>\n</li>\n<li><p><strong>Connect the Power Path:</strong></p>\n<ul>\n<li>Connect the output of your rectifier/filter circuit to the input of your voltage regulator.</li>\n<li>Connect the <em>regulated output</em> of the voltage regulator to the VIN or 5V/3.3V pin of your MCU board.</li>\n<li><strong>Important:</strong> Ensure the harvested voltage <em>before</em> the regulator is consistently higher than the regulator&#39;s required input voltage (headroom). If your harvesting is weak, you might need a boost converter <em>before</em> the regulator, or initially power the MCU from a separate source <em>until</em> sufficient power is harvested. For this PoC, a simple LDO might suffice if the harvested voltage is reliably above its dropout voltage.</li>\n<li>Include a large filter capacitor <em>after</em> the regulator to smooth out power spikes and dips, especially those caused by your own load modulation!</li>\n</ul>\n</li>\n<li><p><strong>Connect the Modulation Path:</strong></p>\n<ul>\n<li>The load modulation circuit&#39;s switching component (MOSFET) should be connected such that it toggles a specific load <em>across</em> the rectified/filtered DC voltage (before the final MCU regulator is often easiest to see the effect, but after works too if the regulator can handle the load changes).</li>\n<li>The control pin of the MOSFET connects to a digital output pin on your MCU.</li>\n<li>Ensure the MOSFET is correctly wired (Source, Gate, Drain) and the gate is driven with sufficient voltage from the MCU pin to turn it fully on (check MOSFET datasheet, especially for &#39;logic-level&#39; MOSFETs if using 3.3V/5V MCU). A pull-down resistor on the gate is good practice.</li>\n</ul>\n</li>\n<li><p><strong>Conceptual Wiring Diagram:</strong></p>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Attacker Coil] --&gt; B(Rectifier &amp; Filter)\n    B --&gt; C(Input Filter Cap)\n    C --&gt; D(Voltage Regulator)\n    D --&gt; E(MCU VIN/VCC)\n    E --&gt; F(MCU Digital Pin)\n    B --&gt; G(Modulation Load + MOSFET)\n    F --&gt; G\n    G --&gt; B\n    E --&gt; H(MCU GND)\n    G --&gt; H\n</code></pre>\n<p><em>Self-Correction Note:</em> The modulation load is typically switched <em>across</em> the rectified DC output, which then affects the reflected impedance seen by the Tx. The MCU is <em>powered</em> by this rectified/regulated DC. The diagram shows this loop.</p>\n</li>\n<li><p><strong>Code Integration:</strong></p>\n<ul>\n<li><p>Your code needs to perform two conceptual tasks:</p>\n<ul>\n<li>Initialize the modulation pin.</li>\n<li>Enter a loop where it performs the data exfiltration modulation sequence periodically or on command.</li>\n<li><em>(Implicit)</em> The harvesting is handled by hardware, providing power to run this code.</li>\n</ul>\n</li>\n<li><p><strong>Example (Arduino-like Pseudocode):</strong></p>\n</li>\n</ul>\n<pre><code class=\"language-cpp\">// Define the pin connected to the MOSFET gate\nconst int modulationPin = 9;\n// Define the desired modulation pattern (e.g., binary for &quot;HI&quot;)\n// &#39;H&#39; = 01001000, &#39;I&#39; = 01001001\n// Let&#39;s send a simpler pattern: 1010 (On-Off-On-Off)\nint modulationPattern[] = {1, 0, 1, 0};\nconst int patternLength = sizeof(modulationPattern) / sizeof(modulationPattern[0]);\nconst int bitDuration_ms = 50; // Duration of each bit (adjust based on observation)\n\nvoid setup() {\n  // Initialize the modulation pin as an output\n  pinMode(modulationPin, OUTPUT);\n  // Ensure MOSFET starts in OFF state\n  digitalWrite(modulationPin, LOW);\n\n  // Optional: Add a small delay to stabilize after power-up\n  delay(1000);\n}\n\nvoid loop() {\n  // Perform the modulation sequence\n  for (int i = 0; i &lt; patternLength; i++) {\n    if (modulationPattern[i] == 1) {\n      // Switch load ON\n      digitalWrite(modulationPin, HIGH);\n    } else {\n      // Switch load OFF\n      digitalWrite(modulationPin, LOW);\n    }\n    // Keep the load state for the bit duration\n    delay(bitDuration_ms);\n  }\n\n  // Add a pause before repeating the pattern\n  delay(2000); // Pause for 2 seconds\n\n  // Note: In a real attack, this loop might be triggered by an event,\n  // or send more complex data. For the PoC, a repeating pattern is fine.\n}\n</code></pre>\n<ul>\n<li><strong>Compile and Upload:</strong> Upload this code to your MCU <em>while it&#39;s powered externally</em> initially.</li>\n<li><strong>Test Powering from Harvested Energy:</strong> Once the code is uploaded and verified to run with external power, disconnect the external power and place your attacker coil in the WPT field. Observe if the MCU powers up and the code runs (e.g., blink an LED if you add one, or simply observe the modulation pin voltage with a scope). Debug your harvesting/regulation circuit if it fails to power the MCU.</li>\n</ul>\n</li>\n</ol>\n<h3><strong>8.2 Refining the Proof-of-Concept</strong></h3>\n<p>Getting the basic integration working is great, but making it <em>demonstrable</em> and observable requires refinement.</p>\n<p><strong>Key Areas for Refinement:</strong></p>\n<ol>\n<li><p><strong>Coil Placement and Alignment:</strong></p>\n<ul>\n<li><strong>Goal:</strong> Maximize coupling (for harvesting and modulation visibility) without necessarily interfering with a legitimate receiver (unless that&#39;s part of your goal).</li>\n<li><strong>Technique:</strong> Place the attacker coil near the target Tx coil. Use your oscilloscope to monitor the <em>rectified DC voltage</em> on your attacker device. Move the coil around (distance, horizontal offset, angle) to find the position that yields the highest stable DC voltage. This is your optimal harvesting spot, which also likely maximizes the reflected power effect for modulation.</li>\n<li><strong>Observation:</strong> Note the sensitivity to position. WPT coupling is highly dependent on alignment.</li>\n</ul>\n</li>\n<li><p><strong>Modulation Depth Tuning:</strong></p>\n<ul>\n<li><strong>Goal:</strong> Choose a modulation load (resistor/capacitor value) that causes a <em>detectable</em> change at the Tx without causing the Tx to shut down or indicate an error.</li>\n<li><strong>Technique:</strong> Experiment with different resistor values (if using resistive load modulation). Start with a relatively high resistance (lower load, smaller effect) and decrease it.</li>\n<li><strong>Observation:</strong> With your attacker device modulating, monitor the Tx input current or Tx coil voltage with your oscilloscope. You are looking for a clear, repeating change in the Tx waveform synchronized with your modulation pattern. If the Tx stops working, your load change is too large. If you see no change, it&#39;s too small. Find the sweet spot. If using capacitive modulation, experiment with capacitor values.</li>\n</ul>\n</li>\n<li><p><strong>Harvesting Efficiency:</strong></p>\n<ul>\n<li><strong>Goal:</strong> Ensure enough power is harvested to reliably run the MCU and the modulation circuit during switching.</li>\n<li><strong>Technique:</strong> Measure the current drawn by your MCU platform (including the MOSFET switching) and compare it to the average current your harvesting circuit can provide at the chosen placement. Use a multimeter in series with the MCU&#39;s power input (after the regulator).</li>\n<li><strong>Optimization:</strong> Ensure low-loss diodes (Schottky diodes are good), appropriately sized filter capacitors, and an efficient voltage regulator.</li>\n</ul>\n</li>\n<li><p><strong>Reliability:</strong></p>\n<ul>\n<li><strong>Goal:</strong> Make sure the modulation pulses are consistent and the MCU doesn&#39;t brown out during switching.</li>\n<li><strong>Technique:</strong> Monitor the MCU&#39;s VCC line with an oscilloscope. If you see significant dips when the MOSFET switches, you might need larger filter capacitors on the regulated output or a more robust power path from harvesting. Add small delays in your code if needed to ensure stable states.</li>\n</ul>\n</li>\n</ol>\n<h3><strong>8.3 Demonstration Setup</strong></h3>\n<p>This is showtime! You need to set up your components to clearly demonstrate both attack vectors.</p>\n<p><strong>Required Equipment:</strong></p>\n<ul>\n<li>Your refined attacker hardware platform.</li>\n<li>A target WPT transmitter (e.g., a standard Qi charger).</li>\n<li><em>(Optional but Recommended)</em> A legitimate WPT receiver (e.g., a smartphone) to show the Tx <em>can</em> charge normally, and potentially observe if your attack affects it.</li>\n<li>Oscilloscope with probes (at least 2 channels helpful).</li>\n<li>Current clamp or in-line current sensor for monitoring Tx input current (or find an accessible voltage point in the Tx related to power transfer).</li>\n<li>A small load powered by your attacker device (e.g., an LED, a small fan, a voltmeter showing harvested DC voltage).</li>\n<li>Camera/phone to record the demonstration.</li>\n<li>Laptop with your MCU code and potentially data analysis tools.</li>\n</ul>\n<p><strong>Setup Steps:</strong></p>\n<ol>\n<li><strong>Prepare the Target Tx:</strong> Plug in the WPT transmitter. Verify it works with a legitimate receiver if you have one.</li>\n<li><strong>Set up Attacker Hardware:</strong> Place your attacker device near the Tx, using the optimal placement found in refinement.</li>\n<li><strong>Demonstrate Energy Hijacking:</strong><ul>\n<li>Show your attacker device is <em>not</em> connected to any external power source.</li>\n<li>Place the attacker coil near the Tx.</li>\n<li>Show the small load (LED lighting up, voltmeter showing voltage) being powered <em>only</em> by the harvested energy.</li>\n<li><em>(Optional but impactful)</em> If you can measure the Tx input current, show its value with the attacker present vs. absent (or with a legitimate receiver present). Note the increase when your attacker harvests.</li>\n</ul>\n</li>\n<li><strong>Demonstrate Data Exfiltration:</strong><ul>\n<li>Keep the attacker coil in place. Ensure the MCU is running its modulation code (powered by harvested energy).</li>\n<li>Connect your oscilloscope probes to the chosen monitoring point(s) on the Tx (e.g., input power line for current clamp, or a voltage across a tuning capacitor). <em>Be extremely careful probing live circuits!</em> If unsure, stick to non-contact methods like current clamps or probing low-voltage control signals if you can identify them. The voltage across the Tx coil itself is often high AC voltage.</li>\n<li>Set up the oscilloscope trigger. This can be tricky. You might need to trigger on a specific voltage level change on the Tx waveform that corresponds to your modulation pulses. A repeating pattern from your MCU code makes triggering easier.</li>\n<li>Capture the Tx waveform on the oscilloscope screen.</li>\n<li>Point out the subtle (or not-so-subtle) changes in the Tx waveform that occur precisely when your MCU is switching the load.</li>\n<li>Relate these changes back to your programmed modulation pattern (e.g., &quot;See this dip/bump? That&#39;s when I switch the load ON. This flat part is when it&#39;s OFF. My code is sending 1010, and you can see that pattern here: dip-no dip-dip-no dip.&quot;).</li>\n</ul>\n</li>\n<li><strong>Record Everything:</strong> Take photos and videos of your setup, the LED lighting up, the voltmeter reading, and especially the oscilloscope screen showing the modulation being detected. These are your key pieces of evidence for the report.</li>\n</ol>\n<h3><strong>8.4 Analyzing Results</strong></h3>\n<p>Now, put on your scientist/analyst hat. What did you actually achieve?</p>\n<ol>\n<li><p><strong>Energy Hijacking Analysis:</strong></p>\n<ul>\n<li><strong>Quantify:</strong> What is the maximum stable DC voltage you harvested? What current can you draw while maintaining that voltage? Calculate the harvested power (P = V * I).</li>\n<li><strong>Impact on Tx:</strong> How much did the Tx input current increase when your attacker was harvesting? If possible, compare the Tx&#39;s stated maximum output power to the power you harvested.</li>\n<li><strong>Efficiency:</strong> How efficient is your harvesting circuit? (Hard to measure precisely without sophisticated equipment, but you can estimate).</li>\n<li><strong>Stealth:</strong> Was the power draw noticeable? Did the Tx react negatively?</li>\n</ul>\n</li>\n<li><p><strong>Data Exfiltration Analysis:</strong></p>\n<ul>\n<li><strong>Visibility:</strong> How clear is the modulation signal on the Tx waveform? Is it easily distinguishable from noise or normal Tx operation?</li>\n<li><strong>Data Rate:</strong> What is the effective bit rate of your modulation? (1 / (bitDuration_ms / 1000)). It will likely be very low (tens or hundreds of bps).</li>\n<li><strong>Reliability:</strong> Could you consistently identify the transmitted pattern on the scope? Would automated detection be reliable based on this signal?</li>\n<li><strong>Impact on Tx/Rx:</strong> Did the modulation interfere with legitimate charging (if a legitimate Rx was present)? Did it cause the Tx to adjust power or show errors?</li>\n</ul>\n</li>\n<li><p><strong>Correlation:</strong> Explicitly link your MCU&#39;s digital output signal (the intended modulation) to the observed changes on the Tx waveform. Show them side-by-side on the scope if you have enough channels, or capture them sequentially with careful timing notes.</p>\n</li>\n</ol>\n<h3><strong>8.5 Limitations of the PoC</strong></h3>\n<p>It&#39;s crucial to be realistic. Your PoC is a demonstration of <em>principle</em>, not a polished, covert attack tool. Acknowledging limitations adds credibility to your analysis.</p>\n<ul>\n<li><strong>Range:</strong> Near-field WPT is inherently short-range (typically &lt; 10 cm). Your PoC is limited to this close proximity.</li>\n<li><strong>Data Rate:</strong> Load modulation bandwidth is limited by the WPT system&#39;s control loop response time and the Q factor of the coils. High-speed data transfer is generally not feasible with simple load modulation.</li>\n<li><strong>Power Levels:</strong> The harvested power is likely small (mW to low Watts). Sufficient for small electronics, but not for charging a laptop or powering significant devices unless the target Tx is very high power (like EV charging).</li>\n<li><strong>Stealth/Detectability:</strong> A sophisticated WPT transmitter actively monitoring the reflected impedance signature with high precision could potentially detect your unauthorized load or unusual modulation patterns. Your PoC might be visible to the Tx&#39;s internal monitoring.</li>\n<li><strong>Tx Dependence:</strong> The success of the attack, especially data exfiltration visibility, depends heavily on the specific WPT transmitter&#39;s design, operating frequency, and how it manages/monitors the resonant field.</li>\n<li><strong>Simplicity:</strong> The modulation scheme (simple OOK) is basic. More complex modulation (FSK, phase modulation) would be harder to implement and detect.</li>\n<li><strong>Energy Source:</strong> The PoC relies on an <em>active</em> WPT field being present. It can&#39;t initiate power transfer.</li>\n</ul>\n<h3><strong>8.6 Potential Countermeasures</strong></h3>\n<p>How would the good guys stop this? Think from the perspective of a WPT system designer concerned about security.</p>\n<ul>\n<li><strong>Enhanced Impedance Monitoring:</strong> Implement more sophisticated analysis of the reflected impedance signature beyond simple threshold detection. Look for deviations from expected load characteristics, unusual patterns, or changes that don&#39;t correspond to standard protocol communication.</li>\n<li><strong>Authentication:</strong> Implement cryptographic authentication between the Tx and <em>authorized</em> Rx devices. This could happen over the WPT&#39;s built-in communication channel (often load modulation itself, ironically) or a separate channel (like NFC or Bluetooth). The Tx only transfers significant power after successful authentication. (Note: Qi 1.2 and later include optional authentication).</li>\n<li><strong>Anomaly Detection (AI/ML):</strong> Train machine learning models on typical Tx operational data (voltage, current, phase, reflected power) with legitimate loads. Deploy the model to detect statistically significant anomalies that might indicate an unauthorized device or malicious modulation.</li>\n<li><strong>Active Channel Probing:</strong> The Tx could periodically send specific probe signals and analyze the reflected response to build a dynamic impedance profile of the environment, making it harder for an attacker to blend in.</li>\n<li><strong>Physical Layer Encryption/Obfuscation:</strong> While you can&#39;t encrypt power, you <em>could</em> potentially use spread spectrum techniques or dynamically change frequency/phase in ways that make passive listening or targeted modulation harder without knowing the Tx&#39;s current state. (More theoretical for simple systems).</li>\n<li><strong>Physical Shielding:</strong> Basic Faraday cages around sensitive areas can block RF fields, though this is often impractical for user-facing WPT surfaces.</li>\n<li><strong>Protocol Integrity Checks:</strong> If the Tx uses load modulation for <em>its own</em> communication (like Qi), ensure that any detected load changes <em>must</em> conform to valid protocol messages. Modulation that doesn&#39;t fit the protocol structure could be flagged as malicious.</li>\n</ul>\n<h3><strong>8.7 Advanced Topics &amp; Future Research</strong></h3>\n<p>Your PoC opens doors to many avenues. Where could this research go next?</p>\n<ul>\n<li><strong>AI/ML for Attack &amp; Defense:</strong><ul>\n<li><em>Attack:</em> Use ML to analyze Tx signals and find the optimal modulation pattern for stealth or maximum data rate against a specific Tx model. Use reinforcement learning to find attack strategies.</li>\n<li><em>Defense:</em> Develop and deploy more robust ML models for anomaly detection.</li>\n</ul>\n</li>\n<li><strong>Targeting Specific WPT Protocols/Implementations:</strong> Analyze the security of specific standards (e.g., different versions of Qi, PMA, proprietary systems) or specific vendor chips. Find implementation vulnerabilities.</li>\n<li><strong>Higher Data Rate Exfiltration:</strong> Investigate more complex load modulation techniques (e.g., using multiple load levels, phase shifts, or frequency shifts if the attacker can influence the Rx coil&#39;s resonance) to increase bandwidth. Could you exfiltrate small files?</li>\n<li><strong>Active Interference &amp; Jamming:</strong> Can an attacker actively transmit RF energy to disrupt or jam a WPT link? What are the effects and how could it be done stealthily?</li>\n<li><strong>Attacking High-Power WPT:</strong> EV charging (kW levels), industrial WPT. The stakes are higher (safety, significant energy theft). Are there unique vulnerabilities in these systems?</li>\n<li><strong>Side-Channel Attacks:</strong> Can information about the device being charged (battery level, charging state) be inferred from the Tx&#39;s reflected power signature?</li>\n<li><strong>WPT as a Covert Communication Channel (Legitimate Use):</strong> Can WPT be <em>intentionally</em> used as a secure, low-bandwidth communication channel by modulating the load in a way only a specific receiver understands, perhaps for authentication or pairing? (Turning the attack into a feature).</li>\n<li><strong>Counter-Countermeasures:</strong> If a Tx implements authentication or anomaly detection, how could an attacker attempt to bypass it? (e.g., mimicking authentication signals, using adversarial ML techniques).</li>\n</ul>\n<h3><strong>8.8 Responsible Disclosure</strong></h3>\n<p>As security researchers, we have an ethical obligation. Finding vulnerabilities is cool, but disclosing them responsibly is paramount.</p>\n<ol>\n<li><strong>Document Thoroughly:</strong> Your capstone project report <em>is</em> the core documentation. Detail the vulnerability, your PoC, the affected systems (general WPT principles, specific standards if applicable), and the potential impact.</li>\n<li><strong>Contact the Vendor/Maintainer:</strong> For real-world vulnerabilities, identify the relevant vendor(s) (e.g., the creators of the WPT standard, manufacturers of vulnerable chips or devices). Find their security contact (often <code>security@vendor.com</code> or a dedicated page).</li>\n<li><strong>Private Disclosure:</strong> Share your findings privately with the vendor, providing them ample time to understand the issue, develop a fix, and distribute it. A common timeframe is 90 days, but this can vary.</li>\n<li><strong>Coordinate Public Disclosure:</strong> After the vendor has released a fix or the agreed-upon time has passed, coordinate a public release of your findings. This informs the public and encourages users to apply patches. Present at conferences, publish a paper (like your capstone report!).</li>\n<li><strong>Never Exploit Illegally:</strong> Do not use your PoC or knowledge to steal energy or data from systems you do not own or have explicit permission to test. This research is for educational purposes and for improving security, not for criminal activity.</li>\n</ol>\n<h3><strong>Capstone Project/Exercise: The Research Paper &amp; Demonstration</strong></h3>\n<p>This is it. Your final deliverable.</p>\n<p><strong>Task:</strong></p>\n<ol>\n<li><p><strong>Finalize your Hardware:</strong> Ensure your integrated attacker platform is robust and reliable enough for demonstration.</p>\n</li>\n<li><p><strong>Finalize your Code:</strong> Ensure your MCU code reliably performs the desired modulation pattern and runs on harvested power.</p>\n</li>\n<li><p><strong>Conduct Final Experiments:</strong> Perform the energy harvesting and data exfiltration demonstration runs, capturing all necessary data (voltage/current measurements, oscilloscope captures).</p>\n</li>\n<li><p><strong>Prepare the Demonstration:</strong> Set up your Tx, attacker device, monitoring equipment (oscilloscope), and the visual indicator of harvesting (LED/voltmeter). Practice your presentation flow.</p>\n</li>\n<li><p><strong>Write the Capstone Report:</strong> Structure your report like a security research paper.</p>\n<ul>\n<li><strong>Title:</strong> Something clear and engaging (e.g., &quot;Attacking Wireless Power: Practical Energy Hijacking and Covert Data Exfiltration via Reflected Power Manipulation&quot;).</li>\n<li><strong>Abstract:</strong> A brief summary (150-250 words) covering the problem, your approach, your findings (the PoC capabilities), and the implications.</li>\n<li><strong>Introduction:</strong> Introduce WPT, its growing prevalence, the overlooked security surface (physical layer), state the problem (unauthorized energy draw, covert data exfil), and clearly state the objective of your research/PoC.</li>\n<li><strong>Background:</strong> Briefly explain the relevant WPT physics (near-field, resonance, coupling, reflected power, load modulation). Reference the concepts learned in Modules 1-4.</li>\n<li><strong>Methodology:</strong> Detail your attacker device&#39;s design and build process. Include:<ul>\n<li>Hardware components used (MCU, coils, rectifier, regulator, MOSFET, load). Include a block diagram and photos of your setup.</li>\n<li>Software design (MCU code logic - explain the modulation pattern, timing, power management). Include key code snippets.</li>\n<li>Experimental setup (Target Tx used, how you monitored the Tx, how you measured harvested power). Include photos/diagrams.</li>\n</ul>\n</li>\n<li><strong>Results:</strong> Present the findings from your experiments.<ul>\n<li><strong>Energy Hijacking:</strong> Quantify harvested power. Show visual proof (LED/voltmeter). Show impact on Tx (e.g., Tx input current change, oscilloscope trace comparison).</li>\n<li><strong>Data Exfiltration:</strong> Show the programmed modulation pattern. Show the corresponding oscilloscope captures of the Tx signal, highlighting where the modulation is visible. Explain how the pattern maps to the signal changes. Comment on signal clarity and timing.</li>\n</ul>\n</li>\n<li><strong>Analysis:</strong> Discuss what your results mean. How successful was each attack vector? Did the integration work as expected? What correlations did you observe between your device&#39;s actions and the Tx&#39;s behavior?</li>\n<li><strong>Limitations:</strong> Reiterate the practical limitations of your PoC (range, data rate, stealth, etc.).</li>\n<li><strong>Countermeasures:</strong> Discuss the potential defenses against this type of attack based on your understanding.</li>\n<li><strong>Future Work:</strong> Suggest directions for further research based on your experience with the PoC.</li>\n<li><strong>Conclusion:</strong> Summarize your achievement – you successfully built a PoC demonstrating energy hijacking and covert data exfiltration from a WPT field by manipulating reflected power. Reiterate the security implications.</li>\n<li><strong>References:</strong> Cite any resources you used (datasheets, tutorials, research papers if you read any beyond the suggested).</li>\n</ul>\n</li>\n<li><p><strong>Prepare Presentation (Optional but Recommended):</strong> If you were presenting this, create slides summarizing your report, including photos and videos of the demo.</p>\n</li>\n</ol>\n<p><strong>Evaluation:</strong> Your success will be evaluated based on:</p>\n<ul>\n<li>The functionality of your integrated attacker device (can it power itself from harvested energy and modulate?).</li>\n<li>The clarity and success of your demonstration of <em>both</em> energy hijacking and data exfiltration.</li>\n<li>The quality and completeness of your capstone report, including thorough analysis, acknowledgment of limitations, and thoughtful discussion of countermeasures and future work.</li>\n</ul>\n<hr>\n<p>This capstone project is a significant undertaking. It requires bringing together everything you&#39;ve learned, troubleshooting hardware and software, and presenting your findings clearly. But successfully building and demonstrating this PoC will give you a deep, practical understanding of WPT security at the physical layer – a truly unique skill set.</p>\n<p>Remember to be patient with debugging, be careful with live electronics, and most importantly, have fun exploring this often-overlooked attack surface! You&#39;re now equipped to not just understand WPT, but to analyze its vulnerabilities and even build tools to demonstrate them. Go forth and research responsibly!</p>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Okay, class! Settle in. Get ready to peel back the curtain on something that feels like science fiction but is very much real, and surprisingly, has a hidden attack surface.\r\n\r\nWe're not just learning about wireless power; we're learning how to *think like an attacker* in a domain few have explored deeply. This isn't about hacking Wi-Fi or breaking crypto. This is about manipulating the *physical world* – the magnetic fields and energy flow – to achieve offensive goals. It's elegant, it's subtle, and it's highly effective against systems that weren't designed with this kind of threat in mind.\r\n\r\nLet's kick off with the absolute essentials in Module 1.\r\n\r\n---\r\n\r\n# **Module 1: Introduction to Wireless Power & Its Security Landscape**\r\n\r\nWelcome to the starting line! Before we can weaponize anything, we need to truly understand it. This module lays the groundwork. We'll cover what wireless power is, how it works *at a fundamental level*, look at where you see it every day (and maybe don't even notice), and critically, start asking \"what could go wrong?\" from a perspective that goes beyond traditional cybersecurity.\r\n\r\n## **Module Objective:**\r\n\r\nBy the end of this module, you will be able to:\r\n*   Explain the fundamental principles of near-field Wireless Power Transfer (WPT).\r\n*   Identify the key components of a near-field WPT system (Transmitter & Receiver).\r\n*   Understand why the unique physics of near-field WPT presents novel security vulnerabilities compared to traditional data systems.\r\n\r\n## **Essential Subtopics: The Foundation**\r\n\r\nLet's break down the core concepts we need to grasp.\r\n\r\n### **1. What is Wireless Power Transfer (WPT)? Near-field vs. Far-field.**\r\n\r\nThink about electricity. Usually, it needs wires, right? WPT is about moving electrical energy from one point to another *without* a physical conductor connecting them. Magic? Nope, just physics!\r\n\r\nThere are two main flavors of WPT, distinguished primarily by distance and the physics they exploit:\r\n\r\n*   **Far-Field WPT (Radiative):**\r\n    *   Uses electromagnetic waves (like radio waves, microwaves, light) to carry energy.\r\n    *   Energy radiates outwards from a source.\r\n    *   Efficiency decreases rapidly with distance (inverse square law).\r\n    *   Best suited for *low-power* transfer over *longer distances* (meters to kilometers).\r\n    *   Examples: RF energy harvesting for tiny IoT sensors, potentially solar power satellites beaming energy down (future concept).\r\n    *   *Security Note (for context, not our focus):* Security here might involve jamming the signal, spoofing the source, or intercepting the radiated energy (though inefficient).\r\n\r\n*   **Near-Field WPT (Non-Radiative):**\r\n    *   Uses magnetic fields (and sometimes electric fields, but magnetic is dominant for most common applications like phone charging).\r\n    *   Energy is transferred via the *coupling* between coils or resonators that are *close* to each other (typically within a few coil diameters).\r\n    *   The magnetic field energy stays largely contained within the near-field region, not radiating significantly into space.\r\n    *   Efficiency is much higher than far-field *at close range*.\r\n    *   Examples: Smartphone wireless charging (Qi standard), electric toothbrushes, RFID (data, but uses the same magnetic coupling), medical implants, EV charging pads.\r\n    *   **This is our target!** The physics of *coupling* and *reflected fields* in the near-field is what makes our attacks possible.\r\n\r\n**Key takeaway:** We are focusing *exclusively* on **Near-Field WPT**, where energy is transferred via magnetic fields between coils in close proximity.\r\n\r\n### **2. Applications of Near-Field WPT**\r\n\r\nNear-field WPT is already integrated into our lives, often invisibly:\r\n\r\n*   **Consumer Electronics:** The most common is smartphone charging (Qi standard). Also seen in smartwatches, earbuds, electric toothbrushes, etc.\r\n*   **Medical Implants:** Pacemakers, neurostimulators, and other implanted devices can be charged wirelessly, reducing the need for surgery to replace batteries. Security is paramount here!\r\n*   **Industrial Automation:** Powering sensors or actuators in hazardous or hard-to-reach locations without physical connections.\r\n*   **Electric Vehicles (EVs):** Wireless charging pads for convenience (though currently less common than plug-in).\r\n*   **RFID:** While primarily for data, RFID readers power the tag using near-field magnetic coupling before reading data.\r\n\r\nThe widespread adoption means more potential targets and greater impact if vulnerabilities are exploited.\r\n\r\n### **3. Inductive and Resonant Coupling: The Physics Behind Near-Field Transfer**\r\n\r\nHow does energy *actually* move without wires in the near-field?\r\n\r\n*   **Inductive Coupling (The Basics):**\r\n    *   Remember your high school physics? A changing current in a wire coil creates a changing magnetic field around it.\r\n    *   If you place another coil nearby *within* this changing magnetic field, the field induces a voltage (and thus current) in the second coil (Faraday's Law of Induction).\r\n    *   This is how simple transformers work, but with an air gap instead of an iron core.\r\n    *   *Limitation:* Simple inductive coupling is very sensitive to distance and alignment. Efficiency drops off *very* quickly as coils move apart.\r\n\r\n*   **Resonant Coupling (The Game Changer):**\r\n    *   This is where it gets cool and efficient for slightly longer ranges (still near-field, but a bit more flexible than simple induction).\r\n    *   Imagine adding capacitors to your coils. This turns each coil into an LC circuit (Inductor-Capacitor).\r\n    *   LC circuits have a *resonant frequency*. Like a musical instrument, they prefer to \"vibrate\" or oscillate electrically at this specific frequency.\r\n    *   If you make the *Transmitter* coil oscillate at its resonant frequency, it creates a strong, oscillating magnetic field.\r\n    *   If you place a *Receiver* coil *tuned to the same resonant frequency* nearby, it will strongly absorb energy from that oscillating field, like one tuning fork making another one vibrate across the room.\r\n    *   *Advantage:* Resonant coupling is much more efficient than simple induction over slightly larger distances and is less sensitive to precise alignment. This is the principle behind most modern WPT standards like Qi.\r\n\r\n**Think of it like this:**\r\n*   Simple Induction: Yelling across a room – some sound reaches, but it's weak and scatters.\r\n*   Resonant Coupling: Singing a specific note to a tuning fork tuned to that note – the tuning fork vibrates strongly, absorbing the energy efficiently.\r\n\r\nThe fact that energy transfer is most efficient at *specific frequencies* and relies on the *interaction* between the Tx and Rx resonators is crucial. This interaction is what we can potentially observe and manipulate.\r\n\r\n### **4. Key Components of a Near-Field WPT System**\r\n\r\nLet's look at the building blocks you'll find in typical WPT systems:\r\n\r\n*   **Transmitter (Tx):** The power source side.\r\n    *   **Power Source:** Usually DC (e.g., wall adapter, battery).\r\n    *   **Oscillator/Driver Circuit:** Converts the DC power into high-frequency AC power at the desired WPT frequency (e.g., 100-200 kHz for Qi low power, 6.78 MHz for some resonant systems). Often uses power electronics like MOSFETs in an inverter configuration (e.g., Class D or Class E amplifier).\r\n    *   **Tx Coil:** The inductor that generates the oscillating magnetic field. Often includes tuning capacitors to resonate at the operating frequency.\r\n    *   **Control Circuitry:** The \"brain\" of the Tx. Manages the power transfer process.\r\n        *   Detects the presence of a valid receiver.\r\n        *   Manages the power level delivered based on receiver requests or load changes.\r\n        *   Handles communication *from* the receiver (this is key!).\r\n        *   Implements safety features (e.g., Foreign Object Detection - FOD).\r\n    *   **Matching Network:** Circuitry between the driver and the Tx coil to ensure maximum power transfer efficiency.\r\n\r\n*   **Receiver (Rx):** The power sink side.\r\n    *   **Rx Coil:** The inductor that captures energy from the magnetic field. Also includes tuning capacitors to resonate at the same frequency as the Tx.\r\n    *   **Rectifier & Filter:** Converts the high-frequency AC voltage induced in the Rx coil back into usable DC voltage. (Diodes, capacitors).\r\n    *   **Voltage Regulator:** Stabilizes the DC voltage to power the connected device (e.g., charge a battery, run electronics).\r\n    *   **Load:** The device consuming the power (battery charger, LED, microcontroller, etc.).\r\n    *   **Control Circuitry:** The \"brain\" of the Rx.\r\n        *   Manages the power drawn by the load.\r\n        *   Communicates its status and power requests back to the Tx (often *by changing its load* - hint, hint!).\r\n\r\n**Diagram Sketch (Conceptual):**\r\n\r\n```\r\n[DC Source] --> [Tx Power Electronics / Oscillator] --> [Tx Coil + Tuning Caps] <--- Magnetic Field ---> [Rx Coil + Tuning Caps] --> [Rectifier + Filter] --> [Voltage Regulator] --> [Load]\r\n                                                                                                                                  ^                                  ^\r\n                                                                                                                                  |                                  |\r\n                                                                                                                                  +------- [Rx Control] <------------+\r\n                                                                                                                                  |\r\n                                                                                                                                  +---- Communication (often via Load Modulation) ----> [Tx Control]\r\n```\r\n\r\nUnderstanding these blocks is essential because our attack will involve *interacting* with this system, either as a rogue \"Receiver\" or by observing the \"Transmitter's\" behavior.\r\n\r\n### **5. The \"Why Security?\": Overlooked Physical Layer**\r\n\r\nThis is where we pivot from electrical engineering to offensive security.\r\n\r\nTraditional security focuses heavily on software, protocols, and data encryption. We think about SQL injection, buffer overflows, TLS vulnerabilities, phishing, etc.\r\n\r\nWhen people *do* think about WPT security, they often focus on:\r\n*   Securing the *data* transmitted *over* the WPT link (e.g., if the Qi standard includes data packets, are they encrypted?).\r\n*   Authentication: How does the Tx know it's talking to a *legitimate* Rx? (Though many simple WPT systems don't do strong authentication).\r\n*   Foreign Object Detection (FOD): Preventing metal objects from overheating in the magnetic field.\r\n\r\n**What's often overlooked?** The *physical act of power transfer itself*.\r\n\r\n*   The magnetic field is an open medium. Anyone can place a coil in it.\r\n*   The *interaction* between Tx and Rx is based on fundamental physics (resonance, coupling, impedance).\r\n*   This physical interaction creates observable side-effects on the Transmitter side.\r\n\r\n**The Security Blind Spot:** Most WPT systems are designed for efficiency and convenience, not malicious physical interaction. They assume receivers are cooperative or at least passive power sinks. They might detect *gross* anomalies (like a large metal object), but not subtle manipulations of the field by another resonant circuit.\r\n\r\nThis is our opportunity! We're attacking the layer *below* the digital communication, manipulating the very energy flow.\r\n\r\n### **6. Introduction to the Attack Surface: Manipulating the Energy Field**\r\n\r\nBased on the components and physics, what can an attacker *do*?\r\n\r\nOur attack surface is the **magnetic field** and the **physical interaction** it facilitates between Tx and Rx.\r\n\r\nSpecifically, the key vulnerability we will exploit centers around **reflected power** or **reflected impedance**.\r\n\r\n*   When a Receiver coil is placed in the Tx's magnetic field, it \"loads\" the field. It draws energy.\r\n*   This loading effect isn't just local to the Rx; it changes the *entire system's* characteristics, including what the Transmitter \"sees\" looking back into its own coil.\r\n*   Think of it like pushing on a spring: the way you push affects how the *other end* of the spring moves, and how the *anchor point* feels the force.\r\n*   Changes in the Rx's behavior (like how much power it draws, or if it intentionally changes its internal circuitry) directly impact the impedance the Tx \"sees\".\r\n*   The Tx often *relies* on observing these changes (e.g., detecting a receiver, regulating power).\r\n\r\n**The Attack Hypothesis:**\r\n*   **Energy Theft:** Can we place our *own* rogue coil in the field and efficiently draw power without being a legitimate or authorized receiver? Can we do it stealthily?\r\n*   **Data Exfiltration:** Can we *intentionally manipulate* our rogue receiver's characteristics (its load) in a way that creates subtle, detectable changes in the Tx's electrical signals? Can we encode data into these changes?\r\n\r\nThis second point is particularly powerful. It means the *power transfer channel* itself can potentially become a covert *data exfiltration channel*, even if the WPT system has no official digital communication or that communication is encrypted. The data is modulated onto the *energy signature*.\r\n\r\n### **7. Overview of the Course Objectives: Building the Attacker PoC**\r\n\r\nThis course isn't just theoretical. We're on a mission to build a working **Proof-of-Concept (PoC)** device.\r\n\r\nThe goal is to create a single piece of hardware (likely based around a microcontroller and some custom RF/power electronics) that can:\r\n\r\n1.  Position itself near a standard WPT transmitter (like a Qi charger).\r\n2.  Harvest energy from the magnetic field, even if it's not a recognized device.\r\n3.  Use that harvested energy (or a small internal battery) to power itself.\r\n4.  Intentionally modulate its electrical load in a specific pattern.\r\n5.  Demonstrate that this load modulation creates a detectable signal on the Transmitter side.\r\n6.  Show how this load modulation can encode simple data.\r\n\r\nWe will effectively be building a device that acts like a malicious parasite, stealing power and whispering secrets back through the power connection itself.\r\n\r\n## **Suggested Resources or Prerequisites:**\r\n\r\nTo get the most out of this module (and the rest of the course), having a handle on these basics will be a huge help:\r\n\r\n*   **Basic Electricity & Magnetism:** Concepts like voltage, current, resistance (Ohm's Law), inductance, capacitance, magnetic fields, how changing magnetic fields induce voltage (Faraday's Law). If these terms aren't completely foreign, you're in good shape.\r\n*   **Basic Electronic Components:** Familiarity with resistors, capacitors, inductors, diodes, transistors (especially MOSFETs as switches). What they look like, what they generally do.\r\n*   **Basic RF Concepts (Introductory Level):** Frequency, wavelength, resonance, impedance. Don't need to be an RF engineer, but knowing that circuits behave differently at high frequencies and that \"resonance\" is important is key.\r\n*   **Reading:**\r\n    *   Search for introductory articles or videos on \"Wireless Power Transfer explained,\" \"Inductive Coupling,\" and \"Resonant Coupling.\"\r\n    *   Look up the **Qi standard** (pronounced \"chee\"). You don't need to read the full specification (it's long and technical!), but understand its basic principles, frequency range, and how devices interact. Search for \"Qi wireless charging principles.\"\r\n    *   Wikipedia pages for \"Wireless Power Transfer,\" \"Inductive Coupling,\" \"Resonant Coupling,\" \"Impedance,\" and \"VSWR\" can be good starting points (but be mindful of depth).\r\n\r\nDon't worry if some of the RF/electronics concepts are hazy right now. We'll reinforce them as we go, especially in Module 2.\r\n\r\n## **Module Project/Exercise: Research and Hypothesize**\r\n\r\nAlright, your first mission! This is about applying what we just discussed and starting to think critically.\r\n\r\n**Task:**\r\n\r\n1.  **Choose a specific, real-world application of near-field WPT.** Examples:\r\n    *   Smartphone wireless charging (Qi)\r\n    *   Wireless charging for electric toothbrushes or shavers\r\n    *   Wireless charging for medical implants (e.g., a specific type of pacemaker or neurostimulator)\r\n    *   Wireless charging for an industrial sensor in a factory\r\n    *   Wireless charging for an electric vehicle\r\n\r\n2.  **Research this application:** Find out (roughly) what WPT standard or technology it uses, its operating frequency range (if possible), and its typical power level. Look for product descriptions, technical reviews, or even academic papers if you're feeling ambitious. *You don't need deep technical schematics yet.*\r\n\r\n3.  **Hypothesize ONE potential physical-layer security risk** based *only* on your understanding from Module 1.\r\n    *   Given that energy is transferred via a magnetic field in close proximity using coupling/resonance...\r\n    *   Given that there's a Transmitter and a Receiver...\r\n    *   Given that the Tx and Rx interact physically via the field...\r\n    *   **How could someone exploit the *energy transfer process itself*?**\r\n    *   Think about things like: Could someone steal power? Could someone interfere with the charging? Could someone *observe* something happening on the Tx side without touching it? Could they potentially send information *back* to the Tx in an unexpected way?\r\n    *   Focus on a *physical* interaction, not hacking the phone's OS or the car's software.\r\n\r\n4.  **Present your findings:** Prepare a short summary (a few paragraphs or a slide) covering:\r\n    *   The chosen application.\r\n    *   Brief details about its WPT (type, frequency, power if known).\r\n    *   Your hypothesized physical-layer security risk.\r\n    *   A brief explanation *why* you think this risk might be possible based on Module 1 concepts (e.g., \"Because it uses a magnetic field, maybe a rogue coil could intercept some energy,\" or \"Since the Rx affects the Tx via the field, maybe changing the Rx's behavior could signal something\").\r\n\r\n**Deliverable:** A short written summary or presentation slide(s) outlining your chosen application, its WPT details, and your hypothesized physical-layer security risk with justification based on Module 1 concepts.\r\n\r\nThis exercise is about starting to connect the physics to the \"what if?\" of security. There are no wrong answers at this stage, as long as your hypothesis relates to the *physical* WPT process we discussed.\r\n\r\n## **Module 1 Summary**\r\n\r\nPhew! We've covered a lot of ground, from the basic definition of WPT and the crucial difference between near-field and far-field, to the core physics of inductive and resonant coupling, the essential components of a WPT system, and most importantly, why the physical layer of WPT is a fascinating and often overlooked security attack surface.\r\n\r\nWe now know *what* near-field WPT is, *how* it generally works via magnetic coupling, and we've been introduced to the idea that manipulating this physical interaction is the key to our offensive goals: energy theft and data exfiltration via reflected power.\r\n\r\nIn the next module, we'll double-click on that critical concept: **The Physics of Reflected Power**. How does the Receiver's actions ripple back and become visible at the Transmitter? That understanding is absolutely vital before we start building anything.\r\n\r\nGet started on that project, ponder the physics, and I'll see you in Module 2!\r\n\r\n---"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Okay, class! Welcome back. Module 1 gave us the lay of the land – what WPT is, its applications, and why we need to think about its *physical layer* security. Now, we're going to dive deep into the fundamental physics that makes our planned attacks possible: **the phenomenon of reflected power**.\r\n\r\nThis isn't just theory; it's the invisible handshake between the WPT transmitter (Tx) and receiver (Rx). Understanding this handshake, how it's formed, and how to interpret its signals is absolutely crucial for both energy theft (Module 6) and data exfiltration (Module 7). We're essentially learning to *listen* to the power field and then *speak* to the transmitter by manipulating what it hears back.\r\n\r\nLet's unlock the secrets of reflected power!\r\n\r\n---\r\n\r\n## **Module 2: The Physics of Reflected Power in WPT**\r\n\r\n*   **Module Objective:** By the end of this module, you will be able to explain the concept of reflected power in resonant systems, understand how the receiver's load affects the transmitter's perspective, and identify the key measurable parameters related to this interaction that are relevant to our attack.\r\n\r\n---\r\n\r\n### **2.1 Resonance and Q Factor in WPT Coils**\r\n\r\nAlright, let's start with the heart of many near-field WPT systems: **Resonance**.\r\n\r\nImagine pushing a swing. If you push at just the right time (the swing's natural frequency), you can build up a large amplitude with very little effort. That's resonance! In electrical circuits, resonance occurs in circuits containing both inductors (L) and capacitors (C). At a specific frequency, the energy oscillating between the inductor's magnetic field and the capacitor's electric field is maximized, and their reactances cancel out.\r\n\r\n*   **Resonance Frequency (f₀):** For a simple series or parallel LC circuit, the resonance frequency is given by:\r\n    ```\r\n    f₀ = 1 / (2 * π * sqrt(L * C))\r\n    ```\r\n    Where:\r\n    *   `f₀` is the resonant frequency in Hertz (Hz)\r\n    *   `π` is approximately 3.14159\r\n    *   `L` is the inductance in Henries (H)\r\n    *   `C` is the capacitance in Farads (F)\r\n\r\n*   **Why Resonance in WPT?** WPT systems use resonance to build up high circulating currents/voltages in the Tx and Rx coils, even with relatively low input power. This creates a stronger magnetic field around the Tx coil, enabling more efficient energy transfer to the Rx coil when it's brought nearby, *provided* the Rx is also tuned to resonate near the same frequency.\r\n\r\n*   **Q Factor (Quality Factor):** Resonance isn't perfect. Real-world components have resistance (R), which dissipates energy (usually as heat). The Q factor quantifies how \"good\" or \"sharp\" a resonant circuit is. It's essentially a ratio of the energy stored in the circuit to the energy lost per cycle.\r\n    *   For a series RLC circuit: `Q = (2 * π * f₀ * L) / R = 1 / (2 * π * f₀ * C * R)`\r\n    *   For a parallel RLC circuit: `Q = R / (2 * π * f₀ * L) = (2 * π * f₀ * C * R)`\r\n    *   In WPT coils, the resistance `R` primarily comes from the wire resistance and other losses. The `L` and `C` are the coil inductance and any tuning capacitance added.\r\n\r\n*   **Why Q Factor Matters in WPT:**\r\n    *   **Efficiency:** Higher Q in the *isolated* Tx and Rx coils generally means less energy is wasted in the coils themselves, potentially leading to higher overall system efficiency *when properly coupled*.\r\n    *   **Bandwidth:** The Q factor is inversely related to the circuit's bandwidth (BW = f₀ / Q). A higher Q means a narrower bandwidth, meaning the circuit is very selective to the resonant frequency.\r\n    *   **Sensitivity to Changes:** Crucially for our attack, a higher Q system is often *more sensitive* to changes in the coupled load. Small changes on the Rx side can cause larger, more noticeable changes in the Tx circuit's behavior. This is a double-edged sword: good for efficient power transfer control, but also potentially good for observing subtle attacker manipulations!\r\n\r\n**Self-Check:** If you increase the resistance in a series RLC circuit, does the Q factor increase or decrease? (Answer: Decrease).\r\n\r\n### **2.2 Coupling Coefficient (k) and Its Impact**\r\n\r\nResonance is about a single circuit. WPT involves *two* circuits (Tx and Rx) interacting via a magnetic field. This interaction is quantified by the **Coupling Coefficient (k)**.\r\n\r\n*   **Mutual Inductance (M):** When current flows through one coil (Tx), it creates a magnetic field. If another coil (Rx) is placed within this field, the changing magnetic field induces a voltage in the Rx coil. This phenomenon is mutual inductance (M), measured in Henries.\r\n*   **Coupling Coefficient (k):** `k` is a dimensionless value ranging from 0 to 1. It describes how much of the magnetic flux produced by one coil links the other coil.\r\n    ```\r\n    k = M / sqrt(L₁ * L₂)\r\n    ```\r\n    Where:\r\n    *   `k` is the coupling coefficient (0 ≤ k ≤ 1)\r\n    *   `M` is the mutual inductance\r\n    *   `L₁` is the self-inductance of the Tx coil\r\n    *   `L₂` is the self-inductance of the Rx coil\r\n\r\n*   **Impact of k in WPT:**\r\n    *   **Power Transfer:** Higher `k` means stronger coupling and generally enables more efficient power transfer at a given distance.\r\n    *   **Resonance Frequency Splitting:** When two resonant circuits are strongly coupled (high `k`), their combined system resonance can split into two distinct frequencies. WPT systems often operate *between* these split frequencies or dynamically adjust. This is a more advanced topic, but understand that `k` significantly alters the overall system's resonant behavior.\r\n    *   **Reflected Impedance:** As we'll see shortly, `k` plays a direct role in how the Rx load impedance is \"reflected\" back to the Tx. Stronger coupling means the Rx has a greater influence on the Tx's observed impedance.\r\n\r\n*   **Factors Affecting k:**\r\n    *   **Distance:** `k` decreases rapidly as the distance between coils increases (inverse cube relationship for small loops). This is why near-field WPT has limited range.\r\n    *   **Alignment:** `k` is maximum when coils are perfectly aligned (coaxial and coplanar). Rotation or misalignment reduces `k`.\r\n    *   **Coil Geometry:** Size, shape, and number of turns affect `L₁`, `L₂`, and `M`.\r\n    *   **Intervening Materials:** Ferrous materials can increase coupling (core), while conductive materials (like metal plates) can reduce coupling by creating eddy currents.\r\n\r\n**Self-Check:** If you move the Rx coil further away from the Tx coil, does the coupling coefficient `k` increase or decrease? (Answer: Decrease).\r\n\r\n### **2.3 Impedance Matching: Why It's Crucial**\r\n\r\nYou might have heard the term \"impedance matching\" in the context of audio systems (matching speaker impedance to amplifier output) or RF systems (matching antenna impedance to transmitter/receiver impedance). The principle is the same in WPT: **for maximum power transfer, the source impedance should ideally match the load impedance.**\r\n\r\n*   **What is Impedance?** We'll cover this in detail next, but briefly, impedance (Z) is the AC equivalent of resistance. It's a measure of opposition to the flow of alternating current, and it includes both resistance (R, energy dissipation) and reactance (X, energy storage in L and C). `Z = R + jX`.\r\n*   **The Goal in WPT:** While a simple resistive load might want its resistance to equal the source resistance for maximum power, WPT systems are dealing with reactive components (coils, capacitors) and complex loads (the Rx circuit). The goal of \"matching\" in WPT is often to make the *total effective impedance* seen by the Tx power source such that power is delivered efficiently and safely, often appearing as a primarily resistive load *at the operating frequency*.\r\n*   **Why Mismatch is Bad:**\r\n    *   **Reduced Efficiency:** When impedances are mismatched, not all the power delivered by the source is absorbed by the load. Some is **reflected** back towards the source.\r\n    *   **Standing Waves:** In systems with transmission lines, mismatch causes forward and reflected waves to interfere, creating standing waves (points of high and low voltage/current). While WPT often doesn't use traditional transmission lines, the concept of energy \"bouncing back\" is valid.\r\n    *   **Stress on Components:** Reflected power can cause excessive voltage or current swings in the source circuit, potentially damaging components.\r\n    *   **Tx Instability/Shutdown:** WPT transmitters monitor the reflected power/impedance. A significant mismatch (like an attacker suddenly appearing) can be interpreted as an error condition (e.g., no legitimate receiver present, or a fault) and cause the Tx to reduce power or shut down.\r\n\r\n**Self-Check:** If a transmitter expects a 50 Ohm load but sees a 100 Ohm load, will power transfer be maximized? Will there be reflected power? (Answer: No, power transfer will not be maximized. Yes, there will be reflected power).\r\n\r\n### **2.4 The Concept of Complex Impedance**\r\n\r\nLet's formalize impedance. Unlike simple DC resistance (R), AC circuits have components that store energy (inductors and capacitors) and release it later. This storage/release causes a phase shift between voltage and current.\r\n\r\n*   **Resistance (R):** Opposition to current flow that dissipates energy (heat). Voltage and current are *in phase* in a pure resistor. Measured in Ohms (Ω).\r\n*   **Reactance (X):** Opposition to current flow due to energy storage in inductors (L) and capacitors (C). Voltage and current are *out of phase* in pure reactances. Measured in Ohms (Ω).\r\n    *   **Inductive Reactance (X_L):** Increases with frequency and inductance. `X_L = 2 * π * f * L`. Current *lags* voltage by 90°.\r\n    *   **Capacitive Reactance (X_C):** Decreases with frequency and capacitance. `X_C = 1 / (2 * π * f * C)`. Current *leads* voltage by 90°.\r\n*   **Impedance (Z):** The total opposition to AC current, combining resistance and reactance. It's a **complex number**.\r\n    *   `Z = R + jX`\r\n    *   `R` is the real part (resistance).\r\n    *   `X` is the imaginary part (total reactance, `X = X_L - X_C`).\r\n    *   `j` is the imaginary unit (sqrt(-1)).\r\n    *   Impedance can also be expressed in polar form: `Z = |Z| ∠ θ`, where `|Z|` is the magnitude (total opposition) and `θ` is the phase angle between voltage and current (`θ = arctan(X/R)`).\r\n\r\n*   **Why Complex Impedance Matters in WPT:** The Tx sees the *total complex impedance* presented by its own coil, tuning components, and the *reflected impedance* from the coupled Rx. Changes in the Rx's load circuit (which contains R, L, and C) alter its own impedance, which in turn alters the *complex reflected impedance*, and therefore the *total complex impedance* seen by the Tx. This change in the Tx's total impedance is what the Tx (and our attacker's monitoring equipment) can potentially detect.\r\n\r\n**Self-Check:** If a circuit has a large inductive reactance (`X_L`) and small resistance (R), will the phase angle (`θ`) be close to 0°, +90°, or -90°? (Answer: Close to +90°).\r\n\r\n### **2.5 Reflected Power and Voltage Standing Wave Ratio (VSWR)**\r\n\r\nNow, let's directly address the concept of reflected power. When a power source (like our WPT Tx) sends energy towards a load (effectively, the coupled Rx circuit), if the load impedance doesn't match the source impedance, some of that energy doesn't get absorbed by the load. Instead, it's reflected back towards the source.\r\n\r\n*   **Incident Power (P_inc):** The power flowing from the source towards the load.\r\n*   **Reflected Power (P_ref):** The power flowing back from the load towards the source due to impedance mismatch.\r\n*   **Delivered Power (P_delivered):** The power actually absorbed by the load. `P_delivered = P_inc - P_ref`.\r\n\r\n*   **Reflection Coefficient (Γ or ρ):** This is a complex number that quantifies the magnitude and phase of the reflected voltage wave relative to the incident voltage wave. It's calculated based on the load impedance (Z_load) and the characteristic impedance (Z₀) of the transmission medium (or effective source impedance).\r\n    ```\r\n    Γ = (Z_load - Z₀) / (Z_load + Z₀)\r\n    ```\r\n    The magnitude of the reflection coefficient, `|Γ|`, ranges from 0 (perfect match, no reflection) to 1 (total reflection, e.g., open or short circuit).\r\n    *   Reflected Power is proportional to `|Γ|²`. `P_ref = P_inc * |Γ|²`.\r\n\r\n*   **Voltage Standing Wave Ratio (VSWR):** In systems with transmission lines, the interference between incident and reflected waves creates a standing wave pattern. VSWR is a measure of the ripple in the voltage magnitude along the line.\r\n    ```\r\n    VSWR = (V_max) / (V_min) = (1 + |Γ|) / (1 - |Γ|)\r\n    ```\r\n    *   VSWR = 1: Perfect match (`|Γ| = 0`), no reflection, flat voltage profile.\r\n    *   VSWR > 1: Mismatch (`|Γ| > 0`), reflection present, standing wave pattern. Higher VSWR means greater mismatch and more reflected power.\r\n    *   VSWR = ∞: Total reflection (`|Γ| = 1`, e.g., open or short circuit).\r\n\r\n*   **Why Reflected Power/VSWR in WPT Context?** Although WPT isn't strictly transmission lines, the concepts of impedance mismatch leading to energy not being absorbed and \"bouncing back\" are directly applicable. The WPT transmitter circuitry effectively \"sees\" an impedance presented by the coupled Rx and its load. If this effective impedance deviates from what the Tx expects (its \"target\" load impedance for efficient transfer), it results in a higher \"effective reflection\" within the Tx's own circuitry. This manifests as changes in the Tx's operating parameters – drawing more or less current from the power supply, changes in voltage/current waveforms across its components, or shifts in phase.\r\n\r\n**Self-Check:** If the magnitude of the reflection coefficient `|Γ|` is 0.5, what percentage of the incident power is reflected? What is the VSWR? (Answer: Reflected Power = `0.5² = 0.25`, so 25%. VSWR = (1+0.5)/(1-0.5) = 1.5/0.5 = 3).\r\n\r\n### **2.6 How the Load Impedance on the *Receiver* coil is \"Reflected\" back to the *Transmitter***\r\n\r\nThis is the core mechanism that allows the attacker to influence the Tx and for the Tx to detect the Rx. The presence and load of the secondary (Rx) coil *changes the effective impedance* seen by the primary (Tx) coil.\r\n\r\nThink of it like this: The magnetic field produced by the Tx coil induces a current in the Rx coil. This current in the Rx coil then produces its *own* magnetic field. This secondary magnetic field couples *back* to the Tx coil, inducing a voltage in it (Lenz's Law). This induced voltage opposes the change in current in the Tx coil, effectively altering the Tx coil's impedance from the perspective of the power source.\r\n\r\n*   **Mathematical View (Simplified):**\r\n    *   Let Z₁ be the self-impedance of the Tx coil (including tuning capacitance and resistance). Z₁ = R₁ + jωL₁.\r\n    *   Let Z₂ be the self-impedance of the Rx coil (including tuning capacitance and resistance). Z₂ = R₂ + jωL₂.\r\n    *   Let Z_load_rx be the impedance of the load connected to the Rx coil (after rectification, or effectively AC impedance presented to the coil).\r\n    *   Let ω be the angular frequency (ω = 2 * π * f).\r\n    *   Let M be the mutual inductance between L₁ and L₂.\r\n\r\n    The total impedance seen by the Tx power source (Z_in) is approximately:\r\n    ```\r\n    Z_in = Z₁ + (ωM)² / (Z₂ + Z_load_rx)\r\n    ```\r\n    *   The term `(ωM)² / (Z₂ + Z_load_rx)` is the **reflected impedance (Z_reflected)**.\r\n    *   Notice that `Z_reflected` is inversely proportional to `(Z₂ + Z_load_rx)`.\r\n    *   This means that as `Z_load_rx` changes (e.g., a device drawing more power, or our attacker circuit modulating its load), `Z_reflected` changes.\r\n    *   Since `Z_in` is the sum of `Z₁` (which is relatively constant) and `Z_reflected`, changes in `Z_load_rx` directly cause changes in `Z_in`.\r\n\r\n*   **How Changes in Z_in Manifest at the Tx:**\r\n    *   **Input Current:** If the Tx is driven by a voltage source, a change in `Z_in` will cause a change in the current drawn from the source (`I_source = V_source / Z_in`).\r\n    *   **Voltage/Current Waveforms:** The amplitude and phase of voltage and current waveforms across the Tx coil and tuning components will change as `Z_in` changes, affecting the Tx's resonant circuit.\r\n    *   **Phase Shift:** The phase difference between voltage and current at the Tx input or across its coil will change as the complex value of `Z_in` changes.\r\n\r\nThis reflected impedance is the **channel** through which the Rx (legitimate or attacker) communicates its presence and state back to the Tx.\r\n\r\n**Self-Check:** If the effective load impedance on the Rx (`Z_load_rx`) increases, does the magnitude of the reflected impedance (`Z_reflected`) increase or decrease? (Answer: Decrease, because it's in the denominator).\r\n\r\n### **2.7 Analyzing the Tx Perspective: How Changes in Rx Load/Presence Manifest**\r\n\r\nBuilding on the previous point, let's be more specific about *what* a WPT transmitter system actually monitors to understand what the coupled Rx is doing. Commercial WPT controllers are designed to detect a legitimate receiver, regulate power delivery, and potentially receive communication from the receiver (e.g., battery level, desired power). They do this by observing the changes in their own primary circuit caused by the reflected impedance.\r\n\r\nCommon parameters monitored by WPT transmitters:\r\n\r\n1.  **Input Current/Power Draw:** The most direct indicator. When a legitimate Rx is placed on the Tx, the total load on the Tx power supply increases. More power is being transferred, so the Tx draws more current (or power) from its source. Our attacker device, when harvesting energy, will also cause the Tx to draw more power.\r\n2.  **Tx Coil Voltage/Current Amplitude:** The AC voltage across or current through the Tx coil and its tuning capacitor are key indicators of the resonant circuit's behavior. Changes in the reflected impedance detune the circuit slightly or change its effective Q, altering the amplitude of these signals.\r\n3.  **Phase Relationship (Voltage vs. Current):** At perfect resonance with no load, the voltage and current in a series resonant circuit are in phase (or 180° out of phase depending on convention), and the impedance is purely resistive. As a load is coupled, the reflected impedance adds a reactive component, causing a phase shift between the Tx voltage and current. Monitoring this phase shift is a very sensitive way for the Tx controller to detect the load and estimate its characteristics.\r\n4.  **Resonance Frequency Shift:** Strong coupling and changes in load can slightly shift the effective resonance frequency of the coupled system. Some advanced Tx designs might monitor or adapt to this shift.\r\n\r\n**The Attacker's Opportunity:** Our goal is to perform actions (harvest energy, modulate load) that cause *detectable* changes in these parameters. We want to either:\r\n*   Cause a sustained change (like increased current draw from energy harvesting) that looks like a legitimate load (or perhaps an *unauthorized* load).\r\n*   Cause rapid, controlled changes (by modulating our load) that encode data, which can be observed as fluctuations in the Tx's current, voltage, or phase.\r\n\r\n### **2.8 Measurement Techniques Overview**\r\n\r\nTo observe these phenomena and verify our understanding (and later, our attacks), we need the right tools.\r\n\r\n*   **Oscilloscope:** Your absolute best friend in this course. Essential for:\r\n    *   Viewing AC voltage and current waveforms in the Tx and Rx circuits.\r\n    *   Measuring the amplitude and frequency of signals.\r\n    *   Observing phase shifts between voltage and current.\r\n    *   Crucially, seeing the subtle (or not-so-subtle) changes in the Tx waveforms caused by the Rx load, *including* our attacker's load modulation. You'll need probes (voltage probes, and ideally a current probe or shunt resistor setup) and sufficient bandwidth/sampling rate for the WPT frequency you're working with (e.g., 13.56 MHz requires a scope with bandwidth significantly higher than that, say 50-100 MHz minimum for clean signals, though lower might work for just seeing amplitude changes).\r\n*   **Multimeter:** Useful for DC measurements (power supply voltage, harvested DC voltage) and basic resistance checks, but not for observing the dynamic AC signals and waveforms we're focusing on here.\r\n*   **Power Meter / Current Sensor (DC):** For quantifying the *total* power drawn by the Tx from its source, or the DC power harvested by our Rx circuit (more in Module 6).\r\n*   **Vector Network Analyzer (VNA):** (Conceptual for this module). A VNA is a sophisticated RF instrument that *directly* measures impedance (Z) and scattering parameters (S-parameters), including the reflection coefficient (S11). It can show you exactly how the input impedance of the Tx coil changes as you couple an Rx and vary its load, across a range of frequencies. While incredibly useful for analyzing WPT systems and designing coils, they are expensive and complex. For this course's practical PoC, we will rely on observing the *effects* of impedance changes (voltage, current, phase) using an oscilloscope, rather than directly measuring the impedance with a VNA. Understand *what* a VNA measures, as it directly relates to the concepts of impedance and reflection coefficient we discussed.\r\n\r\n**Practical Tip:** When using an oscilloscope to observe signals in a switching power circuit like a WPT Tx"
    },
    {
      "title": "3: Understanding the WPT Transmitter (The Attacker's Target)",
      "description": "3: Understanding the WPT Transmitter (The Attacker's Target) Overview",
      "order": 3,
      "content": "Welcome back! In Module 2, we delved into the fascinating physics of resonant coupling and the critical concept of reflected power – how changes on the Receiver (Rx) side are 'seen' by the Transmitter (Tx). Now, we're going to put on our attacker's hat and examine the WPT Transmitter itself. Why? Because to effectively attack a system, you must deeply understand your target. The Tx isn't just a dumb power source; it's an active system that senses, regulates, and reacts. Identifying *how* it does this reveals the vulnerabilities we'll exploit.\r\n\r\n**Module Objective:** By the end of this module, you will be able to describe the typical architecture of a WPT transmitter, understand how it senses the receiver's presence and state, and identify the specific signals or parameters an attacker can monitor or influence to detect receiver behavior or the presence of their own attack device.\r\n\r\n### 3.1 Tx Architecture: The Building Blocks\r\n\r\nAt its core, a WPT transmitter takes a DC power source (like a wall adapter) and converts it into a high-frequency AC signal that drives a coil, generating the oscillating magnetic field. Let's break down the key components:\r\n\r\n1.  **Power Source:** This is typically a DC voltage supply. For consumer electronics like phone chargers, it might be 5V, 9V, or 12V from a USB adapter. For higher power applications (EV charging), it could be much higher DC voltages.\r\n2.  **Inverter/Oscillator:** This is the heart of the AC generation. It takes the DC input and, using switching components (like MOSFETs or transistors), rapidly switches the voltage across the primary circuit to create an AC waveform.\r\n    *   **Why AC?** Magnetic fields are generated by *changing* currents. A steady DC current creates a constant magnetic field (useful for electromagnets, not inductive power transfer). We need a rapidly oscillating field to induce a voltage in the secondary coil.\r\n    *   **Frequency:** The operating frequency depends on the WPT standard or design. Qi standard operates in the 100-200 kHz range (lower frequency, larger coils). Resonant systems often operate at higher frequencies (e.g., 6.78 MHz, 13.56 MHz, or even higher) to enable smaller coils and slightly longer ranges due to higher Q factors.\r\n3.  **Matching Network / Resonant Circuit:** The Tx coil has inductance. To efficiently transfer power and create a strong oscillating magnetic field at the desired frequency, the coil is typically part of a resonant circuit. This involves adding capacitors in series or parallel with the coil.\r\n    *   **Resonance:** When the inductive reactance ($X_L = 2\\pi f L$) and capacitive reactance ($X_C = 1/(2\\pi f C)$) are equal at the operating frequency ($f$), the impedance of the circuit is purely resistive (ideally). This allows for maximum current flow through the coil for a given voltage, maximizing the generated magnetic field strength.\r\n    *   **Matching:** This network also helps match the impedance of the resonant circuit to the output impedance of the inverter/driver stage for optimal power transfer *into* the resonant circuit.\r\n4.  **Tx Coil:** The physical coil of wire that generates the primary magnetic field. Its size, shape, and number of turns are critical for determining its inductance and coupling coefficient with the Rx coil. It's often integrated with the resonant capacitors.\r\n5.  **Control & Sensing Circuitry:** This is the \"brain\" of the Tx. It monitors the system's state (often by looking at the voltage, current, or phase relationship in the resonant circuit or the power drawn from the DC source), implements load detection, regulates output power, and in more complex systems (like Qi), handles communication with the Rx.\r\n\r\n**Simplified Block Diagram (Conceptual):**\r\n\r\n```\r\n[DC Power Source] --> [Inverter/Oscillator] --> [Matching Network/Resonant Circuit] --> [Tx Coil]\r\n                               ^                                        |\r\n                               |----------------------------------------|\r\n                                        [Control & Sensing Circuitry]\r\n```\r\n\r\n### 3.2 Resonant Inverters: Creating the Field\r\n\r\nLet's look a bit closer at the Inverter/Oscillator (Subtopic 2). While there are many types, **Class D** and **Class E** inverters are common in WPT due to their high efficiency when driving resonant loads.\r\n\r\n*   **Class D Inverter:** Uses two switching components (like MOSFETs) to create a square wave voltage across the resonant circuit. When one switch is on, voltage is applied in one direction; when the other is on, voltage is applied in the opposite direction. The resonant circuit acts as a filter, smoothing the square wave into a more sinusoidal current through the coil at the resonant frequency.\r\n*   **Class E Inverter:** Uses a single switching component and relies heavily on the resonant network and timing to achieve high efficiency by minimizing switching losses (e.g., switching when voltage or current is zero - Zero Voltage Switching (ZVS) or Zero Current Switching (ZCS)).\r\n\r\n**Why are these important?** The inverter design dictates the waveform shape and efficiency. More importantly for our attack, the *control* of these inverters (e.g., changing switching frequency, duty cycle, or voltage) is how the Tx regulates the power output. And this regulation is often triggered by the Tx sensing the Rx's load via reflected power.\r\n\r\n### 3.3 Load Detection: How the Tx \"Sees\" the Rx\r\n\r\nThis is where Module 2's concepts become directly applicable to the Tx's function (Subtopic 3). A WPT transmitter needs to know:\r\n\r\n1.  Is a potential receiver present?\r\n2.  If so, is it a *valid* receiver? (More relevant for standards like Qi, less so for our basic hijacking attack, but the *detection mechanism* is the same).\r\n3.  How much power does the receiver need?\r\n\r\nThe primary way the Tx senses a receiver is by detecting the *change* in the impedance and/or power draw of its own Tx coil circuit when a secondary coil (the Rx) is brought into proximity and coupled.\r\n\r\n*   **Without Rx:** The Tx coil circuit resonates freely (or is driven at resonance). The Tx draws a certain amount of power from the source, primarily to maintain the oscillating field and cover its own losses.\r\n*   **With Rx Present & Coupled:** Energy is now being transferred from the Tx coil to the Rx coil. This energy transfer represents a *load* on the Tx's resonant circuit. From the perspective of the Tx inverter, the *effective impedance* of the Tx coil changes.\r\n    *   Recall from Module 2: The load on the secondary coil is \"reflected\" back to the primary coil, appearing as a change in impedance.\r\n    *   This change in impedance means the Tx circuit's voltage/current relationship changes.\r\n    *   Consequently, the *total power drawn from the DC source* by the Tx circuit increases as it delivers power to the Rx.\r\n\r\n**How the Tx Measures This:** The control circuitry monitors parameters that are sensitive to this reflected impedance change:\r\n\r\n*   **Input DC Current:** A simple way is to measure the total current drawn from the DC power source. When a legitimate Rx starts drawing power, the Tx's input current will increase.\r\n*   **Tx Coil Voltage/Current/Phase:** More sophisticated systems directly monitor the AC voltage across the Tx coil, the AC current through it, or the phase difference between them. Changes in reflected impedance alter these AC signals. For example, coupling a loaded Rx might cause the Tx coil voltage to drop or the current to increase, and the phase relationship between voltage and current might shift slightly away from perfect resonance (where voltage and current are in phase).\r\n\r\nThis detection mechanism is often used as a \"ping\" or \"polling\" method. The Tx might periodically send out short bursts of power and listen for the characteristic change in its own electrical parameters, indicating a receiver is present.\r\n\r\n### 3.4 Power Regulation: Adapting to the Load\r\n\r\nOnce a receiver is detected and potentially identified, the Tx needs to regulate the amount of power transferred (Subtopic 4). A phone battery charging at 50% needs more power than one at 90%. The Tx adjusts its output power based on the Rx's reported needs.\r\n\r\nHow does the Tx regulate power? By changing the drive signal to the inverter:\r\n\r\n*   **Changing Frequency:** Shifting the operating frequency slightly away from perfect resonance reduces the efficiency of power transfer.\r\n*   **Changing Voltage/Duty Cycle:** Modifying the voltage amplitude or the duty cycle of the switching signals in the inverter can control the amount of energy pumped into the resonant circuit per cycle.\r\n\r\nThis regulation process is typically a feedback loop:\r\n1.  Rx communicates its power needs (often via load modulation, which the Tx senses as a specific pattern of reflected impedance changes - foreshadowing Module 4 & 7!).\r\n2.  Tx senses this communication signal by monitoring its own electrical parameters (voltage, current, etc.).\r\n3.  Tx adjusts its output power (frequency, voltage, duty cycle).\r\n4.  Rx receives more or less power and continues to communicate its needs.\r\n\r\n**Key Point:** Both load *detection* and load *regulation* rely entirely on the Tx's ability to sense changes in its own circuit caused by the presence and load of the Rx via the physical phenomenon of reflected impedance/power.\r\n\r\n### 3.5 Attacker's Monitoring Points: Where to Look for Signals\r\n\r\nBased on the Tx architecture and sensing mechanisms, where can an attacker, observing the Tx, look for signs of a receiver (legitimate or their own attack device) and potentially even decode data modulated by the receiver? (Subtopic 5)\r\n\r\nThese are the signals or parameters sensitive to reflected power changes:\r\n\r\n*   **DC Input Current/Power:** The easiest to measure externally if the Tx's power cable is accessible. A legitimate Rx appearing or your attack device harvesting power will cause the total DC power draw to increase.\r\n*   **Tx Coil Voltage Waveform:** Observing the AC voltage across the Tx coil with an oscilloscope. Changes in reflected load will alter the amplitude and potentially the shape of this waveform.\r\n*   **Tx Coil Current Waveform:** Observing the AC current through the Tx coil (using a current probe or measuring voltage across a small series sense resistor). Changes in reflected load will alter the amplitude and phase of this waveform relative to the voltage.\r\n*   **Voltage across Tuning Capacitors:** Similar to Tx coil voltage, these points in the resonant circuit are sensitive to impedance changes.\r\n*   **Phase Difference (Voltage vs. Current):** Monitoring the phase angle between the voltage and current at the Tx coil. Resonance implies a near-zero phase shift (purely resistive impedance). A reflected load will introduce reactance, causing the phase shift to change.\r\n\r\n**Attacker's Advantage:** While commercial WPT systems might have internal digital communication protocols, the underlying physical layer interaction (reflected power) is *always* present. By monitoring the analog electrical signals *before* they are processed by the Tx's digital control, an attacker can potentially detect *any* device causing a significant load change in the field, regardless of whether it's an authorized WPT receiver or a malicious harvesting/modulating device.\r\n\r\n### 3.6 Case Study: Qi Standard Tx Operation\r\n\r\nLet's briefly look at the Qi standard as a concrete example (Subtopic 6). While Qi has digital communication layers, its foundation is built upon the physical layer interactions we've discussed.\r\n\r\n1.  **Selection/Ping Phase:** The Qi Tx periodically sends out brief \"pings\" – short bursts of power at the operating frequency.\r\n2.  **Detection Phase:** A Qi-compatible Rx in the field *detects* this ping (it receives a small amount of power). The Rx then *loads* its coil in a specific way (using load modulation - more on this in Module 4) which changes the reflected impedance seen by the Tx.\r\n3.  **Tx Response:** The Qi Tx monitors its coil voltage/current during and after the ping. It looks for the characteristic change caused by the Rx's loading. If it sees this signature, it knows a potential Rx is present.\r\n4.  **Identification & Configuration Phase:** If a receiver is detected, the Tx might transition to a state where it provides continuous power at a low level. The Rx then uses load modulation (changing its load according to a specific protocol) to send messages back to the Tx, identifying itself and requesting power levels. The Tx decodes these messages by observing the *pattern* of reflected impedance changes.\r\n5.  **Power Transfer Phase:** Once configured, the Tx provides continuous power. The Rx continues to communicate its battery level and desired power, and the Tx adjusts its output (e.g., by changing the frequency) based on these requests.\r\n\r\n**The Attack Relevance:** Notice that steps 2, 3, and 4 rely entirely on the Rx influencing the Tx's electrical parameters via reflected impedance (load modulation). Our attack will mimic this physical interaction, either to just draw power (causing a load change the Tx *might* interpret as a legitimate Rx or just an increased load) or to *intentionally* create patterns of load changes to exfiltrate data.\r\n\r\n### Key Takeaways from Module 3:\r\n\r\n*   A WPT transmitter is more than just an oscillator; it's a system that generates, senses, and regulates the power field.\r\n*   The core components are the power source, inverter/oscillator, resonant network, Tx coil, and control/sensing circuitry.\r\n*   Load detection and power regulation in WPT rely on the Tx's ability to sense changes in its own electrical parameters (like input current, coil voltage/current/phase) which are caused by the Rx's presence and load via *reflected impedance*.\r\n*   These observable electrical parameters on the Tx side are the attacker's primary targets for monitoring – they reveal information about what's happening in the power field.\r\n*   Understanding how a standard like Qi uses reflected power for detection and communication highlights the vulnerability: the physical channel used for legitimate control can potentially be manipulated for malicious purposes.\r\n\r\n### Module Project/Exercise: Observing Reflected Power on a Basic Tx\r\n\r\nThis project aims to give you hands-on (or simulation-based) experience with how a load on a secondary coil affects the primary side – the core principle we've discussed.\r\n\r\n**Objective:** Build or simulate a basic resonant WPT transmitter and observe how introducing a passive, loaded secondary coil changes the waveform on the primary side.\r\n\r\n**Option A: Simulation (Recommended if you don't have RF equipment)**\r\n\r\n*   **Tools:** LTspice, CircuitLab, or any circuit simulator capable of AC analysis and transient simulation.\r\n*   **Conceptual Circuit:** We'll simulate a simple series-resonant primary coupled to a secondary coil with a load resistor.\r\n\r\n    ```\r\n    [AC Voltage Source] -- [Resistor (Rs)] -- [Inductor (L1)] -- [Capacitor (C1)] -- -- [AC Voltage Source]\r\n                                                                     |                     |\r\n                                                                     -- Coupled to L2 --\r\n                                                                                           |\r\n                                                                                     [Inductor (L2)] -- [Resistor (Rload)] -- [Ground]\r\n                                                                                           |\r\n                                                                                     [Capacitor (C2)] -- -- -- -- -- -- -- -- [Ground]\r\n    ```\r\n    *   `AC Voltage Source`: Represents the output of our inverter/driver. Set it to a sine wave at a frequency you'll resonate L1/C1 at (e.g., 1V amplitude, 130kHz).\r\n    *   `Rs`: Small series resistor (e.g., 1 Ohm) to represent source impedance and allow easy current measurement (V(Rs)/Rs = Current).\r\n    *   `L1`, `C1`: Primary coil inductance and tuning capacitor. Choose values that resonate at your chosen frequency (e.g., for 130kHz, if L1 = 10uH, C1 = 1/( (2*pi*130e3)^2 * 10e-6 ) ~= 150nF).\r\n    *   `L2`, `C2`: Secondary coil inductance and tuning capacitor. For simplicity in this demo, make them the same values as L1/C1 so they resonate at the same frequency.\r\n    *   `Rload`: The load resistor on the secondary side (e.g., 50 Ohm, 100 Ohm, 1k Ohm). This is what we'll change or remove.\r\n    *   `Coupling`: Most simulators allow you to define coupling (Mutual Inductance, M, or Coupling Coefficient, k) between L1 and L2. Start with a moderate coupling, e.g., k=0.5.\r\n\r\n*   **Step-by-Step Simulation:**\r\n    1.  Set up the circuit in your simulator *without* L2, C2, and Rload connected. Run a transient simulation for a few cycles. Observe the voltage across L1 (V(L1+ node) - V(L1- node)) and the current through L1 (e.g., V(Rs)/Rs). Note the amplitude and phase.\r\n    2.  Now, add L2, C2, and connect Rload (e.g., 100 Ohm). Define the coupling between L1 and L2 (e.g., k=0.5).\r\n    3.  Run the transient simulation again. Observe the voltage across L1 and the current through L1. *Compare* these waveforms to the case without the secondary load.\r\n    4.  Experiment: Change the value of Rload (e.g., to 50 Ohm, 1k Ohm). How does this affect the primary waveforms? What happens if you set Rload to a very high value (approaching open circuit)?\r\n    5.  Experiment: Change the coupling coefficient 'k'. How does stronger/weaker coupling affect the observed changes?\r\n    6.  Experiment (Optional): Change the driving frequency slightly away from resonance. How does this affect the power transfer and the sensitivity of the primary waveforms to the secondary load?\r\n\r\n*   **Documentation:**\r\n    *   Include the circuit diagram used for simulation.\r\n    *   Show screenshots of the primary voltage and current waveforms for at least two cases: 1) No secondary load, and 2) Secondary with a moderate load (e.g., 100 Ohm).\r\n    *   Describe in your own words *how* the primary waveforms changed when the loaded secondary was introduced.\r\n    *   Explain *why* you think these changes occurred, referencing the concept of reflected impedance.\r\n    *   Note any observations from experimenting with different Rload values or coupling coefficients.\r\n\r\n**Option B: Basic Hardware Build (Requires basic electronics tools)**\r\n\r\n*   **Required Components:**\r\n    *   Function Generator (capable of producing sine waves up to ~200kHz or higher, 1-5V amplitude).\r\n    *   Oscilloscope (2 channels recommended, sufficient bandwidth for your frequency).\r\n    *   Two coils: You can buy small WPT coils (e.g., Qi coils) or wind your own (e.g., ~20-30 turns of magnet wire on a 5-10cm diameter form). Try to make them similar.\r\n    *   Capacitors: Various values (e.g., 10nF, 47nF, 100nF, 150nF, 220nF, etc.). You'll use these to tune the coils to resonance.\r\n    *   Resistors: Various power resistors (e.g., 1 Ohm, 10 Ohm, 50 Ohm, 100 Ohm, 1k Ohm, 10k Ohm - 0.5W or 1W rating is usually fine for low power tests).\r\n    *   Breadboard or prototyping board.\r\n    *   Jumper wires.\r\n    *   Optional: Small resistor (e.g., 1 Ohm, 0.5W) to use as a current sense resistor in series with the primary coil.\r\n\r\n*   **Step-by-Step Build & Measurement:**\r\n    1.  **Build the Primary Resonant Circuit:** Connect your primary coil (L1) in series with a capacitor (C1) and a small sense resistor (Rs) if you have one. Connect this series combination to the output of your function generator.\r\n    2.  **Find Resonance:** Set the function generator to a sine wave output (low amplitude, e.g., 2Vpp). Sweep the frequency and/or change the value of C1 until you see the *maximum* voltage across the series LC combination (or maximum voltage across L1/C1 and minimum voltage across Rs if measuring current). This is your approximate resonance frequency. Note this frequency.\r\n    3.  **Observe Primary Waveform (No Secondary Load):** Use your oscilloscope to observe the voltage waveform across the primary coil (or across C1, or the voltage from one side of the series LC-Rs to ground if one side is grounded by the generator). Note the amplitude and shape. If using a current sense resistor, observe the voltage across Rs (representing current).\r\n    4.  **Build the Secondary Resonant Circuit:** Connect your secondary coil (L2) in series with a capacitor (C2) and a load resistor (Rload, e.g., 100 Ohm). Again, try to choose C2 to resonate L2 at roughly the same frequency as the primary.\r\n    5.  **Introduce the Loaded Secondary:** Place the secondary coil near and aligned with the primary coil (e.g., centered, a few cm apart).\r\n    6.  **Observe Primary Waveform (With Loaded Secondary):** Look at the same primary voltage/current waveform(s) on the oscilloscope again. *Compare* them to the waveforms from step 3.\r\n    7.  Experiment: Change the load resistor Rload on the secondary (e.g., replace 100 Ohm with 1k Ohm, or remove it entirely - open circuit). How does this change the primary waveform?\r\n    8.  Experiment: Change the distance or alignment between the coils. How does coupling affect the observed changes on the primary?\r\n    9.  **Safety Note:** Keep the power levels low during this experiment. Function generators typically output low power. Be mindful of component ratings if you use a higher power source later in the course.\r\n\r\n*   **Documentation:**\r\n    *   Draw a schematic of your primary and secondary circuits.\r\n    *   Note the component values (L, C, Rload, Rs) and the resonance frequency you found.\r\n    *   Include oscilloscope screenshots or hand-drawn sketches of the primary voltage and current waveforms for at least two cases: 1) No secondary load, and 2) Secondary with a moderate load (e.g., 100 Ohm). Label axes clearly.\r\n    *   Describe in your own words *how* the primary waveforms changed when the loaded secondary was introduced.\r\n    *   Explain *why* you think these changes occurred, referencing the concept of reflected impedance.\r\n    *   Note any observations from experimenting with different Rload values or coil placements.\r\n\r\n**Expected Outcome:** In both simulation and hardware, you should observe that when a loaded secondary coil is brought near the primary coil, the amplitude of the voltage across the primary coil (and potentially its current) will change. The phase relationship between voltage and current might also shift. This is the direct effect of the reflected impedance caused by the coupled, loaded secondary. You are visually confirming the physical principle that makes WPT load detection and communication possible – and exploitable.\r\n\r\n---\r\n\r\nThis concludes Module 3. You now have a foundational understanding of how a WPT transmitter works, how it senses receivers through reflected power, and where an attacker can look to observe these interactions. In Module 4, we'll shift our focus to the WPT Receiver – understanding its architecture and, crucially, how it uses *load modulation* to communicate, a technique we will then hijack for data exfiltration. Get ready to build or simulate your Tx and see the physics in action!"
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Okay, class! Welcome back. We've built a solid foundation understanding the physics of WPT and how the transmitter works and senses its environment. Now, we're going to flip the perspective and dive deep into the *receiver*. This is critical because, for our attack, the receiver isn't just the *target* of power; it's going to be our *tool* and *proxy* for both stealing energy and, more importantly for this module, *communicating covertly* back to the transmitter.\r\n\r\nThink of it this way: if the transmitter is a radio station broadcasting power, the receiver is usually just a device tuning in to *use* that power. But a clever attacker can turn that tuning device into a low-power walkie-talkie that talks *back* to the station, hidden in plain sight within the power signal itself.\r\n\r\nLet's break down Module 4.\r\n\r\n---\r\n\r\n## Module 4: Understanding the WPT Receiver (The Attacker's Tool/Proxy)\r\n\r\n**Module Objective:** By the end of this module, you will be able to describe the typical architecture of a WPT receiver, understand how it extracts power and manages its load, and, critically, identify how its load characteristics are communicated back to the transmitter via the very mechanism we'll hijack: load modulation.\r\n\r\n**Recap from Module 3:** We looked at the WPT transmitter (Tx), its components, how it generates the oscillating magnetic field, and how it *listens* for changes in its coil's impedance or current draw to detect a receiver and regulate power. This \"listening\" part is key – the Tx is constantly monitoring its own state, which is influenced by what's happening at the receiver (Rx).\r\n\r\n### Essential Subtopics:\r\n\r\nLet's dissect the WPT Receiver piece by piece.\r\n\r\n#### 1. Rx Architecture: Rx Coil, Rectifier, Filter, Voltage Regulator, Load\r\n\r\nImagine a standard Qi charging receiver inside your phone or a medical implant. It needs to capture the AC energy from the Tx field and convert it into stable DC voltage to power its internal circuitry or charge a battery. Here's the typical chain:\r\n\r\n*   **Rx Coil:** This is the antenna for receiving power. Just like the Tx coil, it's usually an inductor tuned to resonate at the same frequency as the Tx (or close to it) to maximize energy transfer. When placed in the oscillating magnetic field generated by the Tx, the changing magnetic flux induces an AC voltage across the Rx coil terminals, thanks to Faraday's Law of Induction.\r\n*   **Rectifier:** The induced voltage is AC (alternating current). Most electronic devices need DC (direct current). The rectifier circuit converts the AC voltage into pulsating DC voltage. The most common type for WPT is a full-wave bridge rectifier, using four diodes.\r\n*   **Filter:** The output of the rectifier is pulsating DC – it goes from zero to a peak voltage, back towards zero, then back to a peak, etc. This isn't smooth enough for most electronics. A filter, typically a capacitor placed across the rectifier output, smooths out these pulses by storing charge when the voltage is high and releasing it when the voltage dips. This results in a much smoother DC voltage, often with some ripple.\r\n*   **Voltage Regulator:** Even after filtering, the DC voltage might vary depending on the distance from the Tx, the alignment of the coils, and the power being drawn by the load. A voltage regulator (like an LDO - Low-Dropout Regulator, or a switching regulator) takes this potentially fluctuating DC voltage and provides a stable, constant DC output voltage required by the actual load (e.g., 5V for charging, 3.3V for circuitry).\r\n*   **Load:** This is the ultimate destination of the power – the battery being charged, the internal electronics of a device, an LED, etc. The load draws current from the voltage regulator.\r\n\r\n**Visualizing the Chain:**\r\n\r\n```\r\n[Rx Coil] --> [Rectifier (Diodes)] --> [Filter (Capacitor)] --> [Voltage Regulator] --> [Load (Battery/Circuitry)]\r\n        (AC Induced)           (Pulsating DC)         (Smoothed DC)          (Stable DC)\r\n```\r\n\r\n#### 2. Power Extraction: AC-to-DC Conversion\r\n\r\nLet's zoom into the rectifier and filter.\r\n\r\n*   **Full-Wave Bridge Rectifier:** This configuration uses four diodes arranged in a bridge. During the positive half-cycle of the incoming AC voltage from the Rx coil, two diodes conduct, allowing current to flow through the load. During the negative half-cycle, the *other* two diodes conduct, again directing current through the load in the *same direction*. This ensures that current always flows one way through the load, creating a full-wave pulsating DC output.\r\n\r\n    ```\r\n    (From Rx Coil)\r\n    Terminal A ---|>|--- +V_out ---\r\n                 |   ^             |\r\n                 |   |             |\r\n                 ---|>|--- Load ---\r\n                 |   ^             |\r\n                 |   |             |\r\n    Terminal B --+---|>|----------\r\n                     |   ^\r\n                     |   |\r\n                     ----|>|-------\r\n                         |\r\n                         -- -V_out (usually 0V or Ground)\r\n    ```\r\n    *(Note: This is a simplified ASCII diagram. A real schematic would show the diodes connected differently, forming the bridge.)*\r\n\r\n*   **Filtering Capacitor:** A large capacitor placed in parallel with the load smooths the output. As the pulsating DC voltage rises, the capacitor charges. As the voltage drops (between pulses), the capacitor discharges into the load, filling in the gaps and keeping the voltage relatively constant. The larger the capacitor, the smoother the output (less ripple).\r\n\r\n#### 3. Load Management: How the Rx Regulates Power\r\n\r\nA simple resistive load would draw current proportional to the voltage. However, real WPT receivers are smarter. They often regulate the power delivered to the final load (like a battery charger IC). This regulation means the *effective impedance* presented by the Rx circuit to the *rectifier* changes depending on the load's needs and the available input power.\r\n\r\nFor example, if the Rx is charging a battery that's nearly full, it draws less current. If the Tx is providing more power than needed, the Rx might increase its internal resistance or even temporarily disconnect the load to manage the voltage and prevent damage. This dynamic load management is a standard feature of WPT receivers.\r\n\r\n#### 4. Communication Channel: Backscatter Modulation (Load Modulation)\r\n\r\nThis is where things get interesting from an attacker's perspective. How does a WPT receiver tell the transmitter anything? It doesn't have a separate Wi-Fi chip or Bluetooth radio for this. Instead, it uses the *power link itself* as a low-speed communication channel.\r\n\r\nThe primary method is **Backscatter Modulation**, often referred to as **Load Modulation** in the context of WPT.\r\n\r\n*   **The Principle:** The receiver intentionally and rapidly changes its electrical load (its impedance). As we learned in Module 2, changing the load impedance on the secondary (Rx) coil affects the *reflected impedance* seen by the primary (Tx) coil.\r\n*   **How it Works:** By quickly switching a component (like a resistor or capacitor) in or out of the Rx circuit, the Rx causes tiny, controlled fluctuations in the reflected impedance at the Tx.\r\n*   **Tx Detection:** The Tx, which is constantly monitoring its own coil current, voltage, or phase, can detect these subtle changes caused by the Rx's load switching. These changes manifest as small variations on the Tx's operating waveforms.\r\n*   **Encoding Data:** The Rx encodes data (like power requests, control packets, or identification signals) by switching the load according to a specific pattern (e.g., turning the load on/off rapidly to represent binary 1s and 0s - On-Off Keying or OOK).\r\n*   **Low Bandwidth:** Because these changes are subtle and the power transfer frequency is relatively low (compared to Wi-Fi), the data rate achievable via load modulation is typically quite low (tens or hundreds of bits per second in standards like Qi).\r\n\r\n**Why is this important for the attacker?** Because this load modulation mechanism is the *same method* we will use to:\r\n1.  Signal our presence (or mimic a legitimate Rx).\r\n2.  Potentially steal power (by presenting a specific load).\r\n3.  *Covertly exfiltrate data* (by intentionally modulating our *own* load in a pattern that encodes information). The Tx is *already designed* to look for these load changes!\r\n\r\n#### 5. Load Modulation: How Changing Rx Load Affects Tx Reflected Impedance\r\n\r\nLet's reiterate this core concept. Imagine the Tx coil as a spring oscillating. When you lightly touch the other end of the spring (representing the Rx with a light load), it only slightly affects the Tx's oscillation. But if you grab the other end firmly (representing the Rx with a heavier load), it significantly dampens or changes the Tx's oscillation.\r\n\r\nIn electrical terms:\r\n*   The impedance of the Rx circuit ($Z_{Rx}$) is transformed through the coupling ($k$) and the coil inductances ($L_1, L_2$) to become a *reflected impedance* ($Z_{reflected}$) that appears in series with the Tx coil impedance ($Z_{Tx}$).\r\n*   A simplified view of the reflected impedance ($Z_{reflected}$) is approximately proportional to $\\frac{k^2 \\omega^2 L_1 L_2}{Z_{Rx}^*}$ (where $k$ is coupling, $\\omega$ is frequency, $L_1, L_2$ are inductances, and $Z_{Rx}^*$ is the complex conjugate of the Rx impedance).\r\n*   This reflected impedance changes the *total* impedance seen by the Tx power source ($Z_{total} = Z_{Tx} + Z_{reflected}$).\r\n*   The Tx's operating voltage, current, and phase are determined by this total impedance.\r\n*   Therefore, by changing $Z_{Rx}$ (via load modulation), the Rx causes a measurable change in $Z_{total}$, which the Tx observes as variations in its own electrical signals.\r\n\r\nThis is the fundamental physical channel we will exploit. We don't need to inject RF signals; we just need to correctly manipulate the load on *our* attacker coil (which acts as an unauthorized receiver).\r\n\r\n#### 6. Types of Load Modulation: Resistive, Capacitive, Inductive\r\n\r\nThe Rx can change its load impedance in several ways:\r\n\r\n*   **Resistive Load Modulation:** This is the most common and often simplest to implement. A resistor is switched in parallel or series with the main load or rectifier output. Switching a resistor changes the *real* part of the Rx impedance. This is often done using a MOSFET acting as a switch controlled by the Rx's microcontroller.\r\n*   **Capacitive Load Modulation:** A capacitor is switched in or out. This changes the *imaginary* (reactive) part of the Rx impedance. This can shift the resonant frequency slightly.\r\n*   **Inductive Load Modulation:** An inductor is switched in or out. Also changes the *imaginary* part of the Rx impedance, but with the opposite sign compared to capacitive modulation.\r\n\r\nFor our initial Proof-of-Concept (PoC) attack, **resistive load modulation** is the easiest to understand and implement, providing a clear signal change at the Tx.\r\n\r\n#### 7. Analyzing the Rx Perspective: How to Intentionally Change the Rx Load Impedance\r\n\r\nFrom an attacker's standpoint using our own hardware (not modifying a legitimate device), we need to build an attacker module that *looks* like a passive WPT receiver but has the capability to *actively control* its load.\r\n\r\nThis means our attacker hardware will need:\r\n*   An Rx coil tuned to the target Tx frequency.\r\n*   A rectifier and filter to get DC power (for potential energy theft and/or powering our own circuitry).\r\n*   A controllable switch (like a MOSFET) connected to a specific load component (like a resistor).\r\n*   A microcontroller to control the switch, turning the load component on and off rapidly according to the data we want to exfiltrate.\r\n\r\nBy switching this load component, we are intentionally performing load modulation, mimicking the legitimate Rx communication method, but for our own malicious purposes.\r\n\r\n### Connecting to the Attack\r\n\r\nThis module is absolutely foundational for both attack vectors:\r\n\r\n*   **Energy Hijacking:** Our attacker device *is* essentially an unauthorized WPT receiver designed specifically for power extraction. Understanding the Rx architecture helps us design an efficient harvesting circuit (Module 6).\r\n*   **Data Exfiltration:** This is where load modulation becomes our covert channel. By understanding how legitimate receivers use load modulation to *send data to the Tx*, we realize we can use the *exact same physical mechanism* to send *our data* (stolen information, attack status, etc.) back to the Tx, where we can then try to observe and decode it (Module 7). The Tx is *already listening* for these load changes!\r\n\r\n### Suggested Resources or Prerequisites:\r\n\r\n*   Module 3 completed (understanding the Tx side of the interaction).\r\n*   Basic understanding of rectification (diodes) and filtering (capacitors) in DC power supplies.\r\n*   Look at datasheets for WPT receiver controller ICs (e.g., from Analog Devices, Texas Instruments, NXP, IDT/Renesas). Even if we don't use these specific chips, their block diagrams and application notes illustrate the standard Rx architecture and how load modulation is implemented for legitimate communication. Search for terms like \"Qi receiver IC datasheet\" or \"wireless power receiver controller\". Pay attention to sections on \"communication\" or \"backscatter modulation\".\r\n\r\n### Module Project/Exercise: Observing Load Change Effects\r\n\r\nAlright, hands-on time! This project directly demonstrates the concept that changing the load on the receiver side has a *measurable effect* on the transmitter side. This is the physical basis for load modulation.\r\n\r\n**Objective:** Build a simple WPT receiver circuit and observe how changing its DC load affects the AC waveform on the transmitter coil.\r\n\r\n**Components Needed:**\r\n\r\n1.  **From Module 3 Project:**\r\n    *   Your basic WPT transmitter circuit (oscillator driving a coil). Power supply for the Tx.\r\n    *   Tx Coil.\r\n    *   Oscilloscope and probes.\r\n2.  **For the Basic Receiver:**\r\n    *   Rx Coil: Needs to be roughly the same size and inductance as your Tx coil, or a standard WPT receiver coil operating at a similar frequency.\r\n    *   Four rectifier diodes: Small signal diodes like 1N4148 *might* work for low power, but 1N400x series (e.g., 1N4001) or Schottky diodes (like 1N5817-1N5819) are better for rectification due to lower voltage drop. Schottky diodes are preferred if available.\r\n    *   Filter Capacitor: Electrolytic capacitor, perhaps 10uF to 100uF, rated for at least the expected peak voltage from the Rx coil (maybe 16V or 25V).\r\n    *   Load Resistors: You'll need a few different values to swap. Let's use:\r\n        *   One relatively low value (e.g., 100 Ohm, 1/4W or 1/2W) - Represents a heavier load.\r\n        *   One relatively high value (e.g., 1 kOhm, 1/4W) - Represents a lighter load.\r\n        *   (Optional) A very high value (e.g., 10 kOhm or infinite - open circuit) - Represents almost no load.\r\n    *   Breadboard and jumper wires.\r\n    *   Multimeter (to measure DC voltage on the Rx).\r\n\r\n**Circuit Diagrams:**\r\n\r\n*   **Transmitter (Tx):** Use the circuit you built in Module 3. Make sure it's working and generating an AC field.\r\n*   **Receiver (Rx):** Build this simple full-wave bridge rectifier and filter on your breadboard:\r\n\r\n    ```\r\n                      +---|>|---+\r\n                      |         |\r\n    (From Rx Coil)  ---|>|--- Load --- +V_DC (to Capacitor + Load Resistor)\r\n    Terminal A ---+             |\r\n                  |             |\r\n                  |             |\r\n                  +---|<|---+   --- -V_DC (usually Ground)\r\n                            |   ^\r\n                            |   |\r\n    Terminal B ---+---------+---|<|---\r\n                  |\r\n    (From Rx Coil)\r\n\r\n    ```\r\n    *   Connect the Rx coil terminals to points A and B.\r\n    *   Connect the positive output (+V_DC) to one leg of the filter capacitor and one leg of your load resistor.\r\n    *   Connect the negative output (-V_DC) to the other leg of the filter capacitor and the other leg of the load resistor.\r\n    *   Ensure the capacitor's polarity is correct if using an electrolytic capacitor (+ to +V_DC, - to -V_DC).\r\n\r\n**Step-by-Step Exercise:**\r\n\r\n1.  **Set up the Tx:** Power up your Module 3 transmitter circuit. Use your oscilloscope to verify it's generating an oscillating voltage/current on its coil. Place an oscilloscope probe safely on the Tx circuit where you can observe the waveform (e.g., across the tuning capacitor, or monitor the current indirectly). **Be careful not to short anything or touch high-voltage points if your Tx circuit involves them.**\r\n2.  **Build the Basic Rx:** Assemble the full-wave rectifier, filter capacitor, and *high-value load resistor (1 kOhm)* on your breadboard according to the diagram.\r\n3.  **Initial Placement:** Place the Rx coil near the Tx coil. Start with them relatively close and aligned (like two coasters stacked). Do *not* connect the Rx to power; it harvests power from the Tx field.\r\n4.  **Observe Rx DC Voltage:** Use your multimeter to measure the DC voltage across the 1 kOhm load resistor (or the filter capacitor). You should see a DC voltage appear, indicating power transfer is happening. Note this voltage.\r\n5.  **Observe Tx Waveform (Light Load):** Look at the waveform on your oscilloscope connected to the Tx circuit. Compare it to the waveform when the Rx coil was *not* present. You should observe *some* change just by introducing the Rx coil (due to coupling), but specifically note the characteristics with the 1 kOhm load attached to the Rx rectifier/filter. Note the amplitude, frequency (should be stable), and overall shape.\r\n6.  **Change the Rx Load (Heavier Load):** Carefully *remove* the 1 kOhm resistor and *insert* the 100 Ohm resistor as the load on the Rx circuit.\r\n7.  **Observe Rx DC Voltage (Heavier Load):** Measure the DC voltage across the 100 Ohm resistor. It might be lower than with the 1 kOhm load because you're drawing more current, potentially pulling down the voltage or exceeding the Tx's capability. Note this voltage.\r\n8.  **Observe Tx Waveform (Heavier Load):** **This is the critical observation.** Look at the waveform on your oscilloscope connected to the Tx circuit again. Compare it to the waveform you saw with the 1 kOhm load. What has changed? You should observe a noticeable difference! The amplitude might drop, the current draw from the Tx power supply will likely increase, and there might be subtle changes in phase or even frequency depending on the Tx design.\r\n9.  **Experiment Further (Optional):**\r\n    *   Try removing the load resistor entirely (open circuit) and observe the Tx waveform. This represents a very light load.\r\n    *   If you have a poteniometer (variable resistor), use it as the load and slowly adjust the resistance while watching the Tx waveform on the oscilloscope. See how the waveform changes smoothly.\r\n10. **Document Your Observations:** Record the measured DC voltages for different loads. Take screenshots or draw sketches of the Tx waveforms for the different load conditions (no Rx, Rx with 1k load, Rx with 100 Ohm load). Describe the differences you observe in the Tx waveform (amplitude changes, shape changes, etc.).\r\n\r\n**Expected Outcome:** You should clearly see that changing the *DC load* on the *receiver side* has a direct and observable impact on the *AC waveform* on the *transmitter side*. This is the physical demonstration of how receiver load changes are \"reflected\" back to the transmitter and why the transmitter can potentially detect them.\r\n\r\n### Review and Conclusion\r\n\r\nIn this module, we've dissected the WPT receiver, understanding its core function of capturing and converting AC power to usable DC. Crucially, we've uncovered the mechanism of **load modulation** – the ingenious way receivers communicate back to the transmitter by intentionally changing their load impedance.\r\n\r\nWe've seen how these load changes physically manifest as detectable variations in the transmitter's electrical signals. This isn't just a detail of WPT design; it's the *doorway* for our data exfiltration attack. By building our own attacker device that can perform controlled load modulation, we can send our own signals back to the Tx, potentially unnoticed among the normal power transfer operations.\r\n\r\nYour project demonstrated this fundamental link. You built a passive Rx, changed its load, and *saw* the effect on the Tx. This is the physical layer interaction we will manipulate.\r\n\r\n**Next Steps:** With this understanding, we are ready to start building our attacker's hardware platform in Module 5. We'll select a microcontroller and the necessary components to not just harvest power passively but to *actively control* our load, preparing for the energy hijacking and data exfiltration implementations in the subsequent modules.\r\n\r\nKeep those coils close and oscilloscopes ready! The hardware build is next."
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Okay, aspiring RF attackers and hardware hackers! Welcome to Module 5. This is where the rubber meets the road – or more accurately, where the copper coil meets the breadboard. We've spent the last few modules understanding the physics, the target (the Tx), and our tool/proxy (the Rx concept, specifically its load modulation capability). Now, we're going to physically build the core platform that will enable both our energy hijacking and data exfiltration attacks.\r\n\r\nThis module is intensely practical. Get ready to select components, wire them up, and write some basic code to make them do our bidding. We're building *our* device, the attacker's proof-of-concept hardware.\r\n\r\n---\r\n\r\n## **Module 5: Building the Attacker's Hardware Platform**\r\n\r\n*   **Module Objective:** Learners will be able to select and integrate hardware components (microcontroller, coils, power handling, modulation circuitry) to build the core platform for the WPT attack device.\r\n\r\n*   **Learning Outcomes:** By the end of this module, you should be able to:\r\n    *   Justify the selection of a suitable microcontroller for this project.\r\n    *   Understand the key parameters for selecting or designing an attacker coil.\r\n    *   Design and assemble a basic power extraction circuit.\r\n    *   Design and assemble a basic load modulation circuit using a switching element.\r\n    *   Integrate these components onto a prototyping board.\r\n    *   Write basic code to control the load modulation circuit.\r\n    *   Use an oscilloscope to verify the functionality of the load modulation circuit.\r\n\r\n---\r\n\r\n### **5.1 Introduction: From Theory to Hardware**\r\n\r\nWe've dissected WPT systems conceptually. We know that changes in the receiver's load impedance are reflected back to the transmitter, altering its observed impedance, voltage, current, or phase. This reflection is *how* legitimate WPT systems often detect a receiver and *how* they communicate (via load modulation).\r\n\r\nOur attacker platform will *mimic* a receiver in specific ways:\r\n1.  It needs a coil to pick up the magnetic field.\r\n2.  It needs circuitry to extract power from that field (for energy hijacking).\r\n3.  It needs circuitry to *intentionally* change its load impedance in a controlled way (for data exfiltration via load modulation).\r\n4.  It needs a brain (a microcontroller) to orchestrate the load modulation and potentially manage power harvesting.\r\n\r\nThis module focuses on selecting and integrating these fundamental building blocks into a single, functional prototype platform. Think of this as building the \"radio\" part of our attack tool.\r\n\r\n### **5.2 Choosing the Microcontroller (The Brains)**\r\n\r\nThe microcontroller (MCU) is the heart of our attacker device. It will control *when* and *how* we modulate the load, potentially read sensors, and in the future, manage harvested power.\r\n\r\n*   **Requirements:**\r\n    *   **Digital I/O:** We need at least one digital output pin to control our load modulation switch. More pins might be useful for status LEDs, debugging, or future expansions (like reading analog values from the Tx field).\r\n    *   **Processing Speed:** For the basic load modulation we'll do initially (simple OOK - On-Off Keying), high speed isn't critical. We're dealing with modulation frequencies likely in the kHz range, well within the capabilities of most MCUs.\r\n    *   **Memory:** Minimal requirements for basic control code.\r\n    *   **Ease of Use:** For a learning environment, a platform with a simple development environment and lots of community support is highly desirable.\r\n    *   **Power Consumption:** Ideally, the MCU should be relatively low power, especially if we aim to power it from harvested energy later.\r\n\r\n*   **Candidate Examples:**\r\n    *   **Arduino Uno (or Nano/Pro Mini):**\r\n        *   *Pros:* Extremely popular, vast community support, simple IDE and programming model (C/C++), 5V or 3.3V operation (depending on board). Plenty of digital I/O.\r\n        *   *Cons:* Relatively slow clock speed compared to newer MCUs, larger physical size (Uno).\r\n        *   *Suitability:* Excellent for getting started, simple prototyping, and understanding the core concepts.\r\n    *   **ESP32 (or ESP8266):**\r\n        *   *Pros:* Much more powerful (faster CPU, more RAM), built-in Wi-Fi and Bluetooth (useful for future data exfiltration methods or remote control), plenty of I/O (including analog), good community support (Arduino IDE compatible). Relatively low cost.\r\n        *   *Cons:* Can be slightly more complex to set up initially than Arduino Uno, 3.3V logic requires level shifting if interfacing with 5V components (though less common now).\r\n        *   *Suitability:* A great choice for a more robust platform, potential for more complex modulation schemes, and integration with other systems.\r\n    *   **STM32 (various boards like 'Blue Pill'):**\r\n        *   *Pros:* Powerful ARM Cortex-M processors, high clock speeds, rich peripherals (timers, ADCs, DACs), low power options.\r\n        *   *Cons:* Can be more complex to program initially (requires setting up toolchains or using CubeIDE), steeper learning curve than Arduino.\r\n        *   *Suitability:* Good for performance-critical applications or when needing specific advanced peripherals.\r\n\r\n*   **Recommendation for this Course:** We will primarily use **Arduino Uno** examples due to its simplicity and accessibility. The concepts and code structure are easily portable to ESP32 or other platforms. If you have an ESP32, feel free to use it – just adjust the pin numbers.\r\n\r\n*   **Step:** Choose your MCU development board based on availability and preference. An Arduino Uno or equivalent is perfectly sufficient for this module's project.\r\n\r\n### **5.3 Designing/Selecting the Attacker Coil (The Antenna)**\r\n\r\nOur attacker coil is the equivalent of a receiver coil in a legitimate WPT system. It needs to efficiently capture the magnetic field energy from the target transmitter.\r\n\r\n*   **Key Considerations:**\r\n    *   **Operating Frequency:** The coil needs to resonate at or near the operating frequency of the target WPT transmitter. Qi standard is typically 100-205 kHz. Other systems might operate at different frequencies (e.g., higher for some resonant systems, MHz for NFC-based power). You need to know or estimate your target's frequency.\r\n    *   **Inductance (L) and Capacitance (C):** The coil's inductance and a parallel tuning capacitor determine its resonant frequency ($f_r = \\frac{1}{2\\pi\\sqrt{LC}}$). You'll need to select an inductance and then add a capacitor to tune it to the target frequency.\r\n    *   **Q Factor:** A higher Q factor means a sharper resonance, which can lead to more efficient energy capture *at* the resonant frequency, but less capture if the frequency is slightly off. For a simple PoC, a moderate Q is fine. Q is affected by wire resistance, core losses (if using a core), and the tuning capacitor's losses.\r\n    *   **Physical Size and Geometry:** The coil's size and shape affect its inductance and how well it couples with the transmitter coil. Larger coils can often capture more flux, but need to fit within the attack scenario. Flat, spiral coils are common for WPT.\r\n    *   **Wire Type:** Litz wire (multiple insulated strands) is often used in WPT coils to reduce AC resistance (skin and proximity effects) at high frequencies, improving Q. Solid core wire works for basic prototyping but might be less efficient.\r\n\r\n*   **Methods for Obtaining an Attacker Coil:**\r\n    1.  **Salvage:** Find old wireless chargers or WPT-enabled devices and desolder their coils. This is often the easiest way to get coils designed for WPT frequencies.\r\n    2.  **Buy Off-the-Shelf:** You can purchase WPT receiver coils designed for specific standards (like Qi) from electronic component suppliers (Digi-Key, Mouser, SparkFun, Adafruit, AliExpress, etc.). Look for coils specified for ~100-200 kHz operation.\r\n    3.  **Wind Your Own:** You can wind your own coil.\r\n        *   *Process:* Get some magnet wire (enameled copper wire, e.g., 24-30 AWG). Find a suitable form (e.g., a 3D printed bobbin, a cardboard tube, or just wind air-core). Wind a specific number of turns.\r\n        *   *Estimating Inductance:* Use online coil inductance calculators (search for \"air core coil inductance calculator\"). The number of turns, coil diameter, and coil length/width are key inputs.\r\n        *   *Tuning:* Once wound, measure its inductance (using an LCR meter or a simple LC resonant circuit with a known capacitor and frequency counter/oscilloscope). Then, calculate the required parallel capacitance to resonate at your target frequency ($C = \\frac{1}{(2\\pi f_r)^2 L}$). Add this capacitor in parallel with the coil.\r\n\r\n*   **Step:** Acquire a WPT receiver coil. Salvaging or buying off-the-shelf Qi receiver coils (~5-20 µH inductance) is recommended for simplicity. If winding your own, aim for an inductance that, when paired with a common capacitor value (e.g., 100nF - 1µF), resonates in the 100-200 kHz range.\r\n\r\n### **5.4 Power Extraction Circuitry (Getting Usable DC)**\r\n\r\nThe AC voltage induced in the attacker coil needs to be converted into a stable DC voltage to potentially power the MCU or, at minimum, to power the load we will switch for modulation.\r\n\r\n*   **Circuit Components:**\r\n    *   **Rectifier:** Converts AC to pulsating DC.\r\n        *   *Option A (Full-Wave Bridge):* Uses 4 diodes. Common, simple. Voltage drop is ~2 * diode drop.\r\n        *   *Option B (Full-Wave with Center-Tap):* Requires a center-tapped coil (less common for off-the-shelf Rx coils) and 2 diodes. Voltage drop is ~1 * diode drop.\r\n        *   *Diode Choice:* **Schottky diodes** are preferred over standard silicon diodes. They have a much lower forward voltage drop (e.g., 0.2-0.4V vs 0.6-1.0V), which is crucial when dealing with potentially low induced voltages from the WPT field. Look for Schottky diodes with low forward voltage and suitable current rating (e.g., 1N5817, 1N5819, or surface mount equivalents).\r\n    *   **Filter Capacitor:** Smooths the pulsating DC output from the rectifier into a more stable DC voltage. A larger capacitor provides better filtering but takes longer to charge. An electrolytic capacitor is typical here (e.g., 10 µF to 100 µF, rated above the expected peak voltage). Place it in parallel with the rectifier output.\r\n    *   **Voltage Regulator:** Provides a stable DC voltage (e.g., 3.3V or 5V) regardless of variations in the harvested power or load.\r\n        *   *Option A (Linear Regulator - LDO):* Simple to use (e.g., LM1117, AMS1117). Requires input voltage to be *higher* than the desired output voltage (dropout voltage). Inefficient if input voltage is much higher than output (dissipates excess power as heat).\r\n        *   *Option B (Switching Regulator - Buck/Boost):* More efficient than linear regulators, can step voltage up or down. More complex circuitry (inductor, switching IC).\r\n        *   *Choice:* An LDO is sufficient and simpler for this basic PoC, assuming the rectified voltage is consistently above the required voltage (e.g., >4V for a 3.3V regulator). If harvested voltage is low and variable, a switching regulator might be needed, but complicates the build.\r\n\r\n*   **Basic Schematic (Rectifier & Filter):**\r\n\r\n    ```\r\n    Attacker Coil (AC)\r\n          +---|>|---+--- Filter Capacitor ---+---> Pulsating DC (+)\r\n          |   D1    |                        |\r\n    ----- L_coil ---- C_tune ---- L_coil -----\r\n          |   D4    |                        |\r\n          +---|<|---+---|>|----+---|<|-------+---> GND (-)\r\n              D3        D2\r\n          (Full-Wave Bridge using Schottky Diodes)\r\n    ```\r\n\r\n    *   *Note:* The tuning capacitor (C_tune) is in parallel with the coil (L_coil). The rectifier bridge (D1-D4) connects across the coil/capacitor parallel combination.\r\n\r\n*   **Adding the Regulator:** Connect the positive pulsating DC output from the filter capacitor to the input of your chosen voltage regulator. Connect the regulator's output to the VCC pin of your MCU and the rest of your circuit. Connect the regulator's ground pin to the circuit's ground.\r\n\r\n*   **Step:** Assemble the rectifier and filter circuit on your breadboard. Use Schottky diodes for the bridge. Add an electrolytic filter capacitor. If you plan to power the MCU from this harvested power *eventually* (not required for *this* module's project, which assumes external MCU power), add a voltage regulator configured for your MCU's operating voltage (e.g., 5V or 3.3V).\r\n\r\n### **5.5 Load Modulation Circuitry (The Attacker's Signal)**\r\n\r\nThis is the core mechanism for data exfiltration. We need to be able to rapidly change the load connected to our attacker coil (or its rectified output) under MCU control. This change in load impedance will reflect back to the Tx.\r\n\r\n*   **Mechanism:** We'll connect a resistive load (or potentially capacitive/inductive, but resistive is simplest) across the rectified DC output of our power extraction circuit. We will use a semiconductor switch, controlled by the MCU, to connect or disconnect this load.\r\n\r\n*   **Switching Element:**\r\n    *   **MOSFET:** An N-channel MOSFET is ideal for switching a load connected to ground. They act like voltage-controlled switches, have very low \"on\" resistance when fully turned on, and can switch quickly.\r\n    *   *How it works:* Apply a voltage (greater than the Gate Threshold Voltage, Vth) between the Gate and Source pins, and the switch turns \"on\" (allowing current to flow between Drain and Source). Apply 0V (or < Vth) to the Gate, and the switch turns \"off\".\r\n    *   *Selection:* Choose a logic-level MOSFET if driving directly from a 3.3V or 5V MCU pin (Gate Threshold Voltage Vth should be low, e.g., < 2V). Ensure its Drain-Source voltage rating ($V_{DS}$) is higher than the peak rectified voltage, and its Drain current rating ($I_D$) is higher than the current the load resistor will draw. Common examples: FQP30N06L (logic-level), BS170 (lower current, not logic-level usually). A small signal MOSFET like the 2N7000 might work for very small loads, but a power MOSFET is generally safer.\r\n\r\n*   **Load Resistor:**\r\n    *   This resistor determines the amount of current drawn when the MOSFET is switched \"on\".\r\n    *   *Value Selection:* The resistance should be low enough to draw a noticeable amount of current from the attacker coil/rectifier when switched on. This current draw needs to be significant enough to cause a detectable change in the reflected impedance at the transmitter. Experimentation is key here. Start with values like 100 Ohms, 50 Ohms, 10 Ohms, or even lower (e.g., 1-5 Ohms) if your rectifier and coil can handle the current. *Be cautious with low resistance values – they draw high current and can generate significant heat in the resistor, MOSFET, and even the rectifier diodes and coil.* Start high and go lower.\r\n    *   *Power Rating:* The resistor needs to handle the power dissipated ($P = V^2/R$, where V is the rectified voltage). Use a resistor with a sufficient wattage rating (e.g., 0.25W, 0.5W, 1W+).\r\n\r\n*   **Basic Schematic (Load Modulation):**\r\n\r\n    ```\r\n    Rectified DC (+) ---+--- Load Resistor ---+--- MOSFET Drain\r\n                        |                       |\r\n    Filter Capacitor ---+                       |\r\n                                                |\r\n    Rectified DC (-) ---+-----------------------+--- MOSFET Source\r\n                        |\r\n                       GND\r\n\r\n    MCU Digital Output --- Gate Resistor (e.g., 1k-10k Ohm) --- MOSFET Gate\r\n    ```\r\n\r\n    *   *Gate Resistor:* A small resistor (e.g., 1k to 10k Ohm) is often placed in series with the MOSFET gate to limit current drawn from the MCU pin when charging the gate capacitance. It's good practice.\r\n\r\n*   **Step:** Assemble the load modulation circuit on your breadboard. Connect the MOSFET (Source to ground, Drain to the load resistor). Connect one leg of the load resistor to the positive output of your rectifier/filter circuit. Add a gate resistor between your chosen MCU digital output pin and the MOSFET's Gate pin.\r\n\r\n### **5.6 Powering the Attacker Device**\r\n\r\nFor this module's project, we will **power the microcontroller externally**. This simplifies testing the load modulation circuit independently of the energy harvesting efficiency.\r\n\r\n*   **External Power:** Connect the MCU development board to your computer via USB, or use a separate 5V/3.3V power supply.\r\n\r\n*   **Future Self-Harvesting (Goal for later modules):** In later modules, we might explore using the harvested power from the WPT field to *power the MCU itself*. This requires careful design to ensure enough power is available and might involve a power management IC or supercapacitor/battery to handle variations. For now, keep it simple with external power for the MCU.\r\n\r\n### **5.7 Integration and Prototyping (Putting it on the Breadboard)**\r\n\r\nNow, combine the pieces you've designed onto a single breadboard.\r\n\r\n*   **Components Needed for Module 5 Project:**\r\n    *   Microcontroller Development Board (e.g., Arduino Uno)\r\n    *   WPT Receiver Coil (salvaged or purchased)\r\n    *   Small tuning capacitor for the coil (value depends on coil inductance and target frequency - estimate or measure!)\r\n    *   4 x Schottky Diodes (e.g., 1N5817)\r\n    *   1 x Electrolytic Filter Capacitor (e.g., 47 µF - 100 µF, 16V+)\r\n    *   1 x N-channel Logic-Level MOSFET (e.g., FQP30N06L or similar low Vth)\r\n    *   1 x Load Resistor (e.g., 10-100 Ohms, 0.5W+) - *Start with a higher value like 100 Ohm and work down if needed.*\r\n    *   1 x Gate Resistor (e.g., 1k - 10k Ohm, 0.25W)\r\n    *   Breadboard\r\n    *   Jumper Wires\r\n    *   USB Cable (for powering/programming MCU)\r\n\r\n*   **Assembly Steps (Detailed):**\r\n\r\n    1.  **Place the MCU:** Put your Arduino Uno (or other board) on the breadboard. Note which pins are digital I/O, GND, and 5V/3.3V.\r\n    2.  **Create Power Rails:** Use jumper wires to connect the 5V (or 3.3V) pin on the Arduino to the positive rail of the breadboard, and the GND pin to the negative (GND) rail.\r\n    3.  **Connect Attacker Coil & Tuning Cap:** Place your WPT coil on the breadboard (or connect it via wires if it's off-board). Connect the tuning capacitor in parallel with the coil leads. *Ensure the capacitor is rated for AC voltage if placed directly across the coil, or use non-polarized ceramic/film caps. If placed after a diode, use polarized electrolytic, observing polarity.* For simplicity, place the tuning cap *directly* across the coil leads.\r\n    4.  **Assemble the Rectifier Bridge:** Arrange the 4 Schottky diodes to form a full-wave bridge rectifier. Pay close attention to the diode band (cathode) direction. The two AC input points connect to the coil/capacitor. One output point is the positive DC (+), the other is the negative DC (-).\r\n        *   *Visual Aid:* Search online for \"diode bridge rectifier breadboard layout\".\r\n    5.  **Add the Filter Capacitor:** Connect the positive lead of the electrolytic capacitor to the positive DC output of the rectifier, and the negative lead to the negative DC output (GND). *Double-check polarity!*\r\n    6.  **Place the MOSFET:** Insert the MOSFET into the breadboard. Identify its pins (Gate, Drain, Source - check the datasheet!). Connect the Source pin to the GND rail.\r\n    7.  **Connect the Load Resistor:** Connect one leg of the load resistor to the positive DC output of the rectifier/filter circuit. Connect the other leg of the load resistor to the Drain pin of the MOSFET.\r\n    8.  **Connect the Gate Resistor:** Connect one leg of the gate resistor to a chosen digital output pin on your MCU (e.g., pin 8). Connect the other leg of the gate resistor to the Gate pin of the MOSFET.\r\n    9.  **Review Connections:** Carefully check all connections against your schematic or the steps above. Pay special attention to diode and capacitor polarity, and MOSFET pinout.\r\n\r\n*   **Schematic of the Integrated Platform (Conceptual):**\r\n\r\n    ```\r\n    [Arduino Uno]\r\n    (Digital Pin X) --[Gate Resistor]--|>|-- (MOSFET Gate)\r\n                                            /\r\n    (5V/3.3V) ----> +V Rail ----------->\r\n                                        |\r\n    (GND) -------> GND Rail ---------> MOSFET Source\r\n                                        |\r\n    [Attacker Coil] --[Tuning Cap]--[Rectifier]--[Filter Cap]--+--[Load Resistor]-- MOSFET Drain\r\n                                                              |\r\n                                                              +-- To +V Rail (if powering circuits from harvested power - NOT for this module's project)\r\n                                                              |\r\n                                                              +-- To MCU V_in/VIN (if powering MCU from harvested power - NOT for this module's project)\r\n    ```\r\n    *   *Note:* For this module's project, the \"+V Rail\" powering the MCU comes *directly* from the Arduino's USB/VIN power, *not* from the harvested power circuit. The harvested power circuit (coil, rectifier, filter) only provides voltage to the load resistor/MOSFET part.\r\n\r\n### **5.8 Basic Measurement Setup**\r\n\r\nBefore writing code, understand how you will verify the circuit is working.\r\n\r\n*   **Tools:** An oscilloscope is essential. A multimeter is also useful for checking basic continuity and DC voltages.\r\n\r\n*   **What to Measure (for this module):**\r\n    1.  **MCU Digital Output:** Connect an oscilloscope probe to the digital pin controlling the MOSFET gate (after the gate resistor is fine, or directly on the MOSFET gate pin). You should see a clear 0V to VCC (5V or 3.3V) square wave when the pin is toggled. This verifies your MCU code is running and controlling the pin.\r\n    2.  **Voltage Across the Switched Load:** Connect an oscilloscope probe across the load resistor (between the connection point with the filter capacitor positive and the MOSFET Drain). The ground clip of the probe should be connected to the circuit's GND rail (MOSFET Source). When the MOSFET is off, you should see the rectified/filtered DC voltage (voltage across the filter cap). When the MOSFET is on, the voltage across the resistor should drop significantly (close to 0V if the MOSFET is ideal and the load is connected directly to ground). This verifies that the MOSFET is switching the load.\r\n\r\n*   **Safety Note:** When working with WPT systems, be mindful of the power levels. Low-power Qi chargers (5W) are relatively safe, but higher power systems (fast chargers, EV chargers) can be dangerous. For these initial tests, you will interact with the *attacker's* circuit, which operates on the voltage induced in *your* coil. This voltage will depend on the Tx power and coupling, but for a basic PoC with a phone charger, it should be low voltage. *Always exercise caution and understand the power sources involved.* Do NOT directly probe the primary (Tx) side of a mains-powered WPT system without proper isolation and knowledge.\r\n\r\n### **5.9 Putting it Together: Module 5 Project**\r\n\r\n**Project Objective:** Build the core attacker hardware platform on a breadboard and program the MCU to toggle the load modulation MOSFET. Verify the digital output signal and the switched voltage across the load resistor using an oscilloscope.\r\n\r\n**Required Materials:**\r\n*   All components listed in section 5.7.\r\n*   Assembled breadboard circuit as described in section 5.7.\r\n*   Computer with Arduino IDE installed.\r\n*   USB cable for Arduino.\r\n*   Oscilloscope and probes.\r\n*   A target WPT transmitter (like a standard Qi wireless phone charger pad). *You will place your attacker coil near this Tx for the final verification step, but the MCU is powered externally.*\r\n\r\n**Step-by-Step Project Instructions:**\r\n\r\n1.  **Assemble the Hardware:** Follow the detailed assembly steps in section 5.7 to build the complete circuit on your breadboard. Double-check all connections, component polarities (diodes, electrolytic cap), and MOSFET pinout.\r\n2.  **Connect MCU:** Connect your Arduino Uno to your computer via the USB cable. This will power the Arduino.\r\n3.  **Open Arduino IDE:** Start the Arduino IDE software.\r\n4.  **Write the Code:** Enter the following basic code into the IDE. This code will simply toggle the digital pin connected to your MOSFET's gate, turning the MOSFET and thus the load resistor on and off periodically."
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Okay, SME hat on, teacher mode engaged! This is where the rubber meets the road – taking the theoretical understanding of reflected power and turning it into a physical reality to steal energy. This is a classic \"side-channel\" attack, but instead of leaking data, we're leaking *power*. Let's build this thing, step-by-step.\r\n\r\n---\r\n\r\n## **Module 6: Attack Vector 1: Energy Hijacking Implementation**\r\n\r\n**Welcome back, future RF hackers!** In Module 5, you built the basic hardware platform – your attacker device's brain (the MCU) and the potential to switch loads. Now, we're giving it a purpose: unauthorized energy harvesting. This is the first of our two primary attack vectors. We'll leverage the physics we discussed in Modules 2 and 4 – specifically, how placing a resonant receiver coil within the Tx field draws energy, and how this changes the Tx's operating point (its \"reflected power signature\").\r\n\r\n**Module Objective:** By the end of this module, you will be able to:\r\n*   Design and assemble a basic energy harvesting circuit optimized for a specific WPT frequency.\r\n*   Integrate this circuit with your attacker platform.\r\n*   Experimentally determine optimal coil placement for energy harvesting.\r\n*   Measure the amount of power harvested by your device.\r\n*   Observe and quantify the effect of your attacker device on the target WPT transmitter's power draw or signal characteristics.\r\n*   Demonstrate energy hijacking by powering a simple load (like an LED) using the harvested energy.\r\n\r\n**Let's Get Started!**\r\n\r\n### **6.1 Designing the Energy Harvesting Circuit**\r\n\r\nThe goal here is simple: capture the oscillating magnetic field energy with our attacker coil and convert it into usable DC voltage to power something.\r\n\r\n*   **Components Review:**\r\n    *   **Attacker Coil:** You selected/designed this in Module 5. Its inductance (L) and self-capacitance, or added parallel capacitance (C), should ideally resonate near the target WPT transmitter's operating frequency (e.g., 100-200 kHz for low-frequency Qi, 6.78 MHz or 13.56 MHz for resonant systems). Resonance is key to efficiently capturing energy!\r\n    *   **Rectifier:** The coil produces AC voltage. We need DC to power most electronics. A bridge rectifier is common, using four diodes to convert both halves of the AC cycle into pulsating DC. For low-voltage WPT, use Schottky diodes if possible – they have a lower forward voltage drop (0.2-0.3V vs 0.7V for silicon), meaning less energy is wasted as heat in the diodes.\r\n    *   **Filter Capacitor:** The output of the rectifier is pulsating DC. A capacitor in parallel smooths this out into a more stable DC voltage. The capacitor charges up during the peaks of the rectified voltage and discharges slightly between peaks. A larger capacitance value provides better filtering but takes longer to charge.\r\n    *   **Voltage Regulator (Optional but Recommended):** The DC voltage from the filter capacitor will vary depending on the coupling, the Tx power, and the load. To provide a stable voltage for your MCU or a specific load (like a 5V LED strip or a 3.3V MCU), a voltage regulator is necessary. Simple Linear Dropout (LDO) regulators are easy to use (e.g., LM1117, AMS1117), but inefficient (they burn excess voltage as heat). Switching regulators (Buck/Boost converters) are more efficient but more complex. For a simple PoC powering an LED, you might skip the regulator or use a simple Zener diode setup, but for powering the MCU reliably, a regulator is best.\r\n\r\n*   **Circuit Diagram Concept:**\r\n\r\n    ```\r\n    Attacker Coil (L) --+----|>|----+---- +V_rectified\r\n                      |    |       |\r\n                      |    |<|----|\r\n                      |    |       |\r\n                      +----|<|----+---- Filter Cap (C_filter) -- Regulator (Optional) -- +V_out (to load/MCU)\r\n                           |    |\r\n                           |    |>|\r\n                           |    |\r\n                           +----+---- 0V (Ground)\r\n    ```\r\n    *(Note: This is a simplified representation. A full bridge rectifier has 4 diodes arranged in a diamond shape).*\r\n\r\n*   **Optimization Considerations:**\r\n    *   **Resonance:** Ensure your attacker coil + parallel capacitor resonates near the target Tx frequency. You can calculate this using `f = 1 / (2 * pi * sqrt(L * C))`. You might need to experiment with capacitor values or use an LC meter/VNA if you have access.\r\n    *   **Diode Selection:** Use low forward voltage diodes (Schottky) for maximum efficiency.\r\n    *   **Capacitor Sizing:** A value in the range of 10uF to 100uF is often sufficient for filtering in basic WPT harvesting circuits at typical frequencies.\r\n    *   **Regulator Choice:** If powering the MCU, ensure the regulator can handle the maximum rectified voltage and provide the required stable voltage and current for the MCU.\r\n\r\n### **6.2 Coil Placement and Coupling: Finding the Sweet Spot**\r\n\r\nUnlike a legitimate receiver designed to sit squarely on a charging pad, your attacker coil needs to intercept the field *from a distance* or *at an angle* where a legitimate receiver might not be. The strength of the captured power depends heavily on the coupling coefficient (k) between the Tx coil and your attacker coil.\r\n\r\n*   **Factors Affecting Coupling:**\r\n    *   **Distance:** Coupling decreases rapidly with distance. Near-field WPT is very short-range.\r\n    *   **Alignment:** Coils are most strongly coupled when their axes are aligned and they are close. However, you might find optimal harvesting slightly off-axis depending on the Tx field pattern.\r\n    *   **Orientation:** The relative orientation of the coils matters.\r\n    *   **Presence of other objects:** Metal objects can disrupt the field. The legitimate receiver itself will alter the field.\r\n\r\n*   **Practical Experimentation:**\r\n    *   Power up your target WPT transmitter (e.g., a standard Qi charger).\r\n    *   Connect your energy harvesting circuit *with a simple indicator load* (like a low-current LED and resistor, or a multimeter set to measure DC voltage) to the output of the filter capacitor or regulator.\r\n    *   Slowly move your attacker coil around the Tx coil.\r\n    *   Observe the indicator (LED brightness or multimeter reading).\r\n    *   Mentally (or physically, mark it) note the positions and orientations where the indicator is strongest. This is where coupling is highest, and you're harvesting the most energy.\r\n    *   *Important:* Note that the optimal position for *harvesting* might be different from the optimal position for *modulating* data later (Module 7), or the optimal position for *stealth*. For this module, focus on maximizing harvested power.\r\n\r\n### **6.3 Stealth Considerations (Or Lack Thereof for PoC V1)**\r\n\r\nA legitimate WPT system is designed to detect when a compliant receiver is present and adjust its power output accordingly. It also often monitors the reflected impedance to ensure the receiver isn't faulty or drawing too much power unexpectedly, which could be a safety hazard or damage the Tx.\r\n\r\n*   **How the Tx Detects You (Potentially):**\r\n    *   **Load Detection:** When you place your coil and start drawing power, you change the overall load impedance seen by the Tx. This is the primary mechanism the Tx uses to detect *any* receiver.\r\n    *   **Specific Protocol Handshake:** Legitimate receivers often perform a digital handshake (e.g., Qi communication packets sent via load modulation) before the Tx provides full power. Your simple harvesting circuit doesn't do this.\r\n    *   **Overcurrent/Overpower Protection:** If you suddenly draw a significant amount of power, the Tx might detect an overcurrent condition and shut down.\r\n    *   **Frequency/Phase Shifts:** Drawing power changes the effective impedance, which can slightly detune the Tx resonant circuit, causing shifts in frequency or phase that the Tx controller might detect.\r\n\r\n*   **Stealth in PoC V1:** For this initial energy hijacking PoC, *we are not aiming for stealth*. The objective is to *demonstrate* the ability to harvest power and *observe* the effect on the Tx. Achieving true stealth is a much more advanced topic requiring detailed knowledge of the target protocol and sophisticated load manipulation. In this module, success is drawing power and seeing the Tx react, even if it throws an error.\r\n\r\n### **6.4 Measurement of Harvested Power**\r\n\r\nQuantifying what you've stolen is crucial for the demonstration.\r\n\r\n*   **What to Measure:**\r\n    *   **DC Voltage:** The stable DC voltage available after the filter capacitor or regulator.\r\n    *   **DC Current:** The amount of current drawn by your load from the harvesting circuit.\r\n\r\n*   **Tools:**\r\n    *   **Multimeter:** The simplest tool. Measure DC Voltage across the output terminals. To measure current, place the multimeter in series with your load (set to DC Amps).\r\n    *   **Current Sensor Module (e.g., INA219):** For integrating measurement into your MCU platform, modules like the INA219 (I2C interface) can measure voltage and current with reasonable accuracy.\r\n    *   **Dedicated USB Power Meter:** If your load is a USB device or battery charger, a simple inline USB power meter can show voltage, current, and even accumulated energy (mAh/Wh).\r\n\r\n*   **Calculation:** Once you have voltage (V) and current (I), the harvested power (P) is simply:\r\n    `P = V * I` (in Watts)\r\n\r\n*   **Procedure:**\r\n    1.  Set up your Tx and attacker coil in the position you found to be optimal for harvesting.\r\n    2.  Connect your harvesting circuit output to your chosen load (e.g., LED, small fan, or just a power resistor).\r\n    3.  Use your multimeter or sensor to measure the DC voltage *across* the load and the DC current *flowing through* the load.\r\n    4.  Calculate the power.\r\n    5.  Repeat measurements at slightly different positions/orientations to confirm your \"optimal\" spot yielded the most power.\r\n\r\n### **6.5 Observing the Tx Response**\r\n\r\nThis is critical evidence that your attacker device is *interacting* with the WPT system. You need to show that the Tx behaves differently when your device is present and harvesting.\r\n\r\n*   **What to Observe:**\r\n    *   **Tx Input Current:** This is often the easiest and safest parameter to measure. When the Tx delivers more power (to a legitimate or illegitimate receiver), its input current from the wall adapter or power supply will increase.\r\n    *   **Tx Input Voltage:** Usually stable, but might dip slightly under heavy load.\r\n    *   **Tx Coil Voltage/Current Waveforms:** Using an oscilloscope, you can look at the AC voltage across or current through the Tx coil. When a load is coupled, the amplitude might drop, the frequency might shift slightly, or the phase relationship between voltage and current might change.\r\n    *   **Tx Indicator LEDs/Display:** Some chargers have LEDs indicating charging status or errors. Note how they change.\r\n    *   **Tx Audible Noise:** Some chargers make noise, which can change under load.\r\n\r\n*   **Tools:**\r\n    *   **AC Clamp Meter:** Safest way to measure AC input current without breaking the circuit. Ensure it's rated for the expected current and frequency (standard clamp meters are for 50/60 Hz, you might need a specialized one for higher frequency Tx waveforms, though input current is usually low frequency).\r\n    *   **Multimeter (for input current):** *Requires breaking the circuit!* **Only attempt this if you are comfortable and confident working with AC mains voltage, or if the Tx is low-voltage DC powered.** Place the multimeter (set to AC Amps) in series with the Tx's power input. **THIS CAN BE EXTREMELY DANGEROUS WITH MAINS VOLTAGE.**\r\n    *   **Oscilloscope:** Connect probes carefully to the Tx coil or related circuitry. **Again, be extremely cautious with potentially high voltages on the Tx coil.** Look for accessible, lower-voltage test points if available.\r\n    *   **Camera/Phone:** To record Tx indicator changes or oscilloscope screen captures.\r\n\r\n*   **Procedure:**\r\n    1.  Set up the target WPT transmitter as it would normally operate (e.g., plugged in).\r\n    2.  Measure/Observe the chosen parameter (e.g., Tx input current) *without* your attacker device present. Record this baseline value.\r\n    3.  Place your attacker coil in the optimal harvesting position.\r\n    4.  Measure/Observe the same Tx parameter *with* your attacker device harvesting power. Record this value.\r\n    5.  Compare the values. Document the change.\r\n    6.  *Optional:* If you have a legitimate WPT receiver, place it on the Tx and observe the parameter. Compare the effect of your attacker vs. a legitimate receiver.\r\n\r\n*   **Safety First!** Working with power electronics, especially mains-powered devices, carries significant risk. **Always be aware of live voltages.** If you are not comfortable probing a powered Tx circuit, focus on measuring the Tx *input current* using a clamp meter or by measuring the current drawn from a *low-voltage* DC power supply if your Tx uses one. **Never open or probe mains-powered devices unless you are qualified and take appropriate safety precautions.**\r\n\r\n### **6.6 Proof-of-Concept Demonstration**\r\n\r\nBringing it all together! The visible proof that you are successfully hijacking energy.\r\n\r\n*   **Simple Loads:**\r\n    *   **LED:** Easiest. Connect one or more LEDs (with appropriate current-limiting resistors) to the output of your harvesting circuit (after the regulator if used, or directly from the filtered DC). The LED lighting up when the attacker coil is near the Tx is a clear visual demonstration.\r\n    *   **Small Fan/Motor:** Another visual/audible indicator.\r\n    *   **Small Battery Charger:** Use the harvested power to charge a small battery (e.g., a tiny LiPo for a drone or IoT device) via a suitable charging IC (like TP4056 for LiPo). This demonstrates storing the stolen energy.\r\n    *   **Powering the MCU:** If your harvesting circuit provides enough stable voltage/current, you can use it to power your MCU directly. The MCU running code (e.g., blinking its own LED) becomes the demonstration of harvested energy.\r\n\r\n*   **Demonstration Setup:**\r\n    1.  Have the target WPT transmitter visible and powered.\r\n    2.  Have your attacker device ready, with the harvesting circuit connected to your chosen simple load.\r\n    3.  Show the load is off when the attacker coil is away from the Tx.\r\n    4.  Bring the attacker coil near the Tx.\r\n    5.  Show the load activating (LED lights up, fan spins, MCU powers on and runs code).\r\n    6.  *Optional:* Show the Tx input current change or Tx indicator change simultaneously if you have the setup for it.\r\n\r\n### **Module Project/Exercise: Implementing and Demonstrating Energy Hijacking**\r\n\r\nAlright, let's build and test!\r\n\r\n**Goal:** Integrate the energy harvesting circuit, find optimal placement, measure harvested power, observe Tx response, and demonstrate power theft using a simple load.\r\n\r\n**Materials Needed:**\r\n*   Completed attacker hardware platform from Module 5 (MCU, prototyping board).\r\n*   Attacker coil (from Module 5).\r\n*   Rectifier diodes (Schottky recommended, e.g., 1N5817, 1N5819). You'll need 4 for a bridge rectifier.\r\n*   Filter capacitor (e.g., 47uF - 100uF electrolytic, rated for voltage higher than expected peak AC).\r\n*   Optional: Voltage regulator (e.g., AMS1117-3.3 or -5.0) and associated capacitors (check datasheet).\r\n*   Simple load: LED(s) with appropriate current-limiting resistor(s), or a small buzzer, or a small DC motor, or a small battery charging module + battery.\r\n*   Multimeter (for measuring DC voltage/current).\r\n*   Optional: AC clamp meter or means to safely measure Tx input current.\r\n*   Optional: Oscilloscope (to observe Tx waveforms).\r\n*   Target WPT transmitter (e.g., a standard Qi charger).\r\n*   Jumper wires, breadboard or perfboard.\r\n\r\n**Step-by-Step Instructions:**\r\n\r\n1.  **Assemble the Energy Harvesting Circuit:**\r\n    *   Build the bridge rectifier using the four diodes. Pay close attention to the polarity (the line on the diode indicates the cathode). The AC inputs come from the coil, and the DC output has positive and negative terminals. *Refer to online diagrams for a diode bridge if needed.*\r\n    *   Connect the attacker coil to the AC input terminals of the bridge rectifier.\r\n    *   Connect the filter capacitor across the DC output terminals of the bridge rectifier. Ensure correct polarity for electrolytic capacitors (+ to +, - to -).\r\n    *   *If using a voltage regulator:* Connect the output of the filter capacitor to the input of the voltage regulator. Add any required input/output capacitors as per the regulator's datasheet. The regulated output is your final +V_out.\r\n    *   *If not using a regulator:* The output of the filter capacitor is your +V_out. Add a simple current-limiting resistor and LED here for initial testing.\r\n\r\n2.  **Initial Harvesting Test:**\r\n    *   Connect a simple indicator (like an LED with a resistor, or just your multimeter set to DC Volts) to the output of your harvesting circuit (+V_out and Ground).\r\n    *   Power up your target WPT transmitter.\r\n    *   Carefully bring your attacker coil near the Tx coil.\r\n    *   Observe the LED lighting up or the voltage reading appearing on the multimeter. If nothing happens, check your wiring, diode polarity, and coil placement. Ensure the Tx is actually transmitting (some require a legitimate receiver handshake first – if so, you might need to place a legitimate receiver briefly to activate it, then swap quickly, or find a Tx that broadcasts continuously).\r\n\r\n3.  **Integrate with Attacker Platform / Final Load:**\r\n    *   Decide how you will demonstrate power harvesting for the final project.\r\n    *   *Option A (Powering MCU):* If your harvested voltage is stable and sufficient (e.g., >3.5V for a 3.3V regulator), connect the output of your harvesting circuit (after regulation) to the appropriate power input pins of your MCU development board. Remove any other power source (like USB). If the MCU powers on and runs a simple \"heartbeat\" sketch (like blinking an onboard LED), you've successfully powered it via WPT harvesting.\r\n    *   *Option B (Powering Separate Load):* Connect your chosen simple load (LED, fan, etc.) to the output of your harvesting circuit. Ensure appropriate current limiting for LEDs/motors.\r\n\r\n4.  **Find Optimal Coil Placement:**\r\n    *   With your harvesting circuit connected to your chosen load/indicator, power up the Tx.\r\n    *   Slowly move your attacker coil around the Tx coil, varying distance, alignment, and orientation.\r\n    *   Observe the load's performance (LED brightness, fan speed, MCU activity) or the voltage reading on a multimeter connected across the load.\r\n    *   Identify and document the position and orientation where you achieve the maximum performance/voltage. This is your optimal harvesting spot.\r\n\r\n5.  **Measure Harvested Power:**\r\n    *   Place the attacker coil in the optimal position found in Step 4.\r\n    *   Use your multimeter to measure the DC voltage across your load and the DC current flowing through your load.\r\n    *   Calculate the harvested power (Watts = Volts * Amps).\r\n    *   Record this value.\r\n\r\n6.  **Observe and Document Tx Response:**\r\n    *   Set up your measurement of the Tx parameter (e.g., input current).\r\n    *   Measure the Tx parameter *without* the attacker coil present. Record the baseline.\r\n    *   Place the attacker coil in the optimal harvesting position.\r\n    *   Measure the Tx parameter *with* the attacker coil harvesting power. Record the new value.\r\n    *   Calculate the *change* in the Tx parameter.\r\n    *   *If using an oscilloscope:* Capture the Tx coil waveform with and without the attacker present and save the images for comparison.\r\n    *   Document your observations (e.g., \"Tx input current increased by 50mA,\" \"Tx status LED changed from Green to Orange,\" \"Tx coil voltage amplitude dropped by 10%\").\r\n\r\n7.  **Prepare Your Demonstration:**\r\n    *   Get your setup ready to show someone (or record a video): Tx, attacker device with harvesting circuit and load, and optionally your Tx observation setup (multimeter, oscilloscope).\r\n    *   Practice the sequence: Show Tx idle -> Place attacker coil -> Show load activating -> Show Tx response (if possible).\r\n\r\n8.  **Document Your Results:**\r\n    *   Write a brief report or create a presentation documenting:\r\n        *   Your energy harvesting circuit design (schematic or description).\r\n        *   The components used.\r\n        *   Your process for finding the optimal coil placement.\r\n        *   The maximum harvested voltage, current, and calculated power.\r\n        *   Your observations of the Tx response (baseline vs. with attacker, include measurements/images).\r\n        *   A description of your power hijacking demonstration.\r\n        *   Any challenges encountered and how you overcame them.\r\n\r\n**Code Examples (Minimal for this module):**\r\n\r\nAs noted, code isn't the focus here, hardware is. If you are using the harvested energy to power your MCU (Option A in Step 3), the code is simply whatever sketch you want to run to prove the MCU is alive. A basic LED blink sketch is perfect.\r\n\r\n```cpp\r\n// Simple Arduino sketch to prove the MCU is powered and running\r\n// If powered by harvested energy, the blinking demonstrates successful harvesting\r\n\r\nconst int ledPin = LED_BUILTIN; // Use the built-in LED on your board\r\n\r\nvoid setup() {\r\n  // Initialize the LED pin as an output\r\n  pinMode(ledPin, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n  // Turn the LED on\r\n  digitalWrite(ledPin, HIGH);\r\n  delay(500); // Wait for 500 milliseconds\r\n\r\n  // Turn the LED off\r\n  digitalWrite(ledPin, LOW);\r\n  delay(500); // Wait for 500 milliseconds\r\n}\r\n```\r\n*Upload this sketch to your MCU *before* attempting to power it via harvesting. Then, remove the USB cable and connect the harvesting circuit output to the MCU's power input. If the LED starts blinking, you've succeeded in powering it wirelessly!*\r\n\r\nIf you are using the MCU to *monitor* something (like the INA219 sensor), you would add the necessary I2C code, but that's beyond the core requirement of *demonstrating* harvesting. For this module, focus on the analog/power side.\r\n\r\n### **Summary & What's Next**\r\n\r\nYou did it! You've built a device capable of performing unauthorized energy harvesting from a WPT field. You've quantified the power you can steal and, importantly, you've gathered evidence that the target Tx *reacts* to your presence, confirming the interaction at the physical layer.\r\n\r\nThis understanding of how your device's load affects the transmitter is not just for stealing power; it's the fundamental principle we will exploit for the second attack vector: covert data exfiltration. In the next module (Module 7), we will modify our attacker platform to *intentionally* manipulate its load in a controlled way to send information back to the Tx, turning the WPT field into a covert communication channel.\r\n\r\nGet your oscilloscope ready, because things are about to get modulated!\r\n\r\n---\r\n**Remember to document your work thoroughly and practice safety in your lab!** Sharing your findings (responsibly) is key to advancing security knowledge."
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Okay, class! Welcome back. We've laid the groundwork, understood the physics of reflected power, poked around the Tx and Rx, and even built our basic attacker platform and siphoned off some free energy. Now, things get really interesting – and a little bit stealthy.\r\n\r\nIn Module 6, we built a device that draws power. That's one attack vector: energy theft. But what if we want to steal *data*? Not data transmitted over the *data* channel (like the Qi communication protocol), but data encoded *within the power transfer itself*?\r\n\r\nThat's the goal of Module 7. We're going to turn our energy harvesting coil into a covert communication device, sending information back to anyone monitoring the power source by subtly manipulating the load, and thus, the reflected power signature. Think of it as whispering secrets back through the power cord. Spooky, right? Let's dive in.\r\n\r\n---\r\n\r\n## **Module 7: Attack Vector 2: Covert Data Exfiltration Implementation**\r\n\r\n*   **Module Objective:** Learners will be able to design, build, and demonstrate a device that can encode small amounts of data by modulating its load impedance and understand how this modulation can be observed as changes in the reflected power signature at the transmitter.\r\n\r\n### **7.1 Revisiting Load Modulation as a Communication Channel**\r\n\r\nRemember in Module 4 when we discussed how legitimate WPT receivers communicate with the transmitter? A primary method, especially in standards like Qi, is **backscatter modulation**, which is fundamentally **load modulation**.\r\n\r\n*   **How it works (Legitimate):** The receiver intentionally changes its load impedance (often by switching a small resistance or capacitance on/off). This change in load impedance on the secondary (Rx) coil is \"reflected\" back to the primary (Tx) coil.\r\n*   **How it's detected (Legitimate):** The transmitter continuously monitors its own state – things like the current drawn from the power supply, the voltage/current/phase relationship across its Tx coil, or the voltage across tuning capacitors. When the receiver modulates its load, these parameters on the Tx side change ever so slightly, following the pattern of the receiver's modulation. The Tx circuitry is designed to detect these subtle changes, demodulate them, and interpret them as control signals or data from the receiver (e.g., \"I'm here\", \"I need more power\", \"My battery is full\").\r\n*   **Our Attack:** We are *not* a legitimate receiver. We don't care about the WPT protocol's defined communication. We are simply placing our attacker coil (our unauthorized Rx) in the field. By building a circuit that *intentionally* changes the load on *our* attacker coil, we can cause *similar* changes in the reflected power signature at the Tx. If we control *when* and *how* we change our load, we can encode our *own* data onto the Tx's observable signals.\r\n\r\nThis is a physical layer attack. We aren't breaking encryption or injecting packets into a digital stream. We are manipulating the fundamental physics of the power transfer to create a side channel.\r\n\r\n### **7.2 Designing the Load Modulation Scheme**\r\n\r\nOkay, we know we need to change our load. How do we encode data using this?\r\n\r\n*   **Simplest Approach: On-Off Keying (OOK):** The easiest way to modulate is to simply switch a load on and off.\r\n    *   Load ON = Represents a digital '1' (or '0', you decide).\r\n    *   Load OFF = Represents a digital '0' (or '1').\r\n*   **What Load?** A resistor is the simplest. When connected across the rectified output of our attacker coil, it draws current. When disconnected, it doesn't.\r\n*   **Modulation Depth:** This refers to *how much* the load changes.\r\n    *   A large change (switching a very low resistance) creates a strong, easily detectable signal at the Tx. However, it's also more likely to disrupt the Tx's operation, potentially triggering error detection or protection mechanisms (like the Tx shutting down), making the attack less covert.\r\n    *   A small change (switching a higher resistance) is stealthier but much harder to detect and decode at the Tx side.\r\n    *   The optimal modulation depth depends heavily on the specific WPT transmitter being targeted. You'll need to experiment.\r\n*   **Data Rate:** How fast can we switch the load?\r\n    *   Limited by the WPT system's bandwidth and the Tx's control loop response time. The Tx needs time to \"see\" and react to the load change.\r\n    *   Attempting to modulate too fast will result in the Tx filtering out the changes or simply not responding quickly enough for the modulation to be observable.\r\n    *   Start *very* slow (e.g., 10-100 bits per second) for initial proof-of-concept. Higher speeds are possible but require more sophisticated signal processing and potentially faster switching circuitry.\r\n*   **Encoding:** We need a way to represent the data we want to send as a sequence of ON/OFF pulses. Simple binary encoding is sufficient for a PoC. We can send ASCII characters, sensor readings, or any other small piece of data.\r\n\r\n### **7.3 Implementing the Modulation Circuit**\r\n\r\nWe already built the foundation for this in Module 5! Our attacker hardware platform includes:\r\n\r\n1.  The attacker Rx coil.\r\n2.  A rectifier and filter to convert AC to DC.\r\n3.  A microcontroller (MCU).\r\n4.  A switching component (like a MOSFET) controllable by the MCU.\r\n5.  A load (like a resistor).\r\n\r\nWe connect the resistor *after* the rectifier/filter, across the DC bus. The MOSFET is placed in series with the resistor (or the low side of the resistor) to switch it on and off under MCU control.\r\n\r\n**Circuit Diagram (Conceptual):**\r\n\r\n```\r\nAttacker Rx Coil\r\n      |\r\n      |\r\n[ Rectifier & Filter ] --> DC Voltage Bus (+)\r\n      |                          |\r\n      |                     [ Resistor ]\r\n      |                          |\r\n      |                     [ MOSFET ] <--- Gate controlled by MCU Digital Pin\r\n      |                          |\r\n-------------------------------------------------- Ground (-)\r\n```\r\n\r\nWhen the MCU's digital pin goes HIGH, the MOSFET turns ON, completing the circuit for the resistor and drawing current from the DC bus. When the pin goes LOW, the MOSFET turns OFF, and the resistor draws no current. This switching action modulates the load presented to the attacker Rx coil, which in turn modulates the reflected impedance seen by the Tx.\r\n\r\n**Component Considerations:**\r\n\r\n*   **MOSFET:** Needs to be able to handle the voltage and current on the DC bus of your attacker Rx. A small N-channel MOSFET (like a 2N7000 or similar logic-level gate MOSFET) is likely sufficient for low-power PoCs. Ensure the MCU's voltage is sufficient to drive the gate fully ON.\r\n*   **Resistor:** Choose a value that creates a noticeable load change *without* causing the Tx to shut down. This requires experimentation. Start with something relatively high (e.g., 100-500 ohms) and decrease it if the modulation isn't visible, while carefully monitoring the Tx's behavior.\r\n\r\n### **7.4 Encoding and Generating the Modulation (Code)**\r\n\r\nLet's write some simple code for an Arduino-compatible MCU to perform OOK modulation to transmit a message. We'll transmit the string \"HI\".\r\n\r\nWe'll need functions to:\r\n1.  Turn the load ON.\r\n2.  Turn the load OFF.\r\n3.  Transmit a single bit (with a defined duration).\r\n4.  Transmit a byte (e.g., an ASCII character), including simple start/stop bits for framing.\r\n5.  Transmit a string.\r\n\r\n```cpp\r\n// Define the digital pin connected to the MOSFET gate\r\nconst int MOSFET_GATE_PIN = 8; // Example pin, choose one suitable for your board\r\n\r\n// Define the duration of a single bit in milliseconds\r\n// This determines the data rate (e.g., 100 ms = 10 bits/sec)\r\nconst int BIT_DURATION_MS = 100; // Adjust based on experimentation\r\n\r\n// Define the duration of start/stop bits (can be same as bit duration)\r\nconst int START_STOP_DURATION_MS = 100;\r\n\r\nvoid setup() {\r\n  // Configure the MOSFET gate pin as an output\r\n  pinMode(MOSFET_GATE_PIN, OUTPUT);\r\n\r\n  // Start with the load off\r\n  digitalWrite(MOSFET_GATE_PIN, LOW);\r\n\r\n  // Optional: Add a small delay at startup\r\n  delay(1000);\r\n\r\n  // Initialize Serial communication for debugging (optional)\r\n  Serial.begin(9600);\r\n  Serial.println(\"Attacker Modulation Device Ready\");\r\n}\r\n\r\nvoid set_load_on() {\r\n  digitalWrite(MOSFET_GATE_PIN, HIGH);\r\n}\r\n\r\nvoid set_load_off() {\r\n  digitalWrite(MOSFET_GATE_PIN, LOW);\r\n}\r\n\r\n// Transmit a single bit using OOK\r\n// bit: 0 or 1\r\n// duration_ms: how long the load is in the corresponding state\r\nvoid transmit_bit(int bit, int duration_ms) {\r\n  if (bit == 1) {\r\n    set_load_on();\r\n    // Serial.print(\"1\"); // Debugging\r\n  } else { // bit == 0\r\n    set_load_off();\r\n    // Serial.print(\"0\"); // Debugging\r\n  }\r\n  delay(duration_ms); // Maintain the state for the bit duration\r\n}\r\n\r\n// Transmit a byte (8 bits) using OOK with start/stop bits\r\n// Simple framing: Start bit (0), 8 data bits (LSB first), Stop bit (1)\r\nvoid transmit_byte(byte data, int bit_duration_ms) {\r\n  // Serial.print(\"\\nSending byte: \"); // Debugging\r\n  // Serial.println(data, BIN); // Debugging\r\n\r\n  // Send Start Bit (typically 0)\r\n  // A '0' bit is represented by Load OFF in this example OOK scheme\r\n  transmit_bit(0, START_STOP_DURATION_MS);\r\n\r\n  // Send Data Bits (8 bits, LSB first)\r\n  for (int i = 0; i < 8; i++) {\r\n    // Extract the i-th bit (0 or 1)\r\n    int bit = (data >> i) & 0x01;\r\n    // A '1' bit is Load ON, '0' bit is Load OFF\r\n    transmit_bit(bit, bit_duration_ms);\r\n  }\r\n\r\n  // Send Stop Bit (typically 1)\r\n  // A '1' bit is represented by Load ON in this example OOK scheme\r\n  transmit_bit(1, START_STOP_DURATION_MS);\r\n\r\n  // Optional: Add a short pause between bytes\r\n  delay(bit_duration_ms * 2);\r\n}\r\n\r\n// Transmit a null-terminated string\r\nvoid transmit_string(const char* str, int bit_duration_ms) {\r\n  // Serial.print(\"\\nSending string: \"); // Debugging\r\n  // Serial.println(str); // Debugging\r\n  while (*str) { // Loop until null terminator\r\n    transmit_byte(*str, bit_duration_ms);\r\n    str++; // Move to the next character\r\n  }\r\n  // Serial.println(\"\\nString transmission complete.\"); // Debugging\r\n}\r\n\r\nvoid loop() {\r\n  // String to transmit\r\n  const char* message = \"HI\";\r\n\r\n  // Transmit the message repeatedly (or once, depending on goal)\r\n  transmit_string(message, BIT_DURATION_MS);\r\n\r\n  // Optional: Add a longer pause between message repetitions\r\n  delay(5000); // Wait 5 seconds before repeating\r\n}\r\n```\r\n\r\n**Code Explanation:**\r\n\r\n*   `MOSFET_GATE_PIN`: Set this to the digital pin connected to your MOSFET's gate.\r\n*   `BIT_DURATION_MS`: This is crucial. It defines how long each '1' or '0' state lasts. A value of 100ms means 10 bits per second (ignoring start/stop and pauses). Start with a large value and decrease it.\r\n*   `set_load_on()` / `set_load_off()`: Simple wrappers for `digitalWrite` to control the MOSFET.\r\n*   `transmit_bit()`: Sets the load state for the specified duration using `delay()`.\r\n*   `transmit_byte()`: Implements a basic serial-like protocol: a start bit (0), 8 data bits (Least Significant Bit first is common), and a stop bit (1). This helps delineate bytes when decoding.\r\n*   `transmit_string()`: Iterates through the characters of a string, sending each byte.\r\n*   `loop()`: Calls `transmit_string()` with our message \"HI\" and repeats.\r\n\r\n**Important:** This code uses blocking `delay()`. For more sophisticated modulation or simultaneous tasks (like energy harvesting and modulation), you'd use non-blocking techniques with timers. But for a simple PoC, `delay()` is fine.\r\n\r\n### **7.5 Observing the Modulation at the Transmitter**\r\n\r\nThis is often the most challenging part of this attack vector. The changes we induce are subtle, especially if we're trying to be stealthy. We need to monitor a signal *on the Tx side* that is sensitive to the reflected impedance.\r\n\r\n**Where to Look on the Tx:**\r\n\r\n*   **Tx Input Current:** The most common and often easiest place to observe. A change in reflected load on the Tx coil causes the Tx power stage to draw more or less current from its DC power supply. You can measure this with a current probe (preferred, non-invasive) or by inserting a small sense resistor in series with the DC input and measuring the voltage across it.\r\n*   **Voltage/Current Across Tx Coil:** The amplitude and phase of the high-frequency AC voltage and current in the Tx coil are directly affected by the reflected impedance. Probing these requires care due to high frequencies and potentially high voltages.\r\n*   **Voltage Across Tuning Capacitors:** Similar to the coil voltage, changes here are indicative of the resonant circuit's state being affected by the load.\r\n*   **Voltage/Current in Tx Switching Stage:** Monitoring the waveforms at the switching transistors (MOSFETs) of the Tx inverter can also reveal modulation effects.\r\n\r\n**Tools:**\r\n\r\n*   **Oscilloscope:** Absolutely essential. You need one with enough bandwidth to see the Tx's operating frequency (often hundreds of kHz or MHz) and, more importantly, enough sensitivity and sampling rate to capture the *envelope* changes caused by our much slower load modulation.\r\n*   **Current Probe:** Highly recommended for safely measuring Tx input current without modifying the circuit significantly.\r\n*   **Differential Voltage Probe:** Safer for measuring across components like tuning capacitors or MOSFETs if single-ended probing is risky.\r\n\r\n**What to Look For:**\r\n\r\nYou won't typically see the sharp square wave of your MCU's digital output. Instead, you'll see the Tx signal (e.g., the high-frequency input current waveform) whose *average level* or *envelope* changes slightly according to your modulation pattern.\r\n\r\nImagine the Tx input current is normally a certain level. When your attacker Rx switches its load ON, it draws more power from the field, which causes the Tx to work harder and draw slightly *more* input current (or sometimes less, depending on the system design and operating point). When your attacker Rx switches its load OFF, the Tx input current returns to its baseline.\r\n\r\nYou are looking for small, relatively slow (at your bit rate) variations superimposed on the much faster Tx operating frequency waveform.\r\n\r\n**Oscilloscope Setup Tips:**\r\n\r\n1.  **Connect Probe:** Connect your probe (e.g., current probe around the Tx's DC input wire).\r\n2.  **Set Timebase:** Set the timebase to capture several bits of your modulation (e.g., if `BIT_DURATION_MS` is 100ms, set timebase to 50ms or 100ms per division).\r\n3.  **Set Vertical Scale:** Start with a coarse scale, then zoom in. You might need millivolts per division if using a sense resistor or current probe output.\r\n4.  **Trigger:** Triggering can be tricky.\r\n    *   **Auto Trigger:** Might show the signal but won't sync to your modulation.\r\n    *   **Normal Trigger:** Set the trigger level on the Tx signal. If the modulation causes a significant jump/drop, you might be able to trigger directly on that edge.\r\n    *   **External Trigger:** If your MCU has a spare pin, you could toggle it simultaneously with your modulation signal and use that to trigger the scope. This is the most reliable method for syncing.\r\n    *   **Single Shot:** If the modulation happens predictably (like in our `loop` function), you can set the scope to single shot and capture one sequence.\r\n5.  **Acquisition Mode:** Use 'Normal' or 'Average' if the signal is noisy. 'Peak Detect' can sometimes help capture brief transients.\r\n\r\n### **7.6 Basic Signal Analysis**\r\n\r\nOnce you've captured a waveform on the oscilloscope that shows variations corresponding to your modulation timing, you need to decode it.\r\n\r\n1.  **Identify Baseline:** Determine the Tx signal level when your attacker's load is OFF.\r\n2.  **Identify Modulated Level:** Determine the Tx signal level when your attacker's load is ON.\r\n3.  **Look for the Pattern:** Scan the captured waveform. Identify the start bit (the dip/bump corresponding to your '0' state), then the sequence of 8 data bits, and finally the stop bit (the opposite state corresponding to your '1' state).\r\n4.  **Measure Durations:** Verify that the pulses and gaps match your expected `BIT_DURATION_MS` (approximately).\r\n5.  **Decode:** Based on your OOK scheme (e.g., ON=1, OFF=0), read the sequence of 0s and 1s for each byte.\r\n6.  **Convert Binary to ASCII:** Group the bits into 8-bit bytes (remembering if you sent LSB or MSB first) and convert them back to ASCII characters.\r\n\r\n**Example (Conceptual):**\r\n\r\nIf you send the byte for 'H' (ASCII 72, binary `01001000`), and your scheme is:\r\n*   Start bit (0) = Load OFF (Tx current low)\r\n*   Data bit 0 (0) = Load OFF (Tx current low)\r\n*   Data bit 1 (0) = Load OFF (Tx current low)\r\n*   Data bit 2 (0) = Load OFF (Tx current low)\r\n*   Data bit 3 (1) = Load ON (Tx current high)\r\n*   Data bit 4 (0) = Load OFF (Tx current low)\r\n*   Data bit 5 (0) = Load OFF (Tx current low)\r\n*   Data bit 6 (1) = Load ON (Tx current high)\r\n*   Data bit 7 (0) = Load OFF (Tx current low)\r\n*   Stop bit (1) = Load ON (Tx current high)\r\n\r\nOn the oscilloscope, you'd look for a pattern of Tx current levels changing: Low (Start), Low, Low, Low, High, Low, Low, High, Low (Data), High (Stop). If the timing matches your `BIT_DURATION_MS`, you've likely found your modulated data!\r\n\r\nFor more complex analysis or higher data rates, you might export the waveform data from the oscilloscope and process it in software (e.g., Python with libraries like NumPy and SciPy) to perform filtering, thresholding, and automated decoding. But for this module's PoC, visual identification and manual decoding are sufficient.\r\n\r\n### **7.7 Proof-of-Concept Demonstration**\r\n\r\nThe culmination of this module is demonstrating that you can actually encode and observe the data transmission.\r\n\r\n**Steps for Demonstration:**\r\n\r\n1.  Have your attacker hardware platform assembled with the modulation circuit.\r\n2.  Load the Arduino code that transmits the string \"HI\".\r\n3.  Set up a standard WPT transmitter (like a Qi charger pad).\r\n4.  Set up your oscilloscope to monitor a suitable point on the Tx (e.g., input current via a probe).\r\n5.  Power on the WPT transmitter.\r\n6.  Power on your attacker device (either via harvested power if Module 6 was successful, or a small battery/USB power).\r\n7.  Place your attacker Rx coil near the WPT Tx coil. Find a position where the Tx remains operational and you can see *some* effect on the Tx signal when you manually toggle the load (e.g., by briefly connecting/disconnecting the resistor).\r\n8.  Start the attacker code running.\r\n9.  Use the oscilloscope to capture the Tx signal during the transmission of \"HI\".\r\n10. Analyze the captured waveform to identify the pulses corresponding to the start bit, the data bits for 'H', the stop bit, the start bit for 'I', the data bits for 'I', and the stop bit.\r\n11. Show the captured waveform and walk through the decoding process to demonstrate that \"HI\" was successfully transmitted via load modulation and observed on the Tx side.\r\n\r\n### **Module Project/Exercise:**\r\n\r\n**Goal:** Implement the data exfiltration attack by modulating your attacker device's load and observing the encoded data on the target WPT transmitter's signal.\r\n\r\n**Steps:**\r\n\r\n1.  **Review and Refine Hardware:** Ensure your attacker platform from Module 5 is functional and includes the MOSFET switch and a suitable load resistor connected across the rectified DC output of your attacker coil.\r\n2.  **Select and Prepare Tx Monitoring Point:** Identify where on your target WPT transmitter you will probe the signal. **Choose the safest option available!** Measuring DC input current with a clamp probe or a sense resistor is often the least invasive and safest. If you must probe AC points, use differential probes and exercise extreme caution. **Be aware of hazardous voltages and frequencies.**\r\n3.  **Install and Adapt Code:** Load the provided Arduino code (or your adaptation) onto your MCU. Adjust the `MOSFET_GATE_PIN` and crucially, the `BIT_DURATION_MS`. You will likely need to experiment with `BIT_DURATION_MS` and the resistor value to find a balance where the modulation is visible but doesn't crash the Tx.\r\n4.  **Setup Tx and Attacker:** Power on your target WPT transmitter. Power on your attacker device.\r\n5.  **Position Attacker Coil:** Place your attacker Rx coil near the Tx coil. Experiment with distance and alignment. Find a spot where the Tx stays active and you get a good coupling.\r\n6.  **Configure Oscilloscope:** Connect your probe to the chosen monitoring point on the Tx. Configure the timebase, vertical scale, and trigger settings on your oscilloscope to capture the Tx signal and look for the slower modulation pattern. Using an external trigger from the MCU (if available) is highly recommended.\r\n7.  **Execute Attack:** Run the code on your MCU.\r\n8.  **Capture and Analyze Waveform:** Capture the Tx signal on the oscilloscope. Zoom in on the captured waveform. Identify the pattern of highs and lows (or dips and bumps) corresponding to your expected binary sequence for \"HI\".\r\n9.  **Decode Data:** Manually decode the captured waveform based on your OOK scheme and bit timing. Confirm that you can identify the start bit, data bits for 'H', stop bit, start bit for 'I', data bits for 'I', and stop bit.\r\n10. **Document Findings:**\r\n    *   Record your hardware setup (MCU, MOSFET, resistor value, coils).\r\n    *   Note the Tx monitoring point used and the probe type.\r\n    *   Include screenshots of the oscilloscope waveform showing the captured modulation. Annotate the screenshot to show where you identified the start bit, data bits, and stop bits.\r\n    *   Show your decoding process and the resulting binary and ASCII data.\r\n    *   Describe any challenges encountered (e.g., Tx shutting down, signal too noisy, difficulty triggering).\r\n\r\nBy successfully completing this project, you will have built and demonstrated a device capable of covertly transmitting data through a WPT link by manipulating the reflected power signature – a true physical layer attack!\r\n\r\n---\r\n\r\nThis concludes Module 7. You've now built the core components and demonstrated the feasibility of both energy hijacking and covert data exfiltration via load modulation. In our final module, Module 8, we will integrate these concepts into a single, polished proof-of-concept, discuss the limitations of our current build, explore potential countermeasures WPT systems could employ, and look at exciting future directions for research in this fascinating area. Get ready to wrap it all up!"
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Alright everyone, welcome to the grand finale! Module 8. This is where we pull *everything* together. We've walked through the physics, reverse-engineered the concepts of WPT Tx and Rx, built the foundational hardware, and explored the individual attack vectors of energy hijacking and data exfiltration.\r\n\r\nNow, we combine them. We refine our proof-of-concept (PoC). We run the full demonstration. We analyze the heck out of what we built, understand its limits, and then pivot to the crucial part: how would the *defenders* stop this, and where does the research go next? This is where your \"research paper\" equivalent comes to life.\r\n\r\nSo, let's gear up. Get your breadboards, your microcontrollers, your coils, and especially your oscilloscopes ready. It's time to make our attacker device a reality and see the full attack chain in action.\r\n\r\n---\r\n\r\n## **Module 8: Capstone Project & Future Directions**\r\n\r\n*   **Module Objective:** Learners will integrate all components and knowledge to create a comprehensive demonstration of both attack vectors, analyze the results, understand the limitations of the PoC, and explore potential countermeasures and advanced attack/defense strategies.\r\n\r\n*   **Estimated Time:** This module is heavily project-based. Allocate significant time for building, testing, debugging, and documentation (easily 8-16+ hours depending on prior experience and debugging needs).\r\n\r\n---\r\n\r\n### **8.1 Integrating Attack Vectors: Powering the Brains with Stolen Energy**\r\n\r\nWe've built a platform that *can* harvest energy (Module 6) and *can* perform load modulation (Module 7). The elegant next step, especially for a stealthy attacker, is to use the *stolen* energy to power the *brains* doing the stealing and modulating – our microcontroller (MCU).\r\n\r\n**Concept:**\r\nThe energy harvesting circuit (coil -> rectifier -> filter -> regulator) provides a DC voltage. This voltage needs to be stable and at the correct level for our MCU (e.g., 3.3V or 5V). The load modulation circuit (MCU pin -> MOSFET -> load resistor/capacitor) is controlled by the MCU, switching the load on/off *across* the harvested power line (or a point downstream of the rectifier but before the final regulator, depending on design).\r\n\r\n**Implementation Steps:**\r\n\r\n1.  **Review your Module 5, 6, and 7 Hardware:** You should have:\r\n    *   Attacker coil.\r\n    *   Rectification and filtering circuit (diodes, capacitors).\r\n    *   A voltage regulator (e.g., a Low Dropout Regulator - LDO, or a small switching regulator) to convert the harvested DC (which might fluctuate) to a stable voltage required by your MCU.\r\n    *   Your chosen MCU development board (e.g., Arduino Nano, ESP32).\r\n    *   A MOSFET or transistor capable of switching the modulation load.\r\n    *   The modulation load component(s) (e.g., resistor, capacitor).\r\n\r\n2.  **Connect the Power Path:**\r\n    *   Connect the output of your rectifier/filter circuit to the input of your voltage regulator.\r\n    *   Connect the *regulated output* of the voltage regulator to the VIN or 5V/3.3V pin of your MCU board.\r\n    *   **Important:** Ensure the harvested voltage *before* the regulator is consistently higher than the regulator's required input voltage (headroom). If your harvesting is weak, you might need a boost converter *before* the regulator, or initially power the MCU from a separate source *until* sufficient power is harvested. For this PoC, a simple LDO might suffice if the harvested voltage is reliably above its dropout voltage.\r\n    *   Include a large filter capacitor *after* the regulator to smooth out power spikes and dips, especially those caused by your own load modulation!\r\n\r\n3.  **Connect the Modulation Path:**\r\n    *   The load modulation circuit's switching component (MOSFET) should be connected such that it toggles a specific load *across* the rectified/filtered DC voltage (before the final MCU regulator is often easiest to see the effect, but after works too if the regulator can handle the load changes).\r\n    *   The control pin of the MOSFET connects to a digital output pin on your MCU.\r\n    *   Ensure the MOSFET is correctly wired (Source, Gate, Drain) and the gate is driven with sufficient voltage from the MCU pin to turn it fully on (check MOSFET datasheet, especially for 'logic-level' MOSFETs if using 3.3V/5V MCU). A pull-down resistor on the gate is good practice.\r\n\r\n4.  **Conceptual Wiring Diagram:**\r\n\r\n    ```mermaid\r\n    graph LR\r\n        A[Attacker Coil] --> B(Rectifier & Filter)\r\n        B --> C(Input Filter Cap)\r\n        C --> D(Voltage Regulator)\r\n        D --> E(MCU VIN/VCC)\r\n        E --> F(MCU Digital Pin)\r\n        B --> G(Modulation Load + MOSFET)\r\n        F --> G\r\n        G --> B\r\n        E --> H(MCU GND)\r\n        G --> H\r\n    ```\r\n    *Self-Correction Note:* The modulation load is typically switched *across* the rectified DC output, which then affects the reflected impedance seen by the Tx. The MCU is *powered* by this rectified/regulated DC. The diagram shows this loop.\r\n\r\n5.  **Code Integration:**\r\n    *   Your code needs to perform two conceptual tasks:\r\n        *   Initialize the modulation pin.\r\n        *   Enter a loop where it performs the data exfiltration modulation sequence periodically or on command.\r\n        *   *(Implicit)* The harvesting is handled by hardware, providing power to run this code.\r\n\r\n    *   **Example (Arduino-like Pseudocode):**\r\n\r\n    ```cpp\r\n    // Define the pin connected to the MOSFET gate\r\n    const int modulationPin = 9;\r\n    // Define the desired modulation pattern (e.g., binary for \"HI\")\r\n    // 'H' = 01001000, 'I' = 01001001\r\n    // Let's send a simpler pattern: 1010 (On-Off-On-Off)\r\n    int modulationPattern[] = {1, 0, 1, 0};\r\n    const int patternLength = sizeof(modulationPattern) / sizeof(modulationPattern[0]);\r\n    const int bitDuration_ms = 50; // Duration of each bit (adjust based on observation)\r\n\r\n    void setup() {\r\n      // Initialize the modulation pin as an output\r\n      pinMode(modulationPin, OUTPUT);\r\n      // Ensure MOSFET starts in OFF state\r\n      digitalWrite(modulationPin, LOW);\r\n\r\n      // Optional: Add a small delay to stabilize after power-up\r\n      delay(1000);\r\n    }\r\n\r\n    void loop() {\r\n      // Perform the modulation sequence\r\n      for (int i = 0; i < patternLength; i++) {\r\n        if (modulationPattern[i] == 1) {\r\n          // Switch load ON\r\n          digitalWrite(modulationPin, HIGH);\r\n        } else {\r\n          // Switch load OFF\r\n          digitalWrite(modulationPin, LOW);\r\n        }\r\n        // Keep the load state for the bit duration\r\n        delay(bitDuration_ms);\r\n      }\r\n\r\n      // Add a pause before repeating the pattern\r\n      delay(2000); // Pause for 2 seconds\r\n\r\n      // Note: In a real attack, this loop might be triggered by an event,\r\n      // or send more complex data. For the PoC, a repeating pattern is fine.\r\n    }\r\n    ```\r\n    *   **Compile and Upload:** Upload this code to your MCU *while it's powered externally* initially.\r\n    *   **Test Powering from Harvested Energy:** Once the code is uploaded and verified to run with external power, disconnect the external power and place your attacker coil in the WPT field. Observe if the MCU powers up and the code runs (e.g., blink an LED if you add one, or simply observe the modulation pin voltage with a scope). Debug your harvesting/regulation circuit if it fails to power the MCU.\r\n\r\n### **8.2 Refining the Proof-of-Concept**\r\n\r\nGetting the basic integration working is great, but making it *demonstrable* and observable requires refinement.\r\n\r\n**Key Areas for Refinement:**\r\n\r\n1.  **Coil Placement and Alignment:**\r\n    *   **Goal:** Maximize coupling (for harvesting and modulation visibility) without necessarily interfering with a legitimate receiver (unless that's part of your goal).\r\n    *   **Technique:** Place the attacker coil near the target Tx coil. Use your oscilloscope to monitor the *rectified DC voltage* on your attacker device. Move the coil around (distance, horizontal offset, angle) to find the position that yields the highest stable DC voltage. This is your optimal harvesting spot, which also likely maximizes the reflected power effect for modulation.\r\n    *   **Observation:** Note the sensitivity to position. WPT coupling is highly dependent on alignment.\r\n\r\n2.  **Modulation Depth Tuning:**\r\n    *   **Goal:** Choose a modulation load (resistor/capacitor value) that causes a *detectable* change at the Tx without causing the Tx to shut down or indicate an error.\r\n    *   **Technique:** Experiment with different resistor values (if using resistive load modulation). Start with a relatively high resistance (lower load, smaller effect) and decrease it.\r\n    *   **Observation:** With your attacker device modulating, monitor the Tx input current or Tx coil voltage with your oscilloscope. You are looking for a clear, repeating change in the Tx waveform synchronized with your modulation pattern. If the Tx stops working, your load change is too large. If you see no change, it's too small. Find the sweet spot. If using capacitive modulation, experiment with capacitor values.\r\n\r\n3.  **Harvesting Efficiency:**\r\n    *   **Goal:** Ensure enough power is harvested to reliably run the MCU and the modulation circuit during switching.\r\n    *   **Technique:** Measure the current drawn by your MCU platform (including the MOSFET switching) and compare it to the average current your harvesting circuit can provide at the chosen placement. Use a multimeter in series with the MCU's power input (after the regulator).\r\n    *   **Optimization:** Ensure low-loss diodes (Schottky diodes are good), appropriately sized filter capacitors, and an efficient voltage regulator.\r\n\r\n4.  **Reliability:**\r\n    *   **Goal:** Make sure the modulation pulses are consistent and the MCU doesn't brown out during switching.\r\n    *   **Technique:** Monitor the MCU's VCC line with an oscilloscope. If you see significant dips when the MOSFET switches, you might need larger filter capacitors on the regulated output or a more robust power path from harvesting. Add small delays in your code if needed to ensure stable states.\r\n\r\n### **8.3 Demonstration Setup**\r\n\r\nThis is showtime! You need to set up your components to clearly demonstrate both attack vectors.\r\n\r\n**Required Equipment:**\r\n\r\n*   Your refined attacker hardware platform.\r\n*   A target WPT transmitter (e.g., a standard Qi charger).\r\n*   *(Optional but Recommended)* A legitimate WPT receiver (e.g., a smartphone) to show the Tx *can* charge normally, and potentially observe if your attack affects it.\r\n*   Oscilloscope with probes (at least 2 channels helpful).\r\n*   Current clamp or in-line current sensor for monitoring Tx input current (or find an accessible voltage point in the Tx related to power transfer).\r\n*   A small load powered by your attacker device (e.g., an LED, a small fan, a voltmeter showing harvested DC voltage).\r\n*   Camera/phone to record the demonstration.\r\n*   Laptop with your MCU code and potentially data analysis tools.\r\n\r\n**Setup Steps:**\r\n\r\n1.  **Prepare the Target Tx:** Plug in the WPT transmitter. Verify it works with a legitimate receiver if you have one.\r\n2.  **Set up Attacker Hardware:** Place your attacker device near the Tx, using the optimal placement found in refinement.\r\n3.  **Demonstrate Energy Hijacking:**\r\n    *   Show your attacker device is *not* connected to any external power source.\r\n    *   Place the attacker coil near the Tx.\r\n    *   Show the small load (LED lighting up, voltmeter showing voltage) being powered *only* by the harvested energy.\r\n    *   *(Optional but impactful)* If you can measure the Tx input current, show its value with the attacker present vs. absent (or with a legitimate receiver present). Note the increase when your attacker harvests.\r\n4.  **Demonstrate Data Exfiltration:**\r\n    *   Keep the attacker coil in place. Ensure the MCU is running its modulation code (powered by harvested energy).\r\n    *   Connect your oscilloscope probes to the chosen monitoring point(s) on the Tx (e.g., input power line for current clamp, or a voltage across a tuning capacitor). *Be extremely careful probing live circuits!* If unsure, stick to non-contact methods like current clamps or probing low-voltage control signals if you can identify them. The voltage across the Tx coil itself is often high AC voltage.\r\n    *   Set up the oscilloscope trigger. This can be tricky. You might need to trigger on a specific voltage level change on the Tx waveform that corresponds to your modulation pulses. A repeating pattern from your MCU code makes triggering easier.\r\n    *   Capture the Tx waveform on the oscilloscope screen.\r\n    *   Point out the subtle (or not-so-subtle) changes in the Tx waveform that occur precisely when your MCU is switching the load.\r\n    *   Relate these changes back to your programmed modulation pattern (e.g., \"See this dip/bump? That's when I switch the load ON. This flat part is when it's OFF. My code is sending 1010, and you can see that pattern here: dip-no dip-dip-no dip.\").\r\n5.  **Record Everything:** Take photos and videos of your setup, the LED lighting up, the voltmeter reading, and especially the oscilloscope screen showing the modulation being detected. These are your key pieces of evidence for the report.\r\n\r\n### **8.4 Analyzing Results**\r\n\r\nNow, put on your scientist/analyst hat. What did you actually achieve?\r\n\r\n1.  **Energy Hijacking Analysis:**\r\n    *   **Quantify:** What is the maximum stable DC voltage you harvested? What current can you draw while maintaining that voltage? Calculate the harvested power (P = V * I).\r\n    *   **Impact on Tx:** How much did the Tx input current increase when your attacker was harvesting? If possible, compare the Tx's stated maximum output power to the power you harvested.\r\n    *   **Efficiency:** How efficient is your harvesting circuit? (Hard to measure precisely without sophisticated equipment, but you can estimate).\r\n    *   **Stealth:** Was the power draw noticeable? Did the Tx react negatively?\r\n\r\n2.  **Data Exfiltration Analysis:**\r\n    *   **Visibility:** How clear is the modulation signal on the Tx waveform? Is it easily distinguishable from noise or normal Tx operation?\r\n    *   **Data Rate:** What is the effective bit rate of your modulation? (1 / (bitDuration_ms / 1000)). It will likely be very low (tens or hundreds of bps).\r\n    *   **Reliability:** Could you consistently identify the transmitted pattern on the scope? Would automated detection be reliable based on this signal?\r\n    *   **Impact on Tx/Rx:** Did the modulation interfere with legitimate charging (if a legitimate Rx was present)? Did it cause the Tx to adjust power or show errors?\r\n\r\n3.  **Correlation:** Explicitly link your MCU's digital output signal (the intended modulation) to the observed changes on the Tx waveform. Show them side-by-side on the scope if you have enough channels, or capture them sequentially with careful timing notes.\r\n\r\n### **8.5 Limitations of the PoC**\r\n\r\nIt's crucial to be realistic. Your PoC is a demonstration of *principle*, not a polished, covert attack tool. Acknowledging limitations adds credibility to your analysis.\r\n\r\n*   **Range:** Near-field WPT is inherently short-range (typically < 10 cm). Your PoC is limited to this close proximity.\r\n*   **Data Rate:** Load modulation bandwidth is limited by the WPT system's control loop response time and the Q factor of the coils. High-speed data transfer is generally not feasible with simple load modulation.\r\n*   **Power Levels:** The harvested power is likely small (mW to low Watts). Sufficient for small electronics, but not for charging a laptop or powering significant devices unless the target Tx is very high power (like EV charging).\r\n*   **Stealth/Detectability:** A sophisticated WPT transmitter actively monitoring the reflected impedance signature with high precision could potentially detect your unauthorized load or unusual modulation patterns. Your PoC might be visible to the Tx's internal monitoring.\r\n*   **Tx Dependence:** The success of the attack, especially data exfiltration visibility, depends heavily on the specific WPT transmitter's design, operating frequency, and how it manages/monitors the resonant field.\r\n*   **Simplicity:** The modulation scheme (simple OOK) is basic. More complex modulation (FSK, phase modulation) would be harder to implement and detect.\r\n*   **Energy Source:** The PoC relies on an *active* WPT field being present. It can't initiate power transfer.\r\n\r\n### **8.6 Potential Countermeasures**\r\n\r\nHow would the good guys stop this? Think from the perspective of a WPT system designer concerned about security.\r\n\r\n*   **Enhanced Impedance Monitoring:** Implement more sophisticated analysis of the reflected impedance signature beyond simple threshold detection. Look for deviations from expected load characteristics, unusual patterns, or changes that don't correspond to standard protocol communication.\r\n*   **Authentication:** Implement cryptographic authentication between the Tx and *authorized* Rx devices. This could happen over the WPT's built-in communication channel (often load modulation itself, ironically) or a separate channel (like NFC or Bluetooth). The Tx only transfers significant power after successful authentication. (Note: Qi 1.2 and later include optional authentication).\r\n*   **Anomaly Detection (AI/ML):** Train machine learning models on typical Tx operational data (voltage, current, phase, reflected power) with legitimate loads. Deploy the model to detect statistically significant anomalies that might indicate an unauthorized device or malicious modulation.\r\n*   **Active Channel Probing:** The Tx could periodically send specific probe signals and analyze the reflected response to build a dynamic impedance profile of the environment, making it harder for an attacker to blend in.\r\n*   **Physical Layer Encryption/Obfuscation:** While you can't encrypt power, you *could* potentially use spread spectrum techniques or dynamically change frequency/phase in ways that make passive listening or targeted modulation harder without knowing the Tx's current state. (More theoretical for simple systems).\r\n*   **Physical Shielding:** Basic Faraday cages around sensitive areas can block RF fields, though this is often impractical for user-facing WPT surfaces.\r\n*   **Protocol Integrity Checks:** If the Tx uses load modulation for *its own* communication (like Qi), ensure that any detected load changes *must* conform to valid protocol messages. Modulation that doesn't fit the protocol structure could be flagged as malicious.\r\n\r\n### **8.7 Advanced Topics & Future Research**\r\n\r\nYour PoC opens doors to many avenues. Where could this research go next?\r\n\r\n*   **AI/ML for Attack & Defense:**\r\n    *   *Attack:* Use ML to analyze Tx signals and find the optimal modulation pattern for stealth or maximum data rate against a specific Tx model. Use reinforcement learning to find attack strategies.\r\n    *   *Defense:* Develop and deploy more robust ML models for anomaly detection.\r\n*   **Targeting Specific WPT Protocols/Implementations:** Analyze the security of specific standards (e.g., different versions of Qi, PMA, proprietary systems) or specific vendor chips. Find implementation vulnerabilities.\r\n*   **Higher Data Rate Exfiltration:** Investigate more complex load modulation techniques (e.g., using multiple load levels, phase shifts, or frequency shifts if the attacker can influence the Rx coil's resonance) to increase bandwidth. Could you exfiltrate small files?\r\n*   **Active Interference & Jamming:** Can an attacker actively transmit RF energy to disrupt or jam a WPT link? What are the effects and how could it be done stealthily?\r\n*   **Attacking High-Power WPT:** EV charging (kW levels), industrial WPT. The stakes are higher (safety, significant energy theft). Are there unique vulnerabilities in these systems?\r\n*   **Side-Channel Attacks:** Can information about the device being charged (battery level, charging state) be inferred from the Tx's reflected power signature?\r\n*   **WPT as a Covert Communication Channel (Legitimate Use):** Can WPT be *intentionally* used as a secure, low-bandwidth communication channel by modulating the load in a way only a specific receiver understands, perhaps for authentication or pairing? (Turning the attack into a feature).\r\n*   **Counter-Countermeasures:** If a Tx implements authentication or anomaly detection, how could an attacker attempt to bypass it? (e.g., mimicking authentication signals, using adversarial ML techniques).\r\n\r\n### **8.8 Responsible Disclosure**\r\n\r\nAs security researchers, we have an ethical obligation. Finding vulnerabilities is cool, but disclosing them responsibly is paramount.\r\n\r\n1.  **Document Thoroughly:** Your capstone project report *is* the core documentation. Detail the vulnerability, your PoC, the affected systems (general WPT principles, specific standards if applicable), and the potential impact.\r\n2.  **Contact the Vendor/Maintainer:** For real-world vulnerabilities, identify the relevant vendor(s) (e.g., the creators of the WPT standard, manufacturers of vulnerable chips or devices). Find their security contact (often `security@vendor.com` or a dedicated page).\r\n3.  **Private Disclosure:** Share your findings privately with the vendor, providing them ample time to understand the issue, develop a fix, and distribute it. A common timeframe is 90 days, but this can vary.\r\n4.  **Coordinate Public Disclosure:** After the vendor has released a fix or the agreed-upon time has passed, coordinate a public release of your findings. This informs the public and encourages users to apply patches. Present at conferences, publish a paper (like your capstone report!).\r\n5.  **Never Exploit Illegally:** Do not use your PoC or knowledge to steal energy or data from systems you do not own or have explicit permission to test. This research is for educational purposes and for improving security, not for criminal activity.\r\n\r\n### **Capstone Project/Exercise: The Research Paper & Demonstration**\r\n\r\nThis is it. Your final deliverable.\r\n\r\n**Task:**\r\n\r\n1.  **Finalize your Hardware:** Ensure your integrated attacker platform is robust and reliable enough for demonstration.\r\n2.  **Finalize your Code:** Ensure your MCU code reliably performs the desired modulation pattern and runs on harvested power.\r\n3.  **Conduct Final Experiments:** Perform the energy harvesting and data exfiltration demonstration runs, capturing all necessary data (voltage/current measurements, oscilloscope captures).\r\n4.  **Prepare the Demonstration:** Set up your Tx, attacker device, monitoring equipment (oscilloscope), and the visual indicator of harvesting (LED/voltmeter). Practice your presentation flow.\r\n5.  **Write the Capstone Report:** Structure your report like a security research paper.\r\n\r\n    *   **Title:** Something clear and engaging (e.g., \"Attacking Wireless Power: Practical Energy Hijacking and Covert Data Exfiltration via Reflected Power Manipulation\").\r\n    *   **Abstract:** A brief summary (150-250 words) covering the problem, your approach, your findings (the PoC capabilities), and the implications.\r\n    *   **Introduction:** Introduce WPT, its growing prevalence, the overlooked security surface (physical layer), state the problem (unauthorized energy draw, covert data exfil), and clearly state the objective of your research/PoC.\r\n    *   **Background:** Briefly explain the relevant WPT physics (near-field, resonance, coupling, reflected power, load modulation). Reference the concepts learned in Modules 1-4.\r\n    *   **Methodology:** Detail your attacker device's design and build process. Include:\r\n        *   Hardware components used (MCU, coils, rectifier, regulator, MOSFET, load). Include a block diagram and photos of your setup.\r\n        *   Software design (MCU code logic - explain the modulation pattern, timing, power management). Include key code snippets.\r\n        *   Experimental setup (Target Tx used, how you monitored the Tx, how you measured harvested power). Include photos/diagrams.\r\n    *   **Results:** Present the findings from your experiments.\r\n        *   **Energy Hijacking:** Quantify harvested power. Show visual proof (LED/voltmeter). Show impact on Tx (e.g., Tx input current change, oscilloscope trace comparison).\r\n        *   **Data Exfiltration:** Show the programmed modulation pattern. Show the corresponding oscilloscope captures of the Tx signal, highlighting where the modulation is visible. Explain how the pattern maps to the signal changes. Comment on signal clarity and timing.\r\n    *   **Analysis:** Discuss what your results mean. How successful was each attack vector? Did the integration work as expected? What correlations did you observe between your device's actions and the Tx's behavior?\r\n    *   **Limitations:** Reiterate the practical limitations of your PoC (range, data rate, stealth, etc.).\r\n    *   **Countermeasures:** Discuss the potential defenses against this type of attack based on your understanding.\r\n    *   **Future Work:** Suggest directions for further research based on your experience with the PoC.\r\n    *   **Conclusion:** Summarize your achievement – you successfully built a PoC demonstrating energy hijacking and covert data exfiltration from a WPT field by manipulating reflected power. Reiterate the security implications.\r\n    *   **References:** Cite any resources you used (datasheets, tutorials, research papers if you read any beyond the suggested).\r\n6.  **Prepare Presentation (Optional but Recommended):** If you were presenting this, create slides summarizing your report, including photos and videos of the demo.\r\n\r\n**Evaluation:** Your success will be evaluated based on:\r\n\r\n*   The functionality of your integrated attacker device (can it power itself from harvested energy and modulate?).\r\n*   The clarity and success of your demonstration of *both* energy hijacking and data exfiltration.\r\n*   The quality and completeness of your capstone report, including thorough analysis, acknowledgment of limitations, and thoughtful discussion of countermeasures and future work.\r\n\r\n---\r\n\r\nThis capstone project is a significant undertaking. It requires bringing together everything you've learned, troubleshooting hardware and software, and presenting your findings clearly. But successfully building and demonstrating this PoC will give you a deep, practical understanding of WPT security at the physical layer – a truly unique skill set.\r\n\r\nRemember to be patient with debugging, be careful with live electronics, and most importantly, have fun exploring this often-overlooked attack surface! You're now equipped to not just understand WPT, but to analyze its vulnerabilities and even build tools to demonstrate them. Go forth and research responsibly!"
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
