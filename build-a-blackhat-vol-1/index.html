<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>build-a-blackhat-vol-1</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">‚Üê Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>build-a-blackhat-vol-1</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 2 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Okay, here&#39;s a comprehensive 8-module course outline for &quot;Assembly for Red Teams &amp; Malware Dev: From Zero to Hero,&quot; designed with a focus on practical application, hands-on learning, and building towards a capstone project. My goal is to make this a learning experience that&#39;s not just informative but also genuinely engaging and empowering.</p>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to create a functional clone of a simple keylogger, demonstrating a comprehensive understanding of assembly language principles and their application in offensive security scenarios.</p>\n<p><strong>Target Audience:</strong> Individuals with basic programming knowledge (preferably in C/C++ or Python) and a foundational understanding of operating systems concepts. No prior assembly experience is required.</p>\n<p><strong>Capstone Project:</strong> Developing a basic keylogger in assembly language. This project will be progressively built upon throughout the course, with each module contributing specific components and functionalities.</p>\n<hr>\n<p><strong>Module 1: Foundations - Processor Architecture and Assembly Basics</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the fundamental concepts of processor architecture, memory organization, and the basics of x86/x64 assembly language.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>CPU Architecture: Registers (general purpose, segment registers, instruction pointer), flags, memory organization (stack, heap, code, data).</li>\n<li>x86/x64 Instruction Set Architecture (ISA): Overview of instruction types (data transfer, arithmetic, logical, control flow).</li>\n<li>Assembly Syntax: Intel vs. AT&amp;T syntax, assembler directives.</li>\n<li>Data Representation: Integers (signed/unsigned), floating-point numbers, character encoding.</li>\n<li>Calling Conventions: Understanding how functions pass arguments and return values (CDECL, STDCALL, FASTCALL).</li>\n<li>Introduction to Debugging Tools: GDB (Linux), OllyDbg/x64dbg (Windows).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Basic understanding of computer architecture, familiarity with a high-level programming language.</li>\n<li><strong>Project/Exercise:</strong> Write a simple assembly program to perform basic arithmetic operations (addition, subtraction, multiplication, division) on two numbers and display the result. This program will form the foundation for later modules. (e.g., calculating the XOR of two hardcoded values to be used in later modules).</li>\n</ul>\n<hr>\n<p><strong>Module 2: Memory Management and Addressing Modes</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn how memory is managed in x86/x64 systems and how to use different addressing modes to access and manipulate data.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Memory Segmentation: Understanding segment registers and their role in memory access.</li>\n<li>Addressing Modes: Register addressing, immediate addressing, direct addressing, indirect addressing, base-index addressing, scaled-index addressing.</li>\n<li>Stack Operations: Push, Pop, Stack Frames, Stack Overflow Basics.</li>\n<li>Heap Allocation: Introduction to dynamic memory allocation (malloc/free equivalent in assembly).</li>\n<li>Virtual Memory: Basic concepts of virtual memory and paging.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 1.</li>\n<li><strong>Project/Exercise:</strong> Modify the arithmetic program from Module 1 to store the input numbers and the result in memory. Experiment with different addressing modes to access these memory locations. Extend the program to dynamically allocate memory on the heap for storing large data sets. This will be used later to store keystrokes.</li>\n</ul>\n<hr>\n<p><strong>Module 3: Control Flow and Procedures</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Master control flow instructions and learn how to define and call procedures (functions) in assembly language.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Conditional Jumps: <code>JE</code>, <code>JNE</code>, <code>JL</code>, <code>JG</code>, <code>JLE</code>, <code>JGE</code>.</li>\n<li>Unconditional Jumps: <code>JMP</code>.</li>\n<li>Loops: Implementing <code>for</code> and <code>while</code> loops in assembly.</li>\n<li>Procedure Calls: <code>CALL</code>, <code>RET</code>, stack frame setup, argument passing.</li>\n<li>Recursion: Implementing recursive functions in assembly.</li>\n<li>Interrupts and System Calls: Introduction to interrupts and how to make system calls.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 2.</li>\n<li><strong>Project/Exercise:</strong> Implement a function in assembly that calculates the factorial of a number using recursion. Integrate this function into the previous arithmetic program and allow the user to choose whether to perform arithmetic operations or calculate the factorial. This will be called from the main program loop.</li>\n</ul>\n<hr>\n<p><strong>Module 4: Reverse Engineering Fundamentals</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Develop skills in reverse engineering x86/x64 binaries using disassemblers and debuggers.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Disassemblers: IDA Pro (demo version), Ghidra, Binary Ninja.</li>\n<li>Debuggers: GDB (Linux), OllyDbg/x64dbg (Windows).</li>\n<li>Static Analysis: Examining code without executing it, identifying function calls, data structures, and control flow.</li>\n<li>Dynamic Analysis: Examining code while it&#39;s running, setting breakpoints, stepping through instructions, inspecting memory.</li>\n<li>Recognizing Common Patterns: Identifying standard library functions, loops, and conditional statements in disassembled code.</li>\n<li>Anti-Reversing Techniques: Introduction to common anti-reversing techniques (e.g., code obfuscation, anti-debugging).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 3.</li>\n<li><strong>Case Study:</strong> Reverse engineer a simple &quot;crackme&quot; program to identify the password validation logic and bypass it.</li>\n<li><strong>Project/Exercise:</strong> Reverse engineer a small, compiled C program to understand its functionality. Identify the main function, key data structures, and control flow.  Document your findings. This will be a core helper function.</li>\n</ul>\n<hr>\n<p><strong>Module 5: Shellcode Development</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn how to write position-independent shellcode for various architectures and operating systems.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Position-Independent Code (PIC): Techniques for writing code that can execute from any memory address.</li>\n<li>System Calls: Making system calls to perform tasks like opening files, reading data, and executing commands.</li>\n<li>Avoiding Null Bytes: Techniques for avoiding null bytes in shellcode to prevent premature termination.</li>\n<li>Shellcode Encoding: Encoding shellcode to bypass basic intrusion detection systems.</li>\n<li>Shellcode for Different Architectures: Writing shellcode for x86, x64, and ARM architectures.</li>\n<li>Shellcode for Different Operating Systems: Writing shellcode for Windows, Linux, and macOS.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 4.</li>\n<li><strong>Project/Exercise:</strong> Write shellcode that executes a simple command (e.g., <code>ls</code> on Linux, <code>dir</code> on Windows).  Test the shellcode in a controlled environment.</li>\n</ul>\n<hr>\n<p><strong>Module 6: Exploitation Techniques</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand common exploitation techniques and how assembly language can be used to exploit vulnerabilities.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Buffer Overflows: Exploiting buffer overflows to overwrite memory and gain control of program execution.</li>\n<li>Return-Oriented Programming (ROP): Constructing ROP chains to execute arbitrary code.</li>\n<li>Format String Vulnerabilities: Exploiting format string vulnerabilities to read and write arbitrary memory.</li>\n<li>Integer Overflows: Exploiting integer overflows to cause unexpected behavior and gain control of program execution.</li>\n<li>Heap Exploitation: Exploiting vulnerabilities in heap management to corrupt memory and gain control of program execution.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 5.</li>\n<li><strong>Case Study:</strong> Analyze and exploit a vulnerable program with a buffer overflow vulnerability.</li>\n<li><strong>Project/Exercise:</strong>  Craft a basic ROP chain to bypass Data Execution Prevention (DEP) and execute shellcode.</li>\n</ul>\n<hr>\n<p><strong>Module 7: Malware Analysis and Reverse Engineering</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Develop skills in analyzing and reverse engineering malware samples using assembly language.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Malware Types: Viruses, worms, Trojans, rootkits, ransomware.</li>\n<li>Malware Analysis Techniques: Static analysis, dynamic analysis, behavioral analysis.</li>\n<li>Identifying Malware Functionality: Recognizing common malware behaviors (e.g., persistence mechanisms, network communication, data exfiltration).</li>\n<li>Dissecting Malware Samples: Using disassemblers and debuggers to understand the inner workings of malware.</li>\n<li>Anti-Analysis Techniques: Identifying and bypassing anti-analysis techniques used by malware (e.g., virtualization detection, code obfuscation).</li>\n<li>Signature Development: Creating signatures to detect malware based on its code or behavior.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 6.</li>\n<li><strong>Case Study:</strong> Analyze a real-world malware sample (e.g., a simple Trojan) to understand its functionality and persistence mechanisms.</li>\n<li><strong>Project/Exercise:</strong> Reverse engineer a simple piece of malware and write a report describing its functionality, persistence mechanisms, and potential impact.  Develop a basic signature to detect the malware.</li>\n</ul>\n<hr>\n<p><strong>Module 8: Advanced Assembly Techniques and Capstone Project</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Apply advanced assembly techniques and complete the capstone project: building a basic keylogger.</li>\n<li><strong>Subtopics:</strong><ul>\n<li>Advanced Debugging Techniques: Using advanced debugging features to analyze complex code and identify subtle vulnerabilities.</li>\n<li>Code Optimization: Optimizing assembly code for performance and size.</li>\n<li>Custom Assembly Tools: Developing custom assembly tools for specific tasks.</li>\n<li>Interfacing with High-Level Languages: Integrating assembly code with high-level languages (e.g., C/C++).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong> Completion of Module 7.</li>\n<li><strong>Capstone Project (Keylogger):</strong><ul>\n<li><strong>Phase 1:</strong> Implement keyboard input handling using assembly language and system calls (e.g., <code>GetKeyState</code> on Windows, <code>/dev/input/event*</code> on Linux).</li>\n<li><strong>Phase 2:</strong> Store captured keystrokes in memory (using dynamically allocated memory from Module 2).</li>\n<li><strong>Phase 3:</strong> Implement a mechanism to write the captured keystrokes to a file (or send them over a network, as an advanced extension).</li>\n<li><strong>Phase 4:</strong> Implement persistence (e.g., running as a service or adding an entry to the registry on Windows, using a systemd service on Linux).</li>\n<li><strong>Phase 5:</strong> Implement basic stealth techniques (e.g., hiding the keylogger process, encrypting the log file).</li>\n</ul>\n</li>\n<li><strong>Final Assessment:</strong> Presentation and demonstration of the completed keylogger project, including a detailed explanation of the code and the techniques used. The demonstration should show the keylogger capturing keystrokes and storing them.</li>\n<li><strong>Bonus:</strong> Implement a way to exfiltrate the data over a network.</li>\n<li><strong>Bonus:</strong> Implement a way to hide the keylogger&#39;s process from task manager.</li>\n</ul>\n<hr>\n<p>This outline provides a solid foundation for learning assembly language and applying it to offensive security and malware development. The hands-on projects and the capstone project will help students develop practical skills and gain confidence in their abilities. I&#39;ve tried to structure it to be engaging and rewarding, with a clear path from beginner to a competent practitioner. Good luck!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay, here&#39;s the detailed course material for Module 1: &quot;Foundations - Processor Architecture and Assembly Basics.&quot; This module aims to lay a solid groundwork for understanding how processors work and how assembly code interacts with them. I&#39;ll break down each subtopic with explanations, examples, and exercises to solidify your understanding.</p>\n<h1>Module 1: Foundations - Processor Architecture and Assembly Basics</h1>\n<p><strong>Module Objective:</strong> Understand the fundamental concepts of processor architecture, memory organization, and the basics of x86/x64 assembly language.</p>\n<h2>Subtopic 1.1: CPU Architecture: Registers, Flags, and Memory Organization</h2>\n<ul>\n<li><p><strong>Explanation:</strong> This section will cover the core components of a CPU that are directly relevant to assembly programming. Think of these as the building blocks you&#39;ll be manipulating with your code.</p>\n<ul>\n<li><p><strong>Registers:</strong>  Registers are small, high-speed storage locations within the CPU.  They&#39;re used to hold data and instructions that the CPU is actively working on. Understanding registers is <em>crucial</em> for assembly.</p>\n<ul>\n<li><strong>General Purpose Registers (x86-64):</strong><ul>\n<li><code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>R8-R15</code></li>\n<li>These registers are used for a wide variety of purposes, including arithmetic operations, storing addresses, and passing arguments to functions.</li>\n<li>The lower portions of these registers are also accessible (e.g., <code>EAX</code> is the lower 32 bits of <code>RAX</code>, <code>AX</code> is the lower 16 bits of <code>EAX</code>, <code>AL</code> is the lower 8 bits of <code>AX</code>, and <code>AH</code> is the upper 8 bits of <code>AX</code>). This allows you to work with different data sizes.</li>\n</ul>\n</li>\n<li><strong>Segment Registers (x86):</strong>  (Less relevant in 64-bit mode, but important to know for legacy code and 32-bit programming)<ul>\n<li><code>CS</code> (Code Segment): Points to the segment containing the currently executing code.</li>\n<li><code>DS</code> (Data Segment): Points to the segment containing data.</li>\n<li><code>SS</code> (Stack Segment): Points to the segment containing the stack.</li>\n<li><code>ES</code>, <code>FS</code>, <code>GS</code> (Extra Segments):  Used for various purposes, often related to thread-local storage.</li>\n</ul>\n</li>\n<li><strong>Instruction Pointer (RIP/EIP):</strong> Holds the address of the next instruction to be executed.  You generally don&#39;t modify this directly, but control flow instructions (jumps, calls) implicitly change its value.</li>\n<li><strong>Flags Register (RFLAGS/EFLAGS):</strong> Contains status flags that reflect the result of arithmetic and logical operations.  These flags are used by conditional jump instructions.  Key flags include:<ul>\n<li><code>ZF</code> (Zero Flag): Set if the result of an operation is zero.</li>\n<li><code>SF</code> (Sign Flag): Set if the result of an operation is negative (most significant bit is set).</li>\n<li><code>CF</code> (Carry Flag): Set if an operation resulted in a carry or borrow.  Important for multi-precision arithmetic.</li>\n<li><code>OF</code> (Overflow Flag): Set if a signed arithmetic operation resulted in an overflow.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Memory Organization:</strong>  Understanding how memory is structured is essential for manipulating data and code.</p>\n<ul>\n<li><strong>Stack:</strong>  A region of memory used for storing local variables, function arguments, and return addresses.  It operates on a LIFO (Last-In, First-Out) principle. The <code>RSP</code> register points to the top of the stack.</li>\n<li><strong>Heap:</strong>  A region of memory used for dynamic memory allocation (allocating memory at runtime).  This is where you&#39;ll store data structures that can grow or shrink as needed.</li>\n<li><strong>Code (Text) Segment:</strong> Contains the executable instructions of the program.</li>\n<li><strong>Data Segment:</strong> Contains global and static variables.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong> (Conceptual)</p>\n<p>Imagine a desk (the CPU).  The registers are like small drawers on the desk, where you can quickly access frequently used items (data).  The stack is like a pile of papers on the desk ‚Äì you add and remove papers from the top. The heap is like a filing cabinet ‚Äì you can store and retrieve larger documents (data) as needed.</p>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>Identify which registers are typically used for passing arguments to functions in the x86-64 calling convention (System V AMD64 ABI).  Hint:  Look up the register usage conventions.</li>\n<li>Explain the purpose of the stack pointer (<code>RSP</code>). How does it change when you push and pop data?</li>\n</ol>\n</li>\n</ul>\n<h2>Subtopic 1.2: x86/x64 Instruction Set Architecture (ISA)</h2>\n<ul>\n<li><p><strong>Explanation:</strong> The ISA defines the set of instructions that a processor can execute.  We&#39;ll focus on the most common and important instructions.</p>\n<ul>\n<li><p><strong>Data Transfer Instructions:</strong></p>\n<ul>\n<li><code>MOV</code>:  Move data between registers and memory.  <code>MOV destination, source</code><ul>\n<li>Example: <code>MOV RAX, RBX</code> (Move the contents of RBX into RAX)</li>\n<li>Example: <code>MOV [RBP-8], RAX</code> (Move the contents of RAX into the memory location pointed to by RBP-8)</li>\n</ul>\n</li>\n<li><code>PUSH</code>: Push data onto the stack.  <code>PUSH source</code><ul>\n<li>Example: <code>PUSH RAX</code> (Push the contents of RAX onto the stack)</li>\n</ul>\n</li>\n<li><code>POP</code>: Pop data from the stack. <code>POP destination</code><ul>\n<li>Example: <code>POP RBX</code> (Pop a value from the stack into RBX)</li>\n</ul>\n</li>\n<li><code>LEA</code>: Load Effective Address.  Calculates the address of a memory location and stores it in a register. <code>LEA destination, source</code><ul>\n<li>Example: <code>LEA RAX, [RBX + RCX * 8 + 10]</code> (Calculate the address RBX + RCX * 8 + 10 and store it in RAX)  This is often used for array indexing.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Arithmetic Instructions:</strong></p>\n<ul>\n<li><code>ADD</code>: Add two operands. <code>ADD destination, source</code><ul>\n<li>Example: <code>ADD RAX, RBX</code> (Add the contents of RBX to RAX)</li>\n</ul>\n</li>\n<li><code>SUB</code>: Subtract two operands. <code>SUB destination, source</code><ul>\n<li>Example: <code>SUB RAX, RBX</code> (Subtract the contents of RBX from RAX)</li>\n</ul>\n</li>\n<li><code>MUL</code>: Unsigned multiplication. <code>MUL source</code> (Implicitly uses RAX; result is stored in RAX:RDX)</li>\n<li><code>IMUL</code>: Signed multiplication.  <code>IMUL destination, source</code> or <code>IMUL destination, source1, source2</code><ul>\n<li>Example: <code>IMUL RAX, RBX</code> (Multiply RAX by RBX and store the result in RAX)</li>\n<li>Example: <code>IMUL RAX, RBX, 5</code> (Multiply RBX by 5 and store the result in RAX)</li>\n</ul>\n</li>\n<li><code>DIV</code>: Unsigned division. <code>DIV source</code> (Divides RAX:RDX by source; quotient in RAX, remainder in RDX)</li>\n<li><code>IDIV</code>: Signed division. <code>IDIV source</code> (Divides RAX:RDX by source; quotient in RAX, remainder in RDX)</li>\n<li><code>INC</code>: Increment a register or memory location. <code>INC destination</code><ul>\n<li>Example: <code>INC RAX</code> (Increment the value in RAX by 1)</li>\n</ul>\n</li>\n<li><code>DEC</code>: Decrement a register or memory location. <code>DEC destination</code><ul>\n<li>Example: <code>DEC RBX</code> (Decrement the value in RBX by 1)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Logical Instructions:</strong></p>\n<ul>\n<li><code>AND</code>: Bitwise AND. <code>AND destination, source</code><ul>\n<li>Example: <code>AND RAX, RBX</code> (Bitwise AND of RAX and RBX)</li>\n</ul>\n</li>\n<li><code>OR</code>: Bitwise OR. <code>OR destination, source</code><ul>\n<li>Example: <code>OR RAX, RBX</code> (Bitwise OR of RAX and RBX)</li>\n</ul>\n</li>\n<li><code>XOR</code>: Bitwise XOR. <code>XOR destination, source</code><ul>\n<li>Example: <code>XOR RAX, RBX</code> (Bitwise XOR of RAX and RBX)</li>\n</ul>\n</li>\n<li><code>NOT</code>: Bitwise NOT (inverts all bits). <code>NOT destination</code><ul>\n<li>Example: <code>NOT RAX</code> (Invert all bits in RAX)</li>\n</ul>\n</li>\n<li><code>SHL</code>/<code>SAL</code>: Shift Left (Arithmetic Left). <code>SHL destination, count</code><ul>\n<li>Example: <code>SHL RAX, 2</code> (Shift the bits in RAX left by 2 positions)</li>\n</ul>\n</li>\n<li><code>SHR</code>: Shift Right (Logical Right). <code>SHR destination, count</code><ul>\n<li>Example: <code>SHR RAX, 1</code> (Shift the bits in RAX right by 1 position)</li>\n</ul>\n</li>\n<li><code>SAR</code>: Shift Right (Arithmetic Right). <code>SAR destination, count</code><ul>\n<li>Example: <code>SAR RAX, 3</code> (Shift the bits in RAX right by 3 positions, preserving the sign)</li>\n</ul>\n</li>\n<li><code>TEST</code>: Performs a bitwise AND but does <em>not</em> modify the destination.  Used to set flags. <code>TEST destination, source</code><ul>\n<li>Example: <code>TEST RAX, RAX</code> (Checks if RAX is zero or non-zero)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Control Flow Instructions:</strong></p>\n<ul>\n<li><code>JMP</code>: Unconditional jump. <code>JMP target</code><ul>\n<li>Example: <code>JMP my_label</code> (Jump to the label <code>my_label</code>)</li>\n</ul>\n</li>\n<li><code>JE</code>/<code>JZ</code>: Jump if Equal/Jump if Zero. <code>JE target</code><ul>\n<li>Example: <code>JE equal_label</code> (Jump to <code>equal_label</code> if the ZF flag is set)</li>\n</ul>\n</li>\n<li><code>JNE</code>/<code>JNZ</code>: Jump if Not Equal/Jump if Not Zero. <code>JNE target</code><ul>\n<li>Example: <code>JNE not_equal_label</code> (Jump to <code>not_equal_label</code> if the ZF flag is not set)</li>\n</ul>\n</li>\n<li><code>JL</code>/<code>JNGE</code>: Jump if Less Than/Jump if Not Greater or Equal. <code>JL target</code></li>\n<li><code>JG</code>/<code>JNLE</code>: Jump if Greater Than/Jump if Not Less or Equal. <code>JG target</code></li>\n<li><code>JLE</code>/<code>JNG</code>: Jump if Less or Equal/Jump if Not Greater. <code>JLE target</code></li>\n<li><code>JGE</code>/<code>JNL</code>: Jump if Greater or Equal/Jump if Not Less. <code>JGE target</code></li>\n<li><code>CALL</code>: Call a procedure (function). <code>CALL procedure_name</code></li>\n<li><code>RET</code>: Return from a procedure. <code>RET</code></li>\n<li><code>CMP</code>: Compare two operands. Sets flags based on the result of the subtraction. <code>CMP operand1, operand2</code><ul>\n<li>Example: <code>CMP RAX, RBX</code> (Compares RAX and RBX; sets flags as if RBX was subtracted from RAX)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"language-assembly\">; Example of adding two numbers and jumping if the result is zero\n\nMOV RAX, 5      ; Move 5 into RAX\nMOV RBX, -5     ; Move -5 into RBX\nADD RAX, RBX      ; Add RBX to RAX (RAX now contains 0)\nJZ  result_is_zero ; Jump to result_is_zero if ZF is set (RAX is zero)\n\n; ... code to execute if the result is not zero ...\n\nJMP end\n\nresult_is_zero:\n    ; ... code to execute if the result is zero ...\n\nend:\n    ; ... program continues ...\n</code></pre>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>Write a short assembly snippet that compares two registers (e.g., <code>RCX</code> and <code>RDX</code>) and jumps to a label if <code>RCX</code> is greater than <code>RDX</code>.</li>\n<li>Explain the difference between <code>SHL</code> and <code>SAR</code>.  When would you use each?</li>\n<li>What are the implicit registers used by the <code>MUL</code> instruction? What is stored in them after the multiplication?</li>\n</ol>\n</li>\n</ul>\n<h2>Subtopic 1.3: Assembly Syntax: Intel vs. AT&amp;T</h2>\n<ul>\n<li><p><strong>Explanation:</strong> There are two main assembly syntax styles: Intel and AT&amp;T.  Intel syntax is more common on Windows, while AT&amp;T syntax is more common on Linux and macOS.  It&#39;s important to be able to recognize and understand both.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Intel Syntax</th>\n<th>AT&amp;T Syntax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operand Order</td>\n<td><code>destination, source</code></td>\n<td><code>source, destination</code></td>\n</tr>\n<tr>\n<td>Register Names</td>\n<td><code>RAX</code>, <code>EBX</code>, etc.</td>\n<td><code>%rax</code>, <code>%ebx</code>, etc.</td>\n</tr>\n<tr>\n<td>Memory Operands</td>\n<td><code>[RAX + RBX * 4 + 10]</code></td>\n<td><code>10(%rax,%rbx,4)</code></td>\n</tr>\n<tr>\n<td>Immediate Values</td>\n<td><code>10</code>, <code>0x10</code></td>\n<td><code>$10</code>, <code>$0x10</code></td>\n</tr>\n<tr>\n<td>Instruction Size</td>\n<td>No prefix</td>\n<td><code>b</code> (byte), <code>w</code> (word), <code>l</code> (long), <code>q</code> (quad)</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>Operand Order:</strong>  The most significant difference.  In Intel syntax, the destination operand comes first, followed by the source operand. In AT&amp;T syntax, it&#39;s the opposite.</li>\n<li><strong>Register Names:</strong> AT&amp;T syntax prefixes register names with a <code>%</code> sign.</li>\n<li><strong>Memory Operands:</strong>  Memory addressing is expressed differently. Intel uses square brackets <code>[]</code>, while AT&amp;T uses parentheses <code>()</code>.</li>\n<li><strong>Immediate Values:</strong>  AT&amp;T syntax prefixes immediate values (constants) with a <code>$</code> sign.</li>\n<li><strong>Instruction Size Suffixes (AT&amp;T):</strong> These suffixes specify the size of the operands being used:<ul>\n<li><code>b</code>: byte (8 bits)</li>\n<li><code>w</code>: word (16 bits)</li>\n<li><code>l</code>: long (32 bits)  (Even though &quot;long&quot; usually means 64 bits in C/C++, in AT&amp;T x86 assembly, <code>l</code> still refers to 32 bits).</li>\n<li><code>q</code>: quadword (64 bits)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Intel Syntax</th>\n<th>AT&amp;T Syntax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Move 10 into RAX</td>\n<td><code>MOV RAX, 10</code></td>\n<td><code>movq $10, %rax</code></td>\n</tr>\n<tr>\n<td>Move RBX into RAX</td>\n<td><code>MOV RAX, RBX</code></td>\n<td><code>movq %rbx, %rax</code></td>\n</tr>\n<tr>\n<td>Move value from memory address <code>RAX+4</code> into RBX</td>\n<td><code>MOV RBX, [RAX + 4]</code></td>\n<td><code>movq 4(%rax), %rbx</code></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>Convert the following Intel syntax instruction to AT&amp;T syntax: <code>ADD EAX, [EBX + 8]</code></li>\n<li>Convert the following AT&amp;T syntax instruction to Intel syntax: <code>movl $0x1234, (%ecx)</code></li>\n<li>Why is it important to be able to read both Intel and AT&amp;T syntax?</li>\n</ol>\n</li>\n</ul>\n<h2>Subtopic 1.4: Data Representation</h2>\n<ul>\n<li><p><strong>Explanation:</strong> Understanding how data is represented in memory is crucial for working with assembly.</p>\n<ul>\n<li><strong>Integers (Signed/Unsigned):</strong><ul>\n<li><strong>Signed Integers:</strong> Use two&#39;s complement representation. The most significant bit (MSB) indicates the sign (0 for positive, 1 for negative).</li>\n<li><strong>Unsigned Integers:</strong> Represent positive numbers only.</li>\n<li><strong>Data Sizes:</strong><ul>\n<li>Byte (8 bits)</li>\n<li>Word (16 bits)</li>\n<li>Doubleword (32 bits)</li>\n<li>Quadword (64 bits)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Floating-Point Numbers:</strong> Represented using the IEEE 754 standard.  We&#39;ll cover this in more detail later if needed, but the key is to know that there are dedicated floating-point registers and instructions.</li>\n<li><strong>Character Encoding:</strong><ul>\n<li><strong>ASCII:</strong>  Each character is represented by a 7-bit integer (0-127).</li>\n<li><strong>UTF-8:</strong> A variable-width encoding that can represent a wider range of characters.  ASCII characters are represented using a single byte, while other characters may require multiple bytes.</li>\n<li><strong>Unicode:</strong> A standard for encoding characters that includes almost all characters from all languages.  UTF-8 is the dominant encoding for Unicode on the web.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong></p>\n<ul>\n<li>The integer <code>10</code> (decimal) is represented as <code>0x0A</code> in hexadecimal.</li>\n<li>The character &#39;A&#39; has an ASCII value of 65 (decimal), which is <code>0x41</code> in hexadecimal.</li>\n</ul>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>What is the two&#39;s complement representation of -5 using 8 bits?</li>\n<li>How would you represent the string &quot;Hello&quot; in ASCII (in hexadecimal)?</li>\n<li>Explain the difference between a signed and an unsigned integer. Why is it important to know which type you&#39;re dealing with?</li>\n</ol>\n</li>\n</ul>\n<h2>Subtopic 1.5: Calling Conventions</h2>\n<ul>\n<li><p><strong>Explanation:</strong> A calling convention is a set of rules that dictate how functions (procedures) pass arguments and return values.  Understanding the calling convention is <em>essential</em> for writing and reverse engineering code that involves function calls.</p>\n<ul>\n<li><strong>CDECL (C Declaration):</strong> (Primarily used in 32-bit x86)<ul>\n<li>Arguments are passed on the stack, from right to left.</li>\n<li>The caller is responsible for cleaning up the stack (removing the arguments).</li>\n<li>Return values are typically stored in <code>EAX</code>.</li>\n</ul>\n</li>\n<li><strong>STDCALL (Standard Call):</strong> (Primarily used in 32-bit Windows API)<ul>\n<li>Arguments are passed on the stack, from right to left.</li>\n<li>The <em>callee</em> (the function being called) is responsible for cleaning up the stack.</li>\n<li>Return values are typically stored in <code>EAX</code>.</li>\n</ul>\n</li>\n<li><strong>FASTCALL:</strong> (Variations exist; often used for performance)<ul>\n<li>A certain number of arguments are passed in registers (typically <code>ECX</code> and <code>EDX</code> in 32-bit), and the remaining arguments are passed on the stack.</li>\n<li>The callee is responsible for cleaning up the stack (if any arguments were passed on the stack).</li>\n</ul>\n</li>\n<li><strong>System V AMD64 ABI (x86-64 Linux, macOS, and most Unix-like systems):</strong><ul>\n<li>Arguments are passed in registers: <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, <code>R9</code>.  If there are more than 6 arguments, the remaining arguments are passed on the stack.</li>\n<li>The caller is <em>not</em> responsible for cleaning up the stack arguments.</li>\n<li>Return values are typically stored in <code>RAX</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Example (x86-64 System V AMD64 ABI):</strong></p>\n<pre><code class=\"language-assembly\">; Example of calling a function with three arguments\n\nMOV RDI, 10   ; First argument (in RDI)\nMOV RSI, 20   ; Second argument (in RSI)\nMOV RDX, 30   ; Third argument (in RDX)\nCALL my_function ; Call the function\n\n; After the function call, the return value will be in RAX\n</code></pre>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>Explain why it&#39;s important to know the calling convention used by a function.</li>\n<li>In the x86-64 System V AMD64 ABI, where would you find the 7th argument passed to a function?</li>\n<li>What is stack alignment and why is it important? (Hint: look up &quot;x86-64 stack alignment&quot;).</li>\n</ol>\n</li>\n</ul>\n<h2>Subtopic 1.6: Introduction to Debugging Tools</h2>\n<ul>\n<li><p><strong>Explanation:</strong> Debuggers are essential tools for understanding and troubleshooting assembly code. They allow you to step through code, inspect registers and memory, and set breakpoints.</p>\n<ul>\n<li><strong>GDB (GNU Debugger):</strong> A powerful command-line debugger commonly used on Linux and macOS.</li>\n<li><strong>OllyDbg/x64dbg:</strong>  Graphical debuggers for Windows. x64dbg is the more modern and actively maintained of the two.</li>\n</ul>\n</li>\n<li><p><strong>Key Debugger Features:</strong></p>\n<ul>\n<li><strong>Breakpoints:</strong>  Stop execution at a specific instruction.</li>\n<li><strong>Stepping:</strong> Execute code one instruction at a time (step into, step over, step out).</li>\n<li><strong>Register Inspection:</strong> View the contents of registers.</li>\n<li><strong>Memory Inspection:</strong> View the contents of memory.</li>\n<li><strong>Disassembly:</strong> View the assembly code of the program.</li>\n<li><strong>Stack Trace:</strong>  See the call stack (the sequence of function calls that led to the current point of execution).</li>\n</ul>\n</li>\n<li><p><strong>Example (GDB):</strong></p>\n<pre><code class=\"language-gdb\">gdb my_program\nbreak main  ; Set a breakpoint at the main function\nrun         ; Start the program\nnext        ; Execute the next instruction\nstep        ; Step into a function call\ninfo registers ; Display the contents of the registers\nx/10x $rsp ; Display the 10 hex values on top of the stack\ncontinue    ; Continue execution\n</code></pre>\n</li>\n<li><p><strong>Exercise:</strong></p>\n<ol>\n<li>Install GDB (on Linux or macOS) or x64dbg (on Windows).</li>\n<li>Compile a simple C program (e.g., &quot;Hello, world!&quot;) and load it into the debugger.</li>\n<li>Set a breakpoint at the <code>main</code> function and step through the code, observing the values of registers and memory.</li>\n<li>Experiment with different debugger commands (e.g., <code>next</code>, <code>step</code>, <code>info registers</code>, <code>x</code>).</li>\n</ol>\n</li>\n</ul>\n<h2>Project/Exercise: Basic Arithmetic Program</h2>\n<ul>\n<li><p><strong>Objective:</strong> Write a simple assembly program to perform basic arithmetic operations (addition, subtraction, multiplication, division) on two numbers and display the result.  This program will form the foundation for later modules. (e.g., calculating the XOR of two hardcoded values to be used in later modules).</p>\n</li>\n<li><p><strong>Steps:</strong></p>\n<ol>\n<li><p><strong>Choose an Assembler:</strong>  NASM (Netwide Assembler) is a good choice for both Linux and Windows.  MASM (Microsoft Assembler) is another option for Windows.  GAS (GNU Assembler) is commonly used on Linux.</p>\n</li>\n<li><p><strong>Write the Assembly Code:</strong>  Here&#39;s a basic example (using NASM syntax, targeting x86-64 Linux).  You&#39;ll need to adapt this to your chosen assembler and operating system.  This example calculates the XOR of two hardcoded values.</p>\n<pre><code class=\"language-assembly\">; nasm -f elf64 arithmetic.asm\n; ld arithmetic.o -o arithmetic\n; ./arithmetic\n\nsection .data\n    num1 dq 0x123456789ABCDEF0  ; Define the first number (64-bit)\n    num2 dq 0xF0DEBC9A87654321  ; Define the second number (64-bit)\n    result dq 0                  ; Reserve space for the result\n    msg db &quot;The XOR result is: 0x&quot;, 0 ; Message to display\n    hex_digits db &quot;0123456789ABCDEF&quot; ; Hexadecimal digits for output\n\nsection .bss\n    hex_buffer resb 17           ; Buffer to store the hexadecimal representation of the result\n\nsection .text\n    global _start\n\n_start:\n    ; Perform XOR operation\n    mov rax, [num1]             ; Load num1 into RAX\n    xor rax, [num2]             ; XOR RAX with num2\n    mov [result], rax           ; Store the result in memory\n\n    ; Convert the result to a hexadecimal string\n    mov rcx, 16                 ; Counter for 16 hex digits (64 bits = 16 hex chars)\n    mov rsi, hex_buffer         ; Pointer to the end of the hex_buffer\n    add rsi, rcx                ; Move RSI to the end of the buffer\n    dec rsi                     ; Start writing from the last position\n\nconvert_loop:\n    mov rdx, rax                ; Copy the result to RDX\n    and rdx, 0xF                ; Get the last 4 bits (one hex digit)\n    mov rbx, hex_digits         ; Load address of hex_digits string\n    add rbx, rdx                ; Add the offset (0-15) to the address of the digit\n    mov dl, [rbx]               ; Move the digit to DL\n    mov [rsi], dl               ; Store the hex digit in the buffer\n    shr rax, 4                  ; Shift the result right by 4 bits\n    dec rsi                     ; Move to the next position in the buffer\n    loop convert_loop           ; Repeat until all digits are converted\n\n    ; Display the message and the result\n    mov rax, 1                  ; syscall number for write\n    mov rdi, 1                  ; file descriptor 1 (stdout)\n    mov rsi, msg                ; pointer to the message\n    mov rdx, msg.len            ; length of the message\n    syscall\n\n    mov rax, 1                  ; syscall number for write\n    mov rdi, 1                  ; file descriptor 1 (stdout)\n    mov rsi, hex_buffer         ; pointer to the hex buffer\n    mov rdx, 16                 ; length of the hex buffer\n    syscall\n\n    ; Exit the program\n    mov rax, 60                 ; syscall number for exit\n    xor rdi, rdi                ; exit code 0\n    syscall\n\nsection .rodata\n    msg.len equ $-msg          ; Calculate the length of the message\n</code></pre>\n</li>\n<li><p><strong>Assemble and Link:</strong> Use your chosen assembler and linker to create an executable file.</p>\n</li>\n<li><p><strong>Run and Debug:</strong> Run the executable and verify that it produces the correct results. Use a debugger to step through the code and understand how it works.</p>\n</li>\n<li><p><strong>Extend:</strong></p>\n<ul>\n<li>Add input from the user (e.g., using system calls to read from standard input).</li>\n<li>Implement more arithmetic operations.</li>\n<li>Add error handling (e.g., check for division by zero).</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Key Considerations:</strong></p>\n<ul>\n<li><strong>System Calls:</strong> You&#39;ll need to use system calls to interact with the operating system (e.g., to print output to the console).  Look up the system call numbers for your OS.</li>\n<li><strong>Data Sizes:</strong> Be mindful of the sizes of the data you&#39;re working with (bytes, words, doublewords, quadwords).  Use the appropriate instructions and register sizes.</li>\n<li><strong>Debugging:</strong> Use a debugger to step through your code and identify any errors.  Pay close attention to the values of registers and memory.</li>\n</ul>\n</li>\n</ul>\n<p>This completes the detailed course material for Module 1. Remember to practice and experiment with the examples to solidify your understanding. Good luck! Let me know if you have any questions.</p>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Error: Could not generate content. Details: Timeout of 600.0s exceeded, last exception: 503 failed to connect to all addresses; last error: UNKNOWN: ipv4:142.250.67.10:443: socket is null</p>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/2 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Okay, here's the detailed course material for Module 1: \"Foundations - Processor Architecture and Assembly Basics.\" This module aims to lay a solid groundwork for understanding how processors work and how assembly code interacts with them. I'll break down each subtopic with explanations, examples, and exercises to solidify your understanding.\r\n\r\n# Module 1: Foundations - Processor Architecture and Assembly Basics\r\n\r\n**Module Objective:** Understand the fundamental concepts of processor architecture, memory organization, and the basics of x86/x64 assembly language.\r\n\r\n## Subtopic 1.1: CPU Architecture: Registers, Flags, and Memory Organization\r\n\r\n*   **Explanation:** This section will cover the core components of a CPU that are directly relevant to assembly programming. Think of these as the building blocks you'll be manipulating with your code.\r\n\r\n    *   **Registers:**  Registers are small, high-speed storage locations within the CPU.  They're used to hold data and instructions that the CPU is actively working on. Understanding registers is *crucial* for assembly.\r\n\r\n        *   **General Purpose Registers (x86-64):**\r\n            *   `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, `R8-R15`\r\n            *   These registers are used for a wide variety of purposes, including arithmetic operations, storing addresses, and passing arguments to functions.\r\n            *   The lower portions of these registers are also accessible (e.g., `EAX` is the lower 32 bits of `RAX`, `AX` is the lower 16 bits of `EAX`, `AL` is the lower 8 bits of `AX`, and `AH` is the upper 8 bits of `AX`). This allows you to work with different data sizes.\r\n        *   **Segment Registers (x86):**  (Less relevant in 64-bit mode, but important to know for legacy code and 32-bit programming)\r\n            *   `CS` (Code Segment): Points to the segment containing the currently executing code.\r\n            *   `DS` (Data Segment): Points to the segment containing data.\r\n            *   `SS` (Stack Segment): Points to the segment containing the stack.\r\n            *   `ES`, `FS`, `GS` (Extra Segments):  Used for various purposes, often related to thread-local storage.\r\n        *   **Instruction Pointer (RIP/EIP):** Holds the address of the next instruction to be executed.  You generally don't modify this directly, but control flow instructions (jumps, calls) implicitly change its value.\r\n        *   **Flags Register (RFLAGS/EFLAGS):** Contains status flags that reflect the result of arithmetic and logical operations.  These flags are used by conditional jump instructions.  Key flags include:\r\n            *   `ZF` (Zero Flag): Set if the result of an operation is zero.\r\n            *   `SF` (Sign Flag): Set if the result of an operation is negative (most significant bit is set).\r\n            *   `CF` (Carry Flag): Set if an operation resulted in a carry or borrow.  Important for multi-precision arithmetic.\r\n            *   `OF` (Overflow Flag): Set if a signed arithmetic operation resulted in an overflow.\r\n\r\n    *   **Memory Organization:**  Understanding how memory is structured is essential for manipulating data and code.\r\n\r\n        *   **Stack:**  A region of memory used for storing local variables, function arguments, and return addresses.  It operates on a LIFO (Last-In, First-Out) principle. The `RSP` register points to the top of the stack.\r\n        *   **Heap:**  A region of memory used for dynamic memory allocation (allocating memory at runtime).  This is where you'll store data structures that can grow or shrink as needed.\r\n        *   **Code (Text) Segment:** Contains the executable instructions of the program.\r\n        *   **Data Segment:** Contains global and static variables.\r\n\r\n*   **Example:** (Conceptual)\r\n\r\n    Imagine a desk (the CPU).  The registers are like small drawers on the desk, where you can quickly access frequently used items (data).  The stack is like a pile of papers on the desk ‚Äì you add and remove papers from the top. The heap is like a filing cabinet ‚Äì you can store and retrieve larger documents (data) as needed.\r\n\r\n*   **Exercise:**\r\n\r\n    1.  Identify which registers are typically used for passing arguments to functions in the x86-64 calling convention (System V AMD64 ABI).  Hint:  Look up the register usage conventions.\r\n    2.  Explain the purpose of the stack pointer (`RSP`). How does it change when you push and pop data?\r\n\r\n## Subtopic 1.2: x86/x64 Instruction Set Architecture (ISA)\r\n\r\n*   **Explanation:** The ISA defines the set of instructions that a processor can execute.  We'll focus on the most common and important instructions.\r\n\r\n    *   **Data Transfer Instructions:**\r\n        *   `MOV`:  Move data between registers and memory.  `MOV destination, source`\r\n            *   Example: `MOV RAX, RBX` (Move the contents of RBX into RAX)\r\n            *   Example: `MOV [RBP-8], RAX` (Move the contents of RAX into the memory location pointed to by RBP-8)\r\n        *   `PUSH`: Push data onto the stack.  `PUSH source`\r\n            *   Example: `PUSH RAX` (Push the contents of RAX onto the stack)\r\n        *   `POP`: Pop data from the stack. `POP destination`\r\n            *   Example: `POP RBX` (Pop a value from the stack into RBX)\r\n        *   `LEA`: Load Effective Address.  Calculates the address of a memory location and stores it in a register. `LEA destination, source`\r\n            *   Example: `LEA RAX, [RBX + RCX * 8 + 10]` (Calculate the address RBX + RCX * 8 + 10 and store it in RAX)  This is often used for array indexing.\r\n\r\n    *   **Arithmetic Instructions:**\r\n        *   `ADD`: Add two operands. `ADD destination, source`\r\n            *   Example: `ADD RAX, RBX` (Add the contents of RBX to RAX)\r\n        *   `SUB`: Subtract two operands. `SUB destination, source`\r\n            *   Example: `SUB RAX, RBX` (Subtract the contents of RBX from RAX)\r\n        *   `MUL`: Unsigned multiplication. `MUL source` (Implicitly uses RAX; result is stored in RAX:RDX)\r\n        *   `IMUL`: Signed multiplication.  `IMUL destination, source` or `IMUL destination, source1, source2`\r\n            *   Example: `IMUL RAX, RBX` (Multiply RAX by RBX and store the result in RAX)\r\n            *   Example: `IMUL RAX, RBX, 5` (Multiply RBX by 5 and store the result in RAX)\r\n        *   `DIV`: Unsigned division. `DIV source` (Divides RAX:RDX by source; quotient in RAX, remainder in RDX)\r\n        *   `IDIV`: Signed division. `IDIV source` (Divides RAX:RDX by source; quotient in RAX, remainder in RDX)\r\n        *   `INC`: Increment a register or memory location. `INC destination`\r\n            *   Example: `INC RAX` (Increment the value in RAX by 1)\r\n        *   `DEC`: Decrement a register or memory location. `DEC destination`\r\n            *   Example: `DEC RBX` (Decrement the value in RBX by 1)\r\n\r\n    *   **Logical Instructions:**\r\n        *   `AND`: Bitwise AND. `AND destination, source`\r\n            *   Example: `AND RAX, RBX` (Bitwise AND of RAX and RBX)\r\n        *   `OR`: Bitwise OR. `OR destination, source`\r\n            *   Example: `OR RAX, RBX` (Bitwise OR of RAX and RBX)\r\n        *   `XOR`: Bitwise XOR. `XOR destination, source`\r\n            *   Example: `XOR RAX, RBX` (Bitwise XOR of RAX and RBX)\r\n        *   `NOT`: Bitwise NOT (inverts all bits). `NOT destination`\r\n            *   Example: `NOT RAX` (Invert all bits in RAX)\r\n        *   `SHL`/`SAL`: Shift Left (Arithmetic Left). `SHL destination, count`\r\n            *   Example: `SHL RAX, 2` (Shift the bits in RAX left by 2 positions)\r\n        *   `SHR`: Shift Right (Logical Right). `SHR destination, count`\r\n            *   Example: `SHR RAX, 1` (Shift the bits in RAX right by 1 position)\r\n        *   `SAR`: Shift Right (Arithmetic Right). `SAR destination, count`\r\n            *   Example: `SAR RAX, 3` (Shift the bits in RAX right by 3 positions, preserving the sign)\r\n        *   `TEST`: Performs a bitwise AND but does *not* modify the destination.  Used to set flags. `TEST destination, source`\r\n            *    Example: `TEST RAX, RAX` (Checks if RAX is zero or non-zero)\r\n\r\n    *   **Control Flow Instructions:**\r\n        *   `JMP`: Unconditional jump. `JMP target`\r\n            *   Example: `JMP my_label` (Jump to the label `my_label`)\r\n        *   `JE`/`JZ`: Jump if Equal/Jump if Zero. `JE target`\r\n            *   Example: `JE equal_label` (Jump to `equal_label` if the ZF flag is set)\r\n        *   `JNE`/`JNZ`: Jump if Not Equal/Jump if Not Zero. `JNE target`\r\n            *   Example: `JNE not_equal_label` (Jump to `not_equal_label` if the ZF flag is not set)\r\n        *   `JL`/`JNGE`: Jump if Less Than/Jump if Not Greater or Equal. `JL target`\r\n        *   `JG`/`JNLE`: Jump if Greater Than/Jump if Not Less or Equal. `JG target`\r\n        *   `JLE`/`JNG`: Jump if Less or Equal/Jump if Not Greater. `JLE target`\r\n        *   `JGE`/`JNL`: Jump if Greater or Equal/Jump if Not Less. `JGE target`\r\n        *   `CALL`: Call a procedure (function). `CALL procedure_name`\r\n        *   `RET`: Return from a procedure. `RET`\r\n        *   `CMP`: Compare two operands. Sets flags based on the result of the subtraction. `CMP operand1, operand2`\r\n            *   Example: `CMP RAX, RBX` (Compares RAX and RBX; sets flags as if RBX was subtracted from RAX)\r\n\r\n*   **Example:**\r\n\r\n    ```assembly\r\n    ; Example of adding two numbers and jumping if the result is zero\r\n\r\n    MOV RAX, 5      ; Move 5 into RAX\r\n    MOV RBX, -5     ; Move -5 into RBX\r\n    ADD RAX, RBX      ; Add RBX to RAX (RAX now contains 0)\r\n    JZ  result_is_zero ; Jump to result_is_zero if ZF is set (RAX is zero)\r\n\r\n    ; ... code to execute if the result is not zero ...\r\n\r\n    JMP end\r\n\r\n    result_is_zero:\r\n        ; ... code to execute if the result is zero ...\r\n\r\n    end:\r\n        ; ... program continues ...\r\n    ```\r\n\r\n*   **Exercise:**\r\n\r\n    1.  Write a short assembly snippet that compares two registers (e.g., `RCX` and `RDX`) and jumps to a label if `RCX` is greater than `RDX`.\r\n    2.  Explain the difference between `SHL` and `SAR`.  When would you use each?\r\n    3.  What are the implicit registers used by the `MUL` instruction? What is stored in them after the multiplication?\r\n\r\n## Subtopic 1.3: Assembly Syntax: Intel vs. AT&T\r\n\r\n*   **Explanation:** There are two main assembly syntax styles: Intel and AT&T.  Intel syntax is more common on Windows, while AT&T syntax is more common on Linux and macOS.  It's important to be able to recognize and understand both.\r\n\r\n    | Feature         | Intel Syntax                 | AT&T Syntax                  |\r\n    |-----------------|------------------------------|------------------------------|\r\n    | Operand Order   | `destination, source`        | `source, destination`        |\r\n    | Register Names  | `RAX`, `EBX`, etc.           | `%rax`, `%ebx`, etc.          |\r\n    | Memory Operands | `[RAX + RBX * 4 + 10]`       | `10(%rax,%rbx,4)`           |\r\n    | Immediate Values| `10`, `0x10`                 | `$10`, `$0x10`                |\r\n    | Instruction Size|  No prefix                   | `b` (byte), `w` (word), `l` (long), `q` (quad) |\r\n\r\n    *   **Operand Order:**  The most significant difference.  In Intel syntax, the destination operand comes first, followed by the source operand. In AT&T syntax, it's the opposite.\r\n    *   **Register Names:** AT&T syntax prefixes register names with a `%` sign.\r\n    *   **Memory Operands:**  Memory addressing is expressed differently. Intel uses square brackets `[]`, while AT&T uses parentheses `()`.\r\n    *   **Immediate Values:**  AT&T syntax prefixes immediate values (constants) with a `$` sign.\r\n    *   **Instruction Size Suffixes (AT&T):** These suffixes specify the size of the operands being used:\r\n        *   `b`: byte (8 bits)\r\n        *   `w`: word (16 bits)\r\n        *   `l`: long (32 bits)  (Even though \"long\" usually means 64 bits in C/C++, in AT&T x86 assembly, `l` still refers to 32 bits).\r\n        *   `q`: quadword (64 bits)\r\n\r\n*   **Example:**\r\n\r\n    | Operation           | Intel Syntax       | AT&T Syntax          |\r\n    |--------------------|--------------------|----------------------|\r\n    | Move 10 into RAX   | `MOV RAX, 10`      | `movq $10, %rax`     |\r\n    | Move RBX into RAX  | `MOV RAX, RBX`     | `movq %rbx, %rax`     |\r\n    | Move value from memory address `RAX+4` into RBX | `MOV RBX, [RAX + 4]` | `movq 4(%rax), %rbx` |\r\n\r\n*   **Exercise:**\r\n\r\n    1.  Convert the following Intel syntax instruction to AT&T syntax: `ADD EAX, [EBX + 8]`\r\n    2.  Convert the following AT&T syntax instruction to Intel syntax: `movl $0x1234, (%ecx)`\r\n    3.  Why is it important to be able to read both Intel and AT&T syntax?\r\n\r\n## Subtopic 1.4: Data Representation\r\n\r\n*   **Explanation:** Understanding how data is represented in memory is crucial for working with assembly.\r\n\r\n    *   **Integers (Signed/Unsigned):**\r\n        *   **Signed Integers:** Use two's complement representation. The most significant bit (MSB) indicates the sign (0 for positive, 1 for negative).\r\n        *   **Unsigned Integers:** Represent positive numbers only.\r\n        *   **Data Sizes:**\r\n            *   Byte (8 bits)\r\n            *   Word (16 bits)\r\n            *   Doubleword (32 bits)\r\n            *   Quadword (64 bits)\r\n    *   **Floating-Point Numbers:** Represented using the IEEE 754 standard.  We'll cover this in more detail later if needed, but the key is to know that there are dedicated floating-point registers and instructions.\r\n    *   **Character Encoding:**\r\n        *   **ASCII:**  Each character is represented by a 7-bit integer (0-127).\r\n        *   **UTF-8:** A variable-width encoding that can represent a wider range of characters.  ASCII characters are represented using a single byte, while other characters may require multiple bytes.\r\n        *   **Unicode:** A standard for encoding characters that includes almost all characters from all languages.  UTF-8 is the dominant encoding for Unicode on the web.\r\n\r\n*   **Example:**\r\n\r\n    *   The integer `10` (decimal) is represented as `0x0A` in hexadecimal.\r\n    *   The character 'A' has an ASCII value of 65 (decimal), which is `0x41` in hexadecimal.\r\n\r\n*   **Exercise:**\r\n\r\n    1.  What is the two's complement representation of -5 using 8 bits?\r\n    2.  How would you represent the string \"Hello\" in ASCII (in hexadecimal)?\r\n    3.  Explain the difference between a signed and an unsigned integer. Why is it important to know which type you're dealing with?\r\n\r\n## Subtopic 1.5: Calling Conventions\r\n\r\n*   **Explanation:** A calling convention is a set of rules that dictate how functions (procedures) pass arguments and return values.  Understanding the calling convention is *essential* for writing and reverse engineering code that involves function calls.\r\n\r\n    *   **CDECL (C Declaration):** (Primarily used in 32-bit x86)\r\n        *   Arguments are passed on the stack, from right to left.\r\n        *   The caller is responsible for cleaning up the stack (removing the arguments).\r\n        *   Return values are typically stored in `EAX`.\r\n    *   **STDCALL (Standard Call):** (Primarily used in 32-bit Windows API)\r\n        *   Arguments are passed on the stack, from right to left.\r\n        *   The *callee* (the function being called) is responsible for cleaning up the stack.\r\n        *   Return values are typically stored in `EAX`.\r\n    *   **FASTCALL:** (Variations exist; often used for performance)\r\n        *   A certain number of arguments are passed in registers (typically `ECX` and `EDX` in 32-bit), and the remaining arguments are passed on the stack.\r\n        *   The callee is responsible for cleaning up the stack (if any arguments were passed on the stack).\r\n    *   **System V AMD64 ABI (x86-64 Linux, macOS, and most Unix-like systems):**\r\n        *   Arguments are passed in registers: `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`.  If there are more than 6 arguments, the remaining arguments are passed on the stack.\r\n        *   The caller is *not* responsible for cleaning up the stack arguments.\r\n        *   Return values are typically stored in `RAX`.\r\n\r\n*   **Example (x86-64 System V AMD64 ABI):**\r\n\r\n    ```assembly\r\n    ; Example of calling a function with three arguments\r\n\r\n    MOV RDI, 10   ; First argument (in RDI)\r\n    MOV RSI, 20   ; Second argument (in RSI)\r\n    MOV RDX, 30   ; Third argument (in RDX)\r\n    CALL my_function ; Call the function\r\n\r\n    ; After the function call, the return value will be in RAX\r\n    ```\r\n\r\n*   **Exercise:**\r\n\r\n    1.  Explain why it's important to know the calling convention used by a function.\r\n    2.  In the x86-64 System V AMD64 ABI, where would you find the 7th argument passed to a function?\r\n    3.  What is stack alignment and why is it important? (Hint: look up \"x86-64 stack alignment\").\r\n\r\n## Subtopic 1.6: Introduction to Debugging Tools\r\n\r\n*   **Explanation:** Debuggers are essential tools for understanding and troubleshooting assembly code. They allow you to step through code, inspect registers and memory, and set breakpoints.\r\n\r\n    *   **GDB (GNU Debugger):** A powerful command-line debugger commonly used on Linux and macOS.\r\n    *   **OllyDbg/x64dbg:**  Graphical debuggers for Windows. x64dbg is the more modern and actively maintained of the two.\r\n\r\n*   **Key Debugger Features:**\r\n\r\n    *   **Breakpoints:**  Stop execution at a specific instruction.\r\n    *   **Stepping:** Execute code one instruction at a time (step into, step over, step out).\r\n    *   **Register Inspection:** View the contents of registers.\r\n    *   **Memory Inspection:** View the contents of memory.\r\n    *   **Disassembly:** View the assembly code of the program.\r\n    *   **Stack Trace:**  See the call stack (the sequence of function calls that led to the current point of execution).\r\n\r\n*   **Example (GDB):**\r\n\r\n    ```gdb\r\n    gdb my_program\r\n    break main  ; Set a breakpoint at the main function\r\n    run         ; Start the program\r\n    next        ; Execute the next instruction\r\n    step        ; Step into a function call\r\n    info registers ; Display the contents of the registers\r\n    x/10x $rsp ; Display the 10 hex values on top of the stack\r\n    continue    ; Continue execution\r\n    ```\r\n\r\n*   **Exercise:**\r\n\r\n    1.  Install GDB (on Linux or macOS) or x64dbg (on Windows).\r\n    2.  Compile a simple C program (e.g., \"Hello, world!\") and load it into the debugger.\r\n    3.  Set a breakpoint at the `main` function and step through the code, observing the values of registers and memory.\r\n    4.  Experiment with different debugger commands (e.g., `next`, `step`, `info registers`, `x`).\r\n\r\n## Project/Exercise: Basic Arithmetic Program\r\n\r\n*   **Objective:** Write a simple assembly program to perform basic arithmetic operations (addition, subtraction, multiplication, division) on two numbers and display the result.  This program will form the foundation for later modules. (e.g., calculating the XOR of two hardcoded values to be used in later modules).\r\n\r\n*   **Steps:**\r\n\r\n    1.  **Choose an Assembler:**  NASM (Netwide Assembler) is a good choice for both Linux and Windows.  MASM (Microsoft Assembler) is another option for Windows.  GAS (GNU Assembler) is commonly used on Linux.\r\n    2.  **Write the Assembly Code:**  Here's a basic example (using NASM syntax, targeting x86-64 Linux).  You'll need to adapt this to your chosen assembler and operating system.  This example calculates the XOR of two hardcoded values.\r\n\r\n        ```assembly\r\n        ; nasm -f elf64 arithmetic.asm\r\n        ; ld arithmetic.o -o arithmetic\r\n        ; ./arithmetic\r\n\r\n        section .data\r\n            num1 dq 0x123456789ABCDEF0  ; Define the first number (64-bit)\r\n            num2 dq 0xF0DEBC9A87654321  ; Define the second number (64-bit)\r\n            result dq 0                  ; Reserve space for the result\r\n            msg db \"The XOR result is: 0x\", 0 ; Message to display\r\n            hex_digits db \"0123456789ABCDEF\" ; Hexadecimal digits for output\r\n\r\n        section .bss\r\n            hex_buffer resb 17           ; Buffer to store the hexadecimal representation of the result\r\n\r\n        section .text\r\n            global _start\r\n\r\n        _start:\r\n            ; Perform XOR operation\r\n            mov rax, [num1]             ; Load num1 into RAX\r\n            xor rax, [num2]             ; XOR RAX with num2\r\n            mov [result], rax           ; Store the result in memory\r\n\r\n            ; Convert the result to a hexadecimal string\r\n            mov rcx, 16                 ; Counter for 16 hex digits (64 bits = 16 hex chars)\r\n            mov rsi, hex_buffer         ; Pointer to the end of the hex_buffer\r\n            add rsi, rcx                ; Move RSI to the end of the buffer\r\n            dec rsi                     ; Start writing from the last position\r\n\r\n        convert_loop:\r\n            mov rdx, rax                ; Copy the result to RDX\r\n            and rdx, 0xF                ; Get the last 4 bits (one hex digit)\r\n            mov rbx, hex_digits         ; Load address of hex_digits string\r\n            add rbx, rdx                ; Add the offset (0-15) to the address of the digit\r\n            mov dl, [rbx]               ; Move the digit to DL\r\n            mov [rsi], dl               ; Store the hex digit in the buffer\r\n            shr rax, 4                  ; Shift the result right by 4 bits\r\n            dec rsi                     ; Move to the next position in the buffer\r\n            loop convert_loop           ; Repeat until all digits are converted\r\n\r\n            ; Display the message and the result\r\n            mov rax, 1                  ; syscall number for write\r\n            mov rdi, 1                  ; file descriptor 1 (stdout)\r\n            mov rsi, msg                ; pointer to the message\r\n            mov rdx, msg.len            ; length of the message\r\n            syscall\r\n\r\n            mov rax, 1                  ; syscall number for write\r\n            mov rdi, 1                  ; file descriptor 1 (stdout)\r\n            mov rsi, hex_buffer         ; pointer to the hex buffer\r\n            mov rdx, 16                 ; length of the hex buffer\r\n            syscall\r\n\r\n            ; Exit the program\r\n            mov rax, 60                 ; syscall number for exit\r\n            xor rdi, rdi                ; exit code 0\r\n            syscall\r\n\r\n        section .rodata\r\n            msg.len equ $-msg          ; Calculate the length of the message\r\n\r\n        ```\r\n\r\n    3.  **Assemble and Link:** Use your chosen assembler and linker to create an executable file.\r\n    4.  **Run and Debug:** Run the executable and verify that it produces the correct results. Use a debugger to step through the code and understand how it works.\r\n    5.  **Extend:**\r\n\r\n        *   Add input from the user (e.g., using system calls to read from standard input).\r\n        *   Implement more arithmetic operations.\r\n        *   Add error handling (e.g., check for division by zero).\r\n\r\n*   **Key Considerations:**\r\n\r\n    *   **System Calls:** You'll need to use system calls to interact with the operating system (e.g., to print output to the console).  Look up the system call numbers for your OS.\r\n    *   **Data Sizes:** Be mindful of the sizes of the data you're working with (bytes, words, doublewords, quadwords).  Use the appropriate instructions and register sizes.\r\n    *   **Debugging:** Use a debugger to step through your code and identify any errors.  Pay close attention to the values of registers and memory.\r\n\r\nThis completes the detailed course material for Module 1. Remember to practice and experiment with the examples to solidify your understanding. Good luck! Let me know if you have any questions."
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Error: Could not generate content. Details: Timeout of 600.0s exceeded, last exception: 503 failed to connect to all addresses; last error: UNKNOWN: ipv4:142.250.67.10:443: socket is null"
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
